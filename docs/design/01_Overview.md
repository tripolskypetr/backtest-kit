# Overview

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [README.md](README.md)
- [package-lock.json](package-lock.json)
- [package.json](package.json)
- [src/index.ts](src/index.ts)
- [types.d.ts](types.d.ts)

</details>



## Purpose and Scope

This document provides a high-level introduction to **backtest-kit**, a production-ready TypeScript framework for backtesting and live trading of algorithmic trading strategies. The framework is designed with clean architecture principles, crash-safe persistence, memory-efficient async generators, and comprehensive signal validation.

This page covers:
- The framework's architectural design and four-layer structure
- Execution modes (backtest vs live trading)
- Key components and their responsibilities
- Signal lifecycle and data flow
- Technology dependencies

For detailed information about specific subsystems, refer to:
- Configuration and registration: [Configuration Functions](#3.1)
- Backtest execution details: [Backtesting](#7)
- Live trading implementation: [Live Trading](#8)
- Signal state management: [Signal Lifecycle](#6)
- Service layer architecture: [Service Layer](#5)

**Sources:** [README.md:1-27](), [types.d.ts:1-50](), [package.json:1-40]()

---

## Framework Purpose

The **backtest-kit** framework enables users to:

1. **Backtest trading strategies** - Test algorithms against historical candle data with memory-efficient streaming
2. **Deploy live trading** - Run strategies in production with crash recovery and atomic persistence
3. **Validate signals** - Automatically validate signal parameters (prices, TP/SL logic, timestamps)
4. **Monitor performance** - Generate markdown reports with statistics (win rate, PnL, close reasons)
5. **Integrate data sources** - Connect custom exchanges via pluggable schema registration

The framework enforces separation of concerns through dependency injection, enabling testable business logic without tight coupling to infrastructure services.

**Sources:** [README.md:1-21](), [types.d.ts:4-50]()

---

## Four-Layer Architecture

The framework follows a clean architecture pattern with four distinct layers:

![Mermaid Diagram](./diagrams\01_Overview_0.svg)

### Layer Responsibilities

| Layer | Purpose | Components | Key Files |
|-------|---------|------------|-----------|
| **Public API** | User-facing functions and utilities | `Backtest`, `Live`, `addStrategy`, `getCandles` | [src/index.ts:1-56]() |
| **Service Orchestration** | Dependency injection, routing, context management | Schema/Connection/Global/Logic services | [src/lib/services/*]() |
| **Business Logic** | Pure, testable domain logic | `ClientStrategy`, `ClientExchange`, `ClientFrame` | [src/client/*]() |
| **Cross-Cutting** | Logging, persistence, reporting, context | `LoggerService`, `PersistSignalAdapter`, Markdown services | [src/lib/services/base](), [src/classes/Persist.ts]() |

**Sources:** [types.d.ts:1-56](), [src/index.ts:1-56](), [README.md:196-208]()

For detailed layer responsibilities, see [Layer Responsibilities](#2.1).

---

## Execution Modes

The framework supports two execution modes with different characteristics:

![Mermaid Diagram](./diagrams\01_Overview_1.svg)

### Backtest Mode

- **Entry Point:** `Backtest.run(symbol, {strategyName, exchangeName, frameName})`
- **Execution:** Iterates through historical timeframes generated by `ClientFrame`
- **Fast-Forward:** Uses `backtest()` method to simulate signal outcomes with future candles
- **Memory:** Streams results via async generator, no accumulation
- **Output:** Only yields `IStrategyTickResultClosed` (completed signals)

**Key Classes:**
- [BacktestLogicPrivateService]() - Orchestrates timeframe iteration
- [FrameGlobalService]() - Generates timestamp arrays
- [ClientFrame]() - Timeframe generation logic
- [BacktestMarkdownService]() - Accumulates results for reporting

**Sources:** [types.d.ts:515-517](), [README.md:105-137]()

### Live Mode

- **Entry Point:** `Live.run(symbol, {strategyName, exchangeName})`
- **Execution:** Infinite loop with 1-minute intervals
- **Real-Time:** Monitors signals against VWAP from last 5 candles
- **Persistence:** Atomic writes to disk before state changes
- **Recovery:** Resumes from last persisted state on crash/restart
- **Output:** Yields `IStrategyTickResult` (idle/opened/active/closed)

**Key Classes:**
- [LiveLogicPrivateService]() - Orchestrates infinite loop
- [PersistSignalAdapter]() - Crash-safe persistence
- [LiveMarkdownService]() - Accumulates events for reporting

**Sources:** [types.d.ts:534-560](), [README.md:140-194]()

---

## Core Components

### Client Layer (Business Logic)

The client layer contains pure business logic without dependency injection:

![Mermaid Diagram](./diagrams\01_Overview_2.svg)

| Component | Responsibility | Key Methods |
|-----------|----------------|-------------|
| `ClientStrategy` | Signal lifecycle, validation, TP/SL monitoring | `tick()`, `backtest()`, `getSignal()` |
| `ClientExchange` | Candle data fetching, VWAP calculation | `getCandles()`, `getAveragePrice()` |
| `ClientFrame` | Timeframe generation for backtesting | `getTimeframe()` |
| `PersistSignalAdapter` | Crash-safe signal persistence | `write()`, `read()` |

**Sources:** [types.d.ts:519-543](), [types.d.ts:173-221](), [types.d.ts:291-308]()

### Service Orchestration Layer

The service layer handles dependency injection and routing:

![Mermaid Diagram](./diagrams\01_Overview_3.svg)

**Service Types:**

1. **Schema Services** - Registry for user configurations
   - `StrategySchemaService`, `ExchangeSchemaService`, `FrameSchemaService`
   - Store schemas registered via `addStrategy()`, `addExchange()`, `addFrame()`

2. **Connection Services** - Memoized client instance creators
   - `StrategyConnectionService`, `ExchangeConnectionService`, `FrameConnectionService`
   - Create and cache client instances

3. **Global Services** - Context-aware wrappers
   - `StrategyGlobalService`, `ExchangeGlobalService`, `FrameGlobalService`
   - Inject `ExecutionContextService` into operations

4. **Logic Services** - Execution orchestration
   - `BacktestLogicPrivateService`, `LiveLogicPrivateService`
   - Implement async generator loops

**Sources:** [types.d.ts:310-351](), [types.d.ts:84-96]()

For detailed service layer documentation, see [Service Layer](#5).

---

## Signal Lifecycle

Signals transition through four states in a type-safe discriminated union:

![Mermaid Diagram](./diagrams\01_Overview_4.svg)

### Signal Types

```typescript
// Discriminated union - type-safe state handling
type IStrategyTickResult = 
  | IStrategyTickResultIdle      // action: "idle"
  | IStrategyTickResultOpened    // action: "opened"
  | IStrategyTickResultActive    // action: "active"
  | IStrategyTickResultClosed    // action: "closed"
```

**Key Interfaces:**

| State | Interface | Properties | When Yielded |
|-------|-----------|------------|--------------|
| Idle | `IStrategyTickResultIdle` | `signal: null` | Backtest: never, Live: yes |
| Opened | `IStrategyTickResultOpened` | `signal: ISignalRow` | Both modes |
| Active | `IStrategyTickResultActive` | `signal, currentPrice` | Backtest: never, Live: no |
| Closed | `IStrategyTickResultClosed` | `signal, pnl, closeReason` | Both modes |

**Sources:** [types.d.ts:442-513](), [types.d.ts:361-392]()

For complete signal lifecycle details, see [Signal Lifecycle](#6).

---

## Configuration System

The framework uses a registration-then-execution pattern:

![Mermaid Diagram](./diagrams\01_Overview_5.svg)

### Registration APIs

| Function | Purpose | Interface |
|----------|---------|-----------|
| `addStrategy()` | Register trading strategy | [IStrategySchema]() |
| `addExchange()` | Register data source | [IExchangeSchema]() |
| `addFrame()` | Register timeframe generator | [IFrameSchema]() |

**Key Characteristics:**
- **Separation:** Registration at startup, instantiation at runtime
- **Memoization:** One instance per schema name
- **Routing:** `MethodContextService` provides schema names for lookup
- **Flexibility:** Multiple strategies/exchanges can coexist

**Sources:** [types.d.ts:546-646](), [src/index.ts:1-11]()

For configuration details, see [Configuration Functions](#3.1).

---

## Dependency Injection Architecture

The framework uses symbol-based dependency injection with scoped context propagation:

![Mermaid Diagram](./diagrams\01_Overview_6.svg)

### Context Propagation

The framework uses **di-scoped** for implicit context passing:

1. **ExecutionContextService** - Provides `{symbol, when, backtest}` to operations
2. **MethodContextService** - Provides `{strategyName, exchangeName, frameName}` for routing

**Benefits:**
- No manual parameter threading
- Type-safe context access
- Scoped to async execution boundaries

**Sources:** [types.d.ts:57-96](), [types.d.ts:310-351]()

For DI system details, see [Dependency Injection System](#2.2).

---

## Technology Stack

### Core Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| `di-kit` | ^1.0.18 | Symbol-based dependency injection container |
| `di-scoped` | ^1.0.20 | Scoped context propagation for async operations |
| `functools-kit` | ^1.0.93 | Functional utilities (singleshot, queued, memoize) |
| `get-moment-stamp` | ^1.1.1 | Timestamp utilities for candle intervals |

**Sources:** [package.json:73-78]()

### Build System

- **Bundler:** Rollup with TypeScript plugin
- **Output:** CommonJS (`build/index.cjs`) and ESM (`build/index.mjs`)
- **Types:** Single declaration file (`types.d.ts`)
- **Target:** Node.js with TypeScript 5.0+

**Sources:** [package.json:40-57]()

---

## Data Flow Overview

### Backtest Execution Flow

![Mermaid Diagram](./diagrams\01_Overview_7.svg)

**Sources:** Referenced in high-level diagrams provided

### Live Execution Flow

![Mermaid Diagram](./diagrams\01_Overview_8.svg)

**Sources:** Referenced in high-level diagrams provided

---

## Memory and Performance

The framework is optimized for production use:

### Memory Efficiency

1. **Async Generators** - Stream results without accumulation
2. **Prototype Methods** - Shared methods across instances
3. **Memoization** - Cache client instances per schema name
4. **No State Accumulation** - Logic services are stateless

### Performance Characteristics

| Feature | Technique | Benefit |
|---------|-----------|---------|
| Client instances | Memoization via `ConnectionServices` | One instance per schema name |
| Backtest streaming | Async generator | Early termination possible |
| Context propagation | `di-scoped` | No parameter threading overhead |
| Persistence | Atomic file writes | Crash safety without performance penalty |

**Sources:** [README.md:18-19](), [README.md:618-629]()

---

## Error Handling

The framework provides comprehensive validation and error handling:

### Signal Validation

Signals are validated automatically in `ClientStrategy`:
- Price validation (positive values)
- TP/SL logic validation (correct relative positions)
- Timestamp validation (positive values)
- Position type validation ("long" or "short")

**Validation Location:** [ClientStrategy.ts]() signal validation logic

### Persistence Errors

- Atomic file writes prevent partial writes
- Automatic retry logic for file operations
- Corrupted file detection and cleanup

**Persistence Location:** [src/classes/Persist.ts]()

**Sources:** [types.d.ts:361-392](), [README.md:210-242]()

For error handling patterns, see [Error Handling](#10.2).

---

## Next Steps

To use the framework:

1. **Installation:** `npm install backtest-kit` - see [Installation and Setup](#1.2)
2. **Configuration:** Register schemas with `addStrategy()`, `addExchange()`, `addFrame()` - see [Configuration Functions](#3.1)
3. **Backtesting:** Use `Backtest.run()` for historical testing - see [Backtest API](#3.2)
4. **Live Trading:** Use `Live.run()` for production deployment - see [Live Trading API](#3.3)
5. **Reporting:** Generate markdown reports with `getReport()` and `dump()` - see [Reporting and Analytics](#9)

**Sources:** [README.md:22-169](), [src/index.ts:1-56]()