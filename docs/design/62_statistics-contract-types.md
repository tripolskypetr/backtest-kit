---
title: design/62_statistics-contract-types
group: design
---

# Statistics & Contract Types

This page documents the statistics models and event contract types used throughout Backtest Kit. Statistics models aggregate and analyze signal data from backtests, live trading, and walker comparisons. Contract types define the payload structures emitted by event subjects during execution.

For information about the event system architecture and listeners, see [Event System Architecture](./14_architecture-deep-dive.md). For details on the reporting classes that generate these statistics, see [Reporting Classes API](./56_api-reference.md).

---

## Statistics Models Overview

Statistics models are immutable data structures returned by `getData()` methods on reporting classes. They contain aggregated metrics, raw event lists, and derived calculations for performance analysis.

### Statistics Model Hierarchy

![Mermaid Diagram](./diagrams\62_statistics-contract-types_0.svg)


---

## BacktestStatisticsModel

Contains comprehensive performance metrics calculated from closed backtest signals. All numeric values use null-safe math: calculations return `null` if result is NaN, Infinity, or division by zero occurs.

### Structure

| Field | Type | Description |
|-------|------|-------------|
| `signalList` | `IStrategyTickResultClosed[]` | Array of all closed signals with full details (price, PNL, timestamps) |
| `totalSignals` | `number` | Total number of closed signals |
| `winCount` | `number` | Number of winning signals (PNL > 0) |
| `lossCount` | `number` | Number of losing signals (PNL < 0) |
| `winRate` | `number \| null` | Win rate as percentage (0-100). Higher is better. |
| `avgPnl` | `number \| null` | Average PNL per signal as percentage. Higher is better. |
| `totalPnl` | `number \| null` | Cumulative PNL across all signals as percentage. Higher is better. |
| `stdDev` | `number \| null` | Standard deviation of returns (volatility metric). Lower is better. |
| `sharpeRatio` | `number \| null` | Risk-adjusted return (avgPnl / stdDev). Higher is better. |
| `annualizedSharpeRatio` | `number \| null` | Annualized Sharpe Ratio (sharpeRatio × √365). Higher is better. |
| `certaintyRatio` | `number \| null` | Ratio of average win to average loss magnitude (avgWin / \|avgLoss\|). Higher is better. |
| `expectedYearlyReturns` | `number \| null` | Projected yearly returns based on average trade duration and PNL. Higher is better. |

### Key Metrics Explained

**Sharpe Ratio**: Measures risk-adjusted returns. Calculated as `avgPnl / stdDev`. A higher Sharpe ratio indicates better risk-adjusted performance. Typical interpretations:
- < 1.0: Poor risk-adjusted returns
- 1.0 - 2.0: Good risk-adjusted returns
- \> 2.0: Excellent risk-adjusted returns

**Certainty Ratio**: Compares the magnitude of average wins to average losses. Formula: `avgWin / |avgLoss|`. A ratio > 1.0 means wins are larger than losses on average. Combined with win rate, provides insight into strategy asymmetry.

**Expected Yearly Returns**: Extrapolates returns to annual basis using average signal duration. Assumes consistent signal generation rate throughout the year.

### Usage Example

```typescript
import { Backtest } from "backtest-kit";

// Run backtest
await Backtest.run("BTCUSDT", {
  strategyName: "my-strategy",
  exchangeName: "binance",
  frameName: "1d-backtest"
});

// Get statistics
const stats = await Backtest.getData("my-strategy");

console.log(`Total signals: ${stats.totalSignals}`);
console.log(`Win rate: ${stats.winRate?.toFixed(2)}%`);
console.log(`Sharpe Ratio: ${stats.sharpeRatio?.toFixed(3)}`);
console.log(`Total PNL: ${stats.totalPnl?.toFixed(2)}%`);

// Null-safe access for derived metrics
if (stats.sharpeRatio !== null && stats.sharpeRatio > 1.5) {
  console.log("Good risk-adjusted performance!");
}

// Access raw signal data
stats.signalList.forEach(signal => {
  console.log(`Signal ${signal.signal.id}: ${signal.pnl.pnlPercentage.toFixed(2)}%`);
});
```


---

## LiveStatisticsModel

Identical structure to `BacktestStatisticsModel` but aggregates signals from live trading execution. Generated by `LiveMarkdownService` which subscribes to `signalLiveEmitter`.

The key difference from backtest statistics is the data source: live statistics reflect real-time trading results with actual market execution, while backtest statistics are simulated.

### Usage Example

```typescript
import { Live } from "backtest-kit";

// Start live trading
Live.background("BTCUSDT", {
  strategyName: "my-strategy",
  exchangeName: "binance"
});

// Later, get live statistics
const stats = await Live.getData("my-strategy");

console.log(`Live trading results:`);
console.log(`Total signals: ${stats.totalSignals}`);
console.log(`Win rate: ${stats.winRate?.toFixed(2)}%`);
console.log(`Total PNL: ${stats.totalPnl?.toFixed(2)}%`);
```


---

## WalkerStatisticsModel

Aggregates results from walker comparisons, ranking multiple strategies by a chosen optimization metric. Extends `WalkerCompleteContract` with additional strategy comparison data.

### Structure

![Mermaid Diagram](./diagrams\62_statistics-contract-types_1.svg)

### IStrategyResult

Each strategy in the walker comparison produces an `IStrategyResult`:

| Field | Type | Description |
|-------|------|-------------|
| `strategyName` | `StrategyName` | Strategy identifier |
| `stats` | `BacktestStatisticsModel` | Complete backtest statistics for this strategy |
| `metricValue` | `number \| null` | Value of the optimization metric used for ranking |

### WalkerMetric Types

```typescript
type WalkerMetric = 
  | "sharpeRatio"
  | "annualizedSharpeRatio"
  | "winRate"
  | "totalPnl"
  | "certaintyRatio"
  | "avgPnl"
  | "expectedYearlyReturns";
```

All metrics are maximized - higher values rank better. The `metric` field in `WalkerStatisticsModel` indicates which metric was used for comparison.

### Usage Example

```typescript
import { Walker } from "backtest-kit";

// Run walker comparison
await Walker.run("BTCUSDT", {
  walkerName: "strategy-comparison"
});

// Get walker results
const stats = await Walker.getData("strategy-comparison");

console.log(`Compared ${stats.totalStrategies} strategies`);
console.log(`Best strategy: ${stats.bestStrategy}`);
console.log(`Best ${stats.metric}: ${stats.bestMetric?.toFixed(3)}`);

// Analyze all strategies
stats.strategyResults.forEach(result => {
  console.log(`${result.strategyName}: ${result.metricValue?.toFixed(3)}`);
  console.log(`  Win rate: ${result.stats.winRate?.toFixed(2)}%`);
  console.log(`  Sharpe: ${result.stats.sharpeRatio?.toFixed(3)}`);
});

// Access best strategy details
if (stats.bestStats) {
  console.log(`Best strategy total PNL: ${stats.bestStats.totalPnl?.toFixed(2)}%`);
}
```


---

## Auxiliary Statistics Models

### ScheduleStatisticsModel

Tracks scheduled signal lifecycle: creation, activation, and cancellation events.

| Field | Type | Description |
|-------|------|-------------|
| `eventList` | `ScheduledEvent[]` | All scheduled/opened/cancelled events with timestamps |
| `totalEvents` | `number` | Total number of events (scheduled + opened + cancelled) |
| `totalScheduled` | `number` | Number of signals created in scheduled state |
| `totalOpened` | `number` | Number of scheduled signals that activated |
| `totalCancelled` | `number` | Number of scheduled signals that cancelled before activation |
| `cancellationRate` | `number \| null` | Percentage of scheduled signals that cancelled (0-100). Lower is better. |
| `activationRate` | `number \| null` | Percentage of scheduled signals that opened (0-100). Higher is better. |
| `avgWaitTime` | `number \| null` | Average time in minutes that cancelled signals waited before cancellation |
| `avgActivationTime` | `number \| null` | Average time in minutes that opened signals waited before activation |

**ScheduledEvent Structure:**

```typescript
interface ScheduledEvent {
  timestamp: number;           // Event timestamp in milliseconds
  action: "scheduled" | "opened" | "cancelled";
  symbol: string;
  signalId: string;
  position: string;
  note?: string;
  currentPrice: number;
  priceOpen: number;           // Scheduled entry price
  takeProfit: number;
  stopLoss: number;
  closeTimestamp?: number;     // Only for cancelled/opened
  duration?: number;           // Only for cancelled/opened (minutes)
}
```


### RiskStatisticsModel

Tracks risk validation rejections with grouping by symbol and strategy.

| Field | Type | Description |
|-------|------|-------------|
| `eventList` | `RiskEvent[]` | All risk rejection events with full context |
| `totalRejections` | `number` | Total number of signals rejected due to risk limits |
| `bySymbol` | `Record<string, number>` | Rejection count grouped by symbol |
| `byStrategy` | `Record<string, number>` | Rejection count grouped by strategy |

**RiskEvent Structure:**

```typescript
interface RiskEvent {
  timestamp: number;
  symbol: string;
  pendingSignal: ISignalDto;
  strategyName: string;
  exchangeName: string;
  currentPrice: number;
  activePositionCount: number;
  comment: string;              // Rejection reason from validation note
}
```


### PartialStatisticsModel

Aggregates partial profit/loss milestone events for unrealized P&L tracking.

| Field | Type | Description |
|-------|------|-------------|
| `profitEvents` | `PartialProfitContract[]` | All profit milestone events |
| `lossEvents` | `PartialLossContract[]` | All loss milestone events |
| `totalProfitEvents` | `number` | Total count of profit milestones reached |
| `totalLossEvents` | `number` | Total count of loss milestones reached |
| `byLevel` | `Record<PartialLevel, number>` | Event count grouped by percentage level (10, 20, 30, etc.) |


### PerformanceStatisticsModel

Aggregates execution timing metrics for profiling and bottleneck detection.

| Field | Type | Description |
|-------|------|-------------|
| `events` | `PerformanceContract[]` | All performance measurement events |
| `totalEvents` | `number` | Total count of performance events |
| `byMetricType` | `Record<PerformanceMetricType, {...}>` | Statistics grouped by operation type |

Each metric type aggregation includes:
- `count`: Number of measurements
- `totalDuration`: Sum of all durations (ms)
- `avgDuration`: Average duration (ms)
- `minDuration`: Minimum duration (ms)
- `maxDuration`: Maximum duration (ms)


### HeatmapStatisticsModel

Provides portfolio-wide aggregated statistics across multiple symbols and strategies.

| Field | Type | Description |
|-------|------|-------------|
| `rows` | `IHeatmapRow[]` | Array of heatmap rows (one per symbol-strategy combination) |
| `totalRows` | `number` | Total number of rows |
| Additional aggregated statistics | Various | Cross-symbol aggregations |


---

## Event Contract Types

Contract types define the payload structures emitted by event subjects. These types ensure type-safe event handling through discriminated unions and strict interfaces.

### Contract Type to Emitter Mapping

![Mermaid Diagram](./diagrams\62_statistics-contract-types_2.svg)


---

## DoneContract

Emitted when execution completes in any mode (backtest, live, walker). Provides final execution context.

### Structure

| Field | Type | Description |
|-------|------|-------------|
| `symbol` | `string` | Trading pair symbol that completed |
| `strategyName` | `StrategyName` | Strategy that completed execution |
| `exchangeName` | `ExchangeName` | Exchange used for execution |
| `frameName` | `FrameName` | Frame used (empty string for live mode) |

### Emitters

- `doneBacktestSubject`: Emitted by `Backtest.background()` on completion
- `doneLiveSubject`: Emitted by `Live.background()` on graceful shutdown
- `doneWalkerSubject`: Emitted by `Walker.background()` on completion

### Usage Example

```typescript
import { listenDoneBacktest } from "backtest-kit";

listenDoneBacktest((event) => {
  console.log(`Backtest completed for ${event.symbol}`);
  console.log(`Strategy: ${event.strategyName}`);
  console.log(`Exchange: ${event.exchangeName}`);
  console.log(`Frame: ${event.frameName}`);
});
```


---

## PerformanceContract

Emitted during execution to track timing metrics for profiling and bottleneck detection.

### Structure

| Field | Type | Description |
|-------|------|-------------|
| `timestamp` | `number` | When the metric was recorded (milliseconds since epoch) |
| `previousTimestamp` | `number \| null` | Timestamp of previous event (null for first event) |
| `metricType` | `PerformanceMetricType` | Type of operation being measured |
| `duration` | `number` | Duration of the operation in milliseconds |
| `symbol` | `string` | Trading pair symbol |
| `strategyName` | `StrategyName` | Strategy executing the operation |
| `exchangeName` | `ExchangeName` | Exchange used |
| `frameName` | `FrameName` | Frame used (empty string for live mode) |

### PerformanceMetricType

```typescript
type PerformanceMetricType = 
  | "backtest_total"      // Total backtest duration from start to finish
  | "backtest_timeframe"  // Duration to process a single timeframe iteration
  | "backtest_signal"     // Duration to process a signal (tick + getNextCandles + backtest)
  | "live_tick";          // Duration of a single live tick iteration
```

### Usage Example

```typescript
import { listenPerformance } from "backtest-kit";

const slowOperations = new Map<string, number>();

listenPerformance((event) => {
  console.log(`[${event.metricType}] ${event.duration.toFixed(2)}ms`);
  
  // Track slow operations
  if (event.duration > 100) {
    const key = `${event.strategyName}:${event.metricType}`;
    slowOperations.set(key, (slowOperations.get(key) || 0) + 1);
  }
  
  // Calculate time between events
  if (event.previousTimestamp !== null) {
    const timeSinceLastEvent = event.timestamp - event.previousTimestamp;
    console.log(`  Time since last event: ${timeSinceLastEvent}ms`);
  }
});
```


---

## Progress Contract Types

### ProgressBacktestContract

Emitted during backtest execution to track frame processing progress.

| Field | Type | Description |
|-------|------|-------------|
| `symbol` | `string` | Trading pair being backtested |
| `strategyName` | `StrategyName` | Strategy executing |
| `exchangeName` | `ExchangeName` | Exchange used |
| `frameName` | `FrameName` | Frame being processed |
| `processedFrames` | `number` | Number of timeframes processed so far |
| `totalFrames` | `number` | Total number of timeframes to process |
| `progress` | `number` | Progress ratio (0.0 to 1.0) |


### ProgressWalkerContract

Emitted during walker execution to track strategy comparison progress.

| Field | Type | Description |
|-------|------|-------------|
| `symbol` | `string` | Trading pair being tested |
| `walkerName` | `WalkerName` | Walker executing |
| `processedStrategies` | `number` | Number of strategies tested so far |
| `totalStrategies` | `number` | Total number of strategies to test |
| `progress` | `number` | Progress ratio (0.0 to 1.0) |


### ProgressOptimizerContract

Emitted during optimizer execution to track data source processing.

| Field | Type | Description |
|-------|------|-------------|
| `symbol` | `string` | Trading pair being analyzed |
| `optimizerName` | `string` | Optimizer executing |
| `processedSources` | `number` | Number of data sources processed |
| `totalSources` | `number` | Total number of data sources |
| `progress` | `number` | Progress ratio (0.0 to 1.0) |


---

## WalkerContract

Emitted during walker execution after each strategy completes. Provides incremental comparison results.

### Structure

| Field | Type | Description |
|-------|------|-------------|
| `symbol` | `string` | Trading pair being tested |
| `walkerName` | `WalkerName` | Walker executing |
| `exchangeName` | `ExchangeName` | Exchange used |
| `frameName` | `FrameName` | Frame used |
| `metric` | `WalkerMetric` | Optimization metric being used |
| `totalStrategies` | `number` | Total strategies to test |
| `strategiesTested` | `number` | Strategies tested so far |
| `strategyName` | `StrategyName` | Current strategy that just completed |
| `metricValue` | `number \| null` | Metric value for current strategy |
| `bestStrategy` | `StrategyName \| null` | Best strategy so far |
| `bestMetric` | `number \| null` | Best metric value so far |

### Usage Example

```typescript
import { listenWalker } from "backtest-kit";

listenWalker((event) => {
  console.log(`[${event.strategiesTested}/${event.totalStrategies}] ${event.strategyName}`);
  console.log(`  ${event.metric}: ${event.metricValue?.toFixed(3) || "N/A"}`);
  console.log(`  Best so far: ${event.bestStrategy} (${event.bestMetric?.toFixed(3) || "N/A"})`);
});
```


---

## WalkerCompleteContract

Emitted when walker completes all strategy comparisons. Contains final results summary.

### Structure

| Field | Type | Description |
|-------|------|-------------|
| `walkerName` | `WalkerName` | Walker that completed |
| `symbol` | `string` | Trading pair tested |
| `exchangeName` | `ExchangeName` | Exchange used |
| `frameName` | `FrameName` | Frame used |
| `metric` | `WalkerMetric` | Optimization metric used |
| `totalStrategies` | `number` | Total strategies tested |
| `bestStrategy` | `StrategyName \| null` | Best performing strategy |
| `bestMetric` | `number \| null` | Best metric value achieved |
| `bestStats` | `BacktestStatisticsModel \| null` | Full statistics for best strategy |

### Usage Example

```typescript
import { listenWalkerComplete } from "backtest-kit";

listenWalkerComplete((results) => {
  console.log(`\n=== Walker ${results.walkerName} Completed ===`);
  console.log(`Symbol: ${results.symbol}`);
  console.log(`Tested ${results.totalStrategies} strategies`);
  console.log(`\nWinner: ${results.bestStrategy}`);
  console.log(`Best ${results.metric}: ${results.bestMetric?.toFixed(3)}`);
  
  if (results.bestStats) {
    console.log(`\nBest Strategy Details:`);
    console.log(`  Win Rate: ${results.bestStats.winRate?.toFixed(2)}%`);
    console.log(`  Total PNL: ${results.bestStats.totalPnl?.toFixed(2)}%`);
    console.log(`  Sharpe Ratio: ${results.bestStats.sharpeRatio?.toFixed(3)}`);
  }
});
```


---

## Partial Event Contracts

### PartialProfitContract

Emitted when a signal reaches a profit milestone (10%, 20%, 30%, etc.).

| Field | Type | Description |
|-------|------|-------------|
| `symbol` | `string` | Trading pair symbol |
| `data` | `ISignalRow` | Signal that reached milestone |
| `currentPrice` | `number` | Current market price |
| `level` | `PartialLevel` | Profit level reached (10, 20, 30, ..., 100) |
| `backtest` | `boolean` | True if backtest mode, false if live |
| `timestamp` | `number` | Event timestamp in milliseconds |

**PartialLevel Type:**
```typescript
type PartialLevel = 10 | 20 | 30 | 40 | 50 | 60 | 70 | 80 | 90 | 100;
```


### PartialLossContract

Emitted when a signal reaches a loss milestone (10%, 20%, 30%, etc.).

| Field | Type | Description |
|-------|------|-------------|
| `symbol` | `string` | Trading pair symbol |
| `data` | `ISignalRow` | Signal that reached milestone |
| `currentPrice` | `number` | Current market price |
| `level` | `PartialLevel` | Loss level reached (10, 20, 30, ..., 100) |
| `backtest` | `boolean` | True if backtest mode, false if live |
| `timestamp` | `number` | Event timestamp in milliseconds |

### Usage Example

```typescript
import { listenPartialProfit, listenPartialLoss } from "backtest-kit";

// Track profit milestones
listenPartialProfit((event) => {
  console.log(`[PROFIT] ${event.symbol}: ${event.level}% profit reached`);
  console.log(`  Signal: ${event.data.id}`);
  console.log(`  Price: ${event.currentPrice}`);
});

// Track loss milestones
listenPartialLoss((event) => {
  console.log(`[LOSS] ${event.symbol}: ${event.level}% loss reached`);
  console.log(`  Signal: ${event.data.id}`);
  console.log(`  Price: ${event.currentPrice}`);
  
  // Consider risk management action at high loss levels
  if (event.level >= 30) {
    console.warn(`  High loss level! Consider intervention.`);
  }
});
```


---

## RiskContract

Emitted when a signal is rejected due to risk validation failure. Only rejection events are emitted (allowed signals do not emit).

### Structure

| Field | Type | Description |
|-------|------|-------------|
| `symbol` | `string` | Trading pair symbol |
| `pendingSignal` | `ISignalDto` | Signal that was rejected |
| `strategyName` | `StrategyName` | Strategy requesting the signal |
| `exchangeName` | `ExchangeName` | Exchange name |
| `currentPrice` | `number` | Current market price at rejection |
| `activePositionCount` | `number` | Number of active positions at rejection time |
| `comment` | `string` | Rejection reason from validation note or "N/A" |
| `timestamp` | `number` | Event timestamp in milliseconds |

### Usage Example

```typescript
import { listenRisk } from "backtest-kit";

const rejectionStats = new Map<string, number>();

listenRisk((event) => {
  console.log(`[RISK REJECTED] ${event.symbol}`);
  console.log(`  Strategy: ${event.strategyName}`);
  console.log(`  Position: ${event.pendingSignal.position}`);
  console.log(`  Active positions: ${event.activePositionCount}`);
  console.log(`  Reason: ${event.comment}`);
  console.log(`  Price: ${event.currentPrice}`);
  
  // Track rejection patterns
  const key = `${event.strategyName}:${event.comment}`;
  rejectionStats.set(key, (rejectionStats.get(key) || 0) + 1);
  
  // Alert on high rejection counts
  if (rejectionStats.get(key)! > 10) {
    console.warn(`  High rejection count for: ${key}`);
  }
});
```


---

## Type Safety and Null Handling

All statistics models follow consistent null-safety patterns:

1. **Raw Data Lists**: Always present, never null (e.g., `signalList`, `eventList`)
2. **Count Fields**: Always present, never null (e.g., `totalSignals`, `winCount`)
3. **Derived Metrics**: Nullable (e.g., `winRate`, `sharpeRatio`, `avgPnl`)

### Null-Safe Math Implementation

Derived metrics return `null` when:
- Division by zero would occur
- Result is NaN or Infinity
- Insufficient data for calculation (e.g., standard deviation with < 2 samples)

This approach prevents misleading statistics and forces explicit null checks in consuming code:

```typescript
const stats = await Backtest.getData("my-strategy");

// Safe: Always available
console.log(`Processed ${stats.totalSignals} signals`);

// Requires null check: Derived metric
if (stats.sharpeRatio !== null) {
  console.log(`Sharpe Ratio: ${stats.sharpeRatio.toFixed(3)}`);
} else {
  console.log("Sharpe Ratio: Insufficient data");
}

// Safe pattern with nullish coalescing
const displaySharpe = stats.sharpeRatio?.toFixed(3) ?? "N/A";
console.log(`Sharpe Ratio: ${displaySharpe}`);
```


---

## Statistics Generation Flow

![Mermaid Diagram](./diagrams\62_statistics-contract-types_3.svg)

**Flow Description:**

1. **Execution**: Strategy methods (`tick`, `backtest`) generate signal events
2. **Emission**: Events emitted to appropriate subjects (mode-specific or global)
3. **Markdown Services**: Subscribe to relevant emitters, accumulate events in memory
4. **Storage**: Events stored in `ReportStorage` with 250-event limit per key
5. **API Access**: `getData()` methods trigger statistics calculation from accumulated events
6. **Models**: Markdown services compute derived metrics and return statistics models


---

## Summary Table: Contract Types

| Contract Type | Emitter | Purpose | Key Fields |
|---------------|---------|---------|------------|
| `IStrategyTickResult` | `signalEmitter`, `signalBacktestEmitter`, `signalLiveEmitter` | Signal lifecycle events | `action`, `signal`, `currentPrice` |
| `DoneContract` | `doneLiveSubject`, `doneBacktestSubject`, `doneWalkerSubject` | Execution completion | `symbol`, `strategyName`, `exchangeName` |
| `ProgressBacktestContract` | `progressBacktestEmitter` | Backtest frame progress | `processedFrames`, `totalFrames`, `progress` |
| `ProgressWalkerContract` | `progressWalkerEmitter` | Walker strategy progress | `processedStrategies`, `totalStrategies`, `progress` |
| `ProgressOptimizerContract` | `progressOptimizerEmitter` | Optimizer source progress | `processedSources`, `totalSources`, `progress` |
| `PerformanceContract` | `performanceEmitter` | Execution timing metrics | `metricType`, `duration`, `timestamp` |
| `WalkerContract` | `walkerEmitter` | Walker incremental results | `strategyName`, `metricValue`, `bestStrategy` |
| `WalkerCompleteContract` | `walkerCompleteSubject` | Walker final results | `bestStrategy`, `bestMetric`, `bestStats` |
| `PartialProfitContract` | `partialProfitSubject` | Profit milestones | `level`, `data`, `currentPrice` |
| `PartialLossContract` | `partialLossSubject` | Loss milestones | `level`, `data`, `currentPrice` |
| `RiskContract` | `riskSubject` | Risk rejections | `pendingSignal`, `comment`, `activePositionCount` |

