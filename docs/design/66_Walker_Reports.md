# Walker Reports

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [src/classes/Backtest.ts](src/classes/Backtest.ts)
- [src/classes/Live.ts](src/classes/Live.ts)
- [src/classes/Walker.ts](src/classes/Walker.ts)
- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)
- [src/lib/services/markdown/BacktestMarkdownService.ts](src/lib/services/markdown/BacktestMarkdownService.ts)
- [src/lib/services/markdown/HeatMarkdownService.ts](src/lib/services/markdown/HeatMarkdownService.ts)
- [src/lib/services/markdown/LiveMarkdownService.ts](src/lib/services/markdown/LiveMarkdownService.ts)
- [src/lib/services/markdown/PartialMarkdownService.ts](src/lib/services/markdown/PartialMarkdownService.ts)
- [src/lib/services/markdown/PerformanceMarkdownService.ts](src/lib/services/markdown/PerformanceMarkdownService.ts)
- [src/lib/services/markdown/RiskMarkdownService.ts](src/lib/services/markdown/RiskMarkdownService.ts)
- [src/lib/services/markdown/ScheduleMarkdownService.ts](src/lib/services/markdown/ScheduleMarkdownService.ts)
- [src/lib/services/markdown/WalkerMarkdownService.ts](src/lib/services/markdown/WalkerMarkdownService.ts)
- [src/model/Column.model.ts](src/model/Column.model.ts)

</details>



Walker reports provide comparative analysis of multiple trading strategies executed on the same symbol during the same timeframe. These reports aggregate performance metrics from individual backtests and rank strategies based on a configured optimization metric (e.g., Sharpe Ratio, total PNL, win rate).

For information about walker execution flow and strategy comparison mechanics, see [Walker Execution Flow](#11.1) and [Strategy Comparison](#11.2). For individual strategy backtest reports, see [Backtest API](#4.3).

---

## Report Architecture

Walker reports are generated by `WalkerMarkdownService`, which subscribes to walker progress events and accumulates strategy results as each backtest completes.

### Data Flow

```mermaid
graph TB
    WalkerExec["WalkerLogicPrivateService<br/>Sequential Strategy Execution"]
    WalkerEmitter["walkerEmitter<br/>RxJS Subject"]
    WalkerMD["WalkerMarkdownService<br/>Report Generation"]
    Storage["ReportStorage<br/>Per-Walker Instance"]
    
    WalkerExec -->|"WalkerContract<br/>(per strategy)"| WalkerEmitter
    WalkerEmitter -->|subscribe| WalkerMD
    WalkerMD -->|"addResult()"| Storage
    
    Storage -->|"getData()"| WalkerStats["WalkerStatisticsModel"]
    Storage -->|"getReport()"| MDFile["Markdown Report"]
    Storage -->|"dump()"| Disk["./dump/walker/{walkerName}.md"]
    
    WalkerUtils["WalkerUtils / WalkerInstance"]
    WalkerUtils -->|delegate| WalkerMD
    
    User["User Code"]
    User -->|"Walker.getReport()"| WalkerUtils
    User -->|"Walker.dump()"| WalkerUtils
    User -->|"Walker.getData()"| WalkerUtils
```

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:1-606](), [src/classes/Walker.ts:1-631]()

### Component Interaction

```mermaid
graph TB
    subgraph "Public API"
        WU["WalkerUtils.dump()"]
        WI["WalkerInstance.dump()"]
    end
    
    subgraph "Service Layer"
        WMS["WalkerMarkdownService"]
        getStorage["getStorage()<br/>memoized"]
        RS["ReportStorage<br/>per walkerName"]
    end
    
    subgraph "Data Models"
        WSM["WalkerStatisticsModel"]
        ISR["IStrategyResult[]"]
        SD["SignalData[]"]
    end
    
    subgraph "Output"
        MD["Markdown Report"]
        File["walkerName.md"]
    end
    
    WU -->|validate walker| WMS
    WI -->|validate walker| WMS
    WMS -->|"getStorage(walkerName)"| getStorage
    getStorage --> RS
    
    RS -->|"getData()"| WSM
    WSM --> ISR
    ISR --> SD
    
    RS -->|"getReport()"| MD
    RS -->|"dump()"| File
    
    WalkerEmitter["walkerEmitter"] -->|"tick()"| WMS
    WMS -->|"addResult()"| RS
```

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:406-606](), [src/classes/Walker.ts:84-439]()

---

## Report Structure

Walker markdown reports consist of four main sections: metadata header, best strategy summary, strategy comparison table, and all-signals PNL table.

### Report Sections

```mermaid
graph TB
    Report["Walker Markdown Report"]
    
    subgraph "Header Section"
        Title["# Walker Comparison Report: {walkerName}"]
        Meta1["**Symbol:** {symbol}"]
        Meta2["**Exchange:** {exchangeName}"]
        Meta3["**Frame:** {frameName}"]
        Meta4["**Optimization Metric:** {metric}"]
        Meta5["**Strategies Tested:** {totalStrategies}"]
    end
    
    subgraph "Best Strategy Section"
        BestTitle["## Best Strategy: {bestStrategy}"]
        BestMetric["**Best {metric}:** {value}"]
        BestSignals["**Total Signals:** {totalSignals}"]
    end
    
    subgraph "Comparison Table"
        CompTitle["## Top Strategies Comparison"]
        CompTable["| Strategy | Metric | Total PNL | Win Rate | ... |<br/>Sorted by metric (descending)"]
    end
    
    subgraph "PNL Table"
        PnlTitle["## All Signals (PNL Table)"]
        PnlTable["| Strategy | Signal ID | Symbol | PNL | ... |<br/>All closed signals from all strategies"]
    end
    
    Report --> Title
    Title --> Meta1
    Meta1 --> Meta2
    Meta2 --> Meta3
    Meta3 --> Meta4
    Meta4 --> Meta5
    
    Meta5 --> BestTitle
    BestTitle --> BestMetric
    BestMetric --> BestSignals
    
    BestSignals --> CompTitle
    CompTitle --> CompTable
    
    CompTable --> PnlTitle
    PnlTitle --> PnlTable
```

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:310-350]()

### Example Report Output

```markdown
# Walker Comparison Report: my-walker

**Symbol:** BTCUSDT
**Exchange:** binance
**Frame:** 1d-backtest
**Optimization Metric:** sharpeRatio
**Strategies Tested:** 5

## Best Strategy: strategy-ma-cross

**Best sharpeRatio:** 1.45
**Total Signals:** 42

## Top Strategies Comparison

| Strategy | Sharpe Ratio | Total PNL | Win Rate | Total Trades |
| --- | --- | --- | --- | --- |
| strategy-ma-cross | 1.45 | +12.34% | 57.14% | 42 |
| strategy-rsi-divergence | 1.23 | +10.12% | 55.00% | 40 |
| strategy-macd-signal | 0.98 | +8.45% | 52.38% | 38 |
...

## All Signals (PNL Table)

| Strategy | Signal ID | Symbol | Position | PNL | Close Reason | Open Time | Close Time |
| --- | --- | --- | --- | --- | --- | --- | --- |
| strategy-ma-cross | abc123 | BTCUSDT | long | +2.45% | take_profit | 2024-01-01 | 2024-01-02 |
...
```

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:326-349]()

---

## Data Models

### WalkerStatisticsModel

The `WalkerStatisticsModel` interface aggregates all walker comparison data:

| Field | Type | Description |
|-------|------|-------------|
| `walkerName` | `WalkerName` | Unique identifier for this walker |
| `symbol` | `string` | Trading pair symbol |
| `exchangeName` | `string` | Exchange name from walker schema |
| `frameName` | `string` | Timeframe name from walker schema |
| `metric` | `WalkerMetric` | Optimization metric used for ranking |
| `totalStrategies` | `number` | Total number of strategies tested |
| `bestStrategy` | `StrategyName \| null` | Name of best performing strategy |
| `bestMetric` | `number \| null` | Best metric value achieved |
| `bestStats` | `BacktestStatisticsModel \| null` | Full statistics for best strategy |
| `strategyResults` | `IStrategyResult[]` | Results for all strategies tested |

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:169-192]()

### IStrategyResult

Per-strategy result data included in comparison table:

| Field | Type | Description |
|-------|------|-------------|
| `strategyName` | `StrategyName` | Strategy identifier |
| `stats` | `BacktestStatisticsModel` | Full backtest statistics |
| `metricValue` | `number \| null` | Value of optimization metric |

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:143-158]()

### SignalData

Individual signal data included in PNL table:

| Field | Type | Description |
|-------|------|-------------|
| `strategyName` | `StrategyName` | Strategy that generated signal |
| `signalId` | `string` | Unique signal identifier |
| `symbol` | `string` | Trading pair symbol |
| `position` | `"long" \| "short"` | Position direction |
| `pnl` | `number` | Profit/loss percentage |
| `closeReason` | `CloseReason` | Why signal closed |
| `openTime` | `number` | Position open timestamp |
| `closeTime` | `number` | Position close timestamp |

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:258-272]()

---

## Column Configuration System

Walker reports use a flexible column configuration system to customize which data appears in tables and how it's formatted.

### Column Types

```mermaid
graph TB
    ColumnModel["ColumnModel&lt;T&gt;<br/>Generic Column Interface"]
    
    StrategyColumn["StrategyColumn<br/>ColumnModel&lt;IStrategyResult&gt;"]
    PnlColumn["PnlColumn<br/>ColumnModel&lt;SignalData&gt;"]
    
    ColumnModel -->|specialized for| StrategyColumn
    ColumnModel -->|specialized for| PnlColumn
    
    StrategyColumn -->|formats| CompTable["Strategy Comparison Table"]
    PnlColumn -->|formats| PnlTable["All Signals PNL Table"]
    
    Config["COLUMN_CONFIG.walker_strategy_columns"]
    Config2["COLUMN_CONFIG.walker_pnl_columns"]
    
    Config -->|provides defaults| StrategyColumn
    Config2 -->|provides defaults| PnlColumn
```

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:24-88](), [src/model/Column.model.ts:1-39]()

### ColumnModel Interface

Each column configuration must implement four properties:

```typescript
interface ColumnModel<T extends object = any> {
  key: string;                                    // Unique identifier
  label: string;                                  // Table header text
  format: (data: T, index: number) => string;    // Value formatter
  isVisible: () => boolean;                       // Visibility toggle
}
```

**Sources:** [src/model/Column.model.ts:26-38]()

### Default Column Configurations

The framework provides default column sets via `COLUMN_CONFIG`:

| Configuration Key | Type | Usage |
|-------------------|------|-------|
| `walker_strategy_columns` | `StrategyColumn[]` | Strategy comparison table columns |
| `walker_pnl_columns` | `PnlColumn[]` | All-signals PNL table columns |

Users can override these defaults by passing custom column arrays to report methods.

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:179-204](), [src/lib/services/markdown/WalkerMarkdownService.ts:250-252]()

---

## API Methods

### WalkerMarkdownService Methods

The service provides four primary methods for interacting with walker reports:

#### getData()

Retrieves aggregated walker statistics without generating markdown:

```typescript
public getData = async (
  walkerName: WalkerName,
  symbol: string,
  metric: WalkerMetric,
  context: {
    exchangeName: string;
    frameName: string;
  }
): Promise<WalkerStatisticsModel>
```

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:457-474]()

#### getReport()

Generates markdown report string with customizable columns:

```typescript
public getReport = async (
  walkerName: WalkerName,
  symbol: string,
  metric: WalkerMetric,
  context: {
    exchangeName: string;
    frameName: string;
  },
  strategyColumns?: StrategyColumn[],
  pnlColumns?: PnlColumn[]
): Promise<string>
```

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:495-514]()

#### dump()

Saves markdown report to disk:

```typescript
public dump = async (
  walkerName: WalkerName,
  symbol: string,
  metric: WalkerMetric,
  context: {
    exchangeName: string;
    frameName: string;
  },
  path?: string,                    // default: "./dump/walker"
  strategyColumns?: StrategyColumn[],
  pnlColumns?: PnlColumn[]
): Promise<void>
```

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:540-561]()

#### clear()

Clears accumulated report data:

```typescript
public clear = async (walkerName?: WalkerName): Promise<void>
```

If `walkerName` is provided, clears only that walker's data. If omitted, clears all walkers.

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:581-586]()

### WalkerUtils / WalkerInstance Methods

The `Walker` utility class and `WalkerInstance` class provide simplified access to walker reports:

```mermaid
graph LR
    User["User Code"]
    WalkerUtils["Walker.dump(symbol, {walkerName})"]
    WalkerInstance["WalkerInstance.dump(symbol, walkerName)"]
    
    WMS["WalkerMarkdownService"]
    
    User -->|convenience API| WalkerUtils
    User -->|instance API| WalkerInstance
    
    WalkerUtils -->|validates walker schema| WMS
    WalkerInstance -->|validates walker schema| WMS
    
    WMS -->|generates| Report["walker-name.md"]
```

**Sources:** [src/classes/Walker.ts:331-348](), [src/classes/Walker.ts:411-438]()

### Usage Examples

#### Generate Report to String

```typescript
import { Walker } from "backtest-kit";

const markdown = await Walker.getReport("BTCUSDT", {
  walkerName: "my-walker"
});

console.log(markdown);
```

#### Save Report to Disk

```typescript
import { Walker } from "backtest-kit";

// Save to default path: ./dump/walker/my-walker.md
await Walker.dump("BTCUSDT", {
  walkerName: "my-walker"
});

// Save to custom path
await Walker.dump("BTCUSDT", {
  walkerName: "my-walker"
}, "./custom/reports");
```

#### Access Raw Statistics

```typescript
import { Walker } from "backtest-kit";

const stats = await Walker.getData("BTCUSDT", {
  walkerName: "my-walker"
});

console.log("Best strategy:", stats.bestStrategy);
console.log("Best metric value:", stats.bestMetric);
console.log("Total strategies tested:", stats.totalStrategies);
```

**Sources:** [src/classes/Walker.ts:331-348](), [src/classes/Walker.ts:366-390](), [src/classes/Walker.ts:411-438]()

---

## Report Generation Process

### Event-Driven Accumulation

```mermaid
sequenceDiagram
    participant WLE as WalkerLogicPrivateService
    participant WE as walkerEmitter
    participant WMS as WalkerMarkdownService
    participant RS as ReportStorage
    
    WLE->>WLE: Run strategy 1 backtest
    WLE->>WE: emit(WalkerContract)
    WE->>WMS: tick(WalkerContract)
    WMS->>RS: addResult(data)
    RS->>RS: Update bestStrategy if better
    
    WLE->>WLE: Run strategy 2 backtest
    WLE->>WE: emit(WalkerContract)
    WE->>WMS: tick(WalkerContract)
    WMS->>RS: addResult(data)
    RS->>RS: Update bestStrategy if better
    
    Note over WLE,RS: Process continues for all strategies
    
    User->>WMS: getReport(walkerName, ...)
    WMS->>RS: getData()
    RS-->>WMS: WalkerStatisticsModel
    WMS->>WMS: Generate markdown tables
    WMS-->>User: Markdown report string
```

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:431-438](), [src/lib/services/markdown/WalkerMarkdownService.ts:143-158]()

### Strategy Ranking

Strategies are sorted by metric value in descending order (best first):

```typescript
// Inside ReportStorage.getComparisonTable()
const sortedResults = [...this._strategyResults].sort((a, b) => {
  const aValue = a.metricValue ?? -Infinity;
  const bValue = b.metricValue ?? -Infinity;
  return bValue - aValue;  // Descending order
});

const topStrategies = sortedResults.slice(0, topN);  // Top N strategies
```

Null metric values are treated as `-Infinity` and appear last in rankings.

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:211-218]()

### Best Strategy Tracking

The best strategy is determined by the walker execution logic and reported via `WalkerContract`:

```typescript
// Inside ReportStorage.addResult()
this._totalStrategies = data.totalStrategies;
this._bestMetric = data.bestMetric;
this._bestStrategy = data.bestStrategy;

// Store full statistics for best strategy
if (data.strategyName === data.bestStrategy) {
  this._bestStats = data.stats;
}
```

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:144-151]()

---

## Table Generation

### Strategy Comparison Table

The comparison table shows top N strategies (default: 10) sorted by optimization metric:

```mermaid
graph TB
    SortedResults["Sorted Strategy Results<br/>(by metric, descending)"]
    TopN["Take Top N<br/>(default: 10)"]
    Columns["Apply Column Configuration<br/>walker_strategy_columns"]
    
    Header["Build Table Header"]
    Rows["Build Table Rows"]
    Table["Markdown Table"]
    
    SortedResults --> TopN
    TopN --> Columns
    
    Columns --> Header
    Columns --> Rows
    
    Header --> Table
    Rows --> Table
```

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:201-241]()

### PNL Table

The PNL table aggregates all closed signals from all strategies:

```typescript
// Collect all closed signals from all strategies
const allSignals: SignalData[] = [];

for (const result of this._strategyResults) {
  for (const signal of result.stats.signalList) {
    allSignals.push({
      strategyName: result.strategyName,
      signalId: signal.signal.id,
      symbol: signal.signal.symbol,
      position: signal.signal.position,
      pnl: signal.pnl.pnlPercentage,
      closeReason: signal.closeReason,
      openTime: signal.signal.pendingAt,
      closeTime: signal.closeTimestamp,
    });
  }
}
```

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:257-273]()

### Column Rendering

Both tables use the same column rendering logic:

```mermaid
graph TB
    Columns["Column Configuration Array"]
    Filter["Filter by isVisible()"]
    VisibleCols["Visible Columns"]
    
    Header["Map to header labels"]
    Separator["Generate separator row"]
    
    Data["Data Rows"]
    FormatRows["For each row:<br/>format(data, index)"]
    
    Assemble["Assemble table:<br/>header | separator | rows"]
    Markdown["Markdown Table String"]
    
    Columns --> Filter
    Filter --> VisibleCols
    
    VisibleCols --> Header
    VisibleCols --> Separator
    VisibleCols --> FormatRows
    
    Data --> FormatRows
    
    Header --> Assemble
    Separator --> Assemble
    FormatRows --> Assemble
    
    Assemble --> Markdown
```

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:221-240](), [src/lib/services/markdown/WalkerMarkdownService.ts:280-297]()

---

## Storage Management

### Per-Walker Storage Isolation

Each walker gets its own `ReportStorage` instance via memoization:

```typescript
private getStorage = memoize<(walkerName: WalkerName) => ReportStorage>(
  ([walkerName]) => `${walkerName}`,
  (walkerName) => new ReportStorage(walkerName)
);
```

This ensures that multiple walkers can run simultaneously without interfering with each other's reports.

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:414-417]()

### Storage Lifecycle

```mermaid
stateDiagram-v2
    [*] --> Uninitialized: Service created
    Uninitialized --> Listening: init() called
    Listening --> Accumulating: First WalkerContract received
    Accumulating --> Accumulating: Additional WalkerContracts
    Accumulating --> Ready: All strategies completed
    Ready --> Generating: getReport() called
    Generating --> Ready: Report returned
    Ready --> Cleared: clear() called
    Cleared --> Uninitialized
```

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:599-602](), [src/lib/services/markdown/WalkerMarkdownService.ts:581-586]()

### Memory Management

The service automatically subscribes to `walkerEmitter` on first use via the `init()` method wrapped in `singleshot()`:

```typescript
protected init = singleshot(async () => {
  this.loggerService.log("walkerMarkdownService init");
  walkerEmitter.subscribe(this.tick);
});
```

To release memory for a specific walker:

```typescript
await walkerMarkdownService.clear("my-walker");
```

To release all walker data:

```typescript
await walkerMarkdownService.clear();
```

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:599-602](), [src/lib/services/markdown/WalkerMarkdownService.ts:581-586]()

---

## Integration with Walker Execution

Walker reports are automatically populated during walker execution. No manual intervention is required:

```mermaid
graph TB
    User["Walker.run(symbol, {walkerName})"]
    WalkerCommand["WalkerCommandService"]
    WalkerLogic["WalkerLogicPrivateService"]
    
    subgraph "For Each Strategy"
        Backtest["BacktestCommandService.run()"]
        Complete["Strategy backtest completes"]
        Extract["Extract BacktestStatisticsModel"]
        Emit["Emit WalkerContract"]
    end
    
    WalkerMD["WalkerMarkdownService<br/>(subscribed to walkerEmitter)"]
    Storage["ReportStorage<br/>(accumulates results)"]
    
    User --> WalkerCommand
    WalkerCommand --> WalkerLogic
    WalkerLogic --> Backtest
    Backtest --> Complete
    Complete --> Extract
    Extract --> Emit
    
    Emit -->|via walkerEmitter| WalkerMD
    WalkerMD -->|addResult()| Storage
    
    Storage -.ready for.-> ReportGen["Walker.getReport()"]
```

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:431-438](), [src/classes/Walker.ts:1-631]()

---

## Performance Considerations

### Bounded Storage

Report storage does not have a hard limit on the number of strategy results, as the total is bounded by the number of strategies configured in the walker schema. However, each strategy's `BacktestStatisticsModel` contains up to 250 signals (MAX_EVENTS) to prevent unbounded memory growth.

**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:70]()

### Async Column Formatting

Column `format()` and `isVisible()` functions can be async, allowing for expensive formatting operations without blocking the event loop:

```typescript
const customColumn: StrategyColumn = {
  key: "custom",
  label: "Custom Metric",
  format: async (result) => {
    // Can perform async operations
    const value = await calculateExpensiveMetric(result);
    return value.toFixed(2);
  },
  isVisible: async () => {
    // Can check async configuration
    return await featureFlags.isEnabled("custom-column");
  }
};
```

**Sources:** [src/model/Column.model.ts:34-37]()

### Report Generation Timing

Report generation is computationally cheap after data accumulation:
- Strategy sorting: O(n log n) where n = number of strategies
- Table rendering: O(s Ã— c) where s = strategies/signals, c = columns
- Markdown assembly: O(rows)

Reports can be generated multiple times from the same accumulated data without re-running backtests.

**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:311-350]()