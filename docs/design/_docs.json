{
    "wiki": {
        "wikis": {
            "en": {
                "metadata": {
                    "repo_name": "bitbucket.org/tpetrptr123/backtest-kit",
                    "commit_hash": "e003281e",
                    "generated_at": "2025-12-17T11:04:07.650130",
                    "config": null,
                    "config_source": "none"
                },
                "pages": [
                    {
                        "page_plan": {
                            "id": "1",
                            "title": "Overview"
                        },
                        "content": "# Overview\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [assets/uml.svg](assets/uml.svg)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [scripts/uml.mjs](scripts/uml.mjs)\n\n</details>\n\n\n\nThis document provides a high-level introduction to Backtest Kit, a production-ready TypeScript framework for building and testing trading strategies. It covers the framework's purpose, key architectural principles, and system organization. For practical usage examples, see [Getting Started](#2). For detailed architectural patterns, see [Architecture Deep Dive](#4).\n\n**Sources:** [README.md:1-29](), [docs/internals.md:1-27]()\n\n## What is Backtest Kit?\n\nBacktest Kit is a TypeScript framework for backtesting and live trading strategies on crypto markets and forex. It enables developers to write trading strategies once and run them identically in historical simulation (backtest) and real-time trading (live) environments without code changes.\n\nThe framework treats market data as an **async stream of time**, processing each timestamp sequentially to architecturally prevent look-ahead bias. Strategies receive temporal context automatically through Node.js `AsyncLocalStorage`, ensuring they can only access historical data up to the current execution timestamp.\n\n**Key Characteristics:**\n\n| Aspect | Implementation |\n|--------|----------------|\n| **Language** | TypeScript 5.0+ |\n| **Runtime** | Node.js with async generators |\n| **Architecture** | Clean architecture with dependency injection |\n| **State Management** | Crash-safe atomic persistence |\n| **Execution Model** | Event-driven with streaming results |\n| **Data Access** | Context-aware temporal queries |\n\n**Sources:** [README.md:3-15](), [README.md:185-199](), [docs/internals.md:10-26]()\n\n## Core Problems Solved\n\n### 1. Look-Ahead Bias Prevention\n\nTraditional backtesting frameworks allow strategies to accidentally access future data, invalidating test results. Backtest Kit makes look-ahead bias **architecturally impossible** by using `ExecutionContextService` to propagate temporal context through all data access operations.\n\nWhen `getCandles()` is called, it automatically retrieves only data up to the current backtest timestamp using `async_hooks` context propagation. The same code runs identically in live mode, where \"current time\" is `new Date()`.\n\n**Sources:** [README.md:185-199]()\n\n### 2. Crash-Safe Live Trading\n\nLive trading systems must recover state after crashes without data loss or duplicate trades. Backtest Kit implements atomic persistence through `PersistSignalAdapter`, which writes signal state to disk synchronously only for opened positions. If the process crashes, `waitForInit()` restores the active signal on restart.\n\n**Sources:** [README.md:19-20](), [docs/internals.md:23]()\n\n### 3. Production-Code Validation\n\nStrategies require rigorous validation before risking capital. Backtest Kit enforces multi-stage validation through `GLOBAL_CONFIG` parameters that check take-profit/stop-loss logic, price sanity, risk/reward ratios, and portfolio limits. Invalid signals are rejected before execution.\n\n**Sources:** [README.md:21](), [docs/internals.md:19]()\n\n### 4. Mode-Agnostic Strategy Development\n\nDevelopers should write strategy logic once, not maintain separate codebases for backtest and live environments. Backtest Kit achieves this through:\n- Shared `ClientStrategy` implementation for both modes\n- Context-aware `getCandles()` that works in any execution mode\n- Identical signal validation and lifecycle management\n- Same event system for monitoring\n\n**Sources:** [README.md:19](), [docs/internals.md:30-38]()\n\n## Key Architectural Principles\n\n### Time Execution Engine\n\nBacktest Kit is fundamentally a **time execution engine**, not a data processing library. The framework processes market data as an **async stream of time**, advancing through historical or real-time timestamps sequentially.\n\n```mermaid\ngraph LR\n    TE[\"Time Execution Engine\"]\n    EC[\"ExecutionContextService\"]\n    MC[\"MethodContextService\"]\n    \n    TE -->|\"propagates\"| EC\n    TE -->|\"propagates\"| MC\n    EC -->|\"provides { symbol, when, backtest }\"| Strategy[\"ClientStrategy.tick()\"]\n    MC -->|\"provides { strategyName, exchangeName }\"| Strategy\n    \n    Strategy -->|\"calls\"| GC[\"getCandles()\"]\n    GC -->|\"reads context\"| EC\n    GC -->|\"returns data ≤ when\"| Strategy\n```\n\n**Temporal Context Propagation:**\n\nThe framework uses `di-scoped` library to propagate two context objects through the execution stack:\n\n| Context Service | Properties | Purpose |\n|----------------|------------|---------|\n| `ExecutionContextService` | `symbol`, `when`, `backtest` | Temporal boundaries for data access |\n| `MethodContextService` | `strategyName`, `exchangeName`, `frameName` | Schema identifiers for configuration |\n\nWhen `BacktestLogicPrivateService` or `LiveLogicPrivateService` executes, they wrap each tick in context:\n\n```typescript\nExecutionContextService.runInContext(() => {\n  MethodContextService.runInContext(() => {\n    // Strategy code executes here with ambient context\n    strategyCoreService.tick();\n  }, { strategyName, exchangeName, frameName });\n}, { symbol, when, backtest: true });\n```\n\n**Sources:** [README.md:185-199](), [docs/internals.md:47-50](), [docs/internals.md:54-67]()\n\n### Crash-Safe Persistence\n\nLive trading requires atomic state persistence to recover from crashes without data corruption or duplicate trades. Backtest Kit implements this through several layers:\n\n```mermaid\ngraph TD\n    CS[\"ClientStrategy\"]\n    PA[\"PersistSignalAdapter\"]\n    PB[\"PersistBase (abstract)\"]\n    FS[\"File System (atomic writes)\"]\n    \n    CS -->|\"opened signal\"| PA\n    PA -->|\"writeSignalData()\"| PB\n    PB -->|\"atomic rename\"| FS\n    \n    CS -->|\"on restart\"| WI[\"waitForInit()\"]\n    WI -->|\"readSignalData()\"| PB\n    PB -->|\"read file\"| FS\n    FS -->|\"restore state\"| CS\n    \n    CS -->|\"closed signal\"| DEL[\"deleteSignalData()\"]\n    DEL -->|\"remove file\"| FS\n```\n\n**Persistence Strategy:**\n\n| State | Action | Rationale |\n|-------|--------|-----------|\n| **Scheduled** | Not persisted | Ephemeral, can be regenerated |\n| **Opened** | Written atomically | Must survive crashes |\n| **Active** | Updated on changes | Track TP/SL modifications |\n| **Closed** | Deleted immediately | No longer needed |\n\nThe `PersistBase` abstract class can be extended for custom storage backends (Redis, MongoDB) by implementing `readSignalData()`, `writeSignalData()`, and `deleteSignalData()` methods.\n\n**Sources:** [docs/internals.md:23](), [docs/internals.md:38](), [docs/internals.md:50-51]()\n\n### Signal Lifecycle State Machine\n\nAll trading signals follow a deterministic state machine with discriminated union types for type safety:\n\n```mermaid\nstateDiagram-v2\n    [*] --> Idle\n    Idle --> Scheduled: \"priceOpen not reached\"\n    Idle --> Opened: \"priceOpen reached\"\n    \n    Scheduled --> Opened: \"price reaches priceOpen\"\n    Scheduled --> Cancelled: \"SL hit or timeout\"\n    \n    Opened --> Active: \"persist to storage\"\n    \n    Active --> Closed_TP: \"priceTakeProfit reached\"\n    Active --> Closed_SL: \"priceStopLoss reached\"\n    Active --> Closed_Time: \"minuteEstimatedTime expired\"\n    \n    Closed_TP --> Idle\n    Closed_SL --> Idle\n    Closed_Time --> Idle\n    Cancelled --> Idle\n```\n\n**Type-Safe State Representation:**\n\nThe `IStrategyTickResult` discriminated union ensures compile-time correctness:\n\n```typescript\ntype IStrategyTickResult = \n  | { action: \"idle\", currentPrice: number }\n  | { action: \"scheduled\", signal: IScheduledSignalRow, currentPrice: number }\n  | { action: \"opened\", signal: ISignalRow, currentPrice: number }\n  | { action: \"active\", signal: ISignalRow, currentPrice: number }\n  | { action: \"closed\", signal: ISignalRow, closeReason: CloseReason, ... }\n  | { action: \"cancelled\", signal: IScheduledSignalRow, ... };\n```\n\nThis eliminates optional field bugs and enables exhaustive pattern matching in TypeScript.\n\n**Sources:** [docs/internals.md:16](), [docs/types/IStrategyTickResult.md:1-14](), [docs/internals.md:44-45]()\n\n### Event-Driven Architecture\n\nAll execution modes emit events through RxJS `Subject` instances, enabling real-time monitoring, logging, and report generation without blocking strategy execution:\n\n```mermaid\ngraph LR\n    subgraph \"Event Producers\"\n        CS[\"ClientStrategy.tick()\"]\n        BT[\"BacktestLogicPrivateService\"]\n        LIVE[\"LiveLogicPrivateService\"]\n    end\n    \n    subgraph \"Event Emitters\"\n        SE[\"signalEmitter\"]\n        SBE[\"signalBacktestEmitter\"]\n        SLE[\"signalLiveEmitter\"]\n        DE[\"doneEmitter\"]\n        RE[\"riskSubject\"]\n    end\n    \n    subgraph \"Event Consumers\"\n        MD[\"MarkdownServices\"]\n        USER[\"User Callbacks\"]\n        LOG[\"Logger\"]\n    end\n    \n    CS -->|\"every tick\"| SE\n    CS -->|\"if backtest\"| SBE\n    CS -->|\"if live\"| SLE\n    BT -->|\"on completion\"| DE\n    LIVE -->|\"on completion\"| DE\n    CS -->|\"validation failure\"| RE\n    \n    SE --> MD\n    SBE --> MD\n    SLE --> MD\n    DE --> MD\n    RE --> MD\n    \n    SE --> USER\n    DE --> USER\n    RE --> USER\n    \n    SE --> LOG\n```\n\n**Event Processing Guarantees:**\n\nAll event listeners use `functools-kit` `queued` wrapper to ensure sequential processing even when callback functions contain async operations. This prevents race conditions during high-frequency event emission.\n\n**Sources:** [docs/internals.md:24](), [docs/internals.md:39](), [docs/internals.md:52-53](), [docs/internals.md:83-89]()\n\n## System Architecture Layers\n\nBacktest Kit follows clean architecture principles with clear separation between business logic, orchestration, and infrastructure concerns:\n\n```mermaid\ngraph TD\n    subgraph \"Public API Layer\"\n        API[\"Global Functions<br/>addExchange, addStrategy,<br/>addFrame, addRisk,<br/>listenSignal*, getCandles\"]\n        BT_CLASS[\"Backtest Class<br/>run/background methods\"]\n        LIVE_CLASS[\"Live Class<br/>run/background methods\"]\n        WALK_CLASS[\"Walker Class<br/>run/background methods\"]\n    end\n    \n    subgraph \"Command Services Layer\"\n        BT_CMD[\"BacktestCommandService\"]\n        LIVE_CMD[\"LiveCommandService\"]\n        WALK_CMD[\"WalkerCommandService\"]\n    end\n    \n    subgraph \"Logic Services Layer\"\n        BT_PUB[\"BacktestLogicPublicService\"]\n        BT_PRIV[\"BacktestLogicPrivateService\"]\n        LIVE_PUB[\"LiveLogicPublicService\"]\n        LIVE_PRIV[\"LiveLogicPrivateService\"]\n        WALK_PUB[\"WalkerLogicPublicService\"]\n        WALK_PRIV[\"WalkerLogicPrivateService\"]\n    end\n    \n    subgraph \"Core Services Layer\"\n        STRAT_CORE[\"StrategyCoreService\"]\n        EXCH_CORE[\"ExchangeCoreService\"]\n        FRAME_CORE[\"FrameCoreService\"]\n    end\n    \n    subgraph \"Connection Services Layer\"\n        STRAT_CONN[\"StrategyConnectionService\"]\n        EXCH_CONN[\"ExchangeConnectionService\"]\n        FRAME_CONN[\"FrameConnectionService\"]\n        RISK_CONN[\"RiskConnectionService\"]\n        PART_CONN[\"PartialConnectionService\"]\n    end\n    \n    subgraph \"Client Layer (Business Logic)\"\n        CLIENT_STRAT[\"ClientStrategy\"]\n        CLIENT_EXCH[\"ClientExchange\"]\n        CLIENT_FRAME[\"ClientFrame\"]\n        CLIENT_RISK[\"ClientRisk\"]\n        CLIENT_PART[\"ClientPartial\"]\n    end\n    \n    subgraph \"Schema Services Layer\"\n        STRAT_SCHEMA[\"StrategySchemaService\"]\n        EXCH_SCHEMA[\"ExchangeSchemaService\"]\n        FRAME_SCHEMA[\"FrameSchemaService\"]\n        RISK_SCHEMA[\"RiskSchemaService\"]\n    end\n    \n    subgraph \"Persistence Layer\"\n        PERSIST[\"PersistSignalAdapter\"]\n        PERSIST_BASE[\"PersistBase (abstract)\"]\n    end\n    \n    API --> BT_CLASS\n    API --> LIVE_CLASS\n    API --> WALK_CLASS\n    \n    BT_CLASS --> BT_CMD\n    LIVE_CLASS --> LIVE_CMD\n    WALK_CLASS --> WALK_CMD\n    \n    BT_CMD --> BT_PUB\n    BT_PUB --> BT_PRIV\n    LIVE_CMD --> LIVE_PUB\n    LIVE_PUB --> LIVE_PRIV\n    WALK_CMD --> WALK_PUB\n    WALK_PUB --> WALK_PRIV\n    \n    BT_PRIV --> STRAT_CORE\n    BT_PRIV --> EXCH_CORE\n    BT_PRIV --> FRAME_CORE\n    LIVE_PRIV --> STRAT_CORE\n    WALK_PRIV --> BT_PUB\n    \n    STRAT_CORE --> STRAT_CONN\n    EXCH_CORE --> EXCH_CONN\n    FRAME_CORE --> FRAME_CONN\n    \n    STRAT_CONN --> CLIENT_STRAT\n    EXCH_CONN --> CLIENT_EXCH\n    FRAME_CONN --> CLIENT_FRAME\n    RISK_CONN --> CLIENT_RISK\n    PART_CONN --> CLIENT_PART\n    \n    STRAT_CONN --> STRAT_SCHEMA\n    EXCH_CONN --> EXCH_SCHEMA\n    FRAME_CONN --> FRAME_SCHEMA\n    RISK_CONN --> RISK_SCHEMA\n    \n    CLIENT_STRAT --> PERSIST\n    PERSIST --> PERSIST_BASE\n```\n\n**Layer Responsibilities:**\n\n| Layer | Components | Responsibility |\n|-------|-----------|----------------|\n| **Public API** | `addStrategy()`, `Backtest`, `Live`, `Walker` classes | User-facing interface, parameter validation |\n| **Command Services** | `BacktestCommandService`, `LiveCommandService`, `WalkerCommandService` | DI wrappers, validation orchestration |\n| **Logic Services** | `BacktestLogicPrivateService`, `LiveLogicPrivateService` | Async generator orchestration, timeframe iteration |\n| **Core Services** | `StrategyCoreService`, `ExchangeCoreService`, `FrameCoreService` | Business logic coordination, context management |\n| **Connection Services** | `StrategyConnectionService`, `ExchangeConnectionService` | Memoized client factories, routing operations |\n| **Client Layer** | `ClientStrategy`, `ClientExchange`, `ClientFrame` | Pure business logic, prototype methods for memory efficiency |\n| **Schema Services** | `StrategySchemaService`, `ExchangeSchemaService` | Configuration storage using ToolRegistry pattern |\n| **Persistence** | `PersistSignalAdapter`, `PersistBase` | Crash-safe atomic file writes, pluggable storage backends |\n\n**Sources:** [docs/internals.md:28-39](), [docs/uml.puml:1-484](), [docs/classes/WalkerCommandService.md:1-79]()\n\n## Dependency Injection Architecture\n\nBacktest Kit uses a custom dependency injection system built on `di-kit` with Symbol-based tokens. All services are instantiated through a central container and accessed via the `backtest` object:\n\n```mermaid\ngraph TD\n    TYPES[\"TYPES Symbol Registry\"]\n    PROVIDE[\"provide() Function\"]\n    INJECT[\"inject() Function\"]\n    \n    subgraph \"Service Container\"\n        BACKTEST[\"backtest Object<br/>(aggregates all services)\"]\n    end\n    \n    subgraph \"Service Instances\"\n        LOG_SVC[\"LoggerService\"]\n        EXEC_CTX[\"ExecutionContextService\"]\n        METHOD_CTX[\"MethodContextService\"]\n        STRAT_SCHEMA[\"StrategySchemaService\"]\n        STRAT_CONN[\"StrategyConnectionService\"]\n        BT_CMD[\"BacktestCommandService\"]\n    end\n    \n    TYPES -->|\"registers symbols\"| PROVIDE\n    PROVIDE -->|\"registers factories\"| INJECT\n    INJECT -->|\"lazy resolution\"| BACKTEST\n    \n    BACKTEST --> LOG_SVC\n    BACKTEST --> EXEC_CTX\n    BACKTEST --> METHOD_CTX\n    BACKTEST --> STRAT_SCHEMA\n    BACKTEST --> STRAT_CONN\n    BACKTEST --> BT_CMD\n    \n    BT_CMD -->|\"injects\"| STRAT_SCHEMA\n    BT_CMD -->|\"injects\"| EXEC_CTX\n    STRAT_CONN -->|\"injects\"| STRAT_SCHEMA\n```\n\n**Service Categories:**\n\nThe framework organizes services into 11 categories:\n\n1. **Base Services**: `LoggerService` for centralized logging\n2. **Context Services**: `ExecutionContextService`, `MethodContextService` for ambient context\n3. **Schema Services**: Registry pattern for immutable configuration storage\n4. **Validation Services**: Memoized existence checks for schema names\n5. **Connection Services**: Memoized factory pattern for client instances\n6. **Core Services**: Business logic orchestration\n7. **Global Services**: Shared state management\n8. **Logic Services**: Async generator implementation (Public/Private split)\n9. **Command Services**: Top-level public API wrappers\n10. **Markdown Services**: Event-driven report generation\n11. **Template Services**: Code generation for LLM integration\n\n**Sources:** [docs/internals.md:31-38]()\n\n## Execution Modes Overview\n\nBacktest Kit provides three execution modes that share the same core strategy logic but differ in orchestration:\n\n| Mode | File | Purpose | Duration | State Persistence |\n|------|------|---------|----------|------------------|\n| **Backtest** | `BacktestLogicPrivateService` | Historical simulation | Finite (startDate → endDate) | None (in-memory only) |\n| **Live** | `LiveLogicPrivateService` | Real-time trading | Infinite (until stopped) | Atomic file writes for crash recovery |\n| **Walker** | `WalkerLogicPrivateService` | Strategy comparison | Finite (sequential backtests) | None (collects results in-memory) |\n\n**Execution Flow Comparison:**\n\n```mermaid\ngraph TB\n    subgraph \"Backtest Mode\"\n        BT_START[\"Backtest.run(symbol, config)\"]\n        BT_FRAME[\"Generate timeframes<br/>startDate → endDate\"]\n        BT_LOOP[\"For each timeframe\"]\n        BT_TICK[\"tick(when, backtest=true)\"]\n        BT_DONE[\"Emit doneBacktestSubject\"]\n    end\n    \n    subgraph \"Live Mode\"\n        LIVE_START[\"Live.run(symbol, config)\"]\n        LIVE_INIT[\"Load persisted signal<br/>waitForInit()\"]\n        LIVE_LOOP[\"while (true)\"]\n        LIVE_TICK[\"tick(new Date(), backtest=false)\"]\n        LIVE_PERSIST[\"Persist opened signals\"]\n        LIVE_SLEEP[\"sleep(TICK_TTL)\"]\n        LIVE_DONE[\"Check stop flag\"]\n    end\n    \n    subgraph \"Walker Mode\"\n        WALK_START[\"Walker.run(symbol, config)\"]\n        WALK_LOAD[\"Load walker schema\"]\n        WALK_LOOP[\"For each strategy\"]\n        WALK_BT[\"Run Backtest.run()\"]\n        WALK_STATS[\"Collect statistics\"]\n        WALK_DONE[\"Compare & emit results\"]\n    end\n    \n    BT_START --> BT_FRAME\n    BT_FRAME --> BT_LOOP\n    BT_LOOP --> BT_TICK\n    BT_TICK --> BT_LOOP\n    BT_LOOP --> BT_DONE\n    \n    LIVE_START --> LIVE_INIT\n    LIVE_INIT --> LIVE_LOOP\n    LIVE_LOOP --> LIVE_TICK\n    LIVE_TICK --> LIVE_PERSIST\n    LIVE_PERSIST --> LIVE_SLEEP\n    LIVE_SLEEP --> LIVE_DONE\n    LIVE_DONE --> LIVE_LOOP\n    \n    WALK_START --> WALK_LOAD\n    WALK_LOAD --> WALK_LOOP\n    WALK_LOOP --> WALK_BT\n    WALK_BT --> WALK_STATS\n    WALK_STATS --> WALK_LOOP\n    WALK_LOOP --> WALK_DONE\n```\n\nAll three modes call the same `StrategyCoreService.tick()` method, ensuring identical signal generation and validation logic across environments.\n\n**Sources:** [docs/internals.md:54-82]()\n\n## Technology Stack\n\nBacktest Kit relies on a minimal set of production dependencies to maintain stability and reduce external risks:\n\n| Dependency | Version | Purpose |\n|------------|---------|---------|\n| **di-kit** | ^1.0.18 | Dependency injection container with Symbol tokens |\n| **di-scoped** | ^1.0.20 | Async context propagation using AsyncLocalStorage |\n| **functools-kit** | ^1.0.94 | Functional utilities (memoization, queued processing, singleshot) |\n| **get-moment-stamp** | ^1.1.1 | Timestamp formatting utilities |\n\n**Peer Dependencies:**\n\nThe framework requires TypeScript 5.0+ as a peer dependency. Users must also install:\n- **ccxt** (or custom exchange adapter) for market data\n- **ollama** (optional) for LLM-powered strategy generation\n- **uuid** for signal ID generation\n\n**Zero Vendor Lock-In:**\n\nUnlike cloud-based platforms (QuantConnect, etc.), Backtest Kit is fully self-hosted with no external API dependencies. All execution, data processing, and persistence occur in your environment.\n\n**Sources:** [package.json:74-79](), [README.md:228-236]()\n\n## Data Flow Summary\n\nThe framework follows a consistent data flow pattern regardless of execution mode:\n\n1. **Configuration Phase**: User calls `addExchange()`, `addStrategy()`, `addFrame()`, `addRisk()` to register schemas\n2. **Validation Phase**: `ValidationServices` check schema name existence and perform shallow validation\n3. **Execution Initiation**: User calls `Backtest.run()`, `Live.run()`, or `Walker.run()` with symbol and context\n4. **Context Setup**: `ExecutionContextService` and `MethodContextService` wrap the execution\n5. **Client Instantiation**: `ConnectionServices` create memoized `ClientStrategy`, `ClientExchange`, `ClientRisk` instances\n6. **Signal Generation**: `ClientStrategy.tick()` calls user-defined `getSignal()` function\n7. **Validation Pipeline**: Multi-stage validation checks TP/SL logic, prices, risk limits\n8. **Signal Processing**: State machine transitions (idle → scheduled → opened → active → closed)\n9. **Event Emission**: Emit to `signalEmitter`, `signalBacktestEmitter`, `signalLiveEmitter`\n10. **Report Generation**: `MarkdownServices` accumulate events and calculate statistics\n\n**Sources:** [docs/internals.md:54-82]()\n\n## Key Interfaces Overview\n\nThe framework exposes several critical interfaces for user interaction:\n\n| Interface | Purpose | Example Properties |\n|-----------|---------|-------------------|\n| `IStrategySchema` | Strategy definition | `strategyName`, `interval`, `getSignal`, `callbacks`, `riskName` |\n| `IExchangeSchema` | Exchange adapter | `exchangeName`, `getCandles`, `formatPrice`, `formatQuantity` |\n| `IFrameSchema` | Timeframe specification | `frameName`, `interval`, `startDate`, `endDate` |\n| `IRiskSchema` | Risk validation rules | `riskName`, `validations[]` |\n| `ISignalDto` | Signal specification | `position`, `priceOpen`, `priceTakeProfit`, `priceStopLoss` |\n| `IStrategyTickResult` | Tick result union | `action: \"idle\" \\| \"opened\" \\| \"active\" \\| \"closed\" \\| ...` |\n\nThe discriminated union pattern for `IStrategyTickResult` ensures type-safe pattern matching:\n\n```typescript\nconst result = await strategy.tick();\nif (result.action === \"closed\") {\n  // TypeScript knows result.signal, result.closeReason exist\n  console.log(result.signal.pnl, result.closeReason);\n}\n```\n\n**Sources:** [docs/interfaces/IStrategyCallbacks.md:1-92](), [docs/types/IStrategyTickResult.md:1-14](), [docs/interfaces/BacktestStatistics.md:1-110](), [docs/interfaces/LiveStatistics.md:1-118]()"
                    },
                    {
                        "page_plan": {
                            "id": "1.1",
                            "title": "Key Features"
                        },
                        "content": "# Key Features\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/classes/Optimizer.ts](src/classes/Optimizer.ts)\n- [src/client/ClientOptimizer.ts](src/client/ClientOptimizer.ts)\n- [src/interfaces/Optimizer.interface.ts](src/interfaces/Optimizer.interface.ts)\n- [src/lib/services/connection/OptimizerConnectionService.ts](src/lib/services/connection/OptimizerConnectionService.ts)\n- [src/lib/services/global/OptimizerGlobalService.ts](src/lib/services/global/OptimizerGlobalService.ts)\n- [src/lib/services/schema/OptimizerSchemaService.ts](src/lib/services/schema/OptimizerSchemaService.ts)\n- [src/lib/services/template/OptimizerTemplateService.ts](src/lib/services/template/OptimizerTemplateService.ts)\n- [src/lib/services/validation/OptimizerValidationService.ts](src/lib/services/validation/OptimizerValidationService.ts)\n- [src/model/Message.model.ts](src/model/Message.model.ts)\n\n</details>\n\n\n\nThis page provides a comprehensive overview of Backtest Kit's capabilities and architectural features. Each feature is described with its purpose, implementation approach, and references to the underlying code entities. For detailed implementation guides, see Getting Started [(2)](#2). For architectural deep dives, see Architecture Deep Dive [(4)](#4).\n\n---\n\n## Core Architectural Features\n\n### Look-Ahead Bias Prevention\n\nBacktest Kit architecturally eliminates look-ahead bias through its **time execution engine**. The system treats market data as an async stream of time, where each execution context carries temporal information that automatically constrains data access.\n\n**Key Implementation:**\n\n- `ExecutionContextService` [src/lib/services/context/ExecutionContextService.ts:1-100]() propagates temporal context using Node.js `AsyncLocalStorage`\n- `getCandles()` function [src/api/getCandles.ts:1-50]() automatically filters data based on current execution timestamp\n- All strategy callbacks receive data UP TO the current moment, never future data\n\n**Technical Guarantee:** The `when` parameter in execution context ensures that `getCandles(symbol, interval, limit)` only returns candles with `timestamp <= when`. This makes look-ahead bias architecturally impossible without explicitly bypassing the context system.\n\n```mermaid\ngraph TB\n    subgraph \"Execution Context Propagation\"\n        AsyncStorage[\"AsyncLocalStorage<br/>(Node.js built-in)\"]\n        ExecCtxService[\"ExecutionContextService<br/>symbol, when, backtest flag\"]\n        MethodCtxService[\"MethodContextService<br/>strategyName, exchangeName\"]\n    end\n    \n    subgraph \"Time-Constrained Data Access\"\n        GetCandles[\"getCandles function<br/>Filters by when timestamp\"]\n        ExchangeCore[\"ExchangeCoreService<br/>Data fetching coordination\"]\n        ClientExchange[\"ClientExchange<br/>CCXT integration\"]\n    end\n    \n    subgraph \"Strategy Execution\"\n        ClientStrategy[\"ClientStrategy.tick<br/>Receives temporal context\"]\n        GetSignal[\"User getSignal function<br/>Cannot access future data\"]\n    end\n    \n    AsyncStorage --> ExecCtxService\n    ExecCtxService --> GetCandles\n    ExecCtxService --> ClientStrategy\n    MethodCtxService --> ClientStrategy\n    \n    GetCandles --> ExchangeCore\n    ExchangeCore --> ClientExchange\n    \n    ClientStrategy --> GetSignal\n    GetSignal --> GetCandles\n    \n    style ExecCtxService fill:#f9f9f9,stroke:#333\n    style GetCandles fill:#f9f9f9,stroke:#333\n```\n\n**Diagram: Temporal Context Propagation for Look-Ahead Bias Prevention**\n\nSources: [README.md:186-199](), [src/lib/services/context/ExecutionContextService.ts](), [src/api/getCandles.ts]()\n\n---\n\n### Multi-Mode Execution\n\nThree execution modes share identical signal logic while differing in orchestration:\n\n| Mode | Class | Logic Service | Purpose | Iteration Pattern |\n|------|-------|---------------|---------|-------------------|\n| **Backtest** | `Backtest` | `BacktestLogicPrivateService` | Historical simulation | Finite generator over timeframes |\n| **Live** | `Live` | `LiveLogicPrivateService` | Real-time trading | Infinite generator with sleep intervals |\n| **Walker** | `Walker` | `WalkerLogicPrivateService` | Strategy comparison | Sequential backtest execution |\n\n**Code Mapping:**\n\n```mermaid\ngraph LR\n    subgraph \"Public API Classes\"\n        BacktestClass[\"Backtest<br/>src/classes/Backtest.ts\"]\n        LiveClass[\"Live<br/>src/classes/Live.ts\"]\n        WalkerClass[\"Walker<br/>src/classes/Walker.ts\"]\n    end\n    \n    subgraph \"Orchestration Services\"\n        BTLogic[\"BacktestLogicPrivateService<br/>Async generator<br/>Timeframe iteration\"]\n        LiveLogic[\"LiveLogicPrivateService<br/>Infinite loop<br/>1-minute polling\"]\n        WalkLogic[\"WalkerLogicPrivateService<br/>Multi-strategy comparison\"]\n    end\n    \n    subgraph \"Shared Core\"\n        StratCore[\"StrategyCoreService<br/>Signal orchestration\"]\n        ClientStrat[\"ClientStrategy<br/>tick method<br/>backtest method\"]\n    end\n    \n    BacktestClass --> BTLogic\n    LiveClass --> LiveLogic\n    WalkerClass --> WalkLogic\n    \n    BTLogic --> StratCore\n    LiveLogic --> StratCore\n    WalkLogic --> BTLogic\n    \n    StratCore --> ClientStrat\n    \n    style StratCore fill:#f9f9f9,stroke:#333\n    style ClientStrat fill:#f9f9f9,stroke:#333\n```\n\n**Diagram: Three Execution Modes Sharing Core Strategy Logic**\n\n**Mode-Specific Behaviors:**\n\n- **Backtest**: Uses `BacktestLogicPrivateService.generate()` [src/lib/services/logic/private/BacktestLogicPrivateService.ts:50-150]() to iterate through historical timeframes. Fast-forward optimization skips frames while signals are active.\n- **Live**: Uses `LiveLogicPrivateService.generate()` [src/lib/services/logic/private/LiveLogicPrivateService.ts:50-150]() with infinite `while(true)` loop. Polls every `TICK_TTL` (61000ms). Persists signals for crash recovery.\n- **Walker**: Uses `WalkerLogicPrivateService.generate()` [src/lib/services/logic/private/WalkerLogicPrivateService.ts:50-150]() to run multiple backtests sequentially, collect statistics from `BacktestMarkdownService`, and compare using configurable metrics.\n\nSources: [src/classes/Backtest.ts](), [src/classes/Live.ts](), [src/classes/Walker.ts](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts](), [src/lib/services/logic/private/LiveLogicPrivateService.ts](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts]()\n\n---\n\n## Validation & Safety Features\n\n### Signal Validation Pipeline\n\nEvery signal passes through seven validation stages before activation, enforced by `GLOBAL_CONFIG` parameters:\n\n```mermaid\ngraph TB\n    Start[\"Signal returned from getSignal\"]\n    \n    V1[\"1. Schema Validation<br/>Check ISignalDto structure\"]\n    V2[\"2. Price Positivity<br/>prices > 0, finite, not NaN\"]\n    V3[\"3. TP/SL Logic<br/>LONG: TP>open>SL<br/>SHORT: SL>open>TP\"]\n    V4[\"4. Min TP Distance<br/>>= CC_MIN_TAKEPROFIT_DISTANCE_PERCENT<br/>Covers 0.1% fee + 0.1% slippage\"]\n    V5[\"5. Max SL Distance<br/><= CC_MAX_STOPLOSS_DISTANCE_PERCENT\"]\n    V6[\"6. Signal Lifetime<br/><= CC_MAX_SIGNAL_LIFETIME_MINUTES\"]\n    V7[\"7. Candle Anomaly Detection<br/>Price spikes, gaps, incomplete candles\"]\n    \n    RiskCheck[\"Risk Validation<br/>ClientRisk.checkSignal\"]\n    \n    Rejected[\"Rejected<br/>Emit riskSubject<br/>Log error\"]\n    Scheduled[\"Scheduled State<br/>priceOpen not reached\"]\n    Opened[\"Opened State<br/>priceOpen reached<br/>Persist to storage\"]\n    \n    Start --> V1\n    V1 -->|Pass| V2\n    V2 -->|Pass| V3\n    V3 -->|Pass| V4\n    V4 -->|Pass| V5\n    V5 -->|Pass| V6\n    V6 -->|Pass| V7\n    V7 -->|Pass| RiskCheck\n    \n    V1 -->|Fail| Rejected\n    V2 -->|Fail| Rejected\n    V3 -->|Fail| Rejected\n    V4 -->|Fail| Rejected\n    V5 -->|Fail| Rejected\n    V6 -->|Fail| Rejected\n    V7 -->|Fail| Rejected\n    \n    RiskCheck -->|Fail| Rejected\n    RiskCheck -->|Pass| CheckPrice{priceOpen<br/>reached?}\n    \n    CheckPrice -->|No| Scheduled\n    CheckPrice -->|Yes| Opened\n    \n    style V4 fill:#f9f9f9,stroke:#333\n    style RiskCheck fill:#f9f9f9,stroke:#333\n```\n\n**Diagram: Seven-Stage Signal Validation Pipeline**\n\n**Validation Implementation:**\n\n- Stages 1-7: `ClientStrategy.prototype.tick` [src/client/ClientStrategy.ts:200-400]() performs inline checks\n- Stage 4 (TP Distance): `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` default 0.21% ensures profits cover 0.1% fee + 0.1% slippage + margin [src/config/params.ts:20-30]()\n- Stage 7 (Anomalies): `ExchangeCoreService.prototype.getValidatedCandles` [src/lib/services/core/ExchangeCoreService.ts:50-150]() checks for median price deviations\n- Risk Check: `ClientRisk.prototype.checkSignal` [src/client/ClientRisk.ts:100-200]() executes custom validation functions\n\n**Configuration Parameters:**\n\n| Parameter | Default | Purpose |\n|-----------|---------|---------|\n| `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` | 0.21% | Minimum profit to cover fees/slippage |\n| `CC_MAX_STOPLOSS_DISTANCE_PERCENT` | 15% | Maximum risk per trade |\n| `CC_MAX_SIGNAL_LIFETIME_MINUTES` | 720 | Maximum signal duration (12 hours) |\n| `CC_PERCENT_FEE` | 0.1% | Trading fee percentage |\n| `CC_PERCENT_SLIPPAGE` | 0.1% | Expected slippage |\n\nSources: [src/client/ClientStrategy.ts:200-400](), [src/config/params.ts:1-100](), [src/client/ClientRisk.ts](), [src/lib/services/core/ExchangeCoreService.ts]()\n\n---\n\n### Crash-Safe Persistence\n\nLive mode implements atomic persistence to prevent signal loss or duplication during system crashes:\n\n**Architecture:**\n\n1. **Selective Persistence**: Only `opened` signals are persisted. Scheduled signals remain ephemeral.\n2. **Atomic Writes**: `PersistSignalAdapter` [src/lib/services/persist/PersistSignalAdapter.ts:1-150]() uses atomic file operations\n3. **Recovery on Startup**: `LiveLogicPrivateService` [src/lib/services/logic/private/LiveLogicPrivateService.ts:50-100]() loads persisted signals via `waitForInit()`\n4. **Cleanup on Close**: Signals deleted from storage when closed (TP/SL/time expired)\n\n**Implementation Classes:**\n\n| Class | Role | File |\n|-------|------|------|\n| `PersistSignalAdapter` | File-based persistence implementation | [src/lib/services/persist/PersistSignalAdapter.ts]() |\n| `PersistBase` | Abstract persistence interface | [src/interfaces/Persist.interface.ts]() |\n| `ClientStrategy.persistSignal` | Save signal to storage | [src/client/ClientStrategy.ts:500-550]() |\n| `ClientStrategy.loadPersistedSignal` | Restore signal on startup | [src/client/ClientStrategy.ts:550-600]() |\n\n**Persistence Key Format:**\n\n```\npersist_{symbol}_{strategyName}_{exchangeName}.json\n```\n\nExample: `persist_BTCUSDT_myStrategy_binance.json`\n\nSources: [src/lib/services/persist/PersistSignalAdapter.ts](), [src/client/ClientStrategy.ts:500-600](), [src/interfaces/Persist.interface.ts]()\n\n---\n\n### Risk Management\n\nRisk management operates at three levels:\n\n```mermaid\ngraph TB\n    subgraph \"Signal-Level Validation\"\n        ISignalDto[\"ISignalDto<br/>TP/SL/position/lifetime\"]\n        ValidationPipeline[\"7-stage validation pipeline<br/>GLOBAL_CONFIG enforcement\"]\n    end\n    \n    subgraph \"Strategy-Level Risk\"\n        IRiskSchema[\"IRiskSchema<br/>Custom validation functions\"]\n        ClientRisk[\"ClientRisk<br/>checkSignal method\"]\n        MergeRisk[\"MergeRisk<br/>Combines multiple risk profiles\"]\n    end\n    \n    subgraph \"Portfolio-Level Risk\"\n        RiskGlobalService[\"RiskGlobalService<br/>Cross-strategy coordination\"]\n        PortfolioLimits[\"Portfolio exposure limits<br/>Concurrent position tracking\"]\n    end\n    \n    ISignalDto --> ValidationPipeline\n    ValidationPipeline --> ClientRisk\n    \n    IRiskSchema --> ClientRisk\n    IRiskSchema --> MergeRisk\n    MergeRisk --> ClientRisk\n    \n    ClientRisk --> RiskGlobalService\n    RiskGlobalService --> PortfolioLimits\n    \n    style ClientRisk fill:#f9f9f9,stroke:#333\n    style RiskGlobalService fill:#f9f9f9,stroke:#333\n```\n\n**Diagram: Three-Level Risk Management Architecture**\n\n**Risk Schema Example:**\n\nFrom [README.md:83-100](), a risk profile with 1% minimum TP and 2:1 R/R:\n\n```typescript\naddRisk({\n  riskName: 'demo',\n  validations: [\n    // TP at least 1%\n    ({ pendingSignal, currentPrice }) => {\n      const tpDistance = calculateTPDistance(pendingSignal, currentPrice);\n      if (tpDistance < 1) throw new Error(`TP too close: ${tpDistance.toFixed(2)}%`);\n    },\n    // R/R at least 2:1\n    ({ pendingSignal, currentPrice }) => {\n      const rr = calculateRiskReward(pendingSignal, currentPrice);\n      if (rr < 2) throw new Error('Poor R/R ratio');\n    }\n  ]\n});\n```\n\n**Implementation:**\n\n- `ClientRisk.prototype.checkSignal` [src/client/ClientRisk.ts:100-150]() executes validation array\n- `MergeRisk` [src/client/MergeRisk.ts:1-100]() combines multiple risk profiles using logical AND\n- `RiskGlobalService` [src/lib/services/global/RiskGlobalService.ts]() maintains portfolio-wide state\n\nSources: [README.md:83-100](), [src/client/ClientRisk.ts](), [src/client/MergeRisk.ts](), [src/lib/services/global/RiskGlobalService.ts]()\n\n---\n\n## Integration & Extensibility\n\n### LLM-Powered Strategy Generation\n\nThe Optimizer system generates executable strategy code using LLM (Large Language Model) integration:\n\n```mermaid\ngraph TB\n    subgraph \"Configuration Phase\"\n        IOptimizerSchema[\"IOptimizerSchema<br/>Training ranges<br/>Data sources<br/>getPrompt function\"]\n        addOptimizer[\"addOptimizer API<br/>Register optimizer\"]\n    end\n    \n    subgraph \"Data Collection Phase\"\n        Source[\"IOptimizerSource<br/>fetch function<br/>user/assistant formatters\"]\n        IterateDocuments[\"iterateDocuments<br/>Pagination with distinctDocuments\"]\n        MessageModel[\"MessageModel array<br/>Conversation history\"]\n    end\n    \n    subgraph \"Code Generation Phase\"\n        OptimizerTemplate[\"OptimizerTemplateService<br/>11 template methods\"]\n        ClientOptimizer[\"ClientOptimizer<br/>getData<br/>getCode<br/>dump\"]\n        GeneratedCode[\"Generated .mjs file<br/>Executable strategy\"]\n    end\n    \n    subgraph \"LLM Integration\"\n        OllamaAPI[\"Ollama API<br/>deepseek-v3.1:671b\"]\n        JsonSchema[\"JSON schema<br/>Signal structure\"]\n    end\n    \n    IOptimizerSchema --> addOptimizer\n    addOptimizer --> ClientOptimizer\n    \n    IOptimizerSchema --> Source\n    Source --> IterateDocuments\n    IterateDocuments --> MessageModel\n    \n    MessageModel --> OllamaAPI\n    OllamaAPI --> JsonSchema\n    \n    OptimizerTemplate --> ClientOptimizer\n    ClientOptimizer --> GeneratedCode\n    \n    style ClientOptimizer fill:#f9f9f9,stroke:#333\n    style OptimizerTemplate fill:#f9f9f9,stroke:#333\n```\n\n**Diagram: LLM-Powered Strategy Generation Workflow**\n\n**Template Methods:**\n\n`OptimizerTemplateService` [src/lib/services/template/OptimizerTemplateService.ts:27-650]() provides 11 code generation methods:\n\n| Method | Purpose | Returns |\n|--------|---------|---------|\n| `getTopBanner` | Imports and initialization | Shebang, imports, constants |\n| `getUserMessage` | LLM user prompt | Data formatted for LLM |\n| `getAssistantMessage` | LLM assistant response | Acknowledgment message |\n| `getWalkerTemplate` | Walker configuration | `addWalker()` call |\n| `getStrategyTemplate` | Strategy with LLM logic | `addStrategy()` with `getSignal()` |\n| `getExchangeTemplate` | CCXT integration | `addExchange()` call |\n| `getFrameTemplate` | Timeframe definition | `addFrame()` call |\n| `getLauncherTemplate` | Execution and listeners | `Walker.background()` + listeners |\n| `getTextTemplate` | Text generation helper | `async text()` function |\n| `getJsonTemplate` | JSON generation helper | `async json()` function |\n| `getJsonDumpTemplate` | Debug output helper | `async dumpJson()` function |\n\n**Generated Code Structure:**\n\nFrom [src/lib/services/template/OptimizerTemplateService.ts:225-350](), the generated file contains:\n\n1. Imports (Ollama, CCXT, backtest-kit)\n2. Helper functions (`text()`, `json()`, `dumpJson()`)\n3. Exchange configuration\n4. Training frames (one per training range)\n5. Test frame (for validation)\n6. Strategies (one per training range × data source)\n7. Walker configuration\n8. Launcher with event listeners\n\n**Example Integration:**\n\nFrom [README.md:111-143](), using Optimizer in a strategy:\n\n```typescript\naddStrategy({\n  strategyName: 'llm-strategy',\n  interval: '5m',\n  getSignal: async (symbol) => {\n    const candles1h = await getCandles(symbol, \"1h\", 24);\n    const messages = await getMessages(symbol, { candles1h });\n    const signal = await json(messages);  // LLM generates signal\n    await dumpSignal(uuid(), messages, signal);\n    return { ...signal, id: uuid() };\n  }\n});\n```\n\nSources: [src/lib/services/template/OptimizerTemplateService.ts](), [src/client/ClientOptimizer.ts](), [src/interfaces/Optimizer.interface.ts](), [README.md:111-143]()\n\n---\n\n### Pluggable Data Sources\n\nBacktest Kit supports custom data sources through the `IExchangeSchema` interface:\n\n**Required Methods:**\n\n| Method | Signature | Purpose |\n|--------|-----------|---------|\n| `getCandles` | `(symbol, interval, since, limit) => ICandleData[]` | Fetch OHLCV candles |\n| `formatPrice` | `(symbol, price) => string` | Format price for display |\n| `formatQuantity` | `(symbol, quantity) => string` | Format quantity for display |\n| `getAveragePrice` | `(symbol, interval) => number` (optional) | Get VWAP or last price |\n\n**CCXT Integration Example:**\n\nFrom [README.md:70-80]():\n\n```typescript\naddExchange({\n  exchangeName: 'binance',\n  getCandles: async (symbol, interval, since, limit) => {\n    const exchange = new ccxt.binance();\n    const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => \n      ({ timestamp, open, high, low, close, volume }));\n  },\n  formatPrice: (symbol, price) => price.toFixed(2),\n  formatQuantity: (symbol, quantity) => quantity.toFixed(8)\n});\n```\n\n**Implementation:**\n\n- `ClientExchange` [src/client/ClientExchange.ts:1-300]() wraps exchange schema\n- `ExchangeCoreService` [src/lib/services/core/ExchangeCoreService.ts:1-200]() coordinates data fetching\n- `ExchangeConnectionService` [src/lib/services/connection/ExchangeConnectionService.ts:1-100]() caches exchange instances\n\n**Candle Validation:**\n\n`ExchangeCoreService.prototype.getValidatedCandles` [src/lib/services/core/ExchangeCoreService.ts:50-150]() performs:\n\n1. Anomaly detection (price spikes beyond median)\n2. Incomplete candle filtering (volume = 0 or prices missing)\n3. Retry logic with exponential backoff\n\nSources: [README.md:70-80](), [src/client/ClientExchange.ts](), [src/lib/services/core/ExchangeCoreService.ts](), [src/interfaces/Exchange.interface.ts]()\n\n---\n\n### Event-Driven Monitoring\n\nThe framework provides 13 event emitters for real-time monitoring:\n\n```mermaid\ngraph LR\n    subgraph \"Signal Events\"\n        signalEmitter[\"signalEmitter<br/>All signals\"]\n        signalBacktestEmitter[\"signalBacktestEmitter<br/>Backtest only\"]\n        signalLiveEmitter[\"signalLiveEmitter<br/>Live only\"]\n    end\n    \n    subgraph \"Progress Events\"\n        progressBacktestEmitter[\"progressBacktestEmitter<br/>Frame completion %\"]\n        walkerEmitter[\"walkerEmitter<br/>Strategy comparison\"]\n        progressOptimizerEmitter[\"progressOptimizerEmitter<br/>Data source processing\"]\n    end\n    \n    subgraph \"Completion Events\"\n        doneBacktestSubject[\"doneBacktestSubject\"]\n        doneLiveSubject[\"doneLiveSubject\"]\n        doneWalkerSubject[\"doneWalkerSubject\"]\n        walkerCompleteSubject[\"walkerCompleteSubject\"]\n    end\n    \n    subgraph \"Partial & Risk Events\"\n        partialProfitSubject[\"partialProfitSubject<br/>10%, 20%, 30%...\"]\n        partialLossSubject[\"partialLossSubject<br/>-10%, -20%...\"]\n        riskSubject[\"riskSubject<br/>Validation failures\"]\n    end\n    \n    subgraph \"System Events\"\n        performanceEmitter[\"performanceEmitter<br/>Timing metrics\"]\n        errorEmitter[\"errorEmitter<br/>Recoverable errors\"]\n        exitEmitter[\"exitEmitter<br/>Fatal errors\"]\n    end\n    \n    style signalEmitter fill:#f9f9f9,stroke:#333\n    style progressBacktestEmitter fill:#f9f9f9,stroke:#333\n    style riskSubject fill:#f9f9f9,stroke:#333\n```\n\n**Diagram: 13 Event Emitters for Monitoring**\n\n**Event Categories:**\n\n1. **Signal Events**: Three-tier emission (global, mode-specific) enables selective subscription\n2. **Progress Events**: Real-time progress tracking for long-running operations\n3. **Completion Events**: Mode-specific completion signals for cleanup/reporting\n4. **Partial Events**: Unrealized P&L milestones (10%, 20%, 30%...)\n5. **Risk Events**: Signal rejection tracking\n6. **System Events**: Performance metrics and error handling\n\n**Public API Listeners:**\n\nFrom [README.md:175-176](), listeners use `functools-kit` `queued` wrapper for sequential execution:\n\n| Function | Event | Purpose |\n|----------|-------|---------|\n| `listenSignalBacktest` | `signalBacktestEmitter` | Backtest signal events |\n| `listenSignalLive` | `signalLiveEmitter` | Live signal events |\n| `listenDoneBacktest` | `doneBacktestSubject` | Backtest completion |\n| `listenDoneLive` | `doneLiveSubject` | Live completion |\n| `listenWalkerProgress` | `walkerEmitter` | Walker progress updates |\n| `listenWalkerComplete` | `walkerCompleteSubject` | Walker final results |\n| `listenPartialProfit` | `partialProfitSubject` | Profit milestones |\n| `listenPartialLoss` | `partialLossSubject` | Loss milestones |\n| `listenRisk` | `riskSubject` | Risk validation failures |\n| `listenPerformance` | `performanceEmitter` | Execution timing |\n| `listenError` | `errorEmitter` | Non-fatal errors |\n| `listenExit` | `exitEmitter` | Fatal errors |\n\n**Markdown Services Integration:**\n\nMarkdown services [src/lib/services/markdown/]() subscribe to emitters and accumulate events in `ReportStorage` (max 250 per key) for report generation.\n\nSources: [src/config/emitters.ts](), [src/api/listeners/](), [README.md:175-176](), [src/lib/services/markdown/]()\n\n---\n\n## Performance & Production Features\n\n### Streaming Architecture\n\nBacktest Kit uses async generators for memory-efficient streaming:\n\n**Generator Patterns:**\n\n| Mode | Generator Type | Memory Behavior | Early Termination |\n|------|----------------|-----------------|-------------------|\n| Backtest | Finite | O(1) per frame | `break` or return from loop |\n| Live | Infinite | O(1) per tick | Set stop flag, wait for cleanup |\n| Walker | Finite | O(strategies) | `break` or return from loop |\n\n**Implementation:**\n\nFrom [src/lib/services/logic/private/BacktestLogicPrivateService.ts:50-150](), backtest uses:\n\n```typescript\npublic async *generate(symbol: string, context: IBacktestContext) {\n  for (const frame of frames) {\n    const result = await this.strategyCoreService.tick(symbol, frame.when, true);\n    yield result;\n  }\n  yield { type: 'done', data: allClosedSignals };\n}\n```\n\n**Event-Driven vs. Pull-Based:**\n\nFrom [README.md:201-224](), two equivalent consumption models:\n\n```typescript\n// Pull-based (async iterator)\nfor await (const event of Backtest.run('BTCUSDT', config)) {\n  // Process event\n}\n\n// Event-driven (background execution)\nBacktest.background('BTCUSDT', config);\nlistenSignalBacktest(event => { /* handle */ });\n```\n\nSources: [README.md:201-224](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts](), [src/lib/services/logic/private/LiveLogicPrivateService.ts]()\n\n---\n\n### VWAP Pricing\n\nVolume Weighted Average Price ensures realistic entry/exit pricing:\n\n**Calculation:**\n\n`ClientExchange.prototype.getVWAP` [src/client/ClientExchange.ts:150-200]() computes:\n\n```\nVWAP = Σ(price × volume) / Σ(volume)\n```\n\nUsing last `CC_AVG_PRICE_CANDLES_COUNT` (default: 5) 1-minute candles.\n\n**Usage Points:**\n\n1. **Signal Activation**: When `priceOpen` is reached, actual entry uses VWAP\n2. **TP/SL Execution**: Exit prices calculated from current VWAP\n3. **Scheduled Signals**: Check if `priceOpen` in [VWAP - tolerance, VWAP + tolerance]\n\n**Configuration:**\n\n| Parameter | Default | Purpose |\n|-----------|---------|---------|\n| `CC_AVG_PRICE_CANDLES_COUNT` | 5 | Number of 1m candles for VWAP |\n| `CC_SCHEDULED_PRICE_TOLERANCE_PERCENT` | 0.1% | Tolerance for scheduled activation |\n\nSources: [src/client/ClientExchange.ts:150-200](), [src/config/params.ts:40-50]()\n\n---\n\n### Self-Hosted Deployment\n\n**Zero Vendor Lock-In:**\n\n- No cloud dependencies\n- No third-party API requirements (except optional Ollama for LLM)\n- All data processing runs locally\n- Custom persistence backends supported\n\n**Dependencies:**\n\nFrom [package.json:74-79]():\n\n```json\n{\n  \"di-kit\": \"^1.0.18\",           // Dependency injection\n  \"di-scoped\": \"^1.0.20\",        // Scoped context management\n  \"functools-kit\": \"^1.0.94\",    // Functional utilities (memoize, iterate)\n  \"get-moment-stamp\": \"^1.1.1\"   // Timestamp utilities\n}\n```\n\n**Peer Dependencies:**\n\n- TypeScript 5.0+ (development only)\n- Node.js 15+ (runtime)\n\n**Optional Integrations:**\n\n- CCXT (exchange data)\n- Ollama (LLM strategies)\n- Redis (custom persistence)\n\n**Comparison to QuantConnect:**\n\nFrom [README.md:226-236]():\n\n| Feature | Backtest Kit | QuantConnect |\n|---------|--------------|--------------|\n| **Language** | TypeScript/JavaScript | C# |\n| **Hosting** | Self-hosted | Cloud-based |\n| **Data** | CCXT or custom | Proprietary |\n| **Fees** | None | Subscription required |\n| **Extensibility** | Full code access | Limited to API |\n\nSources: [package.json:1-80](), [README.md:226-236]()\n\n---\n\n## Production Readiness\n\n### Code Reusability\n\nThe `backtest` flag in `ExecutionContext` enables identical strategy code across modes:\n\n```typescript\n// Strategy code (same for backtest and live)\naddStrategy({\n  strategyName: 'my-strategy',\n  getSignal: async (symbol) => {\n    const candles = await getCandles(symbol, '1h', 24);\n    // Analysis logic here\n    return { position: 'long', ... };\n  }\n});\n\n// Backtest execution\nBacktest.run('BTCUSDT', { strategyName: 'my-strategy', ... });\n\n// Live execution (same strategy)\nLive.run('BTCUSDT', { strategyName: 'my-strategy', ... });\n```\n\n**Behavioral Differences:**\n\n| Aspect | Backtest | Live |\n|--------|----------|------|\n| **Persistence** | In-memory only | Atomic file writes |\n| **Emitters** | `signalBacktestEmitter` | `signalLiveEmitter` |\n| **Time source** | Frame timestamps | `new Date()` |\n| **Execution speed** | Fast-forward possible | Real-time only |\n\nSources: [README.md:19](), [src/lib/services/context/ExecutionContextService.ts]()\n\n---\n\n### Testing Coverage\n\nFrom [README.md:243]():\n\n- 300+ unit and integration tests\n- Validation coverage\n- Recovery scenarios\n- Event emission verification\n- Report generation accuracy\n\n**Test Organization:**\n\nTests use `worker-testbed` [package.json:69]() for isolated execution environments.\n\nSources: [README.md:243](), [package.json:69]()\n\n---\n\n## Summary Table\n\n| Feature Category | Key Components | Primary Files |\n|------------------|----------------|---------------|\n| **Time Engine** | `ExecutionContextService`, `getCandles` | [src/lib/services/context/](), [src/api/getCandles.ts]() |\n| **Validation** | `ClientStrategy.tick`, `GLOBAL_CONFIG` | [src/client/ClientStrategy.ts](), [src/config/params.ts]() |\n| **Persistence** | `PersistSignalAdapter`, `PersistBase` | [src/lib/services/persist/]() |\n| **Risk** | `ClientRisk`, `RiskGlobalService` | [src/client/ClientRisk.ts](), [src/lib/services/global/RiskGlobalService.ts]() |\n| **LLM Integration** | `ClientOptimizer`, `OptimizerTemplateService` | [src/client/ClientOptimizer.ts](), [src/lib/services/template/OptimizerTemplateService.ts]() |\n| **Events** | 13 emitters in `emitters.ts` | [src/config/emitters.ts]() |\n| **Reporting** | Markdown services, `ReportStorage` | [src/lib/services/markdown/]() |\n| **Data Sources** | `ClientExchange`, CCXT integration | [src/client/ClientExchange.ts]() |\n\nSources: All files in [src/]() directory"
                    },
                    {
                        "page_plan": {
                            "id": "1.2",
                            "title": "Architecture Overview"
                        },
                        "content": "# Architecture Overview\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [assets/uml.svg](assets/uml.svg)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/function/add.ts](src/function/add.ts)\n- [src/function/list.ts](src/function/list.ts)\n- [src/lib/core/provide.ts](src/lib/core/provide.ts)\n- [src/lib/core/types.ts](src/lib/core/types.ts)\n- [src/lib/index.ts](src/lib/index.ts)\n\n</details>\n\n\n\nThis page describes the high-level system architecture of Backtest Kit, focusing on the layered design and how components interact. It covers the dependency injection system, service organization, client layer structure, and data flow patterns.\n\nFor details on execution modes (Backtest, Live, Walker), see [Execution Modes](#5). For the signal lifecycle state machine, see [Signals & Signal Lifecycle](#3.1). For the event system details, see [Event System Architecture](#4.4).\n\n## System Layers\n\nBacktest Kit follows a clean architecture pattern with five distinct layers that separate concerns and enable testability. The layers enforce unidirectional dependencies from top to bottom.\n\n```mermaid\ngraph TB\n    subgraph \"Layer 1: Public API\"\n        API[\"Global Functions<br/>(src/function/add.ts,<br/>src/function/list.ts)\"]\n        Classes[\"Execution Classes<br/>(Backtest, Live, Walker,<br/>Optimizer, Performance)\"]\n    end\n    \n    subgraph \"Layer 2: Command Services\"\n        BacktestCmd[\"BacktestCommandService\"]\n        LiveCmd[\"LiveCommandService\"]\n        WalkerCmd[\"WalkerCommandService\"]\n    end\n    \n    subgraph \"Layer 3: Service Layer\"\n        Logic[\"Logic Services<br/>(Public & Private)\"]\n        Core[\"Core Services<br/>(Strategy, Exchange, Frame)\"]\n        Global[\"Global Services<br/>(Risk, Sizing, Optimizer, Partial)\"]\n        Schema[\"Schema Services<br/>(Registry Pattern)\"]\n        Validation[\"Validation Services<br/>(Memoized)\"]\n        Connection[\"Connection Services<br/>(Memoized Factories)\"]\n        Context[\"Context Services<br/>(Execution & Method)\"]\n        Markdown[\"Markdown Services<br/>(Report Generation)\"]\n        Template[\"Template Services<br/>(Code Generation)\"]\n    end\n    \n    subgraph \"Layer 4: Client Layer\"\n        ClientStrategy[\"ClientStrategy<br/>(src/lib/client/ClientStrategy.ts)\"]\n        ClientExchange[\"ClientExchange<br/>(src/lib/client/ClientExchange.ts)\"]\n        ClientRisk[\"ClientRisk/MergeRisk<br/>(src/lib/client/ClientRisk.ts)\"]\n        ClientFrame[\"ClientFrame<br/>(src/lib/client/ClientFrame.ts)\"]\n        ClientPartial[\"ClientPartial<br/>(src/lib/client/ClientPartial.ts)\"]\n    end\n    \n    subgraph \"Layer 5: Persistence & External\"\n        Persist[\"PersistSignalAdapter<br/>(src/lib/adapter/PersistSignalAdapter.ts)\"]\n        Emitters[\"Event Emitters<br/>(src/lib/subject/*.ts)\"]\n        CCXT[\"CCXT Exchange API\"]\n        LLM[\"Ollama LLM\"]\n    end\n    \n    API --> BacktestCmd\n    API --> LiveCmd\n    API --> WalkerCmd\n    Classes --> BacktestCmd\n    Classes --> LiveCmd\n    Classes --> WalkerCmd\n    \n    BacktestCmd --> Logic\n    LiveCmd --> Logic\n    WalkerCmd --> Logic\n    \n    Logic --> Core\n    Logic --> Context\n    Core --> Connection\n    Core --> Schema\n    Core --> Validation\n    Connection --> ClientStrategy\n    Connection --> ClientExchange\n    Connection --> ClientRisk\n    Connection --> ClientFrame\n    Connection --> ClientPartial\n    Global --> Connection\n    Markdown --> Emitters\n    Template --> Schema\n    \n    ClientStrategy --> Persist\n    ClientStrategy --> Emitters\n    ClientExchange --> CCXT\n    Core --> Emitters\n```\n\nSources: [README.md:1-255](), [src/lib/index.ts:1-246](), [src/lib/core/types.ts:1-105](), [docs/internals.md:1-132]()\n\n## Dependency Injection System\n\nThe framework uses a custom dependency injection container built on `di-kit` that manages service instantiation and lifecycle. All services are registered via Symbol tokens defined in `TYPES`.\n\n### TYPES Symbol Registry\n\n```mermaid\ngraph LR\n    TYPES[\"TYPES Object<br/>(src/lib/core/types.ts)\"]\n    \n    Base[\"baseServices<br/>• loggerService\"]\n    Ctx[\"contextServices<br/>• executionContextService<br/>• methodContextService\"]\n    Conn[\"connectionServices<br/>• exchangeConnectionService<br/>• strategyConnectionService<br/>• frameConnectionService<br/>• sizingConnectionService<br/>• riskConnectionService<br/>• optimizerConnectionService<br/>• partialConnectionService\"]\n    Sch[\"schemaServices<br/>• exchangeSchemaService<br/>• strategySchemaService<br/>• frameSchemaService<br/>• walkerSchemaService<br/>• sizingSchemaService<br/>• riskSchemaService<br/>• optimizerSchemaService\"]\n    \n    TYPES --> Base\n    TYPES --> Ctx\n    TYPES --> Conn\n    TYPES --> Sch\n```\n\n| Service Category | Symbol Examples | Lifecycle | Purpose |\n|-----------------|----------------|-----------|---------|\n| **Base Services** | `loggerService` | Singleton | Centralized logging with context propagation |\n| **Context Services** | `executionContextService`, `methodContextService` | Singleton | Ambient context using `di-scoped` AsyncLocalStorage |\n| **Schema Services** | `strategySchemaService`, `exchangeSchemaService` | Singleton | Immutable configuration storage via `ToolRegistry` |\n| **Validation Services** | `strategyValidationService`, `exchangeValidationService` | Singleton | Memoized existence checks |\n| **Connection Services** | `strategyConnectionService`, `exchangeConnectionService` | Singleton | Memoized client instance factories |\n| **Core Services** | `strategyCoreService`, `exchangeCoreService` | Singleton | Business logic orchestration |\n| **Global Services** | `riskGlobalService`, `sizingGlobalService` | Singleton | Shared state across strategies |\n| **Logic Services** | `backtestLogicPrivateService`, `liveLogicPrivateService` | Singleton | Async generator execution loops |\n| **Command Services** | `backtestCommandService`, `liveCommandService` | Singleton | Public API wrappers |\n| **Markdown Services** | `backtestMarkdownService`, `liveMarkdownService` | Singleton | Event subscribers for reporting |\n| **Template Services** | `optimizerTemplateService` | Singleton | Code generation for optimizer |\n\nSources: [src/lib/core/types.ts:1-105](), [src/lib/core/provide.ts:1-143](), [docs/internals.md:27-40]()\n\n### Service Registration Pattern\n\nServices are registered in [src/lib/core/provide.ts:1-143]() using the `provide()` function with lazy factory patterns. The `backtest` object aggregates all service references via `inject()`:\n\n```typescript\n// From src/lib/core/provide.ts\nprovide(TYPES.strategyConnectionService, () => new StrategyConnectionService());\n\n// From src/lib/index.ts\nconst connectionServices = {\n  strategyConnectionService: inject<StrategyConnectionService>(\n    TYPES.strategyConnectionService\n  ),\n};\n\nexport const backtest = {\n  ...baseServices,\n  ...connectionServices,\n  // ... other categories\n};\n```\n\nThe `init()` function is called at module load to trigger service initialization: [src/lib/index.ts:240]().\n\nSources: [src/lib/core/provide.ts:1-143](), [src/lib/index.ts:61-246]()\n\n## Service Layer Architecture\n\nThe service layer consists of 11 categories organized by responsibility. Services never directly instantiate dependencies; instead they use dependency injection.\n\n### Service Dependency Graph\n\n```mermaid\ngraph TD\n    BacktestCmd[\"BacktestCommandService<br/>(src/services/command/)\"]\n    LiveCmd[\"LiveCommandService\"]\n    \n    BtLogicPub[\"BacktestLogicPublicService<br/>(src/services/logic/public/)\"]\n    LiveLogicPub[\"LiveLogicPublicService\"]\n    \n    BtLogicPriv[\"BacktestLogicPrivateService<br/>(src/services/logic/private/)\"]\n    LiveLogicPriv[\"LiveLogicPrivateService\"]\n    \n    StratCore[\"StrategyCoreService<br/>(src/services/core/)\"]\n    ExchCore[\"ExchangeCoreService\"]\n    FrameCore[\"FrameCoreService\"]\n    \n    StratConn[\"StrategyConnectionService<br/>(src/services/connection/)\"]\n    ExchConn[\"ExchangeConnectionService\"]\n    RiskConn[\"RiskConnectionService\"]\n    PartialConn[\"PartialConnectionService\"]\n    \n    StratSchema[\"StrategySchemaService<br/>(src/services/schema/)\"]\n    ExchSchema[\"ExchangeSchemaService\"]\n    RiskSchema[\"RiskSchemaService\"]\n    \n    StratVal[\"StrategyValidationService<br/>(src/services/validation/)\"]\n    ExchVal[\"ExchangeValidationService\"]\n    RiskVal[\"RiskValidationService\"]\n    \n    ClientStrat[\"ClientStrategy\"]\n    ClientExch[\"ClientExchange\"]\n    ClientRisk[\"ClientRisk\"]\n    \n    BacktestCmd --> StratVal\n    BacktestCmd --> ExchVal\n    BacktestCmd --> BtLogicPub\n    \n    LiveCmd --> StratVal\n    LiveCmd --> ExchVal\n    LiveCmd --> LiveLogicPub\n    \n    BtLogicPub --> BtLogicPriv\n    LiveLogicPub --> LiveLogicPriv\n    \n    BtLogicPriv --> StratCore\n    BtLogicPriv --> ExchCore\n    BtLogicPriv --> FrameCore\n    LiveLogicPriv --> StratCore\n    \n    StratCore --> StratConn\n    StratCore --> StratVal\n    ExchCore --> ExchConn\n    ExchCore --> ExchVal\n    \n    StratConn --> StratSchema\n    StratConn --> RiskConn\n    StratConn --> ExchConn\n    StratConn --> PartialConn\n    ExchConn --> ExchSchema\n    RiskConn --> RiskSchema\n    \n    StratConn --> ClientStrat\n    ExchConn --> ClientExch\n    RiskConn --> ClientRisk\n    \n    StratVal --> RiskVal\n```\n\nSources: [src/lib/core/provide.ts:1-143](), [docs/uml.puml:1-1101]()\n\n### Context Propagation Services\n\nTwo context services use `di-scoped` library to propagate ambient information through the call stack without explicit parameter passing:\n\n**ExecutionContextService** ([src/services/context/ExecutionContextService.ts]()) provides:\n- `symbol: string` - Trading pair symbol\n- `when: Date` - Current execution timestamp\n- `backtest: boolean` - Execution mode flag\n\n**MethodContextService** ([src/services/context/MethodContextService.ts]()) provides:\n- `strategyName: string` - Active strategy identifier\n- `exchangeName: string` - Active exchange identifier  \n- `frameName?: string` - Active frame identifier (backtest only)\n\nBoth services wrap execution blocks using `runInContext()` method that leverages Node.js `AsyncLocalStorage` for context isolation.\n\nSources: [src/lib/index.ts:10-15](), [docs/internals.md:27-40]()\n\n### Connection Services (Memoized Factories)\n\nConnection services create and cache client instances using `functools-kit` memoization. The cache key is typically the schema name:\n\n```mermaid\ngraph LR\n    StratConn[\"StrategyConnectionService\"]\n    ExchConn[\"ExchangeConnectionService\"]\n    \n    Cache[\"Memoization Cache<br/>(functools-kit)\"]\n    \n    ClientStrat1[\"ClientStrategy<br/>instance 1\"]\n    ClientStrat2[\"ClientStrategy<br/>instance 2\"]\n    ClientExch1[\"ClientExchange<br/>instance 1\"]\n    \n    StratConn -->|\"getClient(strategyName1)\"| Cache\n    StratConn -->|\"getClient(strategyName2)\"| Cache\n    ExchConn -->|\"getClient(exchangeName)\"| Cache\n    \n    Cache -->|\"cache miss\"| ClientStrat1\n    Cache -->|\"cache hit\"| ClientStrat1\n    Cache -->|\"cache miss\"| ClientStrat2\n    Cache -->|\"cache miss\"| ClientExch1\n```\n\nThis pattern ensures:\n- Only one client instance per unique schema name\n- Efficient memory usage\n- State preservation across multiple strategy executions\n- Fast lookup for repeated access\n\nSources: [src/lib/index.ts:74-96](), [docs/internals.md:32-35]()\n\n## Client Layer (Pure Business Logic)\n\nThe client layer contains pure TypeScript classes with no dependency injection. All methods are prototype methods (not arrow functions) for memory efficiency. Clients receive dependencies via constructor parameters.\n\n### Client Class Hierarchy\n\n| Client Class | File Path | Responsibility | Key Methods |\n|--------------|-----------|----------------|-------------|\n| `ClientStrategy` | [src/lib/client/ClientStrategy.ts]() | Signal lifecycle, validation, persistence | `tick()`, `backtest()`, `getSignal()` |\n| `ClientExchange` | [src/lib/client/ClientExchange.ts]() | Candle data, VWAP calculation, price formatting | `getCandles()`, `getAveragePrice()` |\n| `ClientFrame` | [src/lib/client/ClientFrame.ts]() | Timeframe generation for backtesting | `getTimeframe()` |\n| `ClientRisk` | [src/lib/client/ClientRisk.ts]() | Risk validation, position tracking | `checkSignal()`, `addSignal()`, `removeSignal()` |\n| `MergeRisk` | [src/lib/client/ClientRisk.ts]() | Combines multiple risk profiles | `checkSignal()` |\n| `ClientPartial` | [src/lib/client/ClientPartial.ts]() | Profit/loss milestone tracking | `checkPartials()` |\n| `ClientOptimizer` | [src/lib/client/ClientOptimizer.ts]() | LLM-powered strategy generation | `getData()`, `getCode()` |\n\nSources: [docs/internals.md:30-31]()\n\n### ClientStrategy Signal Processing Flow\n\n```mermaid\nstateDiagram-v2\n    [*] --> tick\n    tick --> getSignal: \"Call user's<br/>getSignal()\"\n    getSignal --> validateSignal: \"Check prices,<br/>TP/SL logic\"\n    validateSignal --> checkRisk: \"ClientRisk<br/>validation\"\n    checkRisk --> scheduled: \"priceOpen<br/>not reached\"\n    checkRisk --> opened: \"priceOpen<br/>reached\"\n    scheduled --> monitorScheduled: \"Check SL<br/>before activation\"\n    monitorScheduled --> opened: \"Price reaches<br/>priceOpen\"\n    monitorScheduled --> cancelled: \"SL hit or<br/>timeout\"\n    opened --> persist: \"PersistSignalAdapter<br/>writeSignalData()\"\n    persist --> backtest: \"Fast processing<br/>mode\"\n    persist --> active: \"Real-time<br/>monitoring\"\n    active --> checkTP: \"VWAP vs<br/>priceTakeProfit\"\n    active --> checkSL: \"VWAP vs<br/>priceStopLoss\"\n    active --> checkTime: \"timestamp vs<br/>minuteEstimatedTime\"\n    checkTP --> closed: \"TP reached\"\n    checkSL --> closed: \"SL reached\"\n    checkTime --> closed: \"Time expired\"\n    backtest --> closed: \"Batch candle<br/>processing\"\n    closed --> [*]\n    cancelled --> [*]\n```\n\nThe `tick()` method at [src/lib/client/ClientStrategy.ts]() orchestrates the entire signal lifecycle with interval throttling to prevent spam.\n\nSources: [docs/internals.md:54-82]()\n\n## Public API Layer\n\nThe public API consists of global functions and execution classes that provide the primary interface for users. All functions are exported from [src/index.ts]().\n\n### Configuration Functions\n\n| Function | File | Purpose |\n|----------|------|---------|\n| `addStrategy()` | [src/function/add.ts:52-64]() | Register `IStrategySchema` with validation |\n| `addExchange()` | [src/function/add.ts:101-113]() | Register `IExchangeSchema` for data source |\n| `addFrame()` | [src/function/add.ts:145-151]() | Register `IFrameSchema` for backtest period |\n| `addRisk()` | [src/function/add.ts:270-282]() | Register `IRiskSchema` with custom validations |\n| `addWalker()` | [src/function/add.ts:190-202]() | Register `IWalkerSchema` for strategy comparison |\n| `addSizing()` | [src/function/add.ts:256-268]() | Register `ISizingSchema` for position sizing |\n| `addOptimizer()` | [src/function/add.ts:294-306]() | Register `IOptimizerSchema` for LLM strategy generation |\n| `setConfig()` | [src/function/config.ts]() | Modify `GLOBAL_CONFIG` parameters |\n| `setLogger()` | [src/function/logger.ts]() | Plug in custom `ILogger` implementation |\n\n### Execution Classes\n\n```mermaid\nclassDiagram\n    class Backtest {\n        +run(symbol, context) AsyncGenerator\n        +background(symbol, context) void\n        +stop(symbol, strategyName) Promise\n        +getData(symbol, strategyName) BacktestStatistics\n        +getReport(symbol, strategyName) string\n        +dump(symbol, strategyName) Promise\n    }\n    \n    class Live {\n        +run(symbol, context) AsyncGenerator\n        +background(symbol, context) void\n        +stop(symbol, strategyName) Promise\n        +getData(symbol, strategyName) LiveStatistics\n        +getReport(symbol, strategyName) string\n        +dump(symbol, strategyName) Promise\n    }\n    \n    class Walker {\n        +run(symbol, context) AsyncGenerator\n        +background(symbol, context) void\n        +stop(symbol, walkerName) Promise\n        +getData(symbol, walkerName) WalkerStatistics\n        +getReport(symbol, walkerName) string\n        +dump(symbol, walkerName) Promise\n    }\n    \n    class Optimizer {\n        +getData(optimizerName) Promise~OptimizerData~\n        +getCode(optimizerName, outputPath) Promise~string~\n        +dump(optimizerName, outputPath) Promise\n    }\n    \n    Backtest --> BacktestCommandService: delegates to\n    Live --> LiveCommandService: delegates to\n    Walker --> WalkerCommandService: delegates to\n    Optimizer --> OptimizerGlobalService: delegates to\n```\n\nEach execution class provides three consumption patterns:\n1. **Async Iterator**: `for await (const event of Backtest.run(...))`\n2. **Background Execution**: `Backtest.background(...)` with event listeners\n3. **Statistics/Reports**: `getData()`, `getReport()`, `dump()` methods\n\nSources: [src/class/Backtest.ts](), [src/class/Live.ts](), [src/class/Walker.ts](), [README.md:201-225]()\n\n## Event-Driven Architecture\n\nThe event system uses RxJS Subject pattern for decoupled communication between producers (strategy execution) and consumers (markdown services, user listeners).\n\n### Event Emitters\n\n| Emitter | File Path | Emits When | Payload Type |\n|---------|-----------|------------|--------------|\n| `signalEmitter` | [src/lib/subject/signalEmitter.ts]() | Every tick (all modes) | `IStrategyTickResult` |\n| `signalBacktestEmitter` | [src/lib/subject/signalBacktestEmitter.ts]() | Backtest mode only | `IStrategyTickResult` |\n| `signalLiveEmitter` | [src/lib/subject/signalLiveEmitter.ts]() | Live mode only | `IStrategyTickResult` |\n| `progressBacktestEmitter` | [src/lib/subject/progressBacktestEmitter.ts]() | Frame completion | `number` (percentage) |\n| `walkerEmitter` | [src/lib/subject/walkerEmitter.ts]() | Strategy completion in walker | `WalkerContract` |\n| `walkerCompleteSubject` | [src/lib/subject/walkerCompleteSubject.ts]() | Walker finishes all strategies | `WalkerCompleteContract` |\n| `doneBacktestSubject` | [src/lib/subject/doneBacktestSubject.ts]() | Backtest completes | `DoneContract` |\n| `doneLiveSubject` | [src/lib/subject/doneLiveSubject.ts]() | Live execution stops | `DoneContract` |\n| `doneWalkerSubject` | [src/lib/subject/doneWalkerSubject.ts]() | Walker completes | `DoneContract` |\n| `riskSubject` | [src/lib/subject/riskSubject.ts]() | Signal fails risk validation | `RiskContract` |\n| `performanceEmitter` | [src/lib/subject/performanceEmitter.ts]() | Execution timing metrics | `PerformanceContract` |\n| `partialProfitSubject` | [src/lib/subject/partialProfitSubject.ts]() | Profit milestone reached | `PartialContract` |\n| `partialLossSubject` | [src/lib/subject/partialLossSubject.ts]() | Loss milestone reached | `PartialContract` |\n| `errorEmitter` | [src/lib/subject/errorEmitter.ts]() | Recoverable error occurs | `Error` |\n| `exitEmitter` | [src/lib/subject/exitEmitter.ts]() | Fatal error (terminate) | `Error` |\n\n### Event Flow Architecture\n\n```mermaid\ngraph LR\n    subgraph \"Event Producers\"\n        StratCore[\"StrategyCoreService\"]\n        ClientStrat[\"ClientStrategy.tick()\"]\n        BtLogic[\"BacktestLogicPrivateService\"]\n        LiveLogic[\"LiveLogicPrivateService\"]\n    end\n    \n    subgraph \"Event Bus\"\n        SigEmit[\"signalEmitter\"]\n        SigBtEmit[\"signalBacktestEmitter\"]\n        SigLiveEmit[\"signalLiveEmitter\"]\n        ProgEmit[\"progressBacktestEmitter\"]\n        DoneEmit[\"done*Subject\"]\n        RiskEmit[\"riskSubject\"]\n        PartialEmit[\"partial*Subject\"]\n    end\n    \n    subgraph \"Event Consumers\"\n        BtMD[\"BacktestMarkdownService\"]\n        LiveMD[\"LiveMarkdownService\"]\n        SchedMD[\"ScheduleMarkdownService\"]\n        HeatMD[\"HeatMarkdownService\"]\n        RiskMD[\"RiskMarkdownService\"]\n        PartialMD[\"PartialMarkdownService\"]\n        UserListeners[\"User Event Listeners<br/>(listenSignal*, etc.)\"]\n    end\n    \n    ClientStrat -->|\"emit\"| SigEmit\n    ClientStrat -->|\"emit\"| SigBtEmit\n    ClientStrat -->|\"emit\"| SigLiveEmit\n    BtLogic -->|\"emit\"| ProgEmit\n    BtLogic -->|\"emit\"| DoneEmit\n    LiveLogic -->|\"emit\"| DoneEmit\n    StratCore -->|\"emit\"| RiskEmit\n    ClientStrat -->|\"emit\"| PartialEmit\n    \n    SigBtEmit -->|\"subscribe\"| BtMD\n    SigLiveEmit -->|\"subscribe\"| LiveMD\n    SigEmit -->|\"subscribe\"| SchedMD\n    SigEmit -->|\"subscribe\"| HeatMD\n    RiskEmit -->|\"subscribe\"| RiskMD\n    PartialEmit -->|\"subscribe\"| PartialMD\n    \n    SigEmit -->|\"subscribe\"| UserListeners\n    DoneEmit -->|\"subscribe\"| UserListeners\n    ProgEmit -->|\"subscribe\"| UserListeners\n    RiskEmit -->|\"subscribe\"| UserListeners\n```\n\nAll user event listeners use `functools-kit` `queued` wrapper ([src/function/listen.ts]()) to ensure sequential async processing, preventing race conditions during high-frequency event emission.\n\nSources: [docs/internals.md:83-90](), [README.md:173-177]()\n\n## Data Flow Patterns\n\nThe framework implements three primary data flow patterns corresponding to the three execution modes.\n\n### Backtest Data Flow\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant BacktestClass as \"Backtest Class\"\n    participant BacktestCmd as \"BacktestCommandService\"\n    participant BtLogicPriv as \"BacktestLogicPrivateService\"\n    participant FrameCore as \"FrameCoreService\"\n    participant StratCore as \"StrategyCoreService\"\n    participant ClientStrat as \"ClientStrategy\"\n    participant Emitters as \"Event Emitters\"\n    participant MarkdownSvc as \"BacktestMarkdownService\"\n    \n    User->>BacktestClass: \"Backtest.run(symbol, context)\"\n    BacktestClass->>BacktestCmd: \"run(symbol, context)\"\n    BacktestCmd->>BtLogicPriv: \"run(symbol)\"\n    BtLogicPriv->>FrameCore: \"getTimeframe()\"\n    FrameCore-->>BtLogicPriv: \"[timestamps]\"\n    \n    loop \"For each timeframe\"\n        BtLogicPriv->>StratCore: \"tick(when)\"\n        StratCore->>ClientStrat: \"tick()\"\n        ClientStrat->>ClientStrat: \"getSignal()\"\n        ClientStrat->>ClientStrat: \"validateSignal()\"\n        ClientStrat->>ClientStrat: \"checkRisk()\"\n        \n        alt \"Signal Opened\"\n            ClientStrat->>ClientStrat: \"backtest(candles)\"\n            ClientStrat->>Emitters: \"emit signalBacktestEmitter\"\n            Emitters->>MarkdownSvc: \"event notification\"\n            ClientStrat-->>StratCore: \"IStrategyTickResultClosed\"\n            StratCore-->>BtLogicPriv: \"result\"\n            BtLogicPriv->>User: \"yield result\"\n        else \"No Signal / Idle\"\n            ClientStrat-->>StratCore: \"IStrategyTickResultIdle\"\n            StratCore-->>BtLogicPriv: \"result\"\n            BtLogicPriv->>BtLogicPriv: \"skip to next\"\n        end\n    end\n    \n    BtLogicPriv->>Emitters: \"emit doneBacktestSubject\"\n    BtLogicPriv-->>User: \"AsyncGenerator complete\"\n```\n\nKey characteristics:\n- Deterministic timeframe iteration via [src/services/logic/private/BacktestLogicPrivateService.ts]()\n- Fast-forward optimization: skip timeframes while signal is active\n- Bulk candle processing via `backtest()` method\n- All events buffered in markdown services (max 250 per key)\n\nSources: [docs/internals.md:54-67](), [src/services/logic/private/BacktestLogicPrivateService.ts]()\n\n### Live Trading Data Flow\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant LiveClass as \"Live Class\"\n    participant LiveCmd as \"LiveCommandService\"\n    participant LiveLogicPriv as \"LiveLogicPrivateService\"\n    participant StratCore as \"StrategyCoreService\"\n    participant ClientStrat as \"ClientStrategy\"\n    participant Persist as \"PersistSignalAdapter\"\n    participant Emitters as \"Event Emitters\"\n    \n    User->>LiveClass: \"Live.run(symbol, context)\"\n    LiveClass->>LiveCmd: \"run(symbol, context)\"\n    LiveCmd->>LiveLogicPriv: \"run(symbol)\"\n    LiveLogicPriv->>Persist: \"waitForInit() - load state\"\n    Persist-->>LiveLogicPriv: \"persisted signal or null\"\n    \n    loop \"Infinite Loop (while !stopped)\"\n        LiveLogicPriv->>LiveLogicPriv: \"when = new Date()\"\n        LiveLogicPriv->>StratCore: \"tick(when)\"\n        StratCore->>ClientStrat: \"tick()\"\n        \n        alt \"No Active Signal\"\n            ClientStrat->>ClientStrat: \"getSignal()\"\n            ClientStrat->>ClientStrat: \"validateSignal()\"\n            ClientStrat->>ClientStrat: \"checkRisk()\"\n            \n            alt \"Signal Opened\"\n                ClientStrat->>Persist: \"writeSignalData()\"\n                Persist-->>ClientStrat: \"persisted\"\n                ClientStrat->>Emitters: \"emit signalLiveEmitter\"\n            end\n        else \"Active Signal Exists\"\n            ClientStrat->>ClientStrat: \"checkTP/SL/Time\"\n            \n            alt \"Signal Closed\"\n                ClientStrat->>Persist: \"deleteSignalData()\"\n                ClientStrat->>Emitters: \"emit signalLiveEmitter\"\n                ClientStrat-->>StratCore: \"IStrategyTickResultClosed\"\n            end\n        end\n        \n        StratCore-->>LiveLogicPriv: \"result\"\n        LiveLogicPriv->>User: \"yield result\"\n        LiveLogicPriv->>LiveLogicPriv: \"sleep(TICK_TTL)\"\n    end\n    \n    LiveLogicPriv->>Emitters: \"emit doneLiveSubject\"\n    LiveLogicPriv-->>User: \"AsyncGenerator complete\"\n```\n\nKey characteristics:\n- Infinite loop with sleep intervals via [src/services/logic/private/LiveLogicPrivateService.ts]()\n- Crash-safe persistence: only opened signals are saved\n- Graceful shutdown: waits for `IStrategyTickResultClosed` before exiting\n- Real-time VWAP pricing from last 5 1-minute candles\n\nSources: [docs/internals.md:68-82](), [src/services/logic/private/LiveLogicPrivateService.ts]()\n\n### Walker Strategy Comparison Flow\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant WalkerClass as \"Walker Class\"\n    participant WalkerLogicPriv as \"WalkerLogicPrivateService\"\n    participant BtLogicPub as \"BacktestLogicPublicService\"\n    participant BtMD as \"BacktestMarkdownService\"\n    participant Emitters as \"Event Emitters\"\n    \n    User->>WalkerClass: \"Walker.run(symbol, context)\"\n    WalkerClass->>WalkerLogicPriv: \"run(symbol)\"\n    WalkerLogicPriv->>WalkerLogicPriv: \"Load walker schema\"\n    WalkerLogicPriv->>WalkerLogicPriv: \"strategies = [...]\"\n    \n    loop \"For each strategy\"\n        WalkerLogicPriv->>BtLogicPub: \"run(symbol, strategyName)\"\n        \n        loop \"Backtest Execution\"\n            BtLogicPub->>BtLogicPub: \"(internal backtest)\"\n            BtLogicPub->>Emitters: \"emit signals\"\n        end\n        \n        BtLogicPub-->>WalkerLogicPriv: \"completed\"\n        WalkerLogicPriv->>BtMD: \"getData(symbol, strategyName)\"\n        BtMD-->>WalkerLogicPriv: \"BacktestStatistics\"\n        WalkerLogicPriv->>WalkerLogicPriv: \"Extract metric value\"\n        WalkerLogicPriv->>WalkerLogicPriv: \"Compare to best\"\n        WalkerLogicPriv->>Emitters: \"emit walkerEmitter\"\n        WalkerLogicPriv->>User: \"yield progress\"\n    end\n    \n    WalkerLogicPriv->>WalkerLogicPriv: \"Determine best strategy\"\n    WalkerLogicPriv->>Emitters: \"emit walkerCompleteSubject\"\n    WalkerLogicPriv-->>User: \"yield final results\"\n```\n\nKey characteristics:\n- Sequential backtest execution per strategy\n- Metric-based ranking (Sharpe ratio, win rate, etc.)\n- Progress events via `walkerEmitter` after each strategy\n- Final comparison results via `walkerCompleteSubject`\n\nSources: [src/services/logic/private/WalkerLogicPrivateService.ts](), [docs/classes/WalkerCommandService.md:1-80]()\n\n## Summary\n\nThe Backtest Kit architecture achieves production-readiness through:\n\n1. **Separation of Concerns**: Five distinct layers with unidirectional dependencies\n2. **Dependency Injection**: Custom DI container with Symbol-based tokens and lazy initialization\n3. **Context Propagation**: AsyncLocalStorage-based ambient context eliminates parameter passing\n4. **Memoization**: Cached client instances prevent redundant instantiation\n5. **Event-Driven Design**: Decoupled producers and consumers via RxJS Subject pattern\n6. **Type Safety**: Discriminated unions for state machines and execution results\n7. **Memory Efficiency**: Prototype methods, bounded event queues, async generators\n8. **Crash Recovery**: Atomic file writes with state restoration on startup\n\nThe architecture enables identical code to run in backtest and live modes while maintaining determinism, testability, and extensibility.\n\nSources: [README.md:1-255](), [docs/internals.md:1-132](), [src/lib/index.ts:1-246]()"
                    },
                    {
                        "page_plan": {
                            "id": "2",
                            "title": "Getting Started"
                        },
                        "content": "# Getting Started\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Heat.ts](src/classes/Heat.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Partial.ts](src/classes/Partial.ts)\n- [src/classes/Performance.ts](src/classes/Performance.ts)\n- [src/classes/Risk.ts](src/classes/Risk.ts)\n- [src/classes/Schedule.ts](src/classes/Schedule.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [test/spec/columns.test.mjs](test/spec/columns.test.mjs)\n\n</details>\n\n\n\nThis page provides a practical guide to installing Backtest Kit and running your first backtest. It covers installation, project setup, component registration, and execution patterns. For advanced topics like strategy development or risk management, see [Strategy Development](#6) and [Risk Management](#7). For architectural details about how the system works internally, see [Architecture Deep Dive](#4).\n\n---\n\n## Installation & Setup\n\n### Dependencies\n\nBacktest Kit requires **TypeScript 5.0 or higher** as a peer dependency. The framework has four core dependencies:\n\n| Package | Purpose |\n|---------|---------|\n| `di-kit` | Dependency injection container |\n| `di-scoped` | Scoped context propagation (AsyncLocalStorage) |\n| `functools-kit` | Utility functions (memoize, singlerun, queued) |\n| `get-moment-stamp` | Timestamp formatting |\n\nSources: [package.json:71-79]()\n\n### Installation Command\n\n```bash\nnpm install backtest-kit ccxt ollama uuid\n```\n\n- `backtest-kit` - The framework itself\n- `ccxt` - Cryptocurrency exchange data provider (optional, for exchange integration)\n- `ollama` - LLM integration for AI-powered strategies (optional)\n- `uuid` - Signal ID generation (recommended)\n\nSources: [README.md:41-43](), [demo/backtest/package.json:8-13]()\n\n### TypeScript Configuration\n\nEnsure your `tsconfig.json` targets ES2020 or higher and enables `esModuleInterop`:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"ES2020\",\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true\n  }\n}\n```\n\nSources: [package.json:71-73]()\n\n### Project Structure\n\n```\nmy-trading-bot/\n├── package.json\n├── tsconfig.json\n├── src/\n│   └── index.mjs\n└── .env (optional, for API keys)\n```\n\nUse `.mjs` extension for ES modules or set `\"type\": \"module\"` in `package.json`.\n\nSources: [demo/backtest/package.json:4](), [demo/live/package.json:4]()\n\n---\n\n## Your First Backtest\n\n### Step 1: Initialize Logging and Configuration\n\n```typescript\nimport { setLogger, setConfig } from 'backtest-kit';\n\n// Enable console logging\nsetLogger({\n  log: console.log,\n  debug: console.debug,\n  info: console.info,\n  warn: console.warn,\n});\n\n// Configure global parameters\nsetConfig({\n  CC_PERCENT_SLIPPAGE: 0.1,    // 0.1% slippage\n  CC_PERCENT_FEE: 0.1,          // 0.1% trading fee\n  CC_SCHEDULE_AWAIT_MINUTES: 120, // Pending signal timeout\n});\n```\n\nThe `setLogger` function allows custom logger injection. The `setConfig` function sets global validation thresholds and fee parameters that apply to all strategies.\n\nSources: [README.md:46-63]()\n\n### Step 2: Register an Exchange\n\nAn exchange provides market data via the `getCandles` method:\n\n```typescript\nimport ccxt from 'ccxt';\nimport { addExchange } from 'backtest-kit';\n\naddExchange({\n  exchangeName: 'binance',\n  getCandles: async (symbol, interval, since, limit) => {\n    const exchange = new ccxt.binance();\n    const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => \n      ({ timestamp, open, high, low, close, volume })\n    );\n  },\n  formatPrice: (symbol, price) => price.toFixed(2),\n  formatQuantity: (symbol, quantity) => quantity.toFixed(8),\n});\n```\n\nThe framework calls `getCandles` with temporal context automatically managed via `AsyncLocalStorage`. This prevents look-ahead bias.\n\nSources: [README.md:66-80]()\n\n### Step 3: Register a Risk Profile\n\nRisk profiles validate signals before execution:\n\n```typescript\nimport { addRisk } from 'backtest-kit';\n\naddRisk({\n  riskName: 'demo',\n  validations: [\n    // Ensure take profit is at least 1% away\n    ({ pendingSignal, currentPrice }) => {\n      const { priceOpen = currentPrice, priceTakeProfit, position } = pendingSignal;\n      const tpDistance = position === 'long' \n        ? ((priceTakeProfit - priceOpen) / priceOpen) * 100\n        : ((priceOpen - priceTakeProfit) / priceOpen) * 100;\n      if (tpDistance < 1) throw new Error(`TP too close: ${tpDistance.toFixed(2)}%`);\n    },\n    // Ensure risk/reward ratio is at least 2:1\n    ({ pendingSignal, currentPrice }) => {\n      const { priceOpen = currentPrice, priceTakeProfit, priceStopLoss, position } = pendingSignal;\n      const reward = position === 'long' ? priceTakeProfit - priceOpen : priceOpen - priceTakeProfit;\n      const risk = position === 'long' ? priceOpen - priceStopLoss : priceStopLoss - priceOpen;\n      if (reward / risk < 2) throw new Error('Poor R/R ratio');\n    },\n  ],\n});\n```\n\nEach validation function throws an error to reject a signal or returns normally to approve it.\n\nSources: [README.md:82-101]()\n\n### Step 4: Register a Timeframe\n\nTimeframes define the date range and resolution for backtesting:\n\n```typescript\nimport { addFrame } from 'backtest-kit';\n\naddFrame({\n  frameName: '1d-test',\n  interval: '1m',  // Process every minute\n  startDate: new Date('2025-12-01'),\n  endDate: new Date('2025-12-02'),\n});\n```\n\nThe `interval` determines how frequently the strategy's `getSignal` function is called (after throttling).\n\nSources: [README.md:102-109]()\n\n### Step 5: Create a Strategy\n\nStrategies generate trading signals:\n\n```typescript\nimport { addStrategy, getCandles, getAveragePrice } from 'backtest-kit';\n\naddStrategy({\n  strategyName: 'simple-strategy',\n  interval: '5m',  // Throttle to every 5 minutes\n  riskName: 'demo',\n  getSignal: async (symbol) => {\n    // Fetch multi-timeframe data\n    const candles1h = await getCandles(symbol, \"1h\", 24);\n    const candles15m = await getCandles(symbol, \"15m\", 48);\n    \n    // Get current VWAP price\n    const currentPrice = await getAveragePrice(symbol);\n    \n    // Simple moving average crossover logic\n    const sma1h = candles1h.reduce((sum, c) => sum + c.close, 0) / candles1h.length;\n    const sma15m = candles15m.reduce((sum, c) => sum + c.close, 0) / candles15m.length;\n    \n    if (sma15m > sma1h) {\n      return {\n        position: 'long',\n        priceOpen: currentPrice,\n        priceTakeProfit: currentPrice * 1.02,  // +2%\n        priceStopLoss: currentPrice * 0.99,    // -1%\n        minuteEstimatedTime: 60,\n      };\n    }\n    \n    return null; // No signal\n  },\n});\n```\n\nThe `getSignal` function has access to `getCandles` and `getAveragePrice` helper functions that automatically use the current temporal context.\n\nSources: [README.md:111-143]()\n\n### Step 6: Run the Backtest\n\nThere are two execution patterns:\n\n**Pattern 1: Event-Driven (Background Execution)**\n\n```typescript\nimport { Backtest, listenSignalBacktest, listenDoneBacktest } from 'backtest-kit';\n\nBacktest.background('BTCUSDT', {\n  strategyName: 'simple-strategy',\n  exchangeName: 'binance',\n  frameName: '1d-test',\n});\n\nlistenSignalBacktest((event) => {\n  console.log('Signal closed:', event.signal.id, 'PNL:', event.pnl.pnlPercentage);\n});\n\nlistenDoneBacktest(async (event) => {\n  console.log('Backtest completed for', event.symbol, event.strategyName);\n  await Backtest.dump(event.symbol, event.strategyName);  // Save report\n});\n```\n\n**Pattern 2: Async Iterator (Pull-Based Execution)**\n\n```typescript\nimport { Backtest } from 'backtest-kit';\n\nfor await (const event of Backtest.run('BTCUSDT', {\n  strategyName: 'simple-strategy',\n  exchangeName: 'binance',\n  frameName: '1d-test',\n})) {\n  if (event.action === 'closed') {\n    console.log('PNL:', event.pnl.pnlPercentage);\n  }\n}\n\n// Generate report after completion\nawait Backtest.dump('BTCUSDT', 'simple-strategy');\n```\n\nSources: [README.md:145-177](), [src/classes/Backtest.ts:378-400]()\n\n### Component Registration Flow\n\n```mermaid\nflowchart TD\n    Start[\"User Application\"] --> SetLogger[\"setLogger()\"]\n    SetLogger --> SetConfig[\"setConfig()\"]\n    SetConfig --> AddExchange[\"addExchange()\"]\n    AddExchange --> AddRisk[\"addRisk()\"]\n    AddRisk --> AddFrame[\"addFrame()\"]\n    AddFrame --> AddStrategy[\"addStrategy()\"]\n    AddStrategy --> RunBacktest[\"Backtest.run() or<br/>Backtest.background()\"]\n    \n    AddExchange --> ExchangeSchema[\"ExchangeSchemaService<br/>stores IExchangeSchema\"]\n    AddRisk --> RiskSchema[\"RiskSchemaService<br/>stores IRiskSchema\"]\n    AddFrame --> FrameSchema[\"FrameSchemaService<br/>stores IFrameSchema\"]\n    AddStrategy --> StrategySchema[\"StrategySchemaService<br/>stores IStrategySchema\"]\n    \n    RunBacktest --> Validation[\"Validation Services<br/>check existence\"]\n    Validation --> ConnectionServices[\"Connection Services<br/>create memoized clients\"]\n    ConnectionServices --> Execution[\"BacktestLogicPrivateService<br/>executes strategy\"]\n```\n\nSources: [README.md:46-177](), [src/classes/Backtest.ts:378-400]()\n\n---\n\n## Quick Start Examples\n\n### Minimal Backtest Example\n\nThis example demonstrates the absolute minimum code required to run a backtest:\n\n```typescript\nimport { \n  addExchange, addStrategy, addFrame, \n  Backtest, listenDoneBacktest \n} from 'backtest-kit';\n\n// Exchange with mock data\naddExchange({\n  exchangeName: 'mock',\n  getCandles: async (symbol, interval, since, limit) => {\n    const candles = [];\n    let timestamp = since.getTime();\n    for (let i = 0; i < limit; i++) {\n      const price = 50000 + Math.random() * 1000;\n      candles.push({ \n        timestamp, \n        open: price, \n        high: price * 1.01, \n        low: price * 0.99, \n        close: price, \n        volume: 100 \n      });\n      timestamp += 60000; // +1 minute\n    }\n    return candles;\n  },\n  formatPrice: (symbol, price) => price.toFixed(2),\n  formatQuantity: (symbol, quantity) => quantity.toFixed(8),\n});\n\n// Simple buy-and-hold strategy\naddStrategy({\n  strategyName: 'buy-hold',\n  interval: '1h',\n  getSignal: async (symbol) => {\n    const price = 50000;\n    return {\n      position: 'long',\n      priceOpen: price,\n      priceTakeProfit: price * 1.10,\n      priceStopLoss: price * 0.95,\n      minuteEstimatedTime: 1440, // 1 day\n    };\n  },\n});\n\n// 1-day timeframe\naddFrame({\n  frameName: 'test-frame',\n  interval: '1m',\n  startDate: new Date('2024-01-01'),\n  endDate: new Date('2024-01-02'),\n});\n\n// Run and generate report\nlistenDoneBacktest(async (event) => {\n  const stats = await Backtest.getData(event.symbol, event.strategyName);\n  console.log('Win Rate:', stats.winRate);\n  console.log('Sharpe Ratio:', stats.sharpeRatio);\n  console.log('Total PNL:', stats.totalPnl);\n});\n\nBacktest.background('BTCUSDT', {\n  strategyName: 'buy-hold',\n  exchangeName: 'mock',\n  frameName: 'test-frame',\n});\n```\n\nSources: [README.md:36-159](), [test/spec/columns.test.mjs:15-112]()\n\n### Live Trading Setup\n\nLive trading uses the same strategy code but with real-time execution:\n\n```typescript\nimport { Live, listenSignalLive } from 'backtest-kit';\n\n// Use same addExchange, addStrategy from above\n\nLive.background('BTCUSDT', {\n  strategyName: 'buy-hold',\n  exchangeName: 'binance',  // Exchange must support real-time API\n});\n\nlistenSignalLive((event) => {\n  if (event.action === 'opened') {\n    console.log('Position opened:', event.signal.position, event.signal.priceOpen);\n  } else if (event.action === 'closed') {\n    console.log('Position closed:', event.closeAction, 'PNL:', event.pnl.pnlPercentage);\n  }\n});\n```\n\nThe `Live` class automatically persists signals to disk for crash recovery. The system polls every minute using `Date.now()` for temporal context.\n\nSources: [README.md:161-171](), [src/classes/Live.ts:398-418]()\n\n### Execution Mode Comparison\n\n```mermaid\ngraph TD\n    subgraph BacktestMode[\"Backtest Mode\"]\n        BT_Entry[\"Backtest.run()\"]\n        BT_Frame[\"FrameCoreService<br/>generates timeframes\"]\n        BT_Tick[\"ClientStrategy.tick()<br/>when = frame timestamp\"]\n        BT_Done[\"Emits doneBacktestSubject<br/>Returns closed signals\"]\n        \n        BT_Entry --> BT_Frame\n        BT_Frame --> BT_Tick\n        BT_Tick --> BT_Done\n    end\n    \n    subgraph LiveMode[\"Live Mode\"]\n        LIVE_Entry[\"Live.run()\"]\n        LIVE_Loop[\"Infinite loop<br/>when = new Date()\"]\n        LIVE_Sleep[\"sleep 1 minute\"]\n        LIVE_Tick[\"ClientStrategy.tick()<br/>when = Date.now()\"]\n        LIVE_Persist[\"PersistSignalAdapter<br/>save to disk\"]\n        \n        LIVE_Entry --> LIVE_Loop\n        LIVE_Loop --> LIVE_Tick\n        LIVE_Tick --> LIVE_Persist\n        LIVE_Persist --> LIVE_Sleep\n        LIVE_Sleep --> LIVE_Loop\n    end\n    \n    subgraph SharedCore[\"Shared Core\"]\n        STRAT[\"ClientStrategy<br/>Signal lifecycle management\"]\n        VALID[\"Signal Validation<br/>TP/SL logic, GLOBAL_CONFIG\"]\n        RISK[\"ClientRisk<br/>Risk validation\"]\n    end\n    \n    BT_Tick --> STRAT\n    LIVE_Tick --> STRAT\n    STRAT --> VALID\n    STRAT --> RISK\n```\n\nSources: [src/classes/Backtest.ts:378-400](), [src/classes/Live.ts:398-418]()\n\n### Walker (Strategy Comparison)\n\nWalker runs multiple strategies on the same timeframe and compares results:\n\n```typescript\nimport { addWalker, Walker, listenDoneWalker } from 'backtest-kit';\n\n// Register multiple strategies with addStrategy()...\n\naddWalker({\n  walkerName: 'strategy-comparison',\n  exchangeName: 'binance',\n  frameName: '1d-test',\n  strategies: ['strategy-a', 'strategy-b', 'strategy-c'],\n  metric: 'sharpeRatio',  // Compare by Sharpe ratio\n});\n\nlistenDoneWalker(async (event) => {\n  const results = await Walker.getData(event.symbol, event.strategyName);\n  console.log('Best strategy:', results.bestStrategy);\n  console.log('Best metric:', results.bestMetric);\n  await Walker.dump(event.symbol, event.strategyName);\n});\n\nWalker.background('BTCUSDT', {\n  walkerName: 'strategy-comparison',\n});\n```\n\nWalker runs each strategy sequentially and emits progress updates after each completion.\n\nSources: [src/classes/Walker.ts:145-194]()\n\n---\n\n## API Surface: Core Functions\n\n| Function | Purpose | Module |\n|----------|---------|--------|\n| `addExchange()` | Register exchange data source | [src/index.ts]() |\n| `addStrategy()` | Register trading strategy | [src/index.ts]() |\n| `addFrame()` | Register backtest timeframe | [src/index.ts]() |\n| `addRisk()` | Register risk profile | [src/index.ts]() |\n| `addWalker()` | Register strategy comparison | [src/index.ts]() |\n| `setConfig()` | Set global configuration | [src/index.ts]() |\n| `setLogger()` | Set custom logger | [src/index.ts]() |\n| `Backtest.run()` | Run backtest (async iterator) | [src/classes/Backtest.ts:378-400]() |\n| `Backtest.background()` | Run backtest (event-driven) | [src/classes/Backtest.ts:423-443]() |\n| `Live.run()` | Run live trading (async iterator) | [src/classes/Live.ts:398-418]() |\n| `Live.background()` | Run live trading (event-driven) | [src/classes/Live.ts:441-459]() |\n| `Walker.run()` | Run strategy comparison (async iterator) | [src/classes/Walker.ts:145-194]() |\n| `listenSignalBacktest()` | Listen to backtest signals | [src/index.ts]() |\n| `listenSignalLive()` | Listen to live signals | [src/index.ts]() |\n| `listenDoneBacktest()` | Listen to backtest completion | [src/index.ts]() |\n| `listenDoneLive()` | Listen to live completion | [src/index.ts]() |\n| `getCandles()` | Get candles with temporal context | [src/index.ts]() |\n| `getAveragePrice()` | Get VWAP price | [src/index.ts]() |\n\nSources: [README.md:36-177](), [src/classes/Backtest.ts](), [src/classes/Live.ts](), [src/classes/Walker.ts]()\n\n---\n\n## Key Architectural Concepts\n\n### Time Execution Engine\n\nBacktest Kit is fundamentally a **time execution engine**. The system processes market data as an async stream of time, where each `tick` call represents a moment in time. The temporal context is propagated via Node.js `AsyncLocalStorage`, making look-ahead bias architecturally impossible.\n\n```mermaid\ngraph LR\n    Frame[\"FrameCoreService<br/>generates timestamps\"] --> Context[\"ExecutionContextService<br/>sets 'when' via AsyncLocalStorage\"]\n    Context --> Strategy[\"ClientStrategy.tick()<br/>calls getSignal()\"]\n    Strategy --> GetCandles[\"getCandles()<br/>reads temporal context\"]\n    GetCandles --> Exchange[\"ClientExchange<br/>filters data <= 'when'\"]\n```\n\nWhen `getCandles` is called inside `getSignal`, it automatically reads the current `when` timestamp from `AsyncLocalStorage` and only returns data up to that point. This prevents future data leakage.\n\nSources: [README.md:186-199]()\n\n### Event-Driven vs Async Iterator\n\nThe framework exposes two consumption models:\n\n**Event-Driven (Production):**\n- `Backtest.background()` starts execution in background\n- Events emitted to `signalBacktestEmitter`, `doneBacktestSubject`\n- Suitable for long-running processes, monitoring, bots\n\n**Async Iterator (Research):**\n- `Backtest.run()` returns async generator\n- Pull-based consumption with `for await...of`\n- Suitable for scripting, testing, LLM agents\n\nBoth use the same underlying `BacktestLogicPrivateService` implementation.\n\nSources: [README.md:201-224]()\n\n### Crash Recovery\n\nOnly **opened** signals are persisted to disk via `PersistSignalAdapter`. Scheduled signals remain in memory. On restart, `Live.run()` calls `waitForInit()` to restore persisted signals before starting the execution loop.\n\nSources: [README.md:19-20]()\n\n---\n\n## Next Steps\n\n- **Strategy Development:** See [Strategy Development](#6) for detailed guide on writing `getSignal` functions, callbacks, and multi-timeframe analysis\n- **Risk Management:** See [Risk Management](#7) for custom validation rules and portfolio limits\n- **Live Trading:** See [Live Trading Mode](#5.2) for production deployment, persistence, and monitoring\n- **Architecture:** See [Architecture Deep Dive](#4) for service layer, dependency injection, and internal systems\n\nSources: [README.md](), [src/classes/Backtest.ts](), [src/classes/Live.ts]()"
                    },
                    {
                        "page_plan": {
                            "id": "2.1",
                            "title": "Installation & Setup"
                        },
                        "content": "# Installation & Setup\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n\n</details>\n\n\n\nThis page covers the installation of Backtest Kit and the initial configuration required to start developing trading strategies. Topics include system requirements, package installation, peer dependencies, TypeScript configuration, and project structure setup. For a complete working example and your first backtest implementation, see [Your First Backtest](#2.2).\n\n---\n\n## System Requirements\n\nBacktest Kit requires specific versions of Node.js and TypeScript to function correctly. The framework leverages modern JavaScript features and TypeScript's type system for compile-time safety.\n\n| Requirement | Minimum Version | Recommended | Notes |\n|------------|----------------|-------------|-------|\n| Node.js | 15.0.0 | 18.0.0+ | Required for `ccxt` dependency |\n| TypeScript | 5.0.0 | 5.9.0+ | Peer dependency for type safety |\n| npm | 7.0.0+ | Latest | Package manager |\n\n**Sources:** [package.json:72-73](), [demo/backtest/package-lock.json:49-51]()\n\n---\n\n## Core Package Installation\n\n### Basic Installation\n\nInstall the framework via npm:\n\n```bash\nnpm install backtest-kit\n```\n\nThis installs the core framework with its runtime dependencies:\n\n- `di-kit` (v1.0.18): Dependency injection container\n- `di-scoped` (v1.0.20): Scoped context management using `AsyncLocalStorage`\n- `functools-kit` (v1.0.94): Utility functions including `queued` wrapper for event handlers\n- `get-moment-stamp` (v1.1.1): Timestamp utilities\n\n**Sources:** [package.json:74-79](), [README.md:40-43]()\n\n### Dependency Tree\n\n```mermaid\ngraph TB\n    BK[\"backtest-kit<br/>(Core Framework)\"]\n    \n    DI[\"di-kit<br/>^1.0.18\"]\n    SCOPED[\"di-scoped<br/>^1.0.20\"]\n    FUNC[\"functools-kit<br/>^1.0.94\"]\n    MOMENT[\"get-moment-stamp<br/>^1.1.1\"]\n    \n    TS[\"typescript<br/>^5.0.0<br/>(peer)\"]\n    \n    BK --> DI\n    BK --> SCOPED\n    BK --> FUNC\n    BK --> MOMENT\n    BK -.-> TS\n    \n    DI_DESC[\"Provides TYPES registry<br/>and inject/provide functions\"]\n    SCOPED_DESC[\"ExecutionContextService<br/>MethodContextService<br/>AsyncLocalStorage-based\"]\n    FUNC_DESC[\"queued function wrapper<br/>for sequential event handling\"]\n    MOMENT_DESC[\"Timestamp conversion utilities\"]\n    \n    DI -.->|\"implements\"| DI_DESC\n    SCOPED -.->|\"implements\"| SCOPED_DESC\n    FUNC -.->|\"implements\"| FUNC_DESC\n    MOMENT -.->|\"implements\"| MOMENT_DESC\n    \n    style BK fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style TS fill:#f9f9f9,stroke:#333,stroke-width:2px,stroke-dasharray: 5 5\n```\n\n**Dependency Roles:**\n- **di-kit**: Implements the TYPES symbol registry used in [src/lib/index.ts]() and the `inject`/`provide` pattern\n- **di-scoped**: Powers `ExecutionContextService` and `MethodContextService` for ambient context propagation without explicit parameters\n- **functools-kit**: Provides the `queued` wrapper that ensures sequential execution of async callbacks in event listeners\n- **get-moment-stamp**: Handles timestamp conversions between Date objects and numeric millisecond stamps\n\n**Sources:** [package.json:74-79](), [package-lock.json:650-680]()\n\n---\n\n## Peer Dependencies\n\n### TypeScript Installation\n\nBacktest Kit requires TypeScript 5.0.0 or higher as a peer dependency. Install it in your project:\n\n```bash\nnpm install --save-dev typescript\n```\n\nThe framework exports comprehensive type definitions via [types.d.ts:1-3000+]() that require TypeScript 5.0+ features including:\n\n- Template literal types\n- `satisfies` operator\n- Const type parameters\n- Improved type inference\n\n### Peer Dependency Verification\n\nThe framework will issue warnings if TypeScript is not installed or is below version 5.0.0. Verify your installation:\n\n```bash\nnpx tsc --version\n```\n\nExpected output: `Version 5.0.0` or higher.\n\n**Sources:** [package.json:71-73](), [demo/backtest/package-lock.json:226-238]()\n\n---\n\n## Optional Dependencies\n\n### Common Use Case Packages\n\nMost Backtest Kit implementations require additional packages for data sources, LLM integration, and utilities:\n\n```bash\nnpm install ccxt ollama uuid\nnpm install --save-dev dotenv-cli\n```\n\n| Package | Version | Purpose | Used In |\n|---------|---------|---------|---------|\n| `ccxt` | 4.5.24+ | Exchange data fetching | `IExchangeSchema.getCandles` implementation |\n| `ollama` | 0.6.3+ | LLM integration for AI strategies | `IStrategySchema.getSignal` with LLM calls |\n| `uuid` | 13.0.0+ | Signal ID generation | Unique identifiers for signals |\n| `dotenv-cli` | 11.0.0+ | Environment variable management | API keys, configuration |\n\n**Sources:** [README.md:42](), [demo/backtest/package.json:8-17](), [demo/optimization/package.json:8-17]()\n\n### Package Installation Flow\n\n```mermaid\ngraph TD\n    START[\"npm init -y\"]\n    \n    CORE[\"npm install backtest-kit\"]\n    PEER[\"npm install -D typescript\"]\n    \n    OPT_DATA[\"npm install ccxt\"]\n    OPT_LLM[\"npm install ollama\"]\n    OPT_UTIL[\"npm install uuid\"]\n    OPT_DEV[\"npm install -D dotenv-cli\"]\n    \n    VERIFY[\"npx tsc --version<br/>node --version\"]\n    \n    SETUP[\"Create src/ directory<br/>Create index.ts entry point\"]\n    \n    CONFIG[\"Configure tsconfig.json\"]\n    \n    IMPORT[\"import { addExchange, addStrategy,<br/>Backtest, setLogger } from 'backtest-kit'\"]\n    \n    READY[\"Ready to develop\"]\n    \n    START --> CORE\n    CORE --> PEER\n    \n    PEER --> OPT_DATA\n    PEER --> OPT_LLM\n    PEER --> OPT_UTIL\n    PEER --> OPT_DEV\n    \n    OPT_DATA --> VERIFY\n    OPT_LLM --> VERIFY\n    OPT_UTIL --> VERIFY\n    OPT_DEV --> VERIFY\n    \n    VERIFY --> SETUP\n    SETUP --> CONFIG\n    CONFIG --> IMPORT\n    IMPORT --> READY\n    \n    style START fill:#f9f9f9,stroke:#333\n    style CORE fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style PEER fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style READY fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**Installation Steps:**\n1. Initialize npm project with `package.json`\n2. Install core `backtest-kit` package\n3. Install peer dependency `typescript`\n4. Install optional packages based on use case (data sources, LLM, utilities)\n5. Verify Node.js and TypeScript versions\n6. Create project structure and TypeScript configuration\n7. Import framework functions and begin development\n\n**Sources:** [README.md:40-43](), [demo/backtest/package.json:1-18]()\n\n---\n\n## TypeScript Configuration\n\n### Minimal tsconfig.json\n\nCreate a `tsconfig.json` file in your project root:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"ES2020\",\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"resolveJsonModule\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n### Configuration Requirements\n\n| Option | Required Value | Reason |\n|--------|---------------|--------|\n| `target` | ES2020+ | Framework uses modern async/await patterns |\n| `module` | ES2020 or NodeNext | ESM support for clean imports |\n| `moduleResolution` | node or node16 | Resolve npm packages correctly |\n| `esModuleInterop` | true | Import CommonJS modules from ESM |\n| `strict` | true (recommended) | Type safety for signal validation |\n| `skipLibCheck` | true | Faster compilation with large type definitions |\n\nThe framework's [types.d.ts]() contains over 3000 lines of type definitions. Setting `skipLibCheck: true` reduces compilation time without sacrificing type safety for your code.\n\n**Sources:** [package.json:51-52](), [README.md:46-47]()\n\n---\n\n## Project Structure\n\n### Recommended Directory Layout\n\n```\nmy-backtest-project/\n├── package.json\n├── package-lock.json\n├── tsconfig.json\n├── .env                    # API keys, configuration\n├── .gitignore              # Exclude node_modules, .env\n├── src/\n│   ├── index.ts           # Entry point\n│   ├── strategies/        # Strategy implementations\n│   │   └── my-strategy.ts\n│   ├── exchanges/         # Exchange configurations\n│   │   └── binance.ts\n│   ├── risks/             # Risk profile definitions\n│   │   └── conservative.ts\n│   └── frames/            # Timeframe definitions\n│       └── daily-test.ts\n└── dump/                  # Generated reports (auto-created)\n    ├── backtest/\n    ├── live/\n    └── performance/\n```\n\n### Entry Point Template\n\nCreate `src/index.ts`:\n\n```typescript\nimport { setLogger, setConfig, addExchange, addStrategy } from 'backtest-kit';\n\n// Configure logging\nsetLogger({\n  log: console.log,\n  debug: console.debug,\n  info: console.info,\n  warn: console.warn,\n});\n\n// Configure global parameters\nsetConfig({\n  CC_PERCENT_SLIPPAGE: 0.1,\n  CC_PERCENT_FEE: 0.1,\n});\n\n// Register components (see section 2.2)\n// addExchange({ ... });\n// addStrategy({ ... });\n```\n\n**Sources:** [README.md:46-63](), [demo/backtest/package.json:4-6]()\n\n### Module Type Configuration\n\nThe demo projects use `\"type\": \"module\"` in [demo/backtest/package.json:4]() to enable native ESM. Add this to your `package.json`:\n\n```json\n{\n  \"type\": \"module\",\n  \"scripts\": {\n    \"start\": \"node dist/index.js\"\n  }\n}\n```\n\nFor TypeScript compilation and execution:\n\n```bash\nnpx tsc\nnode dist/index.js\n```\n\nOr use `ts-node` with ESM loader:\n\n```bash\nnpm install --save-dev ts-node\nnode --loader ts-node/esm src/index.ts\n```\n\n**Sources:** [demo/backtest/package.json:4-6](), [demo/optimization/package.json:4-6]()\n\n---\n\n## Initial Setup Verification\n\n### Import Test\n\nVerify the installation by importing core functions:\n\n```typescript\nimport {\n  // Configuration\n  setLogger,\n  setConfig,\n  \n  // Registration\n  addExchange,\n  addStrategy,\n  addFrame,\n  addRisk,\n  \n  // Execution\n  Backtest,\n  Live,\n  \n  // Event Listeners\n  listenSignalBacktest,\n  listenDoneBacktest,\n} from 'backtest-kit';\n\nconsole.log('Backtest Kit imported successfully');\n```\n\nCompile and run:\n\n```bash\nnpx tsc\nnode dist/index.js\n```\n\nExpected output: `Backtest Kit imported successfully`\n\n### Available Exports\n\nThe framework exports the following categories from [src/index.ts]():\n\n**Configuration Functions:**\n- `setLogger({ log, debug, info, warn })`: Configure logging output\n- `setConfig({ ...GLOBAL_CONFIG })`: Set global parameters like fees and slippage\n\n**Registration Functions:**\n- `addExchange(IExchangeSchema)`: Register data sources\n- `addStrategy(IStrategySchema)`: Register trading strategies\n- `addFrame(IFrameSchema)`: Register timeframes for backtesting\n- `addRisk(IRiskSchema)`: Register risk profiles\n- `addWalker(IWalkerSchema)`: Register strategy comparison configurations\n- `addSizing(ISizingSchema)`: Register position sizing calculators\n- `addOptimizer(IOptimizerSchema)`: Register LLM-based optimizer configurations\n\n**Execution Classes:**\n- `Backtest`: Historical simulation execution\n- `Live`: Real-time trading execution\n- `Walker`: Multi-strategy comparison\n- `Optimizer`: LLM-powered strategy generation\n\n**Event Listeners:**\n- `listenSignal*()`: Signal state change events\n- `listenDone*()`: Completion events\n- `listenPartial*()`: Profit/loss milestone events\n- `listenRisk()`: Risk rejection events\n- `listenPerformance()`: Timing metrics events\n- `listenError()`: Recoverable error events\n- `listenExit()`: Fatal error events\n\n**Utility Functions:**\n- `getCandles(symbol, interval, limit)`: Fetch historical data with temporal context\n- `dumpSignal()`: Persist signal data for debugging\n\n**Sources:** [README.md:66-69](), [README.md:147-171](), [src/index.ts:1-50]()\n\n---\n\n## Environment Variables\n\n### .env File Template\n\nCreate a `.env` file for API keys and configuration:\n\n```bash\n# Exchange API Keys (for live trading)\nBINANCE_API_KEY=your_api_key_here\nBINANCE_API_SECRET=your_secret_here\n\n# Ollama Configuration (for LLM strategies)\nOLLAMA_HOST=http://localhost:11434\nOLLAMA_MODEL=deepseek-v3.1:671b\n\n# Backtest Configuration\nLOG_LEVEL=info\n```\n\nAdd `.env` to your `.gitignore`:\n\n```bash\nnode_modules/\ndist/\n.env\ndump/\n```\n\n### Using dotenv-cli\n\nRun your application with environment variables loaded:\n\n```bash\nnpx dotenv -e .env -- node dist/index.js\n```\n\nAdd to `package.json` scripts:\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"dotenv -e .env -- node dist/index.js\",\n    \"dev\": \"dotenv -e .env -- node --loader ts-node/esm src/index.ts\"\n  }\n}\n```\n\n**Sources:** [demo/backtest/package.json:6](), [demo/optimization/package.json:6]()\n\n---\n\n## Troubleshooting Common Installation Issues\n\n### TypeScript Version Mismatch\n\n**Error:** `error TS2307: Cannot find module 'backtest-kit'`\n\n**Solution:** Ensure TypeScript 5.0+ is installed:\n```bash\nnpm install --save-dev typescript@latest\n```\n\n### Module Resolution Errors\n\n**Error:** `ERR_MODULE_NOT_FOUND` or `Cannot use import statement outside a module`\n\n**Solution:** Add `\"type\": \"module\"` to `package.json` or use `.mjs` file extensions.\n\n### Missing Peer Dependencies\n\n**Error:** `WARN peer dep missing: typescript@^5.0.0`\n\n**Solution:** Install the peer dependency:\n```bash\nnpm install --save-dev typescript\n```\n\n### CCXT Installation Issues\n\n**Error:** `ERR! code 1` during `ccxt` installation\n\n**Solution:** CCXT has install scripts that require build tools:\n- **Windows:** Install Visual Studio Build Tools\n- **macOS/Linux:** Ensure `python3` and `make` are available\n\n**Sources:** [package.json:71-73](), [demo/backtest/package-lock.json:40-51]()\n\n---\n\n## Next Steps\n\nAfter completing installation and setup:\n\n1. **Follow the First Backtest Tutorial:** See [Your First Backtest](#2.2) for a complete working example\n2. **Explore Quick Start Examples:** Review [Quick Start Examples](#2.3) for common patterns\n3. **Study Core Concepts:** Understand [Signals & Signal Lifecycle](#3.1) and [Strategies](#3.2)\n4. **Review API Reference:** Consult [Global Functions](#12.1) for detailed API documentation\n\nThe framework is now installed and ready for development. The next page demonstrates creating a complete backtest with strategy registration, exchange configuration, and execution.\n\n**Sources:** [README.md:36-159](), [package.json:1-80]()"
                    },
                    {
                        "page_plan": {
                            "id": "2.2",
                            "title": "Your First Backtest"
                        },
                        "content": "# Your First Backtest\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Heat.ts](src/classes/Heat.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Partial.ts](src/classes/Partial.ts)\n- [src/classes/Performance.ts](src/classes/Performance.ts)\n- [src/classes/Risk.ts](src/classes/Risk.ts)\n- [src/classes/Schedule.ts](src/classes/Schedule.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [src/config/params.ts](src/config/params.ts)\n- [test/README.md](test/README.md)\n- [test/config/setup.mjs](test/config/setup.mjs)\n- [test/e2e/close.test.mjs](test/e2e/close.test.mjs)\n- [test/e2e/edge.test.mjs](test/e2e/edge.test.mjs)\n- [test/e2e/other.test.mjs](test/e2e/other.test.mjs)\n- [test/e2e/persist.test.mjs](test/e2e/persist.test.mjs)\n- [test/e2e/sanitize.test.mjs](test/e2e/sanitize.test.mjs)\n- [test/e2e/sequence.test.mjs](test/e2e/sequence.test.mjs)\n- [test/spec/columns.test.mjs](test/spec/columns.test.mjs)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page provides a step-by-step tutorial for running your first backtest with Backtest Kit. You will configure an exchange, define a timeframe, create a simple trading strategy, and execute a backtest. By the end, you will understand the core workflow and be ready to develop your own strategies.\n\nFor installation instructions and dependencies, see [Installation & Setup](#2.1). For additional examples demonstrating different patterns, see [Quick Start Examples](#2.3). For detailed strategy development concepts, see [Strategy Development](#6).\n\n---\n\n## Prerequisites\n\nBefore proceeding, ensure you have:\n- Installed `backtest-kit` and `ccxt` via npm (see [Installation & Setup](#2.1))\n- TypeScript 5.0+ configured in your project\n- Basic understanding of trading concepts (long/short positions, take profit, stop loss)\n\n---\n\n## Overview: What We'll Build\n\nWe will create a minimal backtest that:\n1. Connects to Binance historical data via CCXT\n2. Tests a simple strategy on BTC/USDT\n3. Runs over a 1-day timeframe (2025-12-01 to 2025-12-02)\n4. Generates a markdown report with results\n\n### Component Architecture\n\n```mermaid\ngraph TB\n    User[\"User Code\"]\n    \n    subgraph \"Registration Phase\"\n        AddExchange[\"addExchange()<br/>IExchangeSchema\"]\n        AddRisk[\"addRisk()<br/>IRiskSchema\"]\n        AddFrame[\"addFrame()<br/>IFrameSchema\"]\n        AddStrategy[\"addStrategy()<br/>IStrategySchema\"]\n    end\n    \n    subgraph \"Schema Registry\"\n        ExchangeSchemaService[\"ExchangeSchemaService\"]\n        RiskSchemaService[\"RiskSchemaService\"]\n        FrameSchemaService[\"FrameSchemaService\"]\n        StrategySchemaService[\"StrategySchemaService\"]\n    end\n    \n    subgraph \"Execution\"\n        BacktestClass[\"Backtest.background()\"]\n        BacktestCommandService[\"BacktestCommandService\"]\n        BacktestLogicPrivateService[\"BacktestLogicPrivateService\"]\n    end\n    \n    subgraph \"Core Execution Engine\"\n        StrategyCoreService[\"StrategyCoreService\"]\n        ClientStrategy[\"ClientStrategy<br/>(tick method)\"]\n        ClientExchange[\"ClientExchange<br/>(getCandles)\"]\n    end\n    \n    subgraph \"Events & Reporting\"\n        SignalEmitter[\"signalBacktestEmitter\"]\n        DoneEmitter[\"doneBacktestSubject\"]\n        BacktestMarkdownService[\"BacktestMarkdownService\"]\n    end\n    \n    User --> AddExchange\n    User --> AddRisk\n    User --> AddFrame\n    User --> AddStrategy\n    \n    AddExchange --> ExchangeSchemaService\n    AddRisk --> RiskSchemaService\n    AddFrame --> FrameSchemaService\n    AddStrategy --> StrategySchemaService\n    \n    User --> BacktestClass\n    BacktestClass --> BacktestCommandService\n    BacktestCommandService --> BacktestLogicPrivateService\n    \n    BacktestLogicPrivateService --> StrategyCoreService\n    StrategyCoreService --> ClientStrategy\n    ClientStrategy --> ClientExchange\n    \n    ClientStrategy --> SignalEmitter\n    BacktestLogicPrivateService --> DoneEmitter\n    \n    SignalEmitter --> BacktestMarkdownService\n```\n\n**Component Registration Flow**: User code registers schemas via global functions. Schemas are stored in schema services. During execution, services are retrieved and instantiated into client objects.\n\n**Sources**: [README.md:65-159](), [src/classes/Backtest.ts:359-601]()\n\n---\n\n## Step 1: Configure the Exchange\n\nThe exchange provides historical market data. We use CCXT to fetch candle data from Binance.\n\n### Exchange Schema Definition\n\n```typescript\nimport ccxt from 'ccxt';\nimport { addExchange } from 'backtest-kit';\n\naddExchange({\n  exchangeName: 'binance',\n  getCandles: async (symbol, interval, since, limit) => {\n    const exchange = new ccxt.binance();\n    const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n      timestamp,\n      open,\n      high,\n      low,\n      close,\n      volume,\n    }));\n  },\n  formatPrice: (symbol, price) => price.toFixed(2),\n  formatQuantity: (symbol, quantity) => quantity.toFixed(8),\n});\n```\n\n### IExchangeSchema Interface\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `exchangeName` | `string` | Unique identifier for this exchange configuration |\n| `getCandles` | `function` | Async function returning candle data array |\n| `formatPrice` | `function` | Formats price for exchange precision rules |\n| `formatQuantity` | `function` | Formats quantity for exchange lot size rules |\n\nThe `getCandles` function receives:\n- `symbol`: Trading pair (e.g., \"BTC/USDT\")\n- `interval`: Timeframe string (\"1m\", \"5m\", \"1h\", etc.)\n- `since`: Start date (Date object)\n- `limit`: Number of candles to fetch\n\n**Sources**: [README.md:70-80](), [src/lib/services/schema/ExchangeSchemaService.ts]()\n\n---\n\n## Step 2: Define Risk Profile\n\nRisk profiles validate signals before they execute. This prevents unprofitable or dangerous trades.\n\n### Basic Risk Validation\n\n```typescript\nimport { addRisk } from 'backtest-kit';\n\naddRisk({\n  riskName: 'basic-risk',\n  validations: [\n    // Ensure take profit is at least 1% away\n    ({ pendingSignal, currentPrice }) => {\n      const { priceOpen = currentPrice, priceTakeProfit, position } = pendingSignal;\n      const tpDistance = position === 'long'\n        ? ((priceTakeProfit - priceOpen) / priceOpen) * 100\n        : ((priceOpen - priceTakeProfit) / priceOpen) * 100;\n      \n      if (tpDistance < 1) {\n        throw new Error(`TP too close: ${tpDistance.toFixed(2)}%`);\n      }\n    },\n    \n    // Ensure risk/reward ratio is at least 2:1\n    ({ pendingSignal, currentPrice }) => {\n      const { priceOpen = currentPrice, priceTakeProfit, priceStopLoss, position } = pendingSignal;\n      const reward = position === 'long'\n        ? priceTakeProfit - priceOpen\n        : priceOpen - priceTakeProfit;\n      const risk = position === 'long'\n        ? priceOpen - priceStopLoss\n        : priceStopLoss - priceOpen;\n      \n      if (reward / risk < 2) {\n        throw new Error('Poor R/R ratio');\n      }\n    },\n  ],\n});\n```\n\n### Validation Execution Flow\n\n```mermaid\ngraph LR\n    GetSignal[\"getSignal()<br/>returns ISignalDto\"]\n    ValidateSchema[\"Validate Schema<br/>(prices > 0, TP/SL logic)\"]\n    ValidateGlobal[\"Validate GLOBAL_CONFIG<br/>(distance, lifetime)\"]\n    ValidateRisk[\"Run Risk Validations<br/>(custom checks)\"]\n    Scheduled[\"Signal Scheduled\"]\n    Rejected[\"Signal Rejected\"]\n    \n    GetSignal --> ValidateSchema\n    ValidateSchema --> ValidateGlobal\n    ValidateGlobal --> ValidateRisk\n    ValidateRisk -->|All pass| Scheduled\n    ValidateRisk -->|Any fail| Rejected\n```\n\n**Validation Stages**: Signals pass through schema validation (structural checks), global config validation (distance/lifetime limits), and custom risk validations before scheduling.\n\n**Sources**: [README.md:83-100](), [test/e2e/sanitize.test.mjs:26-122]()\n\n---\n\n## Step 3: Define Timeframe\n\nThe timeframe determines the backtest period and candle interval.\n\n### Frame Schema Definition\n\n```typescript\nimport { addFrame } from 'backtest-kit';\n\naddFrame({\n  frameName: '1d-test',\n  interval: '1m',\n  startDate: new Date('2025-12-01T00:00:00Z'),\n  endDate: new Date('2025-12-02T00:00:00Z'),\n});\n```\n\n### IFrameSchema Interface\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `frameName` | `string` | Unique identifier for this timeframe |\n| `interval` | `SignalInterval` | Candle interval: \"1m\", \"5m\", \"15m\", \"30m\", \"1h\", \"4h\", \"1d\" |\n| `startDate` | `Date` | Backtest start timestamp |\n| `endDate` | `Date` | Backtest end timestamp |\n\n**Execution Model**: The backtest engine iterates through time from `startDate` to `endDate` at `interval` increments. Each tick represents one minute of simulated time. The strategy's `interval` parameter (separate from frame interval) determines how often `getSignal()` is called.\n\n**Sources**: [README.md:103-108](), [src/lib/services/logic/backtest/BacktestLogicPrivateService.ts]()\n\n---\n\n## Step 4: Create Strategy\n\nStrategies contain the trading logic. The `getSignal` function analyzes market data and returns trading signals.\n\n### Simple Strategy Example\n\n```typescript\nimport { addStrategy, getCandles } from 'backtest-kit';\n\naddStrategy({\n  strategyName: 'simple-momentum',\n  interval: '5m',\n  riskName: 'basic-risk',\n  getSignal: async (symbol) => {\n    // Fetch recent candles for analysis\n    const candles1h = await getCandles(symbol, '1h', 24);\n    const candles5m = await getCandles(symbol, '5m', 60);\n    \n    // Calculate simple momentum\n    const recentCandles = candles5m.slice(-10);\n    const avgClose = recentCandles.reduce((sum, c) => sum + c.close, 0) / recentCandles.length;\n    const currentPrice = candles5m[candles5m.length - 1].close;\n    \n    // Entry logic: price above average = bullish\n    if (currentPrice > avgClose * 1.02) {\n      return {\n        position: 'long',\n        priceOpen: currentPrice * 0.99,  // Limit order 1% below\n        priceTakeProfit: currentPrice * 1.03,  // 3% profit target\n        priceStopLoss: currentPrice * 0.97,  // 3% stop loss\n        minuteEstimatedTime: 60,  // 1 hour max lifetime\n        note: 'Momentum breakout',\n      };\n    }\n    \n    return null;  // No signal\n  },\n});\n```\n\n### IStrategySchema Interface\n\n| Property | Type | Required | Description |\n|----------|------|----------|-------------|\n| `strategyName` | `string` | Yes | Unique identifier for this strategy |\n| `interval` | `SignalInterval` | Yes | How often `getSignal()` is called |\n| `getSignal` | `function` | Yes | Async function returning `ISignalDto \\| null` |\n| `riskName` | `string` | No | Single risk profile to use |\n| `riskList` | `string[]` | No | Multiple risk profiles (all must pass) |\n| `callbacks` | `IStrategyCallbacks` | No | Lifecycle event handlers |\n\n### Signal Generation Flow\n\n```mermaid\nsequenceDiagram\n    participant BL as BacktestLogicPrivateService\n    participant SC as StrategyCoreService\n    participant CS as ClientStrategy\n    participant GS as getSignal function\n    participant CE as ClientExchange\n    \n    BL->>SC: tick(when, backtest=true)\n    SC->>CS: tick(when, backtest=true)\n    \n    alt Interval throttle allows\n        CS->>GS: Call user's getSignal(symbol)\n        GS->>CE: await getCandles(symbol, \"1h\", 24)\n        CE-->>GS: Array<ICandleData>\n        GS->>GS: Analyze market data\n        GS-->>CS: Return ISignalDto or null\n        \n        alt Signal returned\n            CS->>CS: Validate signal\n            CS->>CS: Check risk\n            alt Validation passes\n                CS->>CS: Schedule or open signal\n            end\n        end\n    end\n    \n    CS-->>SC: Return IStrategyTickResult\n    SC-->>BL: Return IStrategyTickResult\n```\n\n**Interval Throttling**: Even though `tick()` is called every minute, `getSignal()` only executes at `interval` frequency (e.g., every 5 minutes for `interval: '5m'`). This prevents signal spam.\n\n**Sources**: [README.md:112-143](), [src/classes/Backtest.ts:149-178]()\n\n---\n\n## Step 5: Run Backtest\n\nExecute the backtest and handle results via event listeners or async iterator.\n\n### Event-Driven Execution (Background Mode)\n\n```typescript\nimport { Backtest, listenSignalBacktest, listenDoneBacktest } from 'backtest-kit';\n\n// Subscribe to signal events\nlistenSignalBacktest((event) => {\n  if (event.action === 'closed') {\n    console.log(`Signal closed: ${event.result} | PNL: ${event.pnl.pnlPercentage.toFixed(2)}%`);\n  }\n});\n\n// Subscribe to completion event\nlistenDoneBacktest(async (event) => {\n  console.log('Backtest complete!');\n  await Backtest.dump(event.symbol, event.strategyName);\n});\n\n// Start backtest in background\nBacktest.background('BTCUSDT', {\n  strategyName: 'simple-momentum',\n  exchangeName: 'binance',\n  frameName: '1d-test',\n});\n```\n\n### Pull-Based Execution (Async Iterator)\n\n```typescript\nimport { Backtest } from 'backtest-kit';\n\nfor await (const event of Backtest.run('BTCUSDT', {\n  strategyName: 'simple-momentum',\n  exchangeName: 'binance',\n  frameName: '1d-test',\n})) {\n  if (event.action === 'closed') {\n    console.log(`PNL: ${event.pnl.pnlPercentage.toFixed(2)}%`);\n  }\n}\n\n// Backtest complete, generate report\nawait Backtest.dump('BTCUSDT', 'simple-momentum');\n```\n\n### Execution Flow Diagram\n\n```mermaid\ngraph TB\n    Start[\"Backtest.background()\"]\n    Validate[\"Validate Schemas<br/>(StrategyValidationService,<br/>ExchangeValidationService,<br/>FrameValidationService)\"]\n    GetFrame[\"FrameCoreService.frames()<br/>Generate timeframe array\"]\n    \n    subgraph \"Iteration Loop\"\n        NextFrame[\"Get next timestamp\"]\n        SetContext[\"ExecutionContextService<br/>Set(symbol, when, backtest=true)\"]\n        TickStrategy[\"StrategyCoreService.tick()\"]\n        ProcessResult[\"Process IStrategyTickResult\"]\n        EmitEvent[\"Emit to signalBacktestEmitter\"]\n    end\n    \n    Complete[\"Emit doneBacktestSubject\"]\n    Report[\"BacktestMarkdownService<br/>Generate report\"]\n    \n    Start --> Validate\n    Validate --> GetFrame\n    GetFrame --> NextFrame\n    NextFrame --> SetContext\n    SetContext --> TickStrategy\n    TickStrategy --> ProcessResult\n    ProcessResult --> EmitEvent\n    EmitEvent --> NextFrame\n    NextFrame -->|All frames processed| Complete\n    Complete --> Report\n```\n\n**Two Consumption Models**: `Backtest.background()` runs asynchronously and emits events. `Backtest.run()` returns an async generator for pull-based consumption. Both use the same underlying `BacktestLogicPrivateService`.\n\n**Sources**: [README.md:145-159](), [src/classes/Backtest.ts:200-235](), [src/classes/Backtest.ts:378-400]()\n\n---\n\n## Understanding the Results\n\nAfter backtest completion, retrieve statistics and reports.\n\n### Getting Statistics Programmatically\n\n```typescript\nimport { Backtest } from 'backtest-kit';\n\nconst stats = await Backtest.getData('BTCUSDT', 'simple-momentum');\n\nconsole.log('=== Backtest Statistics ===');\nconsole.log(`Total Trades: ${stats.totalTrades}`);\nconsole.log(`Win Rate: ${stats.winRate?.toFixed(2)}%`);\nconsole.log(`Total PNL: ${stats.totalPnl?.toFixed(2)}%`);\nconsole.log(`Sharpe Ratio: ${stats.sharpeRatio?.toFixed(2)}`);\nconsole.log(`Max Drawdown: ${stats.maxDrawdownPercent?.toFixed(2)}%`);\n```\n\n### BacktestStatisticsModel Structure\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `totalTrades` | `number` | Number of closed signals |\n| `winRate` | `number \\| null` | Percentage of winning trades |\n| `totalPnl` | `number \\| null` | Cumulative PNL percentage |\n| `sharpeRatio` | `number \\| null` | Risk-adjusted return metric |\n| `maxDrawdownPercent` | `number \\| null` | Largest peak-to-trough decline |\n| `avgPnl` | `number \\| null` | Average PNL per trade |\n| `avgHoldingTime` | `number \\| null` | Average trade duration (minutes) |\n\n### Generating Markdown Reports\n\n```typescript\nimport { Backtest } from 'backtest-kit';\n\n// Generate report to console\nconst markdown = await Backtest.getReport('BTCUSDT', 'simple-momentum');\nconsole.log(markdown);\n\n// Save report to file (default: ./dump/backtest/simple-momentum.md)\nawait Backtest.dump('BTCUSDT', 'simple-momentum');\n\n// Save to custom path\nawait Backtest.dump('BTCUSDT', 'simple-momentum', './reports/my-backtest');\n```\n\n**Report Contents**: The markdown report includes a summary section with key statistics, a detailed table of all closed signals (with timestamps, prices, PNL, holding time), and performance metrics.\n\n**Sources**: [src/classes/Backtest.ts:276-282](), [src/classes/Backtest.ts:299-305](), [src/classes/Backtest.ts:325-337]()\n\n---\n\n## Complete Example\n\nHere is the full working example combining all steps:\n\n```typescript\nimport ccxt from 'ccxt';\nimport { \n  addExchange, \n  addRisk, \n  addFrame, \n  addStrategy, \n  Backtest,\n  listenDoneBacktest,\n  getCandles,\n} from 'backtest-kit';\n\n// 1. Configure exchange\naddExchange({\n  exchangeName: 'binance',\n  getCandles: async (symbol, interval, since, limit) => {\n    const exchange = new ccxt.binance();\n    const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n      timestamp, open, high, low, close, volume,\n    }));\n  },\n  formatPrice: (symbol, price) => price.toFixed(2),\n  formatQuantity: (symbol, quantity) => quantity.toFixed(8),\n});\n\n// 2. Define risk profile\naddRisk({\n  riskName: 'basic-risk',\n  validations: [\n    ({ pendingSignal, currentPrice }) => {\n      const { priceOpen = currentPrice, priceTakeProfit, position } = pendingSignal;\n      const tpDistance = position === 'long'\n        ? ((priceTakeProfit - priceOpen) / priceOpen) * 100\n        : ((priceOpen - priceTakeProfit) / priceOpen) * 100;\n      if (tpDistance < 1) throw new Error(`TP too close: ${tpDistance.toFixed(2)}%`);\n    },\n  ],\n});\n\n// 3. Define timeframe\naddFrame({\n  frameName: '1d-test',\n  interval: '1m',\n  startDate: new Date('2025-12-01T00:00:00Z'),\n  endDate: new Date('2025-12-02T00:00:00Z'),\n});\n\n// 4. Create strategy\naddStrategy({\n  strategyName: 'simple-momentum',\n  interval: '5m',\n  riskName: 'basic-risk',\n  getSignal: async (symbol) => {\n    const candles5m = await getCandles(symbol, '5m', 60);\n    const recentCandles = candles5m.slice(-10);\n    const avgClose = recentCandles.reduce((sum, c) => sum + c.close, 0) / recentCandles.length;\n    const currentPrice = candles5m[candles5m.length - 1].close;\n    \n    if (currentPrice > avgClose * 1.02) {\n      return {\n        position: 'long',\n        priceOpen: currentPrice * 0.99,\n        priceTakeProfit: currentPrice * 1.03,\n        priceStopLoss: currentPrice * 0.97,\n        minuteEstimatedTime: 60,\n        note: 'Momentum breakout',\n      };\n    }\n    return null;\n  },\n});\n\n// 5. Run backtest\nlistenDoneBacktest(async (event) => {\n  await Backtest.dump(event.symbol, event.strategyName);\n  console.log('Backtest complete! Report saved to ./dump/backtest/');\n});\n\nBacktest.background('BTCUSDT', {\n  strategyName: 'simple-momentum',\n  exchangeName: 'binance',\n  frameName: '1d-test',\n});\n```\n\n**Sources**: [README.md:46-159](), [demo/backtest/package.json:1-18]()\n\n---\n\n## Key Concepts Summary\n\n### Component Registration Order\n\nThe order of `add*()` calls doesn't matter, but all schemas must be registered **before** calling `Backtest.run()` or `Backtest.background()`.\n\n### Context Propagation\n\nThe `ExecutionContextService` automatically provides `(symbol, when, backtest)` context to all functions. You never pass these explicitly - they're ambient via `AsyncLocalStorage`.\n\n### Signal Queue Behavior\n\nOnly **one active signal per symbol** is allowed at any time. New signals wait in queue until the current signal closes. This prevents position size explosions.\n\n### Look-Ahead Bias Prevention\n\n`getCandles()` only returns data **up to the current `when` timestamp**. It's architecturally impossible to access future data during backtesting.\n\n**Sources**: [README.md:186-199](), [test/README.md:6-24]()\n\n---\n\n## Next Steps\n\n- Explore [Quick Start Examples](#2.3) for more patterns\n- Learn about [Signal Lifecycle](#3.1) to understand state transitions\n- Read [Strategy Development](#6) for advanced techniques\n- Study [Risk Management](#7) for portfolio protection\n- Review [Execution Modes](#5) to understand Live and Walker modes\n\n**Sources**: [README.md:1-254]()"
                    },
                    {
                        "page_plan": {
                            "id": "2.3",
                            "title": "Quick Start Examples"
                        },
                        "content": "# Quick Start Examples\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Heat.ts](src/classes/Heat.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Partial.ts](src/classes/Partial.ts)\n- [src/classes/Performance.ts](src/classes/Performance.ts)\n- [src/classes/Risk.ts](src/classes/Risk.ts)\n- [src/classes/Schedule.ts](src/classes/Schedule.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [test/spec/columns.test.mjs](test/spec/columns.test.mjs)\n\n</details>\n\n\n\nThis page provides minimal working code examples demonstrating the three primary execution modes in Backtest Kit. Each example is self-contained and can be run immediately after installation.\n\nFor detailed explanations of the framework's core concepts, see [Core Concepts](#3). For installation instructions, see [Installation & Setup](#2.1). For a step-by-step tutorial building your first strategy, see [Your First Backtest](#2.2).\n\n---\n\n## Example 1: Basic Backtest\n\nThis example demonstrates the minimum code required to run a historical backtest with a simple strategy.\n\n```typescript\nimport { \n  setLogger,\n  addExchange, \n  addStrategy, \n  addFrame,\n  Backtest,\n  listenDoneBacktest,\n  getAveragePrice \n} from 'backtest-kit';\nimport ccxt from 'ccxt';\n\n// Configure logging\nsetLogger({\n  log: console.log,\n  debug: console.debug,\n  info: console.info,\n  warn: console.warn,\n});\n\n// Register exchange data source\naddExchange({\n  exchangeName: 'binance',\n  getCandles: async (symbol, interval, since, limit) => {\n    const exchange = new ccxt.binance();\n    const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => \n      ({ timestamp, open, high, low, close, volume })\n    );\n  },\n  formatPrice: (symbol, price) => price.toFixed(2),\n  formatQuantity: (symbol, quantity) => quantity.toFixed(8),\n});\n\n// Define trading strategy\naddStrategy({\n  strategyName: 'simple-momentum',\n  interval: '5m',  // Check every 5 minutes\n  getSignal: async (symbol) => {\n    const price = await getAveragePrice(symbol);\n    \n    // Simple momentum: buy if price > moving average\n    return {\n      position: 'long',\n      priceOpen: price,\n      priceTakeProfit: price * 1.02,  // 2% profit target\n      priceStopLoss: price * 0.99,    // 1% stop loss\n      minuteEstimatedTime: 60,        // 1 hour max hold\n    };\n  },\n});\n\n// Define backtest timeframe\naddFrame({\n  frameName: '1week-test',\n  interval: '1m',  // Minute-by-minute simulation\n  startDate: new Date('2024-01-01'),\n  endDate: new Date('2024-01-08'),\n});\n\n// Listen for completion\nlistenDoneBacktest(async (event) => {\n  if (event.strategyName === 'simple-momentum') {\n    await Backtest.dump(event.symbol, event.strategyName);\n    console.log('Backtest complete. Report saved to ./dump/backtest/');\n  }\n});\n\n// Run backtest\nBacktest.background('BTCUSDT', {\n  strategyName: 'simple-momentum',\n  exchangeName: 'binance',\n  frameName: '1week-test',\n});\n```\n\n### Execution Flow Diagram\n\n```mermaid\ngraph TD\n    User[\"User Code\"]\n    \n    subgraph \"Registration Phase\"\n        AddExch[\"addExchange()\"]\n        AddStrat[\"addStrategy()\"]\n        AddFrame[\"addFrame()\"]\n    end\n    \n    subgraph \"Execution Phase\"\n        BTBg[\"Backtest.background()\"]\n        BTInst[\"BacktestInstance\"]\n        BTLogic[\"BacktestLogicPrivateService\"]\n        StratCore[\"StrategyCoreService\"]\n        ClientStrat[\"ClientStrategy\"]\n        GetSig[\"getSignal()\"]\n    end\n    \n    subgraph \"Reporting Phase\"\n        ListenDone[\"listenDoneBacktest()\"]\n        BTDump[\"Backtest.dump()\"]\n        BTMd[\"BacktestMarkdownService\"]\n        File[\"./dump/backtest/<br/>simple-momentum.md\"]\n    end\n    \n    User --> AddExch\n    User --> AddStrat\n    User --> AddFrame\n    User --> ListenDone\n    User --> BTBg\n    \n    AddExch --> |\"stores in\"| ExchSchema[\"ExchangeSchemaService\"]\n    AddStrat --> |\"stores in\"| StratSchema[\"StrategySchemaService\"]\n    AddFrame --> |\"stores in\"| FrameSchema[\"FrameSchemaService\"]\n    \n    BTBg --> |\"creates\"| BTInst\n    BTInst --> |\"delegates to\"| BTLogic\n    BTLogic --> |\"iterates frames<br/>calls tick()\"| StratCore\n    StratCore --> |\"manages lifecycle\"| ClientStrat\n    ClientStrat --> |\"invokes\"| GetSig\n    \n    ClientStrat --> |\"emits to\"| SigEmit[\"signalBacktestEmitter\"]\n    SigEmit --> BTMd\n    \n    BTLogic --> |\"emits to\"| DoneEmit[\"doneBacktestSubject\"]\n    DoneEmit --> ListenDone\n    ListenDone --> BTDump\n    BTDump --> BTMd\n    BTMd --> File\n```\n\n**Sources:**\n- [README.md:40-159]()\n- [src/classes/Backtest.ts:200-235]()\n- [src/classes/Backtest.ts:423-443]()\n\n---\n\n## Example 2: Live Trading Mode\n\nThis example demonstrates real-time trading with crash-safe persistence.\n\n```typescript\nimport { \n  addExchange,\n  addStrategy,\n  Live,\n  listenSignalLive,\n  getAveragePrice \n} from 'backtest-kit';\nimport ccxt from 'ccxt';\n\n// Register exchange with API credentials\naddExchange({\n  exchangeName: 'binance-live',\n  getCandles: async (symbol, interval, since, limit) => {\n    const exchange = new ccxt.binance({\n      apiKey: process.env.BINANCE_API_KEY,\n      secret: process.env.BINANCE_SECRET,\n    });\n    const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => \n      ({ timestamp, open, high, low, close, volume })\n    );\n  },\n  formatPrice: (symbol, price) => price.toFixed(2),\n  formatQuantity: (symbol, quantity) => quantity.toFixed(8),\n});\n\n// Define strategy (same as backtest)\naddStrategy({\n  strategyName: 'live-momentum',\n  interval: '5m',\n  getSignal: async (symbol) => {\n    const price = await getAveragePrice(symbol);\n    return {\n      position: 'long',\n      priceOpen: price,\n      priceTakeProfit: price * 1.02,\n      priceStopLoss: price * 0.99,\n      minuteEstimatedTime: 60,\n    };\n  },\n});\n\n// Listen for all signal events\nlistenSignalLive((result) => {\n  if (result.action === 'opened') {\n    console.log('Signal opened:', result.signal.id);\n  } else if (result.action === 'closed') {\n    console.log('Signal closed:', result.signal.id);\n    console.log('PNL:', result.pnl.pnlPercentage.toFixed(2) + '%');\n  }\n});\n\n// Run live trading (infinite loop)\nLive.background('BTCUSDT', {\n  strategyName: 'live-momentum',\n  exchangeName: 'binance-live',\n});\n\nconsole.log('Live trading started. Press Ctrl+C to stop gracefully.');\n```\n\n### Live Trading vs Backtest Comparison\n\n| Aspect | Backtest Mode | Live Mode |\n|--------|--------------|-----------|\n| **Execution** | Finite generator (startDate to endDate) | Infinite generator (until stopped) |\n| **Time source** | Frame timestamps ([src/lib/services/frame/FrameCoreService.ts:37-58]()) | `new Date()` ([src/lib/services/live/LiveLogicPrivateService.ts:61]()) |\n| **Signal persistence** | In-memory only | Written to disk ([src/lib/adapters/PersistSignalAdapter.ts]()) |\n| **Crash recovery** | Not needed (deterministic) | Automatic state restoration on restart |\n| **Completion event** | `doneBacktestSubject` | `doneLiveSubject` (only when stopped + no active signal) |\n| **Use case** | Historical testing, strategy validation | Production trading, real money |\n\n**Sources:**\n- [README.md:161-171]()\n- [src/classes/Live.ts:208-242]()\n- [src/classes/Live.ts:441-459]()\n\n---\n\n## Example 3: Walker (Strategy Comparison)\n\nThis example demonstrates comparing multiple strategies to find the best performer.\n\n```typescript\nimport { \n  addExchange,\n  addStrategy,\n  addFrame,\n  addWalker,\n  Walker,\n  listenDoneWalker,\n  getAveragePrice,\n  getCandles\n} from 'backtest-kit';\nimport ccxt from 'ccxt';\n\n// Register exchange (same as previous examples)\naddExchange({\n  exchangeName: 'binance',\n  getCandles: async (symbol, interval, since, limit) => {\n    const exchange = new ccxt.binance();\n    const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => \n      ({ timestamp, open, high, low, close, volume })\n    );\n  },\n  formatPrice: (symbol, price) => price.toFixed(2),\n  formatQuantity: (symbol, quantity) => quantity.toFixed(8),\n});\n\n// Strategy 1: Aggressive (high risk/reward)\naddStrategy({\n  strategyName: 'aggressive',\n  interval: '5m',\n  getSignal: async (symbol) => {\n    const price = await getAveragePrice(symbol);\n    return {\n      position: 'long',\n      priceOpen: price,\n      priceTakeProfit: price * 1.05,  // 5% profit\n      priceStopLoss: price * 0.98,    // 2% loss\n      minuteEstimatedTime: 30,\n    };\n  },\n});\n\n// Strategy 2: Conservative (low risk/reward)\naddStrategy({\n  strategyName: 'conservative',\n  interval: '5m',\n  getSignal: async (symbol) => {\n    const price = await getAveragePrice(symbol);\n    return {\n      position: 'long',\n      priceOpen: price,\n      priceTakeProfit: price * 1.01,  // 1% profit\n      priceStopLoss: price * 0.995,   // 0.5% loss\n      minuteEstimatedTime: 120,\n    };\n  },\n});\n\n// Strategy 3: Multi-timeframe\naddStrategy({\n  strategyName: 'multi-tf',\n  interval: '15m',\n  getSignal: async (symbol) => {\n    const candles1h = await getCandles(symbol, '1h', 24);\n    const candles5m = await getCandles(symbol, '5m', 60);\n    \n    // Use multiple timeframes for analysis\n    const price = await getAveragePrice(symbol);\n    return {\n      position: 'long',\n      priceOpen: price,\n      priceTakeProfit: price * 1.03,\n      priceStopLoss: price * 0.985,\n      minuteEstimatedTime: 90,\n    };\n  },\n});\n\n// Define backtest timeframe\naddFrame({\n  frameName: '1month-test',\n  interval: '1m',\n  startDate: new Date('2024-01-01'),\n  endDate: new Date('2024-02-01'),\n});\n\n// Define walker to compare strategies\naddWalker({\n  walkerName: 'strategy-comparison',\n  strategies: ['aggressive', 'conservative', 'multi-tf'],\n  exchangeName: 'binance',\n  frameName: '1month-test',\n  metric: 'sharpeRatio',  // Comparison metric\n});\n\n// Listen for completion\nlistenDoneWalker(async (event) => {\n  if (event.strategyName === 'strategy-comparison') {\n    const results = await Walker.getData(event.symbol, 'strategy-comparison');\n    console.log('Best strategy:', results.bestStrategy);\n    console.log('Best Sharpe ratio:', results.bestMetric);\n    \n    await Walker.dump(event.symbol, 'strategy-comparison');\n    console.log('Comparison report saved to ./dump/walker/');\n  }\n});\n\n// Run comparison\nWalker.background('BTCUSDT', {\n  walkerName: 'strategy-comparison',\n});\n```\n\n### Walker Execution Flow\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant WalkerCmd as WalkerCommandService\n    participant WalkerLogic as WalkerLogicPrivateService\n    participant BTLogic as BacktestLogicPublicService\n    participant WalkerMd as WalkerMarkdownService\n    \n    User->>WalkerCmd: Walker.background()\n    WalkerCmd->>WalkerLogic: run()\n    \n    Note over WalkerLogic: Load walker schema<br/>strategies: [aggressive,<br/>conservative, multi-tf]\n    \n    loop For each strategy\n        WalkerLogic->>BTLogic: Backtest.run(strategy)\n        BTLogic-->>WalkerLogic: yield closed signals\n        WalkerLogic->>WalkerMd: Accumulate statistics\n        WalkerLogic->>User: Emit progress event\n    end\n    \n    WalkerLogic->>WalkerMd: Compare by metric\n    Note over WalkerMd: Calculate Sharpe ratios<br/>Find best performer\n    \n    WalkerLogic->>User: Emit walkerCompleteSubject\n    User->>WalkerMd: Walker.getData()\n    WalkerMd-->>User: Return best strategy\n```\n\n### Available Comparison Metrics\n\n| Metric | Description | Use Case |\n|--------|-------------|----------|\n| `sharpeRatio` | Risk-adjusted returns | Balancing profit and volatility |\n| `totalPnl` | Total profit/loss percentage | Maximum absolute returns |\n| `winRate` | Percentage of winning trades | Consistency of strategy |\n| `maxDrawdown` | Largest peak-to-trough decline | Risk tolerance assessment |\n| `avgPnlPerTrade` | Average profit per trade | Efficiency per signal |\n\n**Sources:**\n- [src/classes/Walker.ts:145-194]()\n- [src/classes/Walker.ts:214-246]()\n- [src/lib/services/walker/WalkerLogicPrivateService.ts]()\n\n---\n\n## Example 4: Event-Driven Architecture\n\nThis example demonstrates using event listeners for real-time monitoring and custom logic.\n\n```typescript\nimport {\n  addExchange,\n  addStrategy,\n  addFrame,\n  Backtest,\n  listenSignalBacktest,\n  listenProgressBacktest,\n  listenDoneBacktest,\n  listenPartialProfit,\n  listenPartialLoss,\n  listenRisk,\n  listenError,\n  getAveragePrice\n} from 'backtest-kit';\nimport ccxt from 'ccxt';\n\n// Setup exchange and strategy (omitted for brevity)\n// ... see Example 1 ...\n\n// Track all signal state changes\nlistenSignalBacktest((result) => {\n  console.log(`[${new Date().toISOString()}] Signal event:`, {\n    action: result.action,\n    signalId: result.signal?.id,\n    position: result.signal?.position,\n  });\n  \n  if (result.action === 'closed') {\n    const pnl = result.pnl.pnlPercentage;\n    const emoji = pnl > 0 ? '✅' : '❌';\n    console.log(`${emoji} PNL: ${pnl.toFixed(2)}%`);\n  }\n});\n\n// Monitor backtest progress\nlistenProgressBacktest((event) => {\n  console.log(`Progress: ${event.progress}% complete`);\n});\n\n// Track unrealized profit milestones\nlistenPartialProfit((event) => {\n  console.log(`🎯 Partial profit: ${event.level}% on signal ${event.signalId}`);\n});\n\n// Track unrealized loss milestones\nlistenPartialLoss((event) => {\n  console.warn(`⚠️ Partial loss: ${event.level}% on signal ${event.signalId}`);\n});\n\n// Monitor risk rejections\nlistenRisk((event) => {\n  console.error(`🚫 Risk rejection: ${event.comment}`);\n  console.error(`   Active positions: ${event.activePositionCount}`);\n});\n\n// Handle errors\nlistenError((error) => {\n  console.error('Error during execution:', error);\n});\n\n// Generate final report\nlistenDoneBacktest(async (event) => {\n  const stats = await Backtest.getData(event.symbol, event.strategyName);\n  \n  console.log('\\n=== Backtest Results ===');\n  console.log('Total trades:', stats.totalTrades);\n  console.log('Win rate:', (stats.winRate * 100).toFixed(2) + '%');\n  console.log('Sharpe ratio:', stats.sharpeRatio?.toFixed(2) || 'N/A');\n  console.log('Max drawdown:', stats.maxDrawdown?.toFixed(2) + '%');\n  \n  await Backtest.dump(event.symbol, event.strategyName);\n});\n\n// Run backtest\nBacktest.background('BTCUSDT', {\n  strategyName: 'simple-momentum',\n  exchangeName: 'binance',\n  frameName: '1week-test',\n});\n```\n\n### Event System Architecture\n\n```mermaid\ngraph LR\n    subgraph \"Event Emitters\"\n        SigEmit[\"signalBacktestEmitter\"]\n        ProgEmit[\"progressBacktestEmitter\"]\n        DoneEmit[\"doneBacktestSubject\"]\n        PPEmit[\"partialProfitSubject\"]\n        PLEmit[\"partialLossSubject\"]\n        RiskEmit[\"riskSubject\"]\n        ErrEmit[\"errorEmitter\"]\n    end\n    \n    subgraph \"User Listeners\"\n        ListenSig[\"listenSignalBacktest()\"]\n        ListenProg[\"listenProgressBacktest()\"]\n        ListenDone[\"listenDoneBacktest()\"]\n        ListenPP[\"listenPartialProfit()\"]\n        ListenPL[\"listenPartialLoss()\"]\n        ListenRisk[\"listenRisk()\"]\n        ListenErr[\"listenError()\"]\n    end\n    \n    subgraph \"Internal Services\"\n        ClientStrat[\"ClientStrategy\"]\n        BTLogic[\"BacktestLogicPrivateService\"]\n        ClientPartial[\"ClientPartial\"]\n        RiskGlobal[\"RiskGlobalService\"]\n    end\n    \n    ClientStrat -->|\"emits signals\"| SigEmit\n    BTLogic -->|\"emits progress\"| ProgEmit\n    BTLogic -->|\"emits completion\"| DoneEmit\n    ClientPartial -->|\"emits milestones\"| PPEmit\n    ClientPartial -->|\"emits milestones\"| PLEmit\n    RiskGlobal -->|\"emits rejections\"| RiskEmit\n    ClientStrat -->|\"emits errors\"| ErrEmit\n    \n    SigEmit --> ListenSig\n    ProgEmit --> ListenProg\n    DoneEmit --> ListenDone\n    PPEmit --> ListenPP\n    PLEmit --> ListenPL\n    RiskEmit --> ListenRisk\n    ErrEmit --> ListenErr\n    \n    ListenSig --> UserCode[\"User Code<br/>Custom Logic\"]\n    ListenProg --> UserCode\n    ListenDone --> UserCode\n    ListenPP --> UserCode\n    ListenPL --> UserCode\n    ListenRisk --> UserCode\n    ListenErr --> UserCode\n```\n\n**Event Listener Characteristics:**\n- All listeners use `functools-kit` `queued` wrapper ([src/index.ts:204-210]()) for sequential async execution\n- Events are emitted in order but processed asynchronously\n- Callbacks cannot block strategy execution\n- Unsubscribe by calling returned function: `const unsub = listenSignal(...); unsub();`\n\n**Sources:**\n- [README.md:174-176]()\n- [src/index.ts:200-249]()\n- [src/config/emitters.ts]()\n\n---\n\n## Example 5: Pull-Based Async Iterator Pattern\n\nThis example demonstrates using async iterators instead of event listeners for more control over execution flow.\n\n```typescript\nimport {\n  addExchange,\n  addStrategy,\n  addFrame,\n  Backtest,\n  getAveragePrice\n} from 'backtest-kit';\nimport ccxt from 'ccxt';\n\n// Setup exchange, strategy, frame (omitted for brevity)\n// ... see Example 1 ...\n\n// Pull-based execution with async iterator\nasync function runBacktestWithControl() {\n  const generator = Backtest.run('BTCUSDT', {\n    strategyName: 'simple-momentum',\n    exchangeName: 'binance',\n    frameName: '1week-test',\n  });\n  \n  let tradeCount = 0;\n  let totalPnl = 0;\n  \n  for await (const result of generator) {\n    if (result.action === 'closed') {\n      tradeCount++;\n      totalPnl += result.pnl.pnlPercentage;\n      \n      console.log(`Trade ${tradeCount}: ${result.pnl.pnlPercentage.toFixed(2)}%`);\n      \n      // Conditional early termination\n      if (totalPnl < -10) {\n        console.warn('Total loss exceeded -10%, stopping backtest');\n        break;\n      }\n      \n      // Conditional logic based on results\n      if (tradeCount === 10) {\n        console.log('First 10 trades complete, analyzing...');\n        const winRate = result.pnl.pnlPercentage > 0 ? 1 : 0;\n        if (winRate < 0.5) {\n          console.warn('Win rate below 50%, consider strategy adjustment');\n        }\n      }\n    }\n  }\n  \n  console.log(`\\nBacktest complete: ${tradeCount} trades, ${totalPnl.toFixed(2)}% total PNL`);\n}\n\nrunBacktestWithControl();\n```\n\n### Push vs Pull Execution Models\n\n```mermaid\ngraph TB\n    subgraph \"Push Model (background)\"\n        PushUser[\"User Code\"]\n        PushBg[\"Backtest.background()\"]\n        PushTask[\"Background Task\"]\n        PushEmit[\"Event Emitters\"]\n        PushListen[\"Event Listeners\"]\n        \n        PushUser -->|\"fire and forget\"| PushBg\n        PushBg -->|\"spawns\"| PushTask\n        PushTask -->|\"emits events\"| PushEmit\n        PushEmit -->|\"triggers\"| PushListen\n        PushListen -->|\"callbacks execute\"| PushUser\n        \n        Note1[\"Characteristics:<br/>- Non-blocking<br/>- Decoupled execution<br/>- Multiple subscribers<br/>- Event-driven\"]\n    end\n    \n    subgraph \"Pull Model (run)\"\n        PullUser[\"User Code\"]\n        PullRun[\"Backtest.run()\"]\n        PullGen[\"AsyncGenerator\"]\n        PullLoop[\"for await...of loop\"]\n        \n        PullUser -->|\"creates generator\"| PullRun\n        PullRun -->|\"returns\"| PullGen\n        PullUser -->|\"iterates\"| PullLoop\n        PullLoop -->|\"pulls next value\"| PullGen\n        PullGen -->|\"yields result\"| PullLoop\n        PullLoop -->|\"processes result\"| PullUser\n        \n        Note2[\"Characteristics:<br/>- Blocking iteration<br/>- Sequential control<br/>- Early termination<br/>- Flow control\"]\n    end\n```\n\n**Use Cases:**\n\n| Pattern | Best For |\n|---------|----------|\n| **Push (background)** | Production bots, monitoring dashboards, multi-strategy portfolios, fire-and-forget execution |\n| **Pull (run)** | Research, testing, LLM agents, conditional logic, early termination, sequential workflows |\n\n**Sources:**\n- [README.md:201-224]()\n- [src/classes/Backtest.ts:378-400]()\n- [src/classes/Backtest.ts:423-443]()\n\n---\n\n## Example 6: Global Configuration\n\nThis example demonstrates configuring global parameters that affect all strategies.\n\n```typescript\nimport { setConfig, setLogger } from 'backtest-kit';\n\n// Configure global parameters\nsetConfig({\n  // Trading costs\n  CC_PERCENT_FEE: 0.1,              // 0.1% per trade\n  CC_PERCENT_SLIPPAGE: 0.1,         // 0.1% slippage\n  \n  // Signal validation\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.3,  // TP must be >= 0.3% away (covers fees+slippage)\n  CC_MAX_STOPLOSS_DISTANCE_PERCENT: 10.0,   // SL must be <= 10% away\n  CC_MAX_SIGNAL_LIFETIME_MINUTES: 1440,     // Max 24 hours\n  \n  // VWAP pricing\n  CC_AVG_PRICE_CANDLES_COUNT: 5,    // Use 5 candles for VWAP calculation\n  \n  // Scheduled signals\n  CC_SCHEDULE_AWAIT_MINUTES: 120,   // Pending order timeout (2 hours)\n  \n  // Data validation\n  CC_MAX_PRICE_ANOMALY_PERCENTAGE: 20.0,  // Reject candles with >20% deviation\n  CC_RETRY_COUNT: 3,                      // Retry failed API calls 3 times\n  CC_RETRY_DELAY_MS: 1000,               // Wait 1 second between retries\n});\n\n// Configure logging\nsetLogger({\n  log: console.log,\n  debug: (...args) => {\n    if (process.env.DEBUG === 'true') {\n      console.debug(...args);\n    }\n  },\n  info: console.info,\n  warn: console.warn,\n});\n```\n\n### Configuration Impact on Signal Validation\n\n```mermaid\ngraph TD\n    GetSig[\"getSignal() returns signal\"]\n    \n    subgraph \"Validation Pipeline\"\n        V1[\"Check prices > 0,<br/>finite, not NaN\"]\n        V2[\"Check TP/SL logic<br/>LONG: TP>open>SL<br/>SHORT: SL>open>TP\"]\n        V3[\"Check TP distance >=<br/>MIN_TAKEPROFIT_DISTANCE\"]\n        V4[\"Check SL distance <=<br/>MAX_STOPLOSS_DISTANCE\"]\n        V5[\"Check lifetime <=<br/>MAX_SIGNAL_LIFETIME\"]\n        V6[\"Check candle anomalies<br/>MAX_PRICE_ANOMALY_PERCENTAGE\"]\n        V7[\"Risk validation\"]\n    end\n    \n    GetSig --> V1\n    V1 -->|\"pass\"| V2\n    V1 -->|\"fail\"| Reject[\"Emit riskSubject<br/>Signal rejected\"]\n    \n    V2 -->|\"pass\"| V3\n    V2 -->|\"fail\"| Reject\n    \n    V3 -->|\"pass\"| V4\n    V3 -->|\"fail\"| Reject\n    \n    V4 -->|\"pass\"| V5\n    V4 -->|\"fail\"| Reject\n    \n    V5 -->|\"pass\"| V6\n    V5 -->|\"fail\"| Reject\n    \n    V6 -->|\"pass\"| V7\n    V6 -->|\"fail\"| Reject\n    \n    V7 -->|\"pass\"| Accept[\"Signal accepted<br/>Schedule or Open\"]\n    V7 -->|\"fail\"| Reject\n```\n\n**Critical Configuration Notes:**\n- `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` **must** be set high enough to cover `CC_PERCENT_FEE + CC_PERCENT_SLIPPAGE`, otherwise all trades will lose money even when hitting TP\n- Default value is 0.3% which covers 0.1% fee + 0.1% slippage + 0.1% buffer\n- `CC_MAX_PRICE_ANOMALY_PERCENTAGE` protects against bad data causing unrealistic backtest results\n\n**Sources:**\n- [README.md:45-63]()\n- [README.md:178-184]()\n- [src/config/params.ts:17-95]()\n- [src/lib/services/strategy/ClientStrategy.ts:400-511]()\n\n---\n\n## Running the Examples\n\nAll examples require TypeScript 5.0+ and peer dependencies installed:\n\n```bash\nnpm install backtest-kit ccxt ollama uuid\nnpm install -D typescript @types/node\n```\n\nFor live trading examples, create a `.env` file:\n\n```env\nBINANCE_API_KEY=your_api_key_here\nBINANCE_SECRET=your_secret_here\n```\n\nRun with:\n\n```bash\nnpx tsx example.ts\n# or\nnode --loader tsx example.ts\n```\n\n**Sources:**\n- [README.md:40-43]()\n- [package.json:71-79]()\n- [demo/backtest/package.json]()\n- [demo/live/package.json]()"
                    },
                    {
                        "page_plan": {
                            "id": "3",
                            "title": "Core Concepts"
                        },
                        "content": "# Core Concepts\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [assets/uml.svg](assets/uml.svg)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis document explains the fundamental concepts that underpin the entire backtest-kit framework. Understanding these concepts is essential for developing strategies, managing risk, and interpreting results.\n\nFor information about running backtests or live trading, see [Execution Modes](#5). For details on the internal architecture and service layer, see [Architecture Deep Dive](#4). For practical examples, see [Getting Started](#2).\n\n---\n\n## Signals: The Fundamental Trading Unit\n\nA **signal** represents a single trading position with defined entry, take profit (TP), stop loss (SL), and time parameters. Signals are the atomic unit of execution in backtest-kit.\n\n### Signal Structure\n\nEvery signal contains:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `id` | `string` | Auto-generated UUID v4 identifier |\n| `position` | `\"long\" \\| \"short\"` | Trade direction |\n| `priceOpen` | `number` | Entry price for the position |\n| `priceTakeProfit` | `number` | Target exit price (profit) |\n| `priceStopLoss` | `number` | Maximum loss exit price |\n| `minuteEstimatedTime` | `number` | Duration before time-based exit |\n| `note` | `string` (optional) | Human-readable description |\n\n**Signal DTO vs Signal Row**\n\nStrategies return `ISignalDto` objects [types.d.ts:650-665]() where `id` and `priceOpen` are optional. The framework augments these into `ISignalRow` objects [types.d.ts:670-687]() with:\n- Auto-generated `id` (UUID v4)\n- Defaulted `priceOpen` (current VWAP if omitted)\n- Metadata: `exchangeName`, `strategyName`, `scheduledAt`, `pendingAt`, `symbol`, `_isScheduled`\n\n```mermaid\ngraph LR\n    A[\"getSignal()\"] -->|returns| B[\"ISignalDto\"]\n    B -->|validation| C[\"ISignalRow\"]\n    B -->|priceOpen=null| D[\"IScheduledSignalRow\"]\n    C --> E[\"Active Trading\"]\n    D --> F[\"Waiting for Activation\"]\n```\n\n**Immediate vs Scheduled Signals**\n\n- **Immediate signals**: `priceOpen` omitted or equals current price → opens immediately at VWAP\n- **Scheduled signals**: `priceOpen` specified and differs from current price → enters \"scheduled\" state [types.d.ts:694-697]()\n\nSources: [types.d.ts:650-697]()\n\n---\n\n## Signal Lifecycle State Machine\n\nSignals progress through a multi-stage lifecycle with comprehensive validation before activation. The state machine ensures data integrity and prevents invalid trades.\n\n### Lifecycle Diagram\n\n```mermaid\nstateDiagram-v2\n    [*] --> Idle: \"No active signal\"\n    \n    Idle --> ValidateSchema: \"getSignal returns signal\"\n    \n    ValidateSchema --> ValidatePositive: \"Check prices > 0\"\n    ValidatePositive --> ValidateTPSL: \"Check TP/SL logic\"\n    ValidateTPSL --> ValidateDistance: \"Check TP distance >= MIN\"\n    ValidateDistance --> ValidateSLRange: \"Check SL distance <= MAX\"\n    ValidateSLRange --> ValidateLifetime: \"Check lifetime <= MAX\"\n    ValidateLifetime --> CheckRisk: \"GLOBAL_CONFIG validated\"\n    \n    CheckRisk --> Rejected: \"Risk checks fail\"\n    CheckRisk --> Scheduled: \"priceOpen not reached\"\n    CheckRisk --> Opened: \"priceOpen reached\"\n    \n    Scheduled --> Opened: \"Price reaches priceOpen\"\n    Scheduled --> Cancelled: \"SL hit or timeout\"\n    \n    Opened --> Active: \"Persist signal\"\n    \n    Active --> PartialProfit: \"10%, 20%, 30%...\"\n    Active --> PartialLoss: \"-10%, -20%, -30%...\"\n    \n    PartialProfit --> Active: \"Continue monitoring\"\n    PartialLoss --> Active: \"Continue monitoring\"\n    \n    Active --> Closed_TP: \"priceTakeProfit reached\"\n    Active --> Closed_SL: \"priceStopLoss reached\"\n    Active --> Closed_Time: \"minuteEstimatedTime expired\"\n    \n    Closed_TP --> Idle: \"Calculate PNL\"\n    Closed_SL --> Idle: \"Calculate PNL\"\n    Closed_Time --> Idle: \"Calculate PNL\"\n    Cancelled --> Idle: \"No PNL\"\n    Rejected --> Idle: \"Log error\"\n```\n\n### Validation Stages\n\nBefore any signal activates, it passes through 7 validation checks enforced by `GLOBAL_CONFIG`:\n\n1. **Schema Validation**: Fields match `ISignalDto` interface [types.d.ts:650-665]()\n2. **Positive Price Check**: All prices > 0, finite, not NaN\n3. **TP/SL Logic**: \n   - LONG: `priceTakeProfit > priceOpen > priceStopLoss`\n   - SHORT: `priceStopLoss > priceOpen > priceTakeProfit`\n4. **TP Distance**: `(|priceTakeProfit - priceOpen| / priceOpen) >= CC_MIN_TAKEPROFIT_DISTANCE_PERCENT`\n5. **SL Range**: `(|priceStopLoss - priceOpen| / priceOpen) <= CC_MAX_STOPLOSS_DISTANCE_PERCENT`\n6. **Lifetime Limit**: `minuteEstimatedTime <= CC_MAX_SIGNAL_LIFETIME_MINUTES`\n7. **Risk Validation**: Custom validations from `IRiskSchema` [types.d.ts:417-426]()\n\n### State Transitions\n\n| Current State | Trigger | Next State | Notes |\n|--------------|---------|------------|-------|\n| `Idle` | `getSignal()` returns signal | `ValidateSchema` | Begin validation pipeline |\n| `ValidateSchema` → ... → `CheckRisk` | All checks pass + `priceOpen` not reached | `Scheduled` | Limit order waiting for entry |\n| `ValidateSchema` → ... → `CheckRisk` | All checks pass + `priceOpen` reached | `Opened` | Market order, enter immediately |\n| `CheckRisk` | Risk validation fails | `Rejected` | Signal discarded, emit `riskSubject` |\n| `Scheduled` | Current price reaches `priceOpen` (before SL) | `Opened` | Activation successful |\n| `Scheduled` | `priceStopLoss` hit OR timeout | `Cancelled` | Activation failed, emit cancel event |\n| `Opened` | Signal persisted | `Active` | Begin TP/SL/time monitoring |\n| `Active` | Price reaches `priceTakeProfit` | `Closed_TP` | Exit with profit |\n| `Active` | Price reaches `priceStopLoss` | `Closed_SL` | Exit with loss |\n| `Active` | `minuteEstimatedTime` expires | `Closed_Time` | Exit at current price |\n\n**Key Safety Rule**: Scheduled signals check for SL breach **before** checking for activation. This prevents \"open-and-immediately-stop\" scenarios.\n\nSources: [types.d.ts:650-697](), High-level diagrams (Diagram 3)\n\n---\n\n## Tick Results: Discriminated Union Type System\n\nEvery call to `ClientStrategy.tick()` returns a discriminated union result [types.d.ts:888]() that encodes the current signal state. This design enables type-safe handling without optional fields.\n\n### Result Types\n\n```mermaid\ngraph TD\n    A[\"IStrategyTickResult\"] --> B[\"IStrategyTickResultIdle\"]\n    A --> C[\"IStrategyTickResultScheduled\"]\n    A --> D[\"IStrategyTickResultOpened\"]\n    A --> E[\"IStrategyTickResultActive\"]\n    A --> F[\"IStrategyTickResultClosed\"]\n    A --> G[\"IStrategyTickResultCancelled\"]\n    \n    B --> H[\"action: 'idle'<br/>signal: null\"]\n    C --> I[\"action: 'scheduled'<br/>signal: IScheduledSignalRow\"]\n    D --> J[\"action: 'opened'<br/>signal: ISignalRow\"]\n    E --> K[\"action: 'active'<br/>signal: ISignalRow<br/>percentTp, percentSl\"]\n    F --> L[\"action: 'closed'<br/>signal: ISignalRow<br/>closeReason, pnl\"]\n    G --> M[\"action: 'cancelled'<br/>signal: IScheduledSignalRow\"]\n```\n\n### Type-Safe Pattern Matching\n\nUse the `action` discriminator for type-safe handling:\n\n```typescript\nconst result = await strategy.tick(symbol, when);\n\nswitch (result.action) {\n  case \"idle\":\n    // result.signal is null\n    console.log(\"No active position\");\n    break;\n    \n  case \"scheduled\":\n    // result.signal is IScheduledSignalRow\n    console.log(`Waiting for ${result.signal.priceOpen}`);\n    break;\n    \n  case \"opened\":\n    // result.signal is ISignalRow\n    console.log(`Position opened: ${result.signal.id}`);\n    break;\n    \n  case \"active\":\n    // result.signal is ISignalRow, percentTp/percentSl available\n    console.log(`Active: ${result.percentTp}% to TP`);\n    break;\n    \n  case \"closed\":\n    // result.signal is ISignalRow, closeReason and pnl available\n    console.log(`Closed: ${result.closeReason}, PNL ${result.pnl.pnlPercentage}%`);\n    break;\n    \n  case \"cancelled\":\n    // result.signal is IScheduledSignalRow\n    console.log(`Cancelled without opening`);\n    break;\n}\n```\n\nSources: [types.d.ts:768-888]()\n\n---\n\n## Strategies: Signal Generation Logic\n\nStrategies define **how** signals are generated from market data. A strategy is registered via `addStrategy()` and implements the `IStrategySchema` interface [types.d.ts:728-747]().\n\n### Strategy Schema\n\n```typescript\ninterface IStrategySchema {\n  strategyName: string;                    // Unique identifier\n  interval: SignalInterval;                 // Throttling interval\n  getSignal: (symbol: string, when: Date) => Promise<ISignalDto | null>;\n  callbacks?: Partial<IStrategyCallbacks>; // Lifecycle hooks\n  riskName?: string;                        // Single risk profile\n  riskList?: string[];                      // Multiple risk profiles\n}\n```\n\n**The `getSignal` Function**\n\nThis is the core strategy logic. It receives:\n- `symbol`: Trading pair (e.g., \"BTCUSDT\")\n- `when`: Current timestamp (execution context)\n\nIt returns:\n- `ISignalDto` object if conditions met\n- `null` if no signal\n\n```mermaid\ngraph LR\n    A[\"getSignal(symbol, when)\"] --> B{\"Analyze<br/>Market Data\"}\n    B -->|conditions met| C[\"return ISignalDto\"]\n    B -->|no signal| D[\"return null\"]\n    C --> E[\"Validation Pipeline\"]\n    D --> F[\"IStrategyTickResultIdle\"]\n```\n\n**Interval Throttling**\n\nThe `interval` field [types.d.ts:734]() prevents `getSignal` from being called too frequently:\n\n| Interval | Minimum Time Between Calls |\n|----------|---------------------------|\n| `\"1m\"` | 1 minute |\n| `\"3m\"` | 3 minutes |\n| `\"5m\"` | 5 minutes |\n| `\"15m\"` | 15 minutes |\n| `\"30m\"` | 30 minutes |\n| `\"1h\"` | 1 hour |\n\nThrottling is implemented in `ClientStrategy.tick()` [src/client/ClientStrategy.ts]() by tracking last call timestamp.\n\n**Strategy Callbacks**\n\nOptional lifecycle hooks [types.d.ts:702-723]():\n\n| Callback | When Called | Parameters |\n|----------|-------------|------------|\n| `onTick` | Every tick | `result: IStrategyTickResult` |\n| `onOpen` | Signal opens | `data: ISignalRow, currentPrice` |\n| `onActive` | Signal monitoring | `data: ISignalRow, currentPrice` |\n| `onIdle` | No active signal | `currentPrice` |\n| `onClose` | Signal closes | `data: ISignalRow, priceClose` |\n| `onSchedule` | Signal scheduled | `data: IScheduledSignalRow, currentPrice` |\n| `onCancel` | Scheduled signal cancelled | `data: IScheduledSignalRow, currentPrice` |\n| `onPartialProfit` | Profit milestone reached | `data: ISignalRow, revenuePercent` |\n| `onPartialLoss` | Loss milestone reached | `data: ISignalRow, lossPercent` |\n\nSources: [types.d.ts:728-747](), [types.d.ts:702-723]()\n\n---\n\n## Execution Contexts: Ambient Information Propagation\n\nBacktest-kit uses **scoped context services** to propagate ambient information throughout the call stack without explicit parameter passing. This is implemented via `di-scoped` library using Node.js `AsyncLocalStorage`.\n\n### Context Architecture\n\n```mermaid\ngraph TB\n    A[\"User Code\"] --> B[\"Backtest.run(symbol, context)\"]\n    B --> C[\"MethodContextService.runAsyncIterator()\"]\n    C --> D[\"ExecutionContextService.runInContext()\"]\n    D --> E[\"ClientStrategy.tick()\"]\n    E --> F[\"ClientExchange.getCandles()\"]\n    \n    C -.->|sets| G[\"MethodContext:<br/>strategyName<br/>exchangeName<br/>frameName\"]\n    D -.->|sets| H[\"ExecutionContext:<br/>symbol<br/>when<br/>backtest\"]\n    \n    F -.->|reads| G\n    F -.->|reads| H\n    \n    style G fill:#fff,stroke:#333,stroke-dasharray: 5 5\n    style H fill:#fff,stroke:#333,stroke-dasharray: 5 5\n```\n\n### ExecutionContext\n\nProvides **runtime execution parameters** [types.d.ts:11-18]():\n\n```typescript\ninterface IExecutionContext {\n  symbol: string;      // Trading pair (e.g., \"BTCUSDT\")\n  when: Date;          // Current timestamp\n  backtest: boolean;   // true = backtest mode, false = live mode\n}\n```\n\n**Usage**: Set once per tick, consumed by:\n- `ClientExchange.getCandles()` - fetches data up to `when` timestamp\n- `ClientExchange.getAveragePrice()` - calculates VWAP at `when`\n- `ClientStrategy.tick()` - processes signal at `when`\n\n**Access**: Via `ExecutionContextService` [types.d.ts:38-44]():\n\n```typescript\nExecutionContextService.runInContext(\n  async () => {\n    // Inside this callback, context is automatically available\n    const candles = await getCandles(symbol, \"1m\", 100);\n    // candles are fetched up to ExecutionContext.when timestamp\n  },\n  { symbol: \"BTCUSDT\", when: new Date(), backtest: true }\n);\n```\n\n### MethodContext\n\nProvides **schema identifiers** for dependency routing [types.d.ts:302-309]():\n\n```typescript\ninterface IMethodContext {\n  exchangeName: string;  // Which exchange schema to use\n  strategyName: string;  // Which strategy schema to use\n  frameName: string;     // Which frame schema to use (empty for live)\n}\n```\n\n**Usage**: Set once per execution run, consumed by:\n- `StrategyConnectionService` - routes to correct `ClientStrategy` instance\n- `ExchangeConnectionService` - routes to correct `ClientExchange` instance\n- `FrameConnectionService` - routes to correct `ClientFrame` instance\n\n**Access**: Via `MethodContextService` [types.d.ts:330-336]():\n\n```typescript\nMethodContextService.runAsyncIterator(\n  backtestGenerator,\n  {\n    strategyName: \"my-strategy\",\n    exchangeName: \"my-exchange\",\n    frameName: \"1d-backtest\"\n  }\n);\n```\n\n### Context Propagation Flow\n\n| Layer | Sets Context | Reads Context | Purpose |\n|-------|--------------|---------------|---------|\n| Public API | Neither | Neither | Entry point |\n| Logic Services | Both | Neither | Orchestration |\n| Connection Services | Neither | `MethodContext` | Route to correct client |\n| Client Layer | Neither | `ExecutionContext` | Access runtime params |\n\nSources: [types.d.ts:11-18](), [types.d.ts:38-44](), [types.d.ts:302-309](), [types.d.ts:330-336](), High-level diagrams (Diagram 1)\n\n---\n\n## Time Execution Engine: The Core Architectural Concept\n\nBacktest-kit is fundamentally a **time execution engine**, not a data-processing library. This architectural choice makes look-ahead bias architecturally impossible.\n\n### Conceptual Model\n\n```mermaid\ngraph LR\n    A[\"Time Stream\"] --> B[\"t₀\"]\n    B --> C[\"t₁\"]\n    C --> D[\"t₂\"]\n    D --> E[\"t₃\"]\n    E --> F[\"...\"]\n    \n    B -.->|ExecutionContext| G[\"strategy.tick(symbol, t₀)\"]\n    C -.->|ExecutionContext| H[\"strategy.tick(symbol, t₁)\"]\n    D -.->|ExecutionContext| I[\"strategy.tick(symbol, t₂)\"]\n    \n    G --> J[\"getCandles(symbol, '1m', 100)\"]\n    J -.->|returns data ≤ t₀| K[\"Candles up to t₀\"]\n```\n\n**Key Principle**: At timestamp `t`, all operations see only data from timestamps `≤ t`. The `ExecutionContextService` enforces this constraint throughout the call stack.\n\n### How It Works\n\n1. **Backtest Mode**: `BacktestLogicPrivateService` [src/lib/services/backtest/BacktestLogicPrivateService.ts]() iterates through a pre-generated timeframe:\n   ```typescript\n   for (const when of timeframes) {\n     ExecutionContextService.runInContext(\n       async () => {\n         const result = await strategy.tick(symbol, when);\n         yield result;\n       },\n       { symbol, when, backtest: true }\n     );\n   }\n   ```\n\n2. **Live Mode**: `LiveLogicPrivateService` [src/lib/services/live/LiveLogicPrivateService.ts]() creates timestamps in real-time:\n   ```typescript\n   while (true) {\n     const when = new Date();\n     ExecutionContextService.runInContext(\n       async () => {\n         const result = await strategy.tick(symbol, when);\n         yield result;\n       },\n       { symbol, when, backtest: false }\n     );\n     await sleep(TICK_TTL);\n   }\n   ```\n\n3. **Data Fetching**: `ClientExchange.getCandles()` [src/client/ClientExchange.ts]() reads `ExecutionContext.when` and ensures returned data ≤ `when`:\n   ```typescript\n   async getCandles(symbol, interval, limit) {\n     const { when } = this.execution.context;\n     // Fetch candles from exchange, filtered by when timestamp\n     const candles = await this.schema.getCandles(symbol, interval, since, limit);\n     return candles.filter(c => c.timestamp <= when.getTime());\n   }\n   ```\n\n### Async Stream of Time\n\nThe framework models execution as an **async generator** that yields results progressively:\n\n```mermaid\ngraph LR\n    A[\"Backtest.run(symbol, context)\"] --> B[\"AsyncGenerator<IStrategyTickResult>\"]\n    B --> C[\"yield result₁\"]\n    C --> D[\"yield result₂\"]\n    D --> E[\"yield result₃\"]\n    E --> F[\"yield result₄\"]\n    F --> G[\"return\"]\n```\n\nThis design enables:\n- **Memory efficiency**: No accumulation of results in memory\n- **Early termination**: Consumer can stop iteration at any point\n- **Streaming**: Real-time processing of results\n- **Backpressure**: Generator only produces when consumer is ready\n\nSources: [README.md:186-199](), High-level diagrams (Diagram 1), [types.d.ts:11-18]()\n\n---\n\n## VWAP Pricing: Realistic Price Simulation\n\nAll entry and exit prices use **Volume Weighted Average Price (VWAP)** calculated from the last 5 one-minute candles. This simulates realistic market execution better than using raw close prices.\n\n### VWAP Calculation\n\n```mermaid\ngraph TB\n    A[\"ClientExchange.getAveragePrice()\"] --> B[\"Fetch last 5 1-minute candles\"]\n    B --> C[\"For each candle:<br/>Typical Price = (High + Low + Close) / 3\"]\n    C --> D[\"Numerator = Σ(Typical Price × Volume)\"]\n    C --> E[\"Denominator = Σ(Volume)\"]\n    D --> F[\"VWAP = Numerator / Denominator\"]\n    E --> F\n```\n\n**Formula**:\n\n```\nTypical Price_i = (High_i + Low_i + Close_i) / 3\nVWAP = Σ(Typical Price_i × Volume_i) / Σ(Volume_i)\n```\n\nWhere `i` ranges over the last 5 one-minute candles.\n\n### Configuration\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `CC_AVG_PRICE_CANDLES_COUNT` | 5 | Number of candles for VWAP calculation |\n| Candle interval | `\"1m\"` | Fixed at one minute (hardcoded) |\n\n### Usage in Signal Processing\n\n```mermaid\ngraph LR\n    A[\"ClientStrategy.tick()\"] --> B[\"Get VWAP\"]\n    B --> C{\"Signal State?\"}\n    C -->|Idle| D[\"Call getSignal()\"]\n    D --> E[\"Use VWAP as default priceOpen\"]\n    C -->|Active| F[\"Check TP/SL against VWAP\"]\n    F --> G{\"VWAP reached TP/SL?\"}\n    G -->|Yes| H[\"Close signal\"]\n    G -->|No| I[\"Continue monitoring\"]\n```\n\n**Price Application**:\n- **Signal creation**: If `priceOpen` omitted, defaults to current VWAP\n- **TP/SL monitoring**: Compare current VWAP against `priceTakeProfit` and `priceStopLoss`\n- **Scheduled activation**: Compare current VWAP against `priceOpen` for scheduled signals\n- **Final closure**: Exit price is current VWAP at close timestamp\n\n### PNL Calculation with Fees and Slippage\n\nFinal profit/loss includes realistic trading costs [types.d.ts:757-764]():\n\n```typescript\ninterface IStrategyPnL {\n  pnlPercentage: number;  // Net profit/loss as percentage\n  priceOpen: number;      // Entry price adjusted with slippage + fees\n  priceClose: number;     // Exit price adjusted with slippage + fees\n}\n```\n\n**Cost Model**:\n- **Fee**: 0.1% on entry and exit (configurable via `CC_PERCENT_FEE`)\n- **Slippage**: 0.1% on entry and exit (configurable via `CC_PERCENT_SLIPPAGE`)\n- **Total cost**: ~0.4% per round trip\n\n**Example**:\n- Entry VWAP: $50,000\n- Exit VWAP: $52,000\n- Gross profit: 4%\n- Costs: 0.4%\n- Net PNL: **3.6%**\n\nSources: [types.d.ts:195-204](), [README.md:183](), [src/client/ClientExchange.ts]()\n\n---\n\n## Sequential Signal Processing\n\nBacktest-kit enforces a critical constraint: **only ONE active signal per symbol at any time**. This prevents position size explosions and ensures predictable behavior.\n\n### Constraint Enforcement\n\n```mermaid\ngraph TD\n    A[\"ClientStrategy.tick()\"] --> B{\"Has active signal?\"}\n    B -->|Yes| C[\"Monitor TP/SL/time\"]\n    B -->|No| D[\"Check interval throttle\"]\n    D -->|Too soon| E[\"Return idle result\"]\n    D -->|Interval passed| F[\"Call getSignal()\"]\n    F -->|Returns null| E\n    F -->|Returns signal| G[\"Validate and open\"]\n    C -->|Not closed| H[\"Return active result\"]\n    C -->|Closed| I[\"Clear signal\"]\n    I --> D\n```\n\n**Implementation**: `ClientStrategy` [src/client/ClientStrategy.ts]() maintains `_pendingSignal` field. If non-null, `getSignal()` is never called.\n\n### Backtest Fast-Forward Optimization\n\nAfter a signal opens in backtest mode, the system uses `ClientStrategy.backtest()` method to efficiently process the signal until closure:\n\n```mermaid\ngraph LR\n    A[\"Signal opens at t₀\"] --> B[\"Fetch future candles\"]\n    B --> C[\"Process bulk candles\"]\n    C --> D[\"Find TP/SL/time close\"]\n    D --> E[\"Skip timeframes from t₀ to t_close\"]\n    E --> F[\"Resume at t_close + 1\"]\n```\n\nThis optimization prevents thousands of unnecessary ticks while a signal is active.\n\nSources: [src/client/ClientStrategy.ts](), High-level diagrams (Diagram 3)\n\n---\n\n## Summary Table\n\n| Concept | Key Type/Interface | Purpose | Related Pages |\n|---------|-------------------|---------|---------------|\n| **Signal** | `ISignalDto`, `ISignalRow` | Atomic trading position | [Signals & Signal Lifecycle](#3.1) |\n| **Signal Lifecycle** | `IStrategyTickResult` (discriminated union) | State machine for signal processing | [Signals & Signal Lifecycle](#3.1) |\n| **Strategy** | `IStrategySchema`, `getSignal` function | Logic for generating signals | [Strategies](#3.2), [Strategy Development](#6) |\n| **Execution Context** | `ExecutionContextService`, `IExecutionContext` | Runtime parameters (symbol, when, mode) | [Execution Contexts](#3.3) |\n| **Method Context** | `MethodContextService`, `IMethodContext` | Schema routing (strategy/exchange/frame names) | [Execution Contexts](#3.3) |\n| **Time Execution** | Async generators, context propagation | Stream of time preventing look-ahead bias | [Time Execution Engine](#3.4) |\n| **VWAP Pricing** | `ClientExchange.getAveragePrice()` | Realistic entry/exit pricing | [VWAP Pricing & Data Handling](#3.5) |\n\nSources: [types.d.ts:1-1000](), High-level diagrams (all)"
                    },
                    {
                        "page_plan": {
                            "id": "3.1",
                            "title": "Signals & Signal Lifecycle"
                        },
                        "content": "# Signals & Signal Lifecycle\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/client/ClientStrategy.ts](src/client/ClientStrategy.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/config/params.ts](src/config/params.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Strategy.interface.ts](src/interfaces/Strategy.interface.ts)\n- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)\n- [test/README.md](test/README.md)\n- [test/config/setup.mjs](test/config/setup.mjs)\n- [test/e2e/close.test.mjs](test/e2e/close.test.mjs)\n- [test/e2e/edge.test.mjs](test/e2e/edge.test.mjs)\n- [test/e2e/other.test.mjs](test/e2e/other.test.mjs)\n- [test/e2e/persist.test.mjs](test/e2e/persist.test.mjs)\n- [test/e2e/sanitize.test.mjs](test/e2e/sanitize.test.mjs)\n- [test/e2e/sequence.test.mjs](test/e2e/sequence.test.mjs)\n- [test/index.mjs](test/index.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document explains the signal system in Backtest Kit: what signals are, how they progress through their lifecycle, validation rules, and persistence mechanisms. Signals are the fundamental unit of trading action in the framework, representing entry/exit positions with take profit (TP), stop loss (SL), and time-based expiration.\n\nFor information about how strategies generate signals, see [Strategies](#3.2). For execution context propagation, see [Execution Contexts](#3.3). For the time execution engine that processes signals, see [Time Execution Engine](#3.4).\n\n---\n\n## Core Signal Types\n\nThe framework defines three distinct signal types that represent different stages of signal maturity:\n\n| Type | Interface | Description | When Created |\n|------|-----------|-------------|--------------|\n| **Signal DTO** | `ISignalDto` | User-provided signal from `getSignal()` | Strategy generates signal |\n| **Signal Row** | `ISignalRow` | Validated signal with auto-generated ID | After validation passes |\n| **Scheduled Signal** | `IScheduledSignalRow` | Signal waiting for price activation | When `priceOpen` not yet reached |\n\n### ISignalDto Structure\n\n```typescript\ninterface ISignalDto {\n  id?: string;                    // Optional (auto-generated if omitted)\n  position: \"long\" | \"short\";     // Trade direction\n  note?: string;                  // Human-readable reason\n  priceOpen?: number;             // Entry price (creates scheduled signal if specified)\n  priceTakeProfit: number;        // Target exit price\n  priceStopLoss: number;          // Risk exit price\n  minuteEstimatedTime: number;    // Max lifetime before time_expired\n}\n```\n\n**Sources:** [types.d.ts:649-665](), [src/interfaces/Strategy.interface.ts:24-39]()\n\n### ISignalRow Structure\n\nAfter validation, signals are augmented with runtime metadata:\n\n```typescript\ninterface ISignalRow extends ISignalDto {\n  id: string;                     // UUID v4 (required)\n  priceOpen: number;              // Entry price (required)\n  exchangeName: ExchangeName;     // Exchange identifier\n  strategyName: StrategyName;     // Strategy identifier\n  scheduledAt: number;            // Creation timestamp (milliseconds)\n  pendingAt: number;              // Activation timestamp (milliseconds)\n  symbol: string;                 // Trading pair (e.g., \"BTCUSDT\")\n  _isScheduled: boolean;          // Internal flag for delayed entry\n}\n```\n\n**Scheduled vs Opened Timing:**\n- `scheduledAt`: Always set when signal is created\n- `pendingAt`: Set to `scheduledAt` initially, updated to actual activation time when scheduled signal activates\n\n**Sources:** [types.d.ts:670-687](), [src/interfaces/Strategy.interface.ts:45-62]()\n\n---\n\n## Signal Lifecycle State Machine\n\n### State Overview\n\n```mermaid\nstateDiagram-v2\n    [*] --> Idle\n    \n    Idle --> ValidateSchema: \"getSignal() returns signal\"\n    \n    ValidateSchema --> ValidatePositive: \"Prices > 0, finite\"\n    ValidatePositive --> ValidateTPSL: \"TP/SL logic check\"\n    ValidateTPSL --> ValidateDistance: \"TP distance >= MIN\"\n    ValidateDistance --> ValidateSLRange: \"SL distance <= MAX\"\n    ValidateSLRange --> ValidateLifetime: \"lifetime <= MAX\"\n    ValidateLifetime --> CheckRisk: \"Risk validation\"\n    \n    CheckRisk --> Rejected: \"Risk fail\"\n    CheckRisk --> CheckPrice: \"Risk pass\"\n    \n    CheckPrice --> Scheduled: \"priceOpen not reached\"\n    CheckPrice --> Opened: \"priceOpen reached\"\n    \n    Scheduled --> Opened: \"Price reaches priceOpen\"\n    Scheduled --> Cancelled: \"SL before priceOpen OR timeout\"\n    \n    Opened --> Active: \"Persist signal\"\n    \n    Active --> ClosedTP: \"priceTakeProfit reached\"\n    Active --> ClosedSL: \"priceStopLoss reached\"\n    Active --> ClosedTime: \"minuteEstimatedTime expired\"\n    \n    ClosedTP --> Idle: \"Delete persisted signal\"\n    ClosedSL --> Idle\n    ClosedTime --> Idle\n    Cancelled --> Idle\n    Rejected --> Idle\n```\n\n**Sources:** [types.d.ts:301-308](), [src/client/ClientStrategy.ts:45-476](), High-level Diagram 3\n\n### State Descriptions\n\n| State | Action | Signal Value | Persisted | Description |\n|-------|--------|--------------|-----------|-------------|\n| `idle` | `\"idle\"` | `null` | No | No active signal exists |\n| `scheduled` | `\"scheduled\"` | `IScheduledSignalRow` | Yes (Schedule) | Waiting for `priceOpen` |\n| `opened` | `\"opened\"` | `ISignalRow` | Yes (Signal) | Just activated |\n| `active` | `\"active\"` | `ISignalRow` | Yes (Signal) | Monitoring TP/SL |\n| `closed` | `\"closed\"` | `ISignalRow` | No | Completed with PNL |\n| `cancelled` | `\"cancelled\"` | `IScheduledSignalRow` | No | Scheduled signal expired |\n\n**Critical Constraint:** Only ONE active signal per symbol at any time. New signals wait until current signal closes.\n\n**Sources:** [types.d.ts:768-883](), [src/client/ClientStrategy.ts:554-1500]()\n\n---\n\n## Validation Pipeline\n\n### Seven-Stage Validation\n\nAll signals pass through comprehensive validation before activation:\n\n```mermaid\ngraph TB\n    Start[\"Signal from getSignal()\"] --> Stage1[\"Stage 1: Schema Check\"]\n    Stage1 --> Stage2[\"Stage 2: Positive Prices\"]\n    Stage2 --> Stage3[\"Stage 3: TP/SL Logic\"]\n    Stage3 --> Stage4[\"Stage 4: TP Distance\"]\n    Stage4 --> Stage5[\"Stage 5: SL Range\"]\n    Stage5 --> Stage6[\"Stage 6: Lifetime\"]\n    Stage6 --> Stage7[\"Stage 7: Risk Validation\"]\n    \n    Stage7 --> Pass[\"Validation Passed\"]\n    \n    Stage1 --> Fail[\"Validation Failed\"]\n    Stage2 --> Fail\n    Stage3 --> Fail\n    Stage4 --> Fail\n    Stage5 --> Fail\n    Stage6 --> Fail\n    Stage7 --> Fail\n    \n    Fail --> Reject[\"Signal Rejected\"]\n    Pass --> CreateSignal[\"Create ISignalRow\"]\n```\n\n**Sources:** [src/client/ClientStrategy.ts:45-330](), [src/config/params.ts:1-110]()\n\n### Stage Details\n\n#### Stage 1: Schema Validation\n\nChecks all required fields exist and have correct types:\n- `id`, `position`, `priceOpen`, `priceTakeProfit`, `priceStopLoss`\n- `exchangeName`, `strategyName`, `symbol`, `scheduledAt`, `pendingAt`\n- `minuteEstimatedTime`, `_isScheduled`\n\n```typescript\n// Example failure\nif (signal.position !== \"long\" && signal.position !== \"short\") {\n  throw new Error(`position must be \"long\" or \"short\", got \"${signal.position}\"`);\n}\n```\n\n**Sources:** [src/client/ClientStrategy.ts:48-69]()\n\n#### Stage 2: Positive Price Check\n\nEnsures all prices are finite, positive numbers (prevents NaN/Infinity):\n\n```typescript\nif (!isFinite(currentPrice) || currentPrice <= 0) {\n  errors.push(`currentPrice must be positive, got ${currentPrice}`);\n}\n```\n\n**Sources:** [src/client/ClientStrategy.ts:72-109]()\n\n#### Stage 3: TP/SL Logic Validation\n\nValidates take profit and stop loss relative to position direction:\n\n**LONG Position:**\n- `priceTakeProfit > priceOpen > priceStopLoss`\n- Current price must be between SL and TP (prevents immediate closure)\n\n**SHORT Position:**\n- `priceStopLoss > priceOpen > priceTakeProfit`\n- Current price must be between TP and SL (prevents immediate closure)\n\n```typescript\n// LONG validation\nif (signal.position === \"long\") {\n  if (signal.priceTakeProfit <= signal.priceOpen) {\n    errors.push(`Long: priceTakeProfit (${signal.priceTakeProfit}) must be > priceOpen (${signal.priceOpen})`);\n  }\n  if (currentPrice <= signal.priceStopLoss) {\n    errors.push(`Long immediate: currentPrice (${currentPrice}) <= priceStopLoss. Signal would be immediately closed.`);\n  }\n}\n```\n\n**Sources:** [src/client/ClientStrategy.ts:111-250]()\n\n#### Stage 4: Minimum TP Distance\n\nEnforces `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` (default 0.5%) to ensure profits cover fees and slippage:\n\n**Cost Breakdown:**\n- Entry slippage: 0.1%\n- Entry fee: 0.1%\n- Exit slippage: 0.1%\n- Exit fee: 0.1%\n- **Total costs: 0.4%**\n- Minimum buffer: 0.1%\n- **Required TP distance: 0.5%**\n\n```typescript\nconst tpDistancePercent = ((signal.priceTakeProfit - signal.priceOpen) / signal.priceOpen) * 100;\nif (tpDistancePercent < GLOBAL_CONFIG.CC_MIN_TAKEPROFIT_DISTANCE_PERCENT) {\n  errors.push(`Long: TakeProfit too close (${tpDistancePercent.toFixed(3)}%). Minimum: ${GLOBAL_CONFIG.CC_MIN_TAKEPROFIT_DISTANCE_PERCENT}%`);\n}\n```\n\n**Sources:** [src/client/ClientStrategy.ts:163-173](), [src/config/params.ts:27-36]()\n\n#### Stage 5: SL Range Validation\n\nEnforces both minimum and maximum SL distances:\n\n**Minimum SL Distance** (`CC_MIN_STOPLOSS_DISTANCE_PERCENT`, default 0.5%):\n- Prevents instant stop-out from normal market volatility\n\n**Maximum SL Distance** (`CC_MAX_STOPLOSS_DISTANCE_PERCENT`, default 20%):\n- Prevents catastrophic losses from extreme SL values\n\n```typescript\nconst slDistancePercent = ((signal.priceOpen - signal.priceStopLoss) / signal.priceOpen) * 100;\nif (slDistancePercent < GLOBAL_CONFIG.CC_MIN_STOPLOSS_DISTANCE_PERCENT) {\n  errors.push(`Long: StopLoss too close (${slDistancePercent.toFixed(3)}%)`);\n}\nif (slDistancePercent > GLOBAL_CONFIG.CC_MAX_STOPLOSS_DISTANCE_PERCENT) {\n  errors.push(`Long: StopLoss too far (${slDistancePercent.toFixed(3)}%)`);\n}\n```\n\n**Sources:** [src/client/ClientStrategy.ts:176-199](), [src/config/params.ts:38-49]()\n\n#### Stage 6: Lifetime Limit\n\nEnforces `CC_MAX_SIGNAL_LIFETIME_MINUTES` (default 1440 minutes = 1 day):\n\nPrevents \"eternal signals\" that block risk limits indefinitely:\n\n```typescript\nif (signal.minuteEstimatedTime > GLOBAL_CONFIG.CC_MAX_SIGNAL_LIFETIME_MINUTES) {\n  const days = (signal.minuteEstimatedTime / 60 / 24).toFixed(1);\n  const maxDays = (GLOBAL_CONFIG.CC_MAX_SIGNAL_LIFETIME_MINUTES / 60 / 24).toFixed(0);\n  errors.push(`minuteEstimatedTime too large (${signal.minuteEstimatedTime} minutes = ${days} days). Maximum: ${maxDays} days`);\n}\n```\n\n**Sources:** [src/client/ClientStrategy.ts:306-315](), [src/config/params.ts:51-55]()\n\n#### Stage 7: Risk Validation\n\nCalls `IRisk.checkSignal()` with portfolio context:\n\n```typescript\nconst riskPassed = await self.params.risk.checkSignal({\n  pendingSignal: signal,\n  symbol: self.params.execution.context.symbol,\n  strategyName: self.params.method.context.strategyName,\n  exchangeName: self.params.method.context.exchangeName,\n  currentPrice,\n  timestamp: currentTime,\n});\nif (!riskPassed) {\n  return null; // Signal rejected\n}\n```\n\n**Sources:** [src/client/ClientStrategy.ts:374-386](), [types.d.ts:339-397]()\n\n---\n\n## State Transitions in Detail\n\n### Immediate vs Scheduled Signals\n\nWhen `getSignal()` returns a signal, the framework determines activation path:\n\n```mermaid\ngraph TD\n    GetSignal[\"getSignal() returns ISignalDto\"] --> CheckPriceOpen{\"priceOpen specified?\"}\n    \n    CheckPriceOpen -->|No| Immediate[\"Immediate Signal\"]\n    CheckPriceOpen -->|Yes| CheckReached{\"Price reached priceOpen?\"}\n    \n    CheckReached -->|Yes| Immediate\n    CheckReached -->|No| Scheduled[\"Scheduled Signal\"]\n    \n    Immediate --> SetPriceOpen[\"priceOpen = currentPrice\"]\n    SetPriceOpen --> Validate[\"Run 7-stage validation\"]\n    \n    Scheduled --> ValidateScheduled[\"Run 7-stage validation<br/>(scheduled=true)\"]\n    \n    Validate --> CreateImmediate[\"Create ISignalRow<br/>_isScheduled=false<br/>pendingAt=currentTime\"]\n    ValidateScheduled --> CreateScheduled[\"Create IScheduledSignalRow<br/>_isScheduled=true<br/>pendingAt=scheduledAt\"]\n    \n    CreateImmediate --> Persist[\"Persist to PersistSignalAdapter\"]\n    CreateScheduled --> PersistSchedule[\"Persist to PersistScheduleAdapter\"]\n```\n\n**LONG Position Activation Logic:**\n```typescript\n// LONG = buy lower, wait for price to drop TO priceOpen\nif (signal.position === \"long\" && currentPrice <= signal.priceOpen) {\n  shouldActivateImmediately = true;\n}\n```\n\n**SHORT Position Activation Logic:**\n```typescript\n// SHORT = sell higher, wait for price to rise TO priceOpen\nif (signal.position === \"short\" && currentPrice >= signal.priceOpen) {\n  shouldActivateImmediately = true;\n}\n```\n\n**Sources:** [src/client/ClientStrategy.ts:389-461](), [src/lib/services/connection/StrategyConnectionService.ts:120-151]()\n\n### Scheduled Signal Monitoring\n\nScheduled signals are monitored every tick for three conditions:\n\n```mermaid\nstateDiagram-v2\n    [*] --> Scheduled\n    \n    Scheduled --> CheckTimeout: \"Every tick\"\n    CheckTimeout --> CheckSL: \"Not timed out\"\n    CheckTimeout --> Cancelled: \"CC_SCHEDULE_AWAIT_MINUTES exceeded\"\n    \n    CheckSL --> CheckActivation: \"SL not breached\"\n    CheckSL --> Cancelled: \"SL breached (critical check first)\"\n    \n    CheckActivation --> Opened: \"priceOpen reached\"\n    CheckActivation --> Scheduled: \"priceOpen not reached\"\n    \n    Opened --> [*]\n    Cancelled --> [*]\n```\n\n**Critical Order:** SL check BEFORE activation check prevents \"open-and-immediately-stop\" scenarios.\n\n**LONG Scheduled Monitoring:**\n```typescript\n// Priority 1: Check StopLoss (CANCELLATION)\nif (currentPrice <= scheduled.priceStopLoss) {\n  shouldCancel = true;\n}\n// Priority 2: Check Activation (only if SL not breached)\nelse if (currentPrice <= scheduled.priceOpen) {\n  shouldActivate = true;\n}\n```\n\n**SHORT Scheduled Monitoring:**\n```typescript\n// Priority 1: Check StopLoss (CANCELLATION)\nif (currentPrice >= scheduled.priceStopLoss) {\n  shouldCancel = true;\n}\n// Priority 2: Check Activation (only if SL not breached)\nelse if (currentPrice >= scheduled.priceOpen) {\n  shouldActivate = true;\n}\n```\n\n**Sources:** [src/client/ClientStrategy.ts:610-644](), [src/client/ClientStrategy.ts:554-608]()\n\n### Active Signal Monitoring\n\nOnce opened, signals are monitored for three exit conditions:\n\n```mermaid\ngraph TB\n    Active[\"Active Signal\"] --> Tick[\"Every tick: Get VWAP price\"]\n    \n    Tick --> CheckTP{\"Price reached<br/>priceTakeProfit?\"}\n    Tick --> CheckSL{\"Price reached<br/>priceStopLoss?\"}\n    Tick --> CheckTime{\"Time exceeded<br/>minuteEstimatedTime?\"}\n    \n    CheckTP -->|Yes| CloseTP[\"Close: take_profit\"]\n    CheckSL -->|Yes| CloseSL[\"Close: stop_loss\"]\n    CheckTime -->|Yes| CloseTime[\"Close: time_expired\"]\n    \n    CheckTP -->|No| PartialCheck[\"Check partial profit/loss milestones\"]\n    CheckSL -->|No| PartialCheck\n    CheckTime -->|No| PartialCheck\n    \n    PartialCheck --> ContinueActive[\"Continue monitoring\"]\n    ContinueActive --> Tick\n    \n    CloseTP --> CalculatePNL[\"Calculate PNL with fees/slippage\"]\n    CloseSL --> CalculatePNL\n    CloseTime --> CalculatePNL\n    \n    CalculatePNL --> DeletePersist[\"Delete from PersistSignalAdapter\"]\n    DeletePersist --> EmitClosed[\"Emit closed event\"]\n    EmitClosed --> Idle[\"Return to idle state\"]\n```\n\n**Partial Profit/Loss Tracking:**\n\nDuring active monitoring, the framework tracks milestones:\n- Profit: 10%, 20%, 30%, ..., 100%\n- Loss: -10%, -20%, -30%, ..., -100%\n\nEach level emitted once per signal via `ClientPartial` deduplication.\n\n**Sources:** [src/client/ClientStrategy.ts:813-1130](), [types.d.ts:548-638]()\n\n---\n\n## Persistence & Crash Recovery\n\n### Persistence Strategy\n\nThe framework uses two separate persistence adapters:\n\n| Adapter | Stores | When | Purpose |\n|---------|--------|------|---------|\n| `PersistScheduleAdapter` | `IScheduledSignalRow` | Scheduled signals | Restore pending limit orders |\n| `PersistSignalAdapter` | `ISignalRow` | Opened/active signals | Restore active positions |\n\n**Critical:** Scheduled signals NOT persisted to `PersistSignalAdapter` until activation.\n\n**Sources:** [src/classes/Persist.ts](), [src/client/ClientStrategy.ts:491-552]()\n\n### Crash Recovery Flow\n\n```mermaid\nsequenceDiagram\n    participant System\n    participant ClientStrategy\n    participant PersistSignal\n    participant PersistSchedule\n    \n    System->>ClientStrategy: Initialize\n    ClientStrategy->>PersistSignal: readSignalData()\n    PersistSignal-->>ClientStrategy: ISignalRow or null\n    \n    alt Has pending signal\n        ClientStrategy->>ClientStrategy: Restore _pendingSignal\n        ClientStrategy->>ClientStrategy: Call onActive callback\n    end\n    \n    ClientStrategy->>PersistSchedule: readScheduleData()\n    PersistSchedule-->>ClientStrategy: IScheduledSignalRow or null\n    \n    alt Has scheduled signal\n        ClientStrategy->>ClientStrategy: Restore _scheduledSignal\n        ClientStrategy->>ClientStrategy: Call onSchedule callback\n    end\n    \n    ClientStrategy->>System: Ready for tick()\n```\n\n**Implementation:**\n\nThe `waitForInit()` method (called before first tick) restores state:\n\n```typescript\nasync waitForInit() {\n  if (backtest) return; // Only for live mode\n  \n  // Restore pending signal\n  const pendingSignal = await PersistSignalAdapter.readSignalData(symbol, strategyName);\n  if (pendingSignal) {\n    this._pendingSignal = pendingSignal;\n    if (callbacks?.onActive) {\n      const currentPrice = await exchange.getAveragePrice(symbol);\n      callbacks.onActive(symbol, pendingSignal, currentPrice, false);\n    }\n  }\n  \n  // Restore scheduled signal\n  const scheduledSignal = await PersistScheduleAdapter.readScheduleData(symbol, strategyName);\n  if (scheduledSignal) {\n    this._scheduledSignal = scheduledSignal;\n    if (callbacks?.onSchedule) {\n      const currentPrice = await exchange.getAveragePrice(symbol);\n      callbacks.onSchedule(symbol, scheduledSignal, currentPrice, false);\n    }\n  }\n}\n```\n\n**Atomic Write Operations:**\n\nAll persistence operations are atomic (write-delete patterns):\n\n1. **Signal Opens:** Write to `PersistSignalAdapter`\n2. **Signal Closes:** Delete from `PersistSignalAdapter`\n3. **Scheduled Created:** Write to `PersistScheduleAdapter`\n4. **Scheduled Activates:** Delete from `PersistScheduleAdapter` → Write to `PersistSignalAdapter`\n5. **Scheduled Cancels:** Delete from `PersistScheduleAdapter`\n\n**Sources:** [src/client/ClientStrategy.ts:491-552](), [src/classes/Persist.ts]()\n\n---\n\n## Practical Examples\n\n### Example 1: Immediate LONG Signal\n\n```typescript\n// User's getSignal() returns:\n{\n  position: \"long\",\n  priceTakeProfit: 51000,  // 2% profit target\n  priceStopLoss: 49000,    // 2% risk\n  minuteEstimatedTime: 120 // 2 hours max\n  // priceOpen omitted → immediate entry\n}\n\n// System behavior:\n// 1. Current price: 50000 (VWAP)\n// 2. Set priceOpen = 50000\n// 3. Validate:\n//    - TP distance: (51000-50000)/50000 = 2% ✓ (>0.5% minimum)\n//    - SL distance: (50000-49000)/50000 = 2% ✓ (between 0.5%-20%)\n// 4. Create ISignalRow with _isScheduled=false\n// 5. Persist to PersistSignalAdapter\n// 6. Emit \"opened\" event\n// 7. Monitor for TP/SL/time_expired\n```\n\n**Sources:** [src/client/ClientStrategy.ts:445-461](), [test/e2e/sequence.test.mjs:29-150]()\n\n### Example 2: Scheduled SHORT Signal\n\n```typescript\n// User's getSignal() returns:\n{\n  position: \"short\",\n  priceOpen: 51000,        // Wait for price to rise to 51000\n  priceTakeProfit: 49000,  // Exit at 49000 (profit)\n  priceStopLoss: 52000,    // Exit at 52000 (loss)\n  minuteEstimatedTime: 60\n}\n\n// Current price: 50000 (below priceOpen)\n\n// System behavior:\n// 1. Price 50000 < priceOpen 51000 → Create scheduled signal\n// 2. Validate with scheduled=true\n// 3. Create IScheduledSignalRow with _isScheduled=true\n// 4. Persist to PersistScheduleAdapter\n// 5. Emit \"scheduled\" event\n// 6. Monitor every tick:\n//    - If price >= 52000 (SL) → Cancel\n//    - If price >= 51000 (priceOpen) → Activate\n// 7. On activation:\n//    - Delete from PersistScheduleAdapter\n//    - Create ISignalRow\n//    - Persist to PersistSignalAdapter\n//    - Emit \"opened\" event\n```\n\n**Sources:** [src/client/ClientStrategy.ts:389-442](), [test/e2e/scheduled.test.mjs]()\n\n### Example 3: Scheduled Signal Cancellation\n\n```typescript\n// Scheduled LONG signal:\n{\n  position: \"long\",\n  priceOpen: 49000,        // Wait for price drop\n  priceTakeProfit: 51000,\n  priceStopLoss: 48000,    // Cancel if price drops too far\n  minuteEstimatedTime: 30\n}\n\n// Current price: 50000 (above priceOpen)\n\n// Cancellation scenarios:\n\n// Scenario A: Price drops PAST stop loss\n// Tick 1: price=50000 → scheduled (waiting)\n// Tick 2: price=49500 → scheduled (waiting)\n// Tick 3: price=47500 → CANCELLED (SL=48000 breached before priceOpen reached)\n\n// Scenario B: Timeout\n// Price stays above 49000 for 120 minutes (CC_SCHEDULE_AWAIT_MINUTES)\n// → CANCELLED (exceeded wait time)\n```\n\n**Sources:** [src/client/ClientStrategy.ts:554-608](), [test/e2e/edge.test.mjs:24-100]()\n\n### Example 4: Validation Failure - Micro-Profit\n\n```typescript\n// User returns signal with tiny profit margin:\n{\n  position: \"long\",\n  priceOpen: 42000,\n  priceTakeProfit: 42010,  // Only 0.024% profit!\n  priceStopLoss: 41000,\n  minuteEstimatedTime: 60\n}\n\n// Validation fails at Stage 4:\n// TP distance: (42010-42000)/42000 = 0.024%\n// Minimum required: 0.5% (to cover 0.4% fees/slippage + 0.1% buffer)\n// Error: \"Long: TakeProfit too close to priceOpen (0.024%). Minimum distance: 0.5%\"\n// Signal rejected, no position opened\n```\n\n**Sources:** [src/client/ClientStrategy.ts:163-173](), [test/e2e/sanitize.test.mjs:27-150]()\n\n---\n\n## Signal Sequencing Constraint\n\n**Critical Design Principle:** Only ONE active signal per symbol at any time.\n\n### Queue Behavior\n\n```mermaid\ngraph TB\n    subgraph \"Time T1\"\n        S1_Gen[\"Signal #1 generated\"]\n        S1_Gen --> S1_Open[\"Signal #1 opens\"]\n    end\n    \n    subgraph \"Time T2 (while Signal #1 active)\"\n        S2_Gen[\"getSignal() called\"]\n        S2_Gen --> S2_Block[\"Signal #2 NOT processed\"]\n        S2_Block --> S2_Wait[\"Waits for Signal #1 to close\"]\n    end\n    \n    subgraph \"Time T3\"\n        S1_Close[\"Signal #1 closes (TP/SL/time)\"]\n        S1_Close --> S1_Idle[\"Returns to idle state\"]\n    end\n    \n    subgraph \"Time T4\"\n        S2_Gen2[\"getSignal() called again\"]\n        S2_Gen2 --> S2_Process[\"Signal #2 now processed\"]\n    end\n```\n\n**Rationale:**\n- Prevents position size explosions\n- Maintains predictable risk exposure\n- Simplifies state management\n- Enables reliable crash recovery\n\n**Implementation:** The `tick()` method checks for active signal before calling `getSignal()`:\n\n```typescript\nasync tick() {\n  // Check for existing active signal\n  if (this._pendingSignal) {\n    return monitorActiveSignal();\n  }\n  if (this._scheduledSignal) {\n    return monitorScheduledSignal();\n  }\n  \n  // Only call getSignal() when idle\n  const newSignal = await GET_SIGNAL_FN(this);\n  if (!newSignal) {\n    return idleResult();\n  }\n  \n  return processNewSignal(newSignal);\n}\n```\n\n**Sources:** [src/client/ClientStrategy.ts:813-1130](), [test/README.md:19-23]()"
                    },
                    {
                        "page_plan": {
                            "id": "3.2",
                            "title": "Strategies"
                        },
                        "content": "# Strategies\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [docs/classes/StrategyConnectionService.md](docs/classes/StrategyConnectionService.md)\n- [docs/index.md](docs/index.md)\n- [docs/interfaces/IStrategy.md](docs/interfaces/IStrategy.md)\n- [docs/interfaces/IStrategySchema.md](docs/interfaces/IStrategySchema.md)\n- [docs/types/IStrategyBacktestResult.md](docs/types/IStrategyBacktestResult.md)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document explains what strategies are in Backtest Kit, how they generate trading signals through the `getSignal` function, the `IStrategySchema` interface contract, and how strategies integrate with the execution engine. For implementation details about writing strategies, see [Strategy Development](#6). For information about the signals themselves and their lifecycle states, see [Signals & Signal Lifecycle](#3.1). For the execution context that strategies operate within, see [Execution Contexts](#3.3).\n\n---\n\n## What is a Strategy?\n\nA **strategy** is a registered algorithm that evaluates market conditions at regular intervals and produces trading signals. Each strategy is uniquely identified by a `strategyName` and implements a `getSignal` function that returns either a signal to execute or `null` if no trading opportunity exists.\n\nStrategies are stateless algorithms—they do not maintain position tracking or manage signal lifecycle. Instead, they focus solely on signal generation logic. The framework handles signal validation, persistence, risk management, and lifecycle transitions automatically.\n\n**Key Characteristics:**\n\n| Characteristic | Description |\n|---------------|-------------|\n| **Stateless** | No internal position tracking; each `getSignal` call is independent |\n| **Throttled** | `getSignal` is rate-limited by the `interval` parameter (e.g., 5m, 1h) |\n| **Single Signal** | Only one active signal per symbol-strategy pair at a time |\n| **Mode-Agnostic** | Same code executes in backtest and live modes via temporal context |\n| **Risk-Aware** | Optional `riskName` or `riskList` for portfolio-level validation |\n\nSources: [types.d.ts:728-747]()\n\n---\n\n## IStrategySchema Interface\n\nStrategies are registered using the `addStrategy()` global function with an `IStrategySchema` object. This interface defines the strategy's identity, signal generation logic, and optional configuration.\n\n### Core Fields\n\n```typescript\ninterface IStrategySchema {\n    strategyName: StrategyName;        // Unique identifier\n    interval: SignalInterval;          // Throttling interval\n    getSignal: (symbol: string, when: Date) => Promise<ISignalDto | null>;\n    note?: string;                     // Optional description\n    callbacks?: Partial<IStrategyCallbacks>;\n    riskName?: RiskName;               // Single risk profile\n    riskList?: RiskName[];             // Multiple risk profiles\n}\n```\n\n### Field Descriptions\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `strategyName` | `string` | Yes | Unique identifier used throughout the system for routing and reporting |\n| `interval` | `SignalInterval` | Yes | Minimum time between `getSignal` calls: `1m`, `3m`, `5m`, `15m`, `30m`, `1h` |\n| `getSignal` | `Function` | Yes | Core signal generation function; returns `ISignalDto` or `null` |\n| `note` | `string` | No | Human-readable description for documentation purposes |\n| `callbacks` | `IStrategyCallbacks` | No | Lifecycle event hooks (see section below) |\n| `riskName` | `RiskName` | No | Single risk profile for validation (mutually exclusive with `riskList`) |\n| `riskList` | `RiskName[]` | No | Multiple risk profiles; all must pass validation |\n\nSources: [types.d.ts:728-747](), [src/index.ts:79-88]()\n\n---\n\n## The getSignal Function Contract\n\nThe `getSignal` function is the heart of every strategy. It receives execution context implicitly through `ExecutionContextService` and must return either a valid signal DTO or `null`.\n\n### Function Signature\n\n```typescript\ngetSignal: (symbol: string, when: Date) => Promise<ISignalDto | null>\n```\n\n### Parameters\n\n- **`symbol`**: Trading pair (e.g., `\"BTCUSDT\"`) passed explicitly\n- **`when`**: Current timestamp in backtest mode or real-time in live mode; determines the temporal boundary for data access\n\n### Return Value: ISignalDto\n\nWhen a trading opportunity exists, `getSignal` returns an `ISignalDto` object:\n\n```typescript\ninterface ISignalDto {\n    id?: string;                    // Auto-generated UUID if omitted\n    position: \"long\" | \"short\";     // Trade direction\n    note?: string;                  // Human-readable reason\n    priceOpen?: number;             // Entry price (optional for scheduled signals)\n    priceTakeProfit: number;        // TP target (required)\n    priceStopLoss: number;          // SL exit (required)\n    minuteEstimatedTime: number;    // Expected duration before time_expired\n}\n```\n\n**Signal Types:**\n\n| Condition | Signal Type | Behavior |\n|-----------|------------|----------|\n| `priceOpen` omitted | **Immediate Signal** | Opens at current VWAP; enters \"opened\" state immediately |\n| `priceOpen` specified | **Scheduled Signal** | Waits for price to reach `priceOpen`; enters \"scheduled\" state |\n\n### Null Return\n\nWhen no trading opportunity exists, `getSignal` returns `null`. This is the normal case when market conditions don't meet strategy criteria. The framework handles this gracefully by transitioning to \"idle\" state and emitting an `IStrategyTickResultIdle` event.\n\nSources: [types.d.ts:649-665](), [types.d.ts:728-747]()\n\n---\n\n## Strategy Architecture Diagram\n\nThis diagram shows the relationship between strategy components from registration to execution:\n\n```mermaid\ngraph TB\n    subgraph \"Registration Layer\"\n        AddStrategy[\"addStrategy()\"]\n        Schema[\"IStrategySchema<br/>- strategyName<br/>- interval<br/>- getSignal<br/>- riskName/riskList<br/>- callbacks\"]\n    end\n    \n    subgraph \"Schema Storage\"\n        SchemaService[\"StrategySchemaService<br/>ToolRegistry pattern<br/>Immutable storage\"]\n    end\n    \n    subgraph \"Execution Routing\"\n        ConnectionService[\"StrategyConnectionService<br/>Memoized ClientStrategy<br/>instances by symbol:strategyName\"]\n        CoreService[\"StrategyCoreService<br/>Orchestrates tick/backtest<br/>operations\"]\n    end\n    \n    subgraph \"Strategy Implementation\"\n        ClientStrategy[\"ClientStrategy<br/>- tick() method<br/>- backtest() method<br/>- Signal state machine\"]\n    end\n    \n    subgraph \"Signal Generation\"\n        GetSignal[\"getSignal(symbol, when)<br/>User-defined logic\"]\n        VWAP[\"VWAP Pricing<br/>Last 5 1-min candles\"]\n        Context[\"ExecutionContextService<br/>Temporal boundary\"]\n    end\n    \n    subgraph \"Validation & Risk\"\n        Validator[\"Signal Validation<br/>TP/SL logic<br/>GLOBAL_CONFIG\"]\n        RiskCheck[\"Risk Validation<br/>ClientRisk.checkSignal()\"]\n    end\n    \n    subgraph \"Output\"\n        Result[\"IStrategyTickResult<br/>idle | scheduled |<br/>opened | active |<br/>closed | cancelled\"]\n    end\n    \n    AddStrategy --> Schema\n    Schema --> SchemaService\n    SchemaService --> ConnectionService\n    ConnectionService --> ClientStrategy\n    CoreService --> ConnectionService\n    ClientStrategy --> GetSignal\n    GetSignal --> Context\n    GetSignal --> VWAP\n    GetSignal --> Validator\n    Validator --> RiskCheck\n    RiskCheck --> Result\n    \n    style GetSignal fill:#ffe1e1,stroke:#cc0000,stroke-width:2px\n    style ClientStrategy fill:#e1f5ff,stroke:#0066cc,stroke-width:2px\n    style Result fill:#c8e6c9,stroke:#388e3c,stroke-width:2px\n```\n\n**Execution Flow:**\n\n1. Developer calls `addStrategy()` with `IStrategySchema`\n2. `StrategySchemaService` stores schema in immutable registry\n3. On execution, `StrategyConnectionService` routes to cached `ClientStrategy` instance\n4. `ClientStrategy.tick()` or `ClientStrategy.backtest()` invokes `getSignal`\n5. `getSignal` accesses candles via `getCandles()` (respects temporal context)\n6. Returned `ISignalDto` passes through validation pipeline\n7. Risk validation checks portfolio constraints\n8. Final `IStrategyTickResult` emits to event system\n\nSources: [types.d.ts:728-747](), [docs/classes/StrategyConnectionService.md:1-145](), [src/function/add.ts]()\n\n---\n\n## Signal Generation Flow\n\nThis diagram details the `getSignal` execution process and decision points:\n\n```mermaid\ngraph TD\n    Start[\"Strategy tick triggered<br/>by BacktestLogicPrivateService<br/>or LiveLogicPrivateService\"]\n    \n    Throttle{Interval throttle<br/>check}\n    Skip[\"Return previous state<br/>Continue monitoring\"]\n    \n    NoSignal[\"Has active<br/>pending signal?\"]\n    Monitor[\"Monitor TP/SL/time<br/>Return active state\"]\n    \n    CallGetSignal[\"Invoke getSignal(symbol, when)<br/>User-defined logic\"]\n    \n    ReturnNull{Returns null?}\n    Idle[\"Return IStrategyTickResultIdle<br/>action: 'idle'\"]\n    \n    ValidateDTO[\"Validate ISignalDto<br/>- Prices > 0<br/>- TP/SL logic correct<br/>- Distance thresholds<br/>- Lifetime limits\"]\n    \n    ValidationFail{Validation<br/>passes?}\n    Reject[\"Log error<br/>Emit errorEmitter<br/>Return idle\"]\n    \n    RiskCheck[\"Call ClientRisk.checkSignal()<br/>Portfolio limits<br/>Custom validations\"]\n    \n    RiskFail{Risk<br/>allowed?}\n    RiskReject[\"Emit riskSubject<br/>Return idle\"]\n    \n    PriceOpenCheck{priceOpen<br/>specified?}\n    \n    Scheduled[\"Create IScheduledSignalRow<br/>Return IStrategyTickResultScheduled<br/>action: 'scheduled'\"]\n    \n    Opened[\"Create ISignalRow<br/>Persist to storage<br/>Return IStrategyTickResultOpened<br/>action: 'opened'\"]\n    \n    Start --> Throttle\n    Throttle -->|Not elapsed| Skip\n    Throttle -->|Elapsed| NoSignal\n    NoSignal -->|Yes| Monitor\n    NoSignal -->|No| CallGetSignal\n    CallGetSignal --> ReturnNull\n    ReturnNull -->|Yes| Idle\n    ReturnNull -->|No| ValidateDTO\n    ValidateDTO --> ValidationFail\n    ValidationFail -->|No| Reject\n    ValidationFail -->|Yes| RiskCheck\n    RiskCheck --> RiskFail\n    RiskFail -->|No| RiskReject\n    RiskFail -->|Yes| PriceOpenCheck\n    PriceOpenCheck -->|Yes| Scheduled\n    PriceOpenCheck -->|No| Opened\n    \n    style CallGetSignal fill:#ffe1e1,stroke:#cc0000,stroke-width:2px\n    style Opened fill:#c8e6c9,stroke:#388e3c,stroke-width:2px\n    style Scheduled fill:#fff3cd,stroke:#856404,stroke-width:2px\n```\n\n**Key Decision Points:**\n\n1. **Throttle Check**: Prevents `getSignal` from executing more frequently than `interval` allows\n2. **Active Signal Check**: Only generates new signals when no active position exists\n3. **Null Return**: Normal case when no trading opportunity; returns to idle\n4. **Validation**: Multi-stage checks enforced by `GLOBAL_CONFIG` parameters\n5. **Risk Validation**: Portfolio-level constraints from `ClientRisk`\n6. **priceOpen Logic**: Determines immediate vs. scheduled signal behavior\n\nSources: [types.d.ts:728-747](), [types.d.ts:649-665]()\n\n---\n\n## Strategy Lifecycle Callbacks\n\nThe optional `callbacks` field in `IStrategySchema` provides hooks into signal lifecycle events. All callbacks are optional; the framework emits events to global emitters regardless.\n\n### IStrategyCallbacks Interface\n\n```typescript\ninterface IStrategyCallbacks {\n    onTick: (symbol: string, result: IStrategyTickResult, backtest: boolean) => void;\n    onOpen: (symbol: string, data: ISignalRow, currentPrice: number, backtest: boolean) => void;\n    onActive: (symbol: string, data: ISignalRow, currentPrice: number, backtest: boolean) => void;\n    onIdle: (symbol: string, currentPrice: number, backtest: boolean) => void;\n    onClose: (symbol: string, data: ISignalRow, priceClose: number, backtest: boolean) => void;\n    onSchedule: (symbol: string, data: IScheduledSignalRow, currentPrice: number, backtest: boolean) => void;\n    onCancel: (symbol: string, data: IScheduledSignalRow, currentPrice: number, backtest: boolean) => void;\n    onWrite: (symbol: string, data: ISignalRow | null, backtest: boolean) => void;\n    onPartialProfit: (symbol: string, data: ISignalRow, currentPrice: number, revenuePercent: number, backtest: boolean) => void;\n    onPartialLoss: (symbol: string, data: ISignalRow, currentPrice: number, lossPercent: number, backtest: boolean) => void;\n}\n```\n\n### Callback Descriptions\n\n| Callback | Trigger | Use Case |\n|----------|---------|----------|\n| `onTick` | Every tick execution | Generic monitoring of all strategy states |\n| `onOpen` | Signal opens at `priceOpen` | Position entry confirmation, logging |\n| `onActive` | Signal monitoring (TP/SL tracking) | Real-time P&L tracking, alerts |\n| `onIdle` | No active signal | Strategy dormancy monitoring |\n| `onClose` | Signal closes (TP/SL/time) | Position exit analysis, statistics |\n| `onSchedule` | Scheduled signal created | Pending order notifications |\n| `onCancel` | Scheduled signal cancelled | Alert when limit orders don't activate |\n| `onWrite` | Signal persisted to storage | Testing persistence layer |\n| `onPartialProfit` | Profit milestone (10%, 20%...) | Trail stop adjustments, partial exits |\n| `onPartialLoss` | Loss milestone (-10%, -20%...) | Risk management alerts |\n\n**Important Notes:**\n\n- Callbacks execute **in addition to** global event emitters (e.g., `signalEmitter`, `partialProfitSubject`)\n- All callbacks receive `backtest` boolean to distinguish execution mode\n- Callbacks are synchronous; avoid blocking operations\n\nSources: [types.d.ts:699-723]()\n\n---\n\n## Interval Throttling\n\nThe `interval` field prevents `getSignal` from executing too frequently, reducing computational overhead and preventing signal spam.\n\n### Available Intervals\n\n```typescript\ntype SignalInterval = \"1m\" | \"3m\" | \"5m\" | \"15m\" | \"30m\" | \"1h\";\n```\n\n### Throttling Behavior\n\n| Interval | Backtest Behavior | Live Behavior |\n|----------|------------------|---------------|\n| `1m` | Evaluates every backtest frame (typically 1-minute) | Evaluates every live tick (~1 minute) |\n| `5m` | Evaluates every 5th frame; skips intermediate frames | Evaluates every 5 minutes |\n| `1h` | Evaluates every 60th frame | Evaluates hourly |\n\n**Implementation:**\n\nThrottling is enforced in `ClientStrategy.tick()` by comparing current timestamp against last `getSignal` execution time. If insufficient time has elapsed, the strategy returns its current state without invoking `getSignal`.\n\n**Choosing an Interval:**\n\n- **Lower intervals (1m, 5m)**: Higher responsiveness, more computation\n- **Higher intervals (30m, 1h)**: Suitable for swing strategies, reduces noise\n- **Recommendation**: Match interval to strategy timeframe; a strategy analyzing hourly candles should use `1h` interval\n\nSources: [types.d.ts:643-645](), [types.d.ts:728-747]()\n\n---\n\n## Risk Integration\n\nStrategies can integrate with the risk management system by specifying `riskName` (single risk profile) or `riskList` (multiple profiles). These fields are mutually exclusive.\n\n### Single Risk Profile\n\n```typescript\naddStrategy({\n    strategyName: \"momentum-strategy\",\n    riskName: \"conservative\",  // References addRisk({ riskName: \"conservative\", ... })\n    // ... other fields\n});\n```\n\nThe specified risk profile validates signals before they activate. If validation fails, the signal is rejected and `riskSubject` emits an event.\n\n### Multiple Risk Profiles\n\n```typescript\naddStrategy({\n    strategyName: \"high-risk-strategy\",\n    riskList: [\"max-position-limit\", \"correlation-check\", \"volatility-filter\"],\n    // ... other fields\n});\n```\n\nAll risk profiles in `riskList` must pass validation. If any validation fails, the signal is rejected.\n\n### Risk Validation Flow\n\n```mermaid\ngraph LR\n    Signal[\"getSignal returns<br/>ISignalDto\"]\n    \n    HasRisk{riskName or<br/>riskList present?}\n    \n    GetRisk[\"Resolve risk profiles<br/>via RiskConnectionService\"]\n    \n    Validate[\"ClientRisk.checkSignal()<br/>or MergeRisk for multiple\"]\n    \n    AllPass{All validations<br/>pass?}\n    \n    Accept[\"Signal proceeds<br/>to open/schedule\"]\n    \n    Reject[\"Signal rejected<br/>Emit riskSubject<br/>Return idle\"]\n    \n    NoRisk[\"Skip risk validation<br/>Signal proceeds\"]\n    \n    Signal --> HasRisk\n    HasRisk -->|No| NoRisk\n    HasRisk -->|Yes| GetRisk\n    GetRisk --> Validate\n    Validate --> AllPass\n    AllPass -->|Yes| Accept\n    AllPass -->|No| Reject\n    \n    style Reject fill:#ffcccc,stroke:#cc0000,stroke-width:2px\n    style Accept fill:#ccffcc,stroke:#00cc00,stroke-width:2px\n```\n\n**Risk Validation Context:**\n\nThe `IRiskCheckArgs` passed to risk validations includes:\n\n- `symbol`: Trading pair\n- `pendingSignal`: The signal being validated\n- `strategyName`: Strategy attempting to open position\n- `exchangeName`: Exchange for execution\n- `currentPrice`: Current VWAP\n- `timestamp`: Current time\n\nRisk profiles access additional portfolio state via `IRiskValidationPayload`:\n\n- `activePositionCount`: Total open positions across all strategies\n- `activePositions`: List of active signals with metadata\n\nSources: [types.d.ts:728-747](), [types.d.ts:413-426](), [types.d.ts:339-356]()\n\n---\n\n## Strategy Execution Model\n\nStrategies execute differently depending on the mode (backtest vs. live) but use the same `getSignal` logic.\n\n### Backtest Mode Execution\n\n**Flow:**\n\n1. `BacktestLogicPrivateService` generates timeframe array from `IFrameSchema`\n2. For each timestamp, `StrategyCoreService` invokes `ClientStrategy.tick()`\n3. `ClientStrategy.tick()` checks throttling, calls `getSignal` if allowed\n4. If signal opens, `ClientStrategy.backtest()` is called with future candles\n5. `backtest()` iterates through candles, checking TP/SL on each candle\n6. Once signal closes, iteration continues to next timeframe\n\n**Optimization:**\n\nThe \"fast backtest\" optimization skips timeframes while a signal is active, jumping directly to candles for TP/SL monitoring. This dramatically reduces iterations for long-duration signals.\n\n### Live Mode Execution\n\n**Flow:**\n\n1. `LiveLogicPrivateService` enters infinite loop with `sleep(TICK_TTL)`\n2. Every ~1 minute, `StrategyCoreService` invokes `ClientStrategy.tick()`\n3. `ClientStrategy.tick()` checks throttling, calls `getSignal` if allowed\n4. If signal opens, it persists to storage for crash recovery\n5. On subsequent ticks, TP/SL monitoring continues until closure\n6. On closure, persisted signal is deleted\n\n**Persistence:**\n\nOnly \"opened\" signals persist to storage (via `PersistSignalAdapter`). Scheduled signals remain ephemeral until activation. This enables crash recovery without data bloat.\n\nSources: High-level system diagrams provided, [types.d.ts:728-747]()\n\n---\n\n## Registration and Routing Flow\n\nThis diagram traces the path from `addStrategy()` to strategy execution in both modes:\n\n```mermaid\ngraph TB\n    subgraph \"User Code\"\n        UserCode[\"Developer calls<br/>addStrategy(IStrategySchema)\"]\n    end\n    \n    subgraph \"Global Function Layer\"\n        AddStrategyFn[\"addStrategy()<br/>src/function/add.ts\"]\n    end\n    \n    subgraph \"Validation Layer\"\n        Validator[\"StrategyValidationService<br/>Check for duplicate<br/>strategyName\"]\n    end\n    \n    subgraph \"Storage Layer\"\n        SchemaService[\"StrategySchemaService<br/>ToolRegistry storage<br/>Immutable schema map\"]\n    end\n    \n    subgraph \"Execution Initiation\"\n        BacktestRun[\"Backtest.run() or<br/>Backtest.background()\"]\n        LiveRun[\"Live.run() or<br/>Live.background()\"]\n    end\n    \n    subgraph \"Context Setup\"\n        MethodCtx[\"MethodContextService.runAsyncIterator()<br/>Sets strategyName, exchangeName, frameName\"]\n        ExecCtx[\"ExecutionContextService.runInContext()<br/>Sets symbol, when, backtest flag\"]\n    end\n    \n    subgraph \"Service Orchestration\"\n        CoreService[\"StrategyCoreService.tick()<br/>Orchestrates strategy execution\"]\n        ConnectionService[\"StrategyConnectionService.tick()<br/>Routes to correct ClientStrategy\"]\n    end\n    \n    subgraph \"Strategy Instance\"\n        ClientStrategy[\"ClientStrategy.tick()<br/>Throttling, getSignal, validation\"]\n        GetSignal[\"User-defined getSignal(symbol, when)\"]\n    end\n    \n    subgraph \"Result Emission\"\n        Result[\"IStrategyTickResult<br/>Emitted to signalEmitter\"]\n    end\n    \n    UserCode --> AddStrategyFn\n    AddStrategyFn --> Validator\n    Validator --> SchemaService\n    \n    SchemaService -.->|Later referenced| BacktestRun\n    SchemaService -.->|Later referenced| LiveRun\n    \n    BacktestRun --> MethodCtx\n    LiveRun --> MethodCtx\n    \n    MethodCtx --> ExecCtx\n    ExecCtx --> CoreService\n    CoreService --> ConnectionService\n    \n    ConnectionService -->|Memoized instance| ClientStrategy\n    ClientStrategy --> GetSignal\n    GetSignal --> Result\n    \n    style GetSignal fill:#ffe1e1,stroke:#cc0000,stroke-width:2px\n    style SchemaService fill:#fff3cd,stroke:#856404,stroke-width:2px\n    style ClientStrategy fill:#e1f5ff,stroke:#0066cc,stroke-width:2px\n```\n\n**Key Components:**\n\n- **addStrategy()**: Entry point, delegates to `StrategySchemaService`\n- **StrategySchemaService**: Stores schemas in `ToolRegistry` (immutable map)\n- **StrategyValidationService**: Checks for duplicate names using memoization\n- **MethodContextService**: Propagates schema names (strategyName, exchangeName, frameName) through call stack\n- **ExecutionContextService**: Propagates runtime state (symbol, when, backtest flag)\n- **StrategyCoreService**: Top-level orchestrator, delegates to ConnectionService\n- **StrategyConnectionService**: Routes to memoized `ClientStrategy` instances by `symbol:strategyName` key\n- **ClientStrategy**: Implements `IStrategy` interface, executes `getSignal` and manages signal state machine\n\nSources: [src/function/add.ts](), [types.d.ts:728-747](), [docs/classes/StrategyConnectionService.md:1-145]()\n\n---\n\n## Code Entity Reference\n\nThis table maps conceptual strategy components to concrete code entities:\n\n| Concept | Code Entity | Location | Description |\n|---------|-------------|----------|-------------|\n| Strategy Schema | `IStrategySchema` | [types.d.ts:728-747]() | Registration interface |\n| Signal DTO | `ISignalDto` | [types.d.ts:649-665]() | Return type of `getSignal` |\n| Signal Row | `ISignalRow` | [types.d.ts:669-687]() | Augmented signal with metadata |\n| Scheduled Signal | `IScheduledSignalRow` | [types.d.ts:694-697]() | Signal awaiting price activation |\n| Tick Result | `IStrategyTickResult` | [types.d.ts:888]() | Discriminated union of all states |\n| Interval Type | `SignalInterval` | [types.d.ts:645]() | Throttling intervals |\n| Callbacks | `IStrategyCallbacks` | [types.d.ts:699-723]() | Lifecycle event hooks |\n| Registration | `addStrategy()` | [src/function/add.ts]() | Global registration function |\n| Schema Storage | `StrategySchemaService` | [docs/classes/StrategySchemaService.md]() | Immutable registry |\n| Routing | `StrategyConnectionService` | [docs/classes/StrategyConnectionService.md]() | Memoized instance routing |\n| Orchestration | `StrategyCoreService` | [docs/classes/StrategyCoreService.md]() | Top-level execution coordinator |\n| Implementation | `ClientStrategy` | [docs/classes/ClientExchange.md]() | Strategy instance with tick/backtest methods |\n| Risk Integration | `ClientRisk` | [docs/classes/ClientRisk.md]() | Signal validation |\n\nSources: [types.d.ts:728-747](), [docs/classes/StrategyConnectionService.md:1-145]()\n\n---\n\n## Summary\n\nStrategies in Backtest Kit are:\n\n1. **Registered** via `addStrategy()` with an `IStrategySchema` object\n2. **Identified** by unique `strategyName` for routing and reporting\n3. **Throttled** by `interval` to control `getSignal` execution frequency\n4. **Stateless** algorithms that generate `ISignalDto` or return `null`\n5. **Validated** through multi-stage checks (TP/SL logic, GLOBAL_CONFIG, risk profiles)\n6. **Mode-agnostic** via temporal context provided by `ExecutionContextService`\n7. **Event-driven** with optional lifecycle callbacks and global emitters\n8. **Single-signal** constrained—one active signal per symbol-strategy pair\n\nThe `getSignal` function is the core contract: it receives temporal context implicitly, accesses market data via `getCandles()`, and returns trading signals that the framework validates, persists, and monitors through completion.\n\nFor practical implementation guidance, see [Strategy Development](#6). For detailed `getSignal` patterns, see [Signal Generation (getSignal)](#6.2).\n\nSources: [types.d.ts:728-747](), [types.d.ts:649-665](), [README.md:1-255]()"
                    },
                    {
                        "page_plan": {
                            "id": "3.3",
                            "title": "Execution Contexts"
                        },
                        "content": "# Execution Contexts\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/add.ts](src/function/add.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/function/list.ts](src/function/list.ts)\n- [src/index.ts](src/index.ts)\n- [src/lib/core/provide.ts](src/lib/core/provide.ts)\n- [src/lib/core/types.ts](src/lib/core/types.ts)\n- [src/lib/index.ts](src/lib/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page explains the execution context system in backtest-kit, which provides ambient context propagation throughout the framework without explicit parameter passing. Two context types exist: **ExecutionContext** (runtime parameters like symbol, timestamp, mode) and **MethodContext** (schema routing identifiers like strategyName, exchangeName). For information about the broader service architecture that consumes these contexts, see [4.1 Service Layer & Dependency Injection](#4.1). For details on how strategies and exchanges use this context, see [3.2 Strategies](#3.2) and [8.1 Exchange Configuration](#8.1).\n\n## Overview\n\nExecution contexts solve the parameter drilling problem in deeply nested call stacks. Instead of passing `symbol`, `when`, `backtest`, `strategyName`, `exchangeName`, and `frameName` through every function call from the public API down to client implementations, these values are stored in scoped context objects that can be accessed anywhere in the call hierarchy.\n\nThe framework uses the `di-scoped` library to implement lexical scoping for context values. When a context is set using `runInContext()` or `runAsyncIterator()`, all code executed within that scope can access the context via the `.context` property without it being passed as an explicit parameter.\n\n**Sources:** [types.d.ts:5-18](), [types.d.ts:296-309]()\n\n## The Two Context Types\n\n### ExecutionContext\n\n**IExecutionContext** contains runtime parameters that change on every tick or operation:\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `symbol` | `string` | Trading pair symbol (e.g., \"BTCUSDT\") |\n| `when` | `Date` | Current timestamp for operation (historical for backtest, current for live) |\n| `backtest` | `boolean` | Execution mode: `true` for historical simulation, `false` for live trading |\n\nThe `ExecutionContext` is set at the innermost execution loop level where individual ticks are processed. It provides temporal context that prevents look-ahead bias by ensuring all operations use the correct \"current time.\"\n\n**Sources:** [types.d.ts:11-18]()\n\n### MethodContext\n\n**IMethodContext** contains schema routing identifiers that remain constant throughout an execution session:\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `exchangeName` | `ExchangeName` | Identifies which exchange schema to use for data fetching |\n| `strategyName` | `StrategyName` | Identifies which strategy schema to execute |\n| `frameName` | `FrameName` | Identifies which timeframe generator to use (empty string for live mode) |\n\nThe `MethodContext` is set at the orchestration layer (backtest/live/walker logic services) and determines which memoized client instances are retrieved from connection services.\n\n**Sources:** [types.d.ts:302-309]()\n\n## Context Services Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Context Service Definitions\"\n        IEC[\"IExecutionContext<br/>{symbol, when, backtest}\"]\n        IMC[\"IMethodContext<br/>{exchangeName, strategyName, frameName}\"]\n    end\n    \n    subgraph \"Service Instances\"\n        ECS[\"ExecutionContextService<br/>di-scoped scoped class\"]\n        MCS[\"MethodContextService<br/>di-scoped scoped class\"]\n    end\n    \n    subgraph \"DI Registration\"\n        TYPES_EC[\"TYPES.executionContextService<br/>Symbol('executionContextService')\"]\n        TYPES_MC[\"TYPES.methodContextService<br/>Symbol('methodContextService')\"]\n        PROVIDE_EC[\"provide(TYPES.executionContextService,<br/>() => new ExecutionContextService())\"]\n        PROVIDE_MC[\"provide(TYPES.methodContextService,<br/>() => new MethodContextService())\"]\n    end\n    \n    subgraph \"Exported API\"\n        LIB_EC[\"lib.executionContextService\"]\n        LIB_MC[\"lib.methodContextService\"]\n        EXPORT_EC[\"export { ExecutionContextService }\"]\n        EXPORT_MC[\"export { MethodContextService }\"]\n    end\n    \n    IEC -.->|\"defines interface for\"| ECS\n    IMC -.->|\"defines interface for\"| MCS\n    \n    ECS --> TYPES_EC\n    MCS --> TYPES_MC\n    \n    TYPES_EC --> PROVIDE_EC\n    TYPES_MC --> PROVIDE_MC\n    \n    PROVIDE_EC --> LIB_EC\n    PROVIDE_MC --> LIB_MC\n    \n    ECS --> EXPORT_EC\n    MCS --> EXPORT_MC\n```\n\n**Sources:** [src/lib/core/types.ts:5-8](), [src/lib/core/provide.ts:60-63](), [src/lib/index.ts:66-71]()\n\n## Context Propagation with di-scoped\n\nThe `di-scoped` library provides two key methods for establishing context scope:\n\n### runInContext\n\nUsed for synchronous or promise-based async operations:\n\n```typescript\nExecutionContextService.runInContext(\n  async () => {\n    // Inside this callback, context is automatically available\n    // via executionContextService.context.symbol, .when, .backtest\n    return await someOperation();\n  },\n  { symbol: \"BTCUSDT\", when: new Date(), backtest: true }\n);\n```\n\n### runAsyncIterator\n\nUsed for async generator functions (streams):\n\n```typescript\nMethodContextService.runAsyncIterator(\n  backtestGenerator,\n  {\n    strategyName: \"my-strategy\",\n    exchangeName: \"binance\",\n    frameName: \"1d-backtest\"\n  }\n);\n```\n\nThis establishes context for the entire generator lifetime, allowing all yielded values to access the same schema routing information.\n\n**Sources:** [types.d.ts:27-36](), [types.d.ts:318-328]()\n\n## Context Flow Through Execution Layers\n\n```mermaid\ngraph TB\n    subgraph \"Public API Layer\"\n        BT_RUN[\"Backtest.run(symbol, context)\"]\n        LIVE_RUN[\"Live.run(symbol, context)\"]\n        WALK_RUN[\"Walker.run(symbol, walkerContext)\"]\n    end\n    \n    subgraph \"Command Services\"\n        BT_CMD[\"BacktestCommandService\"]\n        LIVE_CMD[\"LiveCommandService\"]\n        WALK_CMD[\"WalkerCommandService\"]\n    end\n    \n    subgraph \"Logic Public Services\"\n        BT_LOG_PUB[\"BacktestLogicPublicService\"]\n        LIVE_LOG_PUB[\"LiveLogicPublicService\"]\n        WALK_LOG_PUB[\"WalkerLogicPublicService\"]\n    end\n    \n    subgraph \"MethodContext Established\"\n        MC_SET[\"MethodContextService.runAsyncIterator()<br/>{strategyName, exchangeName, frameName}\"]\n    end\n    \n    subgraph \"Logic Private Services\"\n        BT_LOG_PRIV[\"BacktestLogicPrivateService<br/>Iterates timeframes\"]\n        LIVE_LOG_PRIV[\"LiveLogicPrivateService<br/>Infinite loop with sleep\"]\n        WALK_LOG_PRIV[\"WalkerLogicPrivateService<br/>Sequential strategy execution\"]\n    end\n    \n    subgraph \"ExecutionContext Established\"\n        EC_SET[\"ExecutionContextService.runInContext()<br/>{symbol, when, backtest}\"]\n    end\n    \n    subgraph \"Core Services\"\n        STRAT_CORE[\"StrategyCoreService.tick()\"]\n        EXCH_CORE[\"ExchangeCoreService.getCandles()\"]\n        FRAME_CORE[\"FrameCoreService.getTimeframe()\"]\n    end\n    \n    subgraph \"Connection Services\"\n        STRAT_CONN[\"StrategyConnectionService<br/>Reads methodContext\"]\n        EXCH_CONN[\"ExchangeConnectionService<br/>Reads methodContext\"]\n        FRAME_CONN[\"FrameConnectionService<br/>Reads methodContext\"]\n    end\n    \n    subgraph \"Client Layer\"\n        CLIENT_STRAT[\"ClientStrategy<br/>Reads executionContext\"]\n        CLIENT_EXCH[\"ClientExchange<br/>Reads executionContext\"]\n        CLIENT_FRAME[\"ClientFrame\"]\n    end\n    \n    BT_RUN --> BT_CMD\n    LIVE_RUN --> LIVE_CMD\n    WALK_RUN --> WALK_CMD\n    \n    BT_CMD --> BT_LOG_PUB\n    LIVE_CMD --> LIVE_LOG_PUB\n    WALK_CMD --> WALK_LOG_PUB\n    \n    BT_LOG_PUB --> MC_SET\n    LIVE_LOG_PUB --> MC_SET\n    WALK_LOG_PUB --> MC_SET\n    \n    MC_SET --> BT_LOG_PRIV\n    MC_SET --> LIVE_LOG_PRIV\n    MC_SET --> WALK_LOG_PRIV\n    \n    BT_LOG_PRIV --> EC_SET\n    LIVE_LOG_PRIV --> EC_SET\n    WALK_LOG_PRIV --> EC_SET\n    \n    EC_SET --> STRAT_CORE\n    EC_SET --> EXCH_CORE\n    EC_SET --> FRAME_CORE\n    \n    STRAT_CORE --> STRAT_CONN\n    EXCH_CORE --> EXCH_CONN\n    FRAME_CORE --> FRAME_CONN\n    \n    STRAT_CONN --> CLIENT_STRAT\n    EXCH_CONN --> CLIENT_EXCH\n    FRAME_CONN --> CLIENT_FRAME\n```\n\n**Sources:** [src/lib/index.ts:131-163](), [src/index.ts:162-163]()\n\n## Context Access Patterns\n\n### Accessing ExecutionContext in Client Classes\n\nClient classes (ClientExchange, ClientStrategy, ClientFrame) receive context services via constructor dependency injection:\n\n```typescript\ninterface IExchangeParams extends IExchangeSchema {\n  logger: ILogger;\n  execution: TExecutionContextService; // ExecutionContext injected here\n}\n```\n\nInside client methods, context is accessed via the `.context` property:\n\n```typescript\nasync getCandles(symbol: string, interval: CandleInterval, limit: number) {\n  const { when, backtest } = this.execution.context;\n  // Use when as the reference timestamp for fetching historical data\n  // Use backtest flag to adjust behavior for simulation vs live\n}\n```\n\n**Sources:** [types.d.ts:105-110]()\n\n### Accessing MethodContext in Connection Services\n\nConnection services use MethodContext to retrieve the correct schema names for memoized client instantiation:\n\n```typescript\n// Inside StrategyConnectionService\nconst { strategyName } = this.methodContext.context;\nconst schema = this.strategySchemaService.get(strategyName);\n// Create or retrieve memoized ClientStrategy instance\n```\n\nThis pattern allows connection services to route operations to the correct client instances without schema names being passed through every function call.\n\n**Sources:** [types.d.ts:330-336]()\n\n## Context Propagation in Backtest vs Live\n\n```mermaid\ngraph TB\n    subgraph \"Backtest Mode\"\n        BT_FRAME[\"Generate timeframes<br/>[t1, t2, t3, ..., tn]\"]\n        BT_LOOP[\"for each timeframe\"]\n        BT_EC[\"ExecutionContextService.runInContext()<br/>{symbol, when: timeframe[i], backtest: true}\"]\n        BT_TICK[\"StrategyCoreService.tick()\"]\n        BT_CLIENT[\"ClientStrategy reads context<br/>when = historical timestamp<br/>backtest = true\"]\n    end\n    \n    subgraph \"Live Mode\"\n        LIVE_SLEEP[\"sleep(TICK_TTL = 1 minute)\"]\n        LIVE_LOOP[\"while(true)\"]\n        LIVE_EC[\"ExecutionContextService.runInContext()<br/>{symbol, when: new Date(), backtest: false}\"]\n        LIVE_TICK[\"StrategyCoreService.tick()\"]\n        LIVE_CLIENT[\"ClientStrategy reads context<br/>when = current timestamp<br/>backtest = false\"]\n    end\n    \n    BT_FRAME --> BT_LOOP\n    BT_LOOP --> BT_EC\n    BT_EC --> BT_TICK\n    BT_TICK --> BT_CLIENT\n    BT_CLIENT -.->|\"next timeframe\"| BT_LOOP\n    \n    LIVE_SLEEP --> LIVE_LOOP\n    LIVE_LOOP --> LIVE_EC\n    LIVE_EC --> LIVE_TICK\n    LIVE_TICK --> LIVE_CLIENT\n    LIVE_CLIENT -.->|\"sleep and repeat\"| LIVE_SLEEP\n```\n\nThe key difference:\n- **Backtest**: `when` is set to each historical timeframe timestamp, advancing deterministically\n- **Live**: `when` is set to `new Date()` on each iteration, tracking real-time\n\nBoth modes use the same `StrategyCoreService.tick()` and `ClientStrategy` implementations, but behavior differs based on the `backtest` flag in the context.\n\n**Sources:** Diagram 2 from high-level architecture\n\n## MethodContext Propagation in Walker Mode\n\nWalker mode demonstrates nested context usage:\n\n```mermaid\ngraph TB\n    WALK_START[\"Walker.run(symbol, {walkerName})\"]\n    WALK_MC[\"MethodContextService.runAsyncIterator()<br/>{strategyName: '', exchangeName: '', frameName: ''}\"]\n    WALK_LOAD[\"Load walker schema<br/>Get list of strategies to test\"]\n    WALK_FOR[\"for each strategyName in walker.strategies\"]\n    \n    subgraph \"Inner Backtest Context\"\n        BT_MC[\"MethodContextService.runAsyncIterator()<br/>{strategyName, exchangeName, frameName}\"]\n        BT_RUN[\"BacktestLogicPublicService.run()\"]\n        BT_COMPLETE[\"Collect statistics\"]\n    end\n    \n    WALK_START --> WALK_MC\n    WALK_MC --> WALK_LOAD\n    WALK_LOAD --> WALK_FOR\n    WALK_FOR --> BT_MC\n    BT_MC --> BT_RUN\n    BT_RUN --> BT_COMPLETE\n    BT_COMPLETE -.->|\"next strategy\"| WALK_FOR\n```\n\nWalker establishes an outer MethodContext with empty schema names, then for each strategy creates a nested inner MethodContext with the specific strategyName/exchangeName/frameName. This allows each backtest to run in isolated context.\n\n**Sources:** Diagram 2 from high-level architecture\n\n## Benefits of Context Propagation\n\n### Eliminates Parameter Drilling\n\nWithout contexts, every function in the call stack would need these parameters:\n\n```typescript\n// Without contexts (hypothetical)\nasync tick(\n  symbol: string,\n  when: Date,\n  backtest: boolean,\n  strategyName: string,\n  exchangeName: string,\n  frameName: string\n) {\n  await this.getCandles(symbol, when, backtest, exchangeName, ...);\n}\n```\n\nWith contexts, function signatures are clean:\n\n```typescript\n// With contexts (actual)\nasync tick() {\n  await this.getCandles();\n}\n```\n\n### Enforces Temporal Correctness\n\nBy making `when` available via context, the framework ensures all operations use the correct temporal reference. ClientExchange uses `when` as the cutoff point for historical data fetching, preventing look-ahead bias.\n\n### Enables Shared Client Instances\n\nMethodContext allows connection services to retrieve the correct schema and instantiate clients once per strategyName:exchangeName combination. Without MethodContext, each service would need to explicitly pass schema names through the call hierarchy.\n\n**Sources:** [types.d.ts:6-18](), [types.d.ts:297-309]()\n\n## Integration with Dependency Injection\n\nContext services are registered in the DI container like other services:\n\n| Service | Symbol | Constructor | Injection Type |\n|---------|--------|-------------|----------------|\n| ExecutionContextService | `TYPES.executionContextService` | `new ExecutionContextService()` | Singleton per application |\n| MethodContextService | `TYPES.methodContextService` | `new MethodContextService()` | Singleton per application |\n\nHowever, unlike typical services, context services manage **scoped state** using `di-scoped`. The service instances themselves are singletons, but the `.context` property value is scoped to the current execution context established by `runInContext()` or `runAsyncIterator()`.\n\n**Sources:** [src/lib/core/types.ts:5-8](), [src/lib/core/provide.ts:60-63]()\n\n## Code Reference Table\n\n| Component | File Path | Lines |\n|-----------|-----------|-------|\n| IExecutionContext interface | [types.d.ts]() | 11-18 |\n| IMethodContext interface | [types.d.ts]() | 302-309 |\n| ExecutionContextService declaration | [types.d.ts]() | 38-49 |\n| MethodContextService declaration | [types.d.ts]() | 330-336 |\n| Context service DI registration | [src/lib/core/provide.ts]() | 60-63 |\n| Context service TYPES symbols | [src/lib/core/types.ts]() | 5-8 |\n| Context services export | [src/lib/index.ts]() | 66-71, 162-163 |\n| IExchangeParams using ExecutionContext | [types.d.ts]() | 105-110 |\n\n**Sources:** [types.d.ts:11-18](), [types.d.ts:302-309](), [types.d.ts:38-49](), [types.d.ts:330-336](), [src/lib/core/provide.ts:60-63](), [src/lib/core/types.ts:5-8](), [src/lib/index.ts:66-71](), [src/lib/index.ts:162-163](), [types.d.ts:105-110]()"
                    },
                    {
                        "page_plan": {
                            "id": "3.4",
                            "title": "Time Execution Engine"
                        },
                        "content": "# Time Execution Engine\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [assets/uml.svg](assets/uml.svg)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [scripts/uml.mjs](scripts/uml.mjs)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document explains the Time Execution Engine, the core architectural pattern that powers Backtest Kit. The Time Execution Engine treats market data processing as an **async stream of time**, where strategies are evaluated step-by-step with strict temporal context. This architecture makes look-ahead bias architecturally impossible by controlling what data is visible at each point in time.\n\nFor details about how strategies generate signals within this time stream, see [Strategies](#3.2). For information about execution modes (Backtest, Live, Walker), see [Execution Modes](#5).\n\n---\n\n## Core Concept: Time as Ambient Context\n\nThe Time Execution Engine operates on a fundamental principle: **time is propagated as ambient context throughout the entire call stack**. When your strategy's `getSignal()` function executes, it doesn't receive the current timestamp as a parameter. Instead, the timestamp exists as ambient context that all data access functions automatically respect.\n\nThis is implemented using Node.js `AsyncLocalStorage` via the `di-scoped` library, which provides two context services:\n\n| Context Service | Stores | Lifecycle | Purpose |\n|-----------------|--------|-----------|---------|\n| `ExecutionContextService` | `symbol`, `when`, `backtest` | Per tick | Controls temporal data visibility |\n| `MethodContextService` | `strategyName`, `exchangeName`, `frameName` | Per execution | Routes to correct schema configuration |\n\nThe `when` field in `ExecutionContextService` is the key to the entire time execution model. Every data access operation reads this value to determine \"what time is it right now?\" and returns only data up to that point.\n\n**Sources:** [README.md:185-198](), [docs/internals.md:42-52]()\n\n---\n\n## Execution Context Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Context Propagation Layer\"\n        ECS[ExecutionContextService<br/>symbol: string<br/>when: Date<br/>backtest: boolean]\n        MCS[MethodContextService<br/>strategyName: string<br/>exchangeName: string<br/>frameName: string]\n    end\n    \n    subgraph \"Orchestration Layer\"\n        BTLogic[BacktestLogicPrivateService]\n        LiveLogic[LiveLogicPrivateService]\n        StratCore[StrategyCoreService]\n    end\n    \n    subgraph \"Strategy Execution Layer\"\n        ClientStrat[ClientStrategy]\n        GetSignal[User getSignal Function]\n        GetCandles[getCandles Helper]\n    end\n    \n    subgraph \"Data Access Layer\"\n        ClientExch[ClientExchange]\n        ExchSchema[IExchangeSchema.getCandles]\n    end\n    \n    BTLogic -->|\"runInContext(when = frame)\"| ECS\n    LiveLogic -->|\"runInContext(when = new Date())\"| ECS\n    \n    BTLogic -->|\"runInContext(schemas)\"| MCS\n    LiveLogic -->|\"runInContext(schemas)\"| MCS\n    \n    ECS -.->|\"ambient context\"| StratCore\n    MCS -.->|\"ambient context\"| StratCore\n    \n    StratCore --> ClientStrat\n    ClientStrat --> GetSignal\n    \n    GetSignal --> GetCandles\n    GetCandles -->|\"reads when from context\"| ECS\n    GetCandles --> ClientExch\n    \n    ClientExch -->|\"getCandles(since=when)\"| ExchSchema\n    \n    ECS -.->|\"temporal boundary\"| ClientExch\n```\n\n**Execution Context Flow**\n\nThe diagram shows how temporal context flows from orchestration through strategy execution to data access. The dashed lines represent ambient context propagation via `AsyncLocalStorage`, while solid lines represent direct function calls.\n\n**Sources:** [docs/internals.md:54-81](), High-level architecture diagrams (Diagram 1, 3, 4)\n\n---\n\n## Time Iteration Patterns\n\n### Backtest Mode: Discrete Time Steps\n\nIn backtest mode, time moves forward in discrete steps defined by the frame interval. The `BacktestLogicPrivateService` generates a sequence of timestamps and processes each one sequentially:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant BTLogic as BacktestLogicPrivateService\n    participant ECS as ExecutionContextService\n    participant Frame as FrameCoreService\n    participant Strat as StrategyCoreService\n    \n    User->>BTLogic: run(symbol, context)\n    BTLogic->>Frame: getTimeFrames(frameName)\n    Frame-->>BTLogic: [t1, t2, t3, ..., tn]\n    \n    loop For each timeframe\n        BTLogic->>ECS: runInContext({ when: ti, backtest: true })\n        ECS->>Strat: tick(symbol)\n        Strat-->>ECS: result\n        ECS-->>BTLogic: yield result\n    end\n    \n    BTLogic-->>User: async generator completes\n```\n\n**Backtest Time Flow**\n\nThe backtest engine iterates through pre-generated timeframes, setting the execution context for each tick. Strategies see a deterministic progression of time.\n\n**Key implementation characteristics:**\n\n- Time is **deterministic** - always processes the same timestamps in the same order\n- Time moves at **frame interval** - typically 1 minute, 5 minutes, etc.\n- Strategies can **skip timeframes** after signal opens using fast backtest optimization\n- The `when` value is always **in the past** relative to real-world time\n\n**Sources:** [docs/internals.md:54-67](), Diagram 2 from high-level architecture\n\n---\n\n### Live Mode: Continuous Time Flow\n\nIn live mode, time moves continuously with the real-world clock. The `LiveLogicPrivateService` runs an infinite loop that sleeps between ticks:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant LiveLogic as LiveLogicPrivateService\n    participant ECS as ExecutionContextService\n    participant Strat as StrategyCoreService\n    participant Sleep as sleep(TICK_TTL)\n    \n    User->>LiveLogic: run(symbol, context)\n    \n    loop while(true)\n        LiveLogic->>LiveLogic: when = new Date()\n        LiveLogic->>ECS: runInContext({ when, backtest: false })\n        ECS->>Strat: tick(symbol)\n        Strat-->>ECS: result\n        ECS-->>LiveLogic: yield result\n        LiveLogic->>Sleep: sleep(60_000 + 1)\n        Sleep-->>LiveLogic: continue\n        \n        alt stop() called && signal closed\n            LiveLogic-->>User: generator completes\n        end\n    end\n```\n\n**Live Time Flow**\n\nThe live engine continuously polls at regular intervals, setting the execution context to the current real-world time for each tick.\n\n**Key implementation characteristics:**\n\n- Time is **non-deterministic** - follows real-world clock\n- Time moves at **~1 minute intervals** - `TICK_TTL = 60_000 + 1` milliseconds\n- Strategies must handle **graceful shutdown** - waits for signals to close\n- The `when` value is always **now** relative to real-world time\n- Implements **crash recovery** via persistence between ticks\n\n**Sources:** [docs/internals.md:69-82](), Diagram 2 from high-level architecture\n\n---\n\n## Temporal Data Access: getCandles()\n\nThe `getCandles()` helper function is the primary interface for strategies to access historical market data. It automatically respects the temporal context:\n\n```typescript\n// User code - no timestamp parameter needed\nconst candles = await getCandles(symbol, \"1h\", 24);\n```\n\nInternally, this maps to:\n\n```mermaid\ngraph LR\n    A[\"getCandles(symbol, interval, limit)\"] --> B[ExchangeGlobalService]\n    B --> C[ExecutionContextService.getContext]\n    C --> D[\"context.when\"]\n    D --> E[ClientExchange.getCandles]\n    E --> F[\"IExchangeSchema.getCandles(since=when)\"]\n    F --> G[\"Returns candles UP TO when\"]\n    \n    style D fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**Temporal Data Access Flow**\n\nThe temporal boundary is enforced at the `ClientExchange` level, which reads `when` from context and passes it as the `since` parameter to the exchange schema.\n\n### Multi-Timeframe Synchronization\n\nWhen strategies request multiple timeframes, all are automatically synchronized to the same temporal context:\n\n```typescript\n// All candles respect the SAME \"when\" timestamp\nconst candles1h = await getCandles(symbol, \"1h\", 24);\nconst candles15m = await getCandles(symbol, \"15m\", 48);\nconst candles5m = await getCandles(symbol, \"5m\", 60);\nconst candles1m = await getCandles(symbol, \"1m\", 60);\n```\n\nIn backtest mode, if `when = \"2025-01-15 14:30:00\"`:\n- `candles1h` contains data up to `2025-01-15 14:00:00`\n- `candles15m` contains data up to `2025-01-15 14:15:00`\n- `candles5m` contains data up to `2025-01-15 14:25:00`\n- `candles1m` contains data up to `2025-01-15 14:29:00`\n\nEach timeframe respects the **same temporal boundary** but rounds down to its interval.\n\n**Sources:** [README.md:123-134](), [README.md:189-198]()\n\n---\n\n## Look-Ahead Bias Prevention\n\nThe Time Execution Engine makes look-ahead bias **architecturally impossible** through three mechanisms:\n\n### 1. Temporal Context Isolation\n\nThe `when` timestamp is stored in `AsyncLocalStorage`, making it impossible for user code to access future data:\n\n```mermaid\ngraph TB\n    subgraph \"AsyncLocalStorage Isolation\"\n        Context[\"ExecutionContextService<br/>when: 2025-01-15 14:30:00\"]\n    end\n    \n    subgraph \"User Strategy Code\"\n        GetSignal[\"getSignal() function\"]\n        GetCandles1[\"getCandles('1h', 24)\"]\n        GetCandles2[\"getCandles('5m', 60)\"]\n    end\n    \n    subgraph \"Data Access Layer\"\n        Exchange[\"Exchange.getCandles()\"]\n        CCXT[\"CCXT fetchOHLCV()\"]\n    end\n    \n    Context -.->|\"automatic propagation\"| GetSignal\n    GetSignal --> GetCandles1\n    GetSignal --> GetCandles2\n    \n    GetCandles1 -->|\"reads when from context\"| Exchange\n    GetCandles2 -->|\"reads when from context\"| Exchange\n    \n    Exchange -->|\"since=2025-01-15 14:30:00<br/>limit=24\"| CCXT\n    CCXT -.->|\"returns only past data\"| Exchange\n    \n    style Context fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**Temporal Isolation Architecture**\n\nUser code cannot bypass the temporal boundary because it has no direct access to the current timestamp or future data.\n\n### 2. Schema-Level Enforcement\n\nThe `IExchangeSchema.getCandles()` contract requires implementations to respect the `since` parameter:\n\n| Parameter | Type | Purpose |\n|-----------|------|---------|\n| `symbol` | string | Trading pair identifier |\n| `interval` | SignalInterval | Candle timeframe |\n| `since` | Date | **Temporal boundary** - only return data before this |\n| `limit` | number | Maximum candles to return |\n\nImplementations must ensure `candle.timestamp <= since.getTime()` for all returned candles.\n\n### 3. Same Code, Same Guarantees\n\nThe temporal context mechanism works identically in backtest and live modes:\n\n| Mode | `when` Value | Data Returned |\n|------|--------------|---------------|\n| Backtest | Historical timestamp from frame | Historical data up to that timestamp |\n| Live | `new Date()` | Historical data up to current time |\n\nThis means strategies tested in backtest mode will behave identically in live mode, with the same temporal guarantees.\n\n**Sources:** [README.md:185-198](), [docs/internals.md:54-81]()\n\n---\n\n## Implementation Components\n\n### Core Services\n\nThe following services implement the Time Execution Engine:\n\n```mermaid\ngraph TB\n    subgraph \"Context Services\"\n        ECS[ExecutionContextService]\n        MCS[MethodContextService]\n    end\n    \n    subgraph \"Logic Services\"\n        BTPriv[BacktestLogicPrivateService]\n        LivePriv[LiveLogicPrivateService]\n        BTPub[BacktestLogicPublicService]\n        LivePub[LiveLogicPublicService]\n    end\n    \n    subgraph \"Core Services\"\n        StratCore[StrategyCoreService]\n        ExchCore[ExchangeCoreService]\n        FrameCore[FrameCoreService]\n    end\n    \n    subgraph \"Connection Services\"\n        StratConn[StrategyConnectionService]\n        ExchConn[ExchangeConnectionService]\n    end\n    \n    subgraph \"Client Layer\"\n        ClientStrat[ClientStrategy]\n        ClientExch[ClientExchange]\n    end\n    \n    BTPub --> BTPriv\n    LivePub --> LivePriv\n    \n    BTPriv --> ECS\n    BTPriv --> MCS\n    BTPriv --> StratCore\n    BTPriv --> FrameCore\n    \n    LivePriv --> ECS\n    LivePriv --> MCS\n    LivePriv --> StratCore\n    \n    StratCore --> StratConn\n    StratConn --> ClientStrat\n    \n    ExchCore --> ExchConn\n    ExchConn --> ClientExch\n    \n    ClientStrat -.->|\"reads context\"| ECS\n    ClientExch -.->|\"reads when\"| ECS\n```\n\n**Service Component Architecture**\n\nThe time execution engine is implemented through a layered service architecture with clear separation of concerns.\n\n### Key Service Responsibilities\n\n| Service | Responsibility | Location |\n|---------|---------------|----------|\n| `ExecutionContextService` | Stores and propagates `when` timestamp via `AsyncLocalStorage` | Context layer |\n| `MethodContextService` | Stores and propagates schema names via `AsyncLocalStorage` | Context layer |\n| `BacktestLogicPrivateService` | Generates timeframes and iterates through them | Orchestration layer |\n| `LiveLogicPrivateService` | Runs infinite loop with real-time timestamps | Orchestration layer |\n| `StrategyCoreService` | Orchestrates strategy execution within temporal context | Core layer |\n| `ClientStrategy` | Executes user's `getSignal()` function with ambient context | Client layer |\n| `ClientExchange` | Fetches candles respecting temporal boundary from context | Client layer |\n\n**Sources:** [docs/internals.md:28-40](), Diagram 4 from high-level architecture\n\n---\n\n## Async Generator Pattern\n\nThe Time Execution Engine uses async generators to stream time progression as events:\n\n### Backtest Generator (Finite)\n\n```typescript\nasync function* backtestGenerator() {\n  const frames = getTimeFrames(frameName);\n  \n  for (const when of frames) {\n    // Set temporal context\n    const result = await ExecutionContextService.runInContext(\n      () => StrategyCoreService.tick(symbol),\n      { symbol, when, backtest: true }\n    );\n    \n    // Stream result\n    yield result;\n  }\n  \n  // Generator completes when frames exhausted\n}\n```\n\n### Live Generator (Infinite)\n\n```typescript\nasync function* liveGenerator() {\n  while (!stopped) {\n    // Set temporal context to NOW\n    const when = new Date();\n    const result = await ExecutionContextService.runInContext(\n      () => StrategyCoreService.tick(symbol),\n      { symbol, when, backtest: false }\n    );\n    \n    // Stream result\n    yield result;\n    \n    // Wait for next tick\n    await sleep(TICK_TTL);\n    \n    // Check for graceful shutdown\n    if (stopped && result.action === 'closed') {\n      break;\n    }\n  }\n}\n```\n\n### Generator Consumption\n\nUsers can consume the time stream in two ways:\n\n**Pull-based (Iterator):**\n```typescript\nfor await (const event of Backtest.run('BTCUSDT', config)) {\n  // Process each time step\n}\n```\n\n**Push-based (Events):**\n```typescript\nBacktest.background('BTCUSDT', config);\nlistenSignalBacktest(event => {\n  // React to each time step\n});\n```\n\nBoth consumption patterns receive the same time-ordered stream of events.\n\n**Sources:** [README.md:201-224](), [docs/internals.md:42-52]()\n\n---\n\n## Temporal Guarantees\n\nThe Time Execution Engine provides the following architectural guarantees:\n\n### 1. Sequential Time Processing\n\nTime always moves forward. In backtest mode, timestamps are strictly increasing. In live mode, each tick uses `new Date()` which is monotonically increasing.\n\n### 2. Deterministic Backtest Execution\n\nGiven the same:\n- Strategy code\n- Exchange data\n- Frame configuration\n- Random seed (if used)\n\nA backtest will always produce the same results when run multiple times.\n\n### 3. Live-Backtest Equivalence\n\nA strategy tested in backtest mode will exhibit the same logical behavior in live mode because:\n- The same `ClientStrategy` code executes\n- The same temporal context mechanism applies\n- The same data access patterns work\n- Only the `backtest` flag differs\n\n### 4. No Future Data Leakage\n\nIt is architecturally impossible to access data from beyond the current `when` timestamp because:\n- User code has no direct access to timestamps\n- All data access goes through context-aware helpers\n- The `IExchangeSchema` contract enforces the temporal boundary\n- AsyncLocalStorage prevents context bypass\n\n### 5. Multi-Timeframe Consistency\n\nWhen requesting multiple timeframes in the same tick, all are synchronized to the same temporal boundary, preventing data misalignment between timeframes.\n\n**Sources:** [README.md:185-198](), [docs/internals.md:91-102]()\n\n---\n\n## Usage Example\n\nThis example demonstrates how the Time Execution Engine works from a user's perspective:\n\n```typescript\nimport { addStrategy, getCandles } from 'backtest-kit';\n\naddStrategy({\n  strategyName: 'temporal-demo',\n  interval: '5m',\n  \n  getSignal: async (symbol) => {\n    // No timestamp parameter - context is ambient\n    \n    // All these calls respect the SAME temporal boundary\n    const candles1h = await getCandles(symbol, '1h', 24);\n    const candles5m = await getCandles(symbol, '5m', 60);\n    \n    // Calculate indicators using synchronized data\n    const sma1h = calculateSMA(candles1h, 20);\n    const rsi5m = calculateRSI(candles5m, 14);\n    \n    // Generate signal based on current market state\n    if (crossover(rsi5m, 70) && sma1h.trend === 'up') {\n      return {\n        id: uuid(),\n        position: 'long',\n        priceOpen: candles5m[candles5m.length - 1].close,\n        priceTakeProfit: candles5m[candles5m.length - 1].close * 1.02,\n        priceStopLoss: candles5m[candles5m.length - 1].close * 0.99,\n      };\n    }\n    \n    return null;\n  },\n});\n```\n\nIn backtest mode, `getCandles()` returns historical data up to the current frame timestamp. In live mode, it returns historical data up to `new Date()`. The same code works in both modes with identical temporal guarantees.\n\n**Sources:** [README.md:111-142]()\n\n---\n\n## Related Architecture\n\nThe Time Execution Engine interacts with other architectural components:\n\n- **Execution Contexts** ([#3.3](#3.3)) - Detailed explanation of context propagation mechanisms\n- **Execution Modes** ([#5](#5)) - How time flows differently in Backtest/Live/Walker modes\n- **VWAP Pricing** ([#3.5](#3.5)) - How realistic pricing integrates with temporal context\n- **Signal Lifecycle** ([#3.1](#3.1)) - How signals evolve through time-bound state transitions\n\n**Sources:** High-level architecture diagrams, [docs/internals.md:1-131]()"
                    },
                    {
                        "page_plan": {
                            "id": "3.5",
                            "title": "VWAP Pricing & Data Handling"
                        },
                        "content": "# VWAP Pricing & Data Handling\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/config/params.ts](src/config/params.ts)\n- [test/README.md](test/README.md)\n- [test/config/setup.mjs](test/config/setup.mjs)\n- [test/e2e/close.test.mjs](test/e2e/close.test.mjs)\n- [test/e2e/edge.test.mjs](test/e2e/edge.test.mjs)\n- [test/e2e/other.test.mjs](test/e2e/other.test.mjs)\n- [test/e2e/persist.test.mjs](test/e2e/persist.test.mjs)\n- [test/e2e/sanitize.test.mjs](test/e2e/sanitize.test.mjs)\n- [test/e2e/sequence.test.mjs](test/e2e/sequence.test.mjs)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page explains how Backtest Kit calculates Volume Weighted Average Price (VWAP) for realistic entry and exit prices, manages candle data buffers, detects price anomalies from exchange APIs, and implements fallback mechanisms for edge cases. This system ensures that backtests simulate real-world execution conditions with slippage and market depth.\n\nFor information about how VWAP integrates with the time execution engine and signal lifecycle, see [Time Execution Engine](#3.4). For exchange configuration and the `getCandles` contract, see [Exchange Configuration](#8.1).\n\n---\n\n## VWAP Calculation Overview\n\nVWAP (Volume Weighted Average Price) is used to simulate realistic order execution prices. Instead of using a single candle's close price, the system calculates a volume-weighted average across multiple recent candles to account for market depth and order book dynamics.\n\n**Why VWAP?**\n- **Realism**: Simulates market impact of large orders\n- **Slippage**: Accounts for price movement during order execution\n- **Reproducibility**: Deterministic calculation across backtest and live modes\n- **Bias Prevention**: Prevents cherry-picking best prices from individual candles\n\n### VWAP Formula\n\n```\nVWAP = Σ(price_i × volume_i) / Σ(volume_i)\n```\n\nWhere `price_i` is typically the candle's close price and `volume_i` is the trading volume for that candle.\n\n**Fallback for Zero Volume**:\n```\nSimple Average = Σ(price_i) / n\n```\n\nWhen all candles have zero volume (low-liquidity assets), the system falls back to a simple arithmetic mean.\n\nSources: [src/config/params.ts:8-11](), [README.md:22]()\n\n---\n\n## Candle Buffer Management\n\nThe system maintains a configurable buffer of recent candles for VWAP calculation. By default, **5 candles** are used, representing the last 5 minutes of data when using a 1-minute interval.\n\n### Buffer Size Configuration\n\n| Parameter | Default | Purpose |\n|-----------|---------|---------|\n| `CC_AVG_PRICE_CANDLES_COUNT` | 5 | Number of candles for VWAP calculation |\n\n**Buffer Behavior**:\n1. Each call to `getAveragePrice()` fetches the last N candles\n2. Candles are requested from the exchange via `getCandles()` method\n3. VWAP is calculated across all returned candles\n4. Buffer size is constant regardless of market volatility\n\n### Temporal Context Guarantee\n\nThe `getCandles()` function is time-aware via `AsyncLocalStorage` context propagation. In backtest mode, it **always** returns candles up to the current simulation timestamp, preventing look-ahead bias.\n\n```mermaid\ngraph LR\n    subgraph \"Candle Buffer Flow\"\n        A[\"getAveragePrice(symbol)\"]\n        B[\"ExecutionContext<br/>(symbol, when, backtest)\"]\n        C[\"getCandles(symbol, '1m', limit=5)\"]\n        D[\"Exchange API\"]\n        E[\"Candle Validation\"]\n        F[\"VWAP Calculation\"]\n        G[\"Return Price\"]\n    end\n    \n    A --> B\n    B --> C\n    C --> D\n    D --> E\n    E --> F\n    F --> G\n    \n    B -.->|\"temporal context\"| C\n    E -.->|\"anomaly detection\"| F\n```\n\n**Diagram: Candle Buffer Data Flow**\n\nSources: [src/config/params.ts:8-11](), [README.md:189-199]()\n\n---\n\n## Data Validation Pipeline\n\nCandle data undergoes multi-stage validation to detect incomplete or anomalous data from exchange APIs. This is critical because exchanges like Binance occasionally return candles with prices near zero (e.g., $0.01) when data is incomplete.\n\n### Validation Stages\n\n```mermaid\ngraph TD\n    subgraph \"Candle Validation Pipeline\"\n        A[\"Raw Candles<br/>from Exchange\"]\n        B[\"Retry Logic<br/>(3 attempts)\"]\n        C[\"Median Price<br/>Calculation\"]\n        D[\"Anomaly Detection<br/>(1000× threshold)\"]\n        E[\"Volume Check<br/>(zero volume?)\"]\n        F[\"Valid Candles\"]\n        G[\"Fallback: Simple Average\"]\n        H[\"Fallback: Retry\"]\n    end\n    \n    A --> B\n    B --> C\n    C --> D\n    D -->|\"price < median/1000\"| H\n    D -->|\"valid\"| E\n    E -->|\"volume > 0\"| F\n    E -->|\"all zero\"| G\n    H --> B\n    G --> F\n```\n\n**Diagram: Candle Validation Pipeline**\n\nSources: [src/config/params.ts:76-104]()\n\n---\n\n## Anomaly Detection\n\nThe system detects incomplete or corrupted candle data using a **median-based threshold**. If any candle's price is more than 1000× lower than the median price, it's flagged as anomalous.\n\n### Price Anomaly Threshold\n\n| Parameter | Default | Purpose |\n|-----------|---------|---------|\n| `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR` | 1000 | Maximum deviation factor for anomaly detection |\n| `CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN` | 5 | Minimum candles required for reliable median calculation |\n\n**Detection Algorithm**:\n\n1. **Collect all price points** from candles (open, high, low, close)\n2. **Calculate median price** (if ≥5 candles) or average (if <5 candles)\n3. **Check each candle**: If any price < `median / 1000`, flag as anomaly\n4. **Reject batch**: If anomaly detected, trigger retry logic\n\n### Example Scenario\n\n```\nBTC median price: $50,000\nAnomaly threshold: $50,000 / 1000 = $50\nIncomplete candle: close = $0.01\n\nResult: Anomaly detected → Retry fetch\n```\n\n**Why 1000× Factor?**\n\nFrom the configuration comments:\n- Incomplete candles from Binance typically have prices near $0.01-$1\n- Normal BTC price range: $20,000-$100,000\n- Factor 1000 catches anomalies below $20-$100 when median is $20,000-$100,000\n- Factor 100 would be too permissive (allows $200 when median is $20,000)\n- Factor 10,000 might be too strict for low-cap altcoins\n\n### Median vs Average\n\n| Dataset Size | Method Used | Reason |\n|-------------|-------------|---------|\n| < 5 candles | Simple Average | Median unstable with small datasets |\n| ≥ 5 candles | Median | More robust against outliers (anomalies) |\n\nWith 5 candles × 4 price points (OHLC) = **20 data points**, the median is statistically reliable.\n\nSources: [src/config/params.ts:76-104]()\n\n---\n\n## Retry Logic\n\nThe system implements exponential backoff retry logic for `getCandles()` calls to handle transient network failures or rate limits.\n\n### Retry Configuration\n\n| Parameter | Default | Purpose |\n|-----------|---------|---------|\n| `CC_GET_CANDLES_RETRY_COUNT` | 3 | Maximum number of retry attempts |\n| `CC_GET_CANDLES_RETRY_DELAY_MS` | 5000 | Delay between retries (5 seconds) |\n\n### Retry Flow\n\n```mermaid\nstateDiagram-v2\n    [*] --> Attempt1: getCandles() called\n    Attempt1 --> Validate1: Received candles\n    Validate1 --> Success: Valid data\n    Validate1 --> Wait1: Anomaly detected\n    Wait1 --> Attempt2: Sleep 5s\n    Attempt2 --> Validate2: Received candles\n    Validate2 --> Success: Valid data\n    Validate2 --> Wait2: Anomaly detected\n    Wait2 --> Attempt3: Sleep 5s\n    Attempt3 --> Validate3: Received candles\n    Validate3 --> Success: Valid data\n    Validate3 --> Error: Still anomalous\n    Error --> [*]: Throw error\n    Success --> [*]: Return candles\n```\n\n**Diagram: Retry State Machine**\n\n**Retry Trigger Conditions**:\n1. Network error (timeout, connection refused)\n2. Exchange API error (rate limit, 500 error)\n3. Anomaly detection failure (price < threshold)\n4. Empty candle array returned\n\n**No Retry Conditions**:\n- Zero volume candles (valid, triggers fallback)\n- Small dataset (<5 candles, uses average)\n- Valid data on first attempt\n\nSources: [src/config/params.ts:66-74]()\n\n---\n\n## Fallback Mechanisms\n\nThe system implements multiple fallback strategies to handle edge cases where normal VWAP calculation is impossible.\n\n### Zero Volume Fallback\n\nWhen all candles in the buffer have `volume = 0` (low-liquidity assets), the VWAP denominator becomes zero. The system automatically falls back to a **simple arithmetic mean** of close prices.\n\n**Example from Tests**:\n```javascript\n// Test case: test/e2e/edge.test.mjs:148-283\n// All candles have volume=0\ncandles.push({\n  timestamp,\n  open: 42000,\n  close: 42000,\n  volume: 0,  // Zero volume!\n});\n\n// System uses fallback: (42000 + 42000 + ...) / n\nconst price = await getAveragePrice(\"BTCUSDT\");\n// Returns: 42000 (simple average)\n```\n\n### Small Dataset Fallback\n\nWhen fewer than 5 candles are available (e.g., newly listed asset, beginning of timeframe), the system uses **simple average** instead of median for anomaly detection.\n\n| Candles Available | Anomaly Detection Method |\n|-------------------|-------------------------|\n| < 5 candles | Simple average of prices |\n| ≥ 5 candles | Median of prices (more robust) |\n\n**Rationale**: Median requires minimum 7-10 data points for statistical stability. With <5 candles (20 price points), average is more stable.\n\nSources: [test/e2e/edge.test.mjs:148-283](), [src/config/params.ts:92-103]()\n\n---\n\n## Integration with Signal Lifecycle\n\nVWAP pricing is used at critical points in the signal lifecycle to ensure realistic execution simulation:\n\n### Entry Price (Scheduled → Opened)\n\nWhen a scheduled signal activates (price reaches `priceOpen`), the system calculates VWAP to determine the **actual entry price**, which may differ from `priceOpen` due to:\n- Volume-weighted slippage\n- Market depth simulation\n- Order book pressure\n\n### Exit Price (Opened → Closed)\n\nWhen a signal closes (TP/SL/time), VWAP is recalculated to determine the **actual exit price**. This accounts for:\n- Exit order execution slippage\n- Market conditions at close time\n- Volume at exit point\n\n### Price Discovery Flow\n\n```mermaid\nsequenceDiagram\n    participant Strategy as \"ClientStrategy\"\n    participant Context as \"ExecutionContext\"\n    participant Exchange as \"ClientExchange\"\n    participant API as \"Exchange API\"\n    \n    Strategy->>Context: getAveragePrice(symbol)\n    Context->>Exchange: getCandles(symbol, '1m', 5)\n    Exchange->>API: fetchOHLCV(symbol, '1m', limit=5)\n    API-->>Exchange: [candle1, candle2, ..., candle5]\n    Exchange->>Exchange: Validate candles (anomaly check)\n    Exchange->>Exchange: Calculate VWAP or fallback\n    Exchange-->>Context: VWAP price\n    Context-->>Strategy: Current market price\n    Strategy->>Strategy: Check TP/SL with VWAP price\n```\n\n**Diagram: VWAP Price Discovery Sequence**\n\nSources: [README.md:189-199]()\n\n---\n\n## Configuration Reference\n\nAll VWAP and data handling parameters are defined in `GLOBAL_CONFIG`.\n\n### Complete Parameter Table\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `CC_AVG_PRICE_CANDLES_COUNT` | `number` | 5 | Number of candles for VWAP calculation |\n| `CC_GET_CANDLES_RETRY_COUNT` | `number` | 3 | Maximum retry attempts for failed requests |\n| `CC_GET_CANDLES_RETRY_DELAY_MS` | `number` | 5000 | Delay between retries (milliseconds) |\n| `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR` | `number` | 1000 | Price deviation threshold (median/factor) |\n| `CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN` | `number` | 5 | Minimum candles for median calculation |\n\n### Customizing Configuration\n\n```typescript\nimport { setConfig } from 'backtest-kit';\n\nsetConfig({\n  CC_AVG_PRICE_CANDLES_COUNT: 10,  // Use 10 candles for VWAP\n  CC_GET_CANDLES_RETRY_COUNT: 5,   // More retries for unstable connection\n  CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR: 500,  // Stricter anomaly detection\n}, true);  // true = replace all config\n```\n\n**Warning**: Changing `CC_AVG_PRICE_CANDLES_COUNT` affects execution realism. Larger buffers smooth out price volatility but may miss short-term opportunities. Smaller buffers are more responsive but may be affected by single-candle anomalies.\n\nSources: [src/config/params.ts:1-122]()\n\n---\n\n## VWAP vs Simple Pricing Comparison\n\n### Impact on Backtest Results\n\n| Pricing Method | Pros | Cons | Use Case |\n|---------------|------|------|----------|\n| **Single Candle Close** | Fast, simple | Unrealistic, cherry-picks prices | Not recommended |\n| **VWAP (5 candles)** | Realistic slippage, accounts for volume | Slightly more complex | **Default, recommended** |\n| **VWAP (20+ candles)** | Smooths volatility, reduces noise | May miss short-term signals | Low-frequency strategies |\n\n### Example: Price Difference\n\n```\nCandle 1: close=42000, volume=100\nCandle 2: close=42010, volume=200\nCandle 3: close=42020, volume=150\nCandle 4: close=42030, volume=50\nCandle 5: close=42040, volume=100\n\nSimple Average: (42000 + 42010 + 42020 + 42030 + 42040) / 5 = 42020\n\nVWAP: (42000×100 + 42010×200 + 42020×150 + 42030×50 + 42040×100) / (100+200+150+50+100)\n    = 25,217,000 / 600\n    = 42,028.33\n\nDifference: 8.33 points (0.02%)\n```\n\nOver hundreds of trades, this difference compounds significantly.\n\nSources: [README.md:22]()\n\n---\n\n## Anomaly Detection Examples\n\n### Case Study: Binance Incomplete Candles\n\n**Problem**: Binance API occasionally returns incomplete candles with prices near $0.01 when data is still being aggregated.\n\n**Without Anomaly Detection**:\n```\nSignal: LONG at priceOpen=$42,000, TP=$43,000\nVWAP calculation includes anomalous candle: $0.01\nCalculated VWAP: $8,400 (average of [$42k, $42k, $0.01, $42k, $42k])\nResult: Signal immediately triggers TP (thinks price jumped to $43k)\n```\n\n**With Anomaly Detection**:\n```\nMedian price: $42,000\nAnomaly threshold: $42,000 / 1000 = $42\nCandle with $0.01 detected: $0.01 < $42 → Anomaly!\nAction: Retry getCandles() (up to 3 attempts)\nResult: Fetch valid data, calculate correct VWAP=$42,015\n```\n\n### Test Coverage\n\nThe test suite includes comprehensive anomaly detection coverage:\n\n**Test File**: [test/e2e/edge.test.mjs:148-283]()\n- Zero volume handling\n- Large profit scenarios (>100%)\n- Price skip scenarios (scheduled signal cancellation)\n\n**Test File**: [test/e2e/sanitize.test.mjs]()\n- Negative price rejection\n- NaN/Infinity price rejection\n- Extreme price validation\n\nSources: [test/e2e/edge.test.mjs:148-283](), [src/config/params.ts:76-90]()\n\n---\n\n## Performance Considerations\n\n### Optimization Strategies\n\n1. **Candle Count**: Default 5 candles balances realism vs. API call overhead\n2. **Retry Logic**: 3 retries with 5s delay prevents excessive API calls\n3. **Median Calculation**: O(n log n) complexity, fast for small datasets\n4. **Volume Check**: Early detection of zero-volume edge case avoids division by zero\n\n### Memory Usage\n\n- **Per Symbol**: 5 candles × ~200 bytes/candle = ~1KB per VWAP calculation\n- **No Persistent Cache**: Candles are fetched fresh on each call (prevents stale data)\n- **Temporal Context**: Leverages `AsyncLocalStorage` for zero-copy context propagation\n\n### API Call Frequency\n\n- **Backtest Mode**: One `getCandles()` call per signal generation (throttled by `interval`)\n- **Live Mode**: One `getCandles()` call per tick (~1 minute with default config)\n- **Retry Impact**: Failed calls trigger 3× more requests, mitigated by 5s delay\n\nSources: [src/config/params.ts:1-122](), [README.md:186-199]()\n\n---\n\n## Edge Cases and Error Handling\n\n### Comprehensive Edge Case Matrix\n\n| Scenario | Detection | Handling | Test Coverage |\n|----------|-----------|----------|---------------|\n| **Zero volume** | Volume sum = 0 | Fallback to simple average | [test/e2e/edge.test.mjs:148-283]() |\n| **Negative prices** | price < 0 | Reject signal, log error | [test/e2e/sanitize.test.mjs:351-443]() |\n| **NaN prices** | !isFinite(price) | Reject signal, log error | [test/e2e/sanitize.test.mjs:455-542]() |\n| **Anomalous prices** | price < median/1000 | Retry fetch (3×) | Config + retry logic |\n| **Empty candle array** | candles.length = 0 | Retry or throw error | Retry logic |\n| **Incomplete candles** | Missing OHLC fields | Validate schema, retry | Exchange validation |\n| **API timeout** | Network error | Retry with backoff | Retry logic |\n| **Rate limit** | 429 HTTP error | Retry with 5s delay | Retry logic |\n\n### Error Propagation\n\n```mermaid\ngraph TD\n    subgraph \"Error Handling Flow\"\n        A[\"getAveragePrice() called\"]\n        B[\"getCandles() attempt\"]\n        C[\"Anomaly detected\"]\n        D[\"Retry logic\"]\n        E[\"Max retries exceeded\"]\n        F[\"Throw Error\"]\n        G[\"Error bubbles to Strategy\"]\n        H[\"Signal validation fails\"]\n        I[\"Signal rejected\"]\n        J[\"Log to errorEmitter\"]\n    end\n    \n    A --> B\n    B --> C\n    C -->|\"attempt < 3\"| D\n    D --> B\n    C -->|\"attempt = 3\"| E\n    E --> F\n    F --> G\n    G --> H\n    H --> I\n    I --> J\n```\n\n**Diagram: Error Propagation Path**\n\n**Critical Principle**: Anomalies in candle data **never** cause signal execution. They either retry or fail the signal entirely, preventing trades based on bad data.\n\nSources: [test/e2e/sanitize.test.mjs](), [src/config/params.ts:66-104]()\n\n---\n\n## Summary\n\nVWAP Pricing & Data Handling in Backtest Kit provides:\n\n1. **Realistic Execution**: Volume-weighted pricing simulates market depth\n2. **Robust Validation**: Multi-stage anomaly detection prevents bad data\n3. **Fallback Mechanisms**: Zero-volume and small-dataset edge cases handled\n4. **Retry Logic**: Transient failures don't crash backtests\n5. **Configuration**: Tunable parameters for different asset classes\n6. **Test Coverage**: Comprehensive edge case testing ensures reliability\n\n**Key Takeaway**: The system prioritizes **data integrity** over speed. If data cannot be validated, the signal is rejected rather than executed with potentially incorrect prices.\n\nFor implementation details of the `getCandles` interface, see [Exchange Configuration](#8.1). For how VWAP integrates with signal pricing, see [Signals & Signal Lifecycle](#3.1).\n\nSources: [README.md:1-255](), [src/config/params.ts:1-122]()"
                    },
                    {
                        "page_plan": {
                            "id": "4",
                            "title": "Architecture Deep Dive"
                        },
                        "content": "# Architecture Deep Dive\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/add.ts](src/function/add.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/function/list.ts](src/function/list.ts)\n- [src/index.ts](src/index.ts)\n- [src/lib/core/provide.ts](src/lib/core/provide.ts)\n- [src/lib/core/types.ts](src/lib/core/types.ts)\n- [src/lib/index.ts](src/lib/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document provides a detailed technical exploration of Backtest Kit's internal architecture, focusing on the dependency injection system, service layer organization, context propagation mechanisms, and architectural patterns. This material is intended for developers who need to understand the framework's internal design, extend its functionality, or troubleshoot complex issues.\n\nFor information about the public API and usage patterns, see [Getting Started](#2). For details on strategy development and signal generation, see [Strategy Development](#6). For client-layer implementation specifics, see [Client Layer](#4.2).\n\n## The Dependency Injection Container\n\nBacktest Kit implements a custom dependency injection container using Symbol-based tokens for type-safe service resolution. The DI system consists of three core components:\n\n1. **TYPES Registry** - Symbol-based tokens for each service\n2. **Service Providers** - Factory functions that instantiate services\n3. **Service Injectors** - Lazy dependency resolution functions\n4. **Backtest Aggregator** - Central object exposing all services\n\n### TYPES Symbol Registry\n\nThe framework defines unique Symbol tokens for each service, organized by category. These symbols serve as dependency injection keys that prevent naming collisions and enable type-safe resolution.\n\n**TYPES Symbol Structure**\n\n```mermaid\ngraph TB\n    subgraph \"TYPES Registry (src/lib/core/types.ts)\"\n        BASE[\"baseServices<br/>loggerService\"]\n        CONTEXT[\"contextServices<br/>executionContextService<br/>methodContextService\"]\n        SCHEMA[\"schemaServices<br/>exchangeSchemaService<br/>strategySchemaService<br/>frameSchemaService<br/>walkerSchemaService<br/>sizingSchemaService<br/>riskSchemaService<br/>optimizerSchemaService\"]\n        VALIDATION[\"validationServices<br/>exchangeValidationService<br/>strategyValidationService<br/>frameValidationService<br/>walkerValidationService<br/>sizingValidationService<br/>riskValidationService<br/>optimizerValidationService<br/>configValidationService<br/>columnValidationService\"]\n        CONNECTION[\"connectionServices<br/>exchangeConnectionService<br/>strategyConnectionService<br/>frameConnectionService<br/>sizingConnectionService<br/>riskConnectionService<br/>optimizerConnectionService<br/>partialConnectionService\"]\n        CORE[\"coreServices<br/>exchangeCoreService<br/>strategyCoreService<br/>frameCoreService\"]\n        GLOBAL[\"globalServices<br/>sizingGlobalService<br/>riskGlobalService<br/>optimizerGlobalService<br/>partialGlobalService\"]\n        COMMAND[\"commandServices<br/>liveCommandService<br/>backtestCommandService<br/>walkerCommandService\"]\n        LOGIC_PRIV[\"logicPrivateServices<br/>backtestLogicPrivateService<br/>liveLogicPrivateService<br/>walkerLogicPrivateService\"]\n        LOGIC_PUB[\"logicPublicServices<br/>backtestLogicPublicService<br/>liveLogicPublicService<br/>walkerLogicPublicService\"]\n        MARKDOWN[\"markdownServices<br/>backtestMarkdownService<br/>liveMarkdownService<br/>scheduleMarkdownService<br/>performanceMarkdownService<br/>walkerMarkdownService<br/>heatMarkdownService<br/>partialMarkdownService<br/>outlineMarkdownService<br/>riskMarkdownService\"]\n        TEMPLATE[\"templateServices<br/>optimizerTemplateService\"]\n    end\n    \n    BASE --> TYPES_EXPORT[\"TYPES Object<br/>Exported from<br/>src/lib/core/types.ts\"]\n    CONTEXT --> TYPES_EXPORT\n    SCHEMA --> TYPES_EXPORT\n    VALIDATION --> TYPES_EXPORT\n    CONNECTION --> TYPES_EXPORT\n    CORE --> TYPES_EXPORT\n    GLOBAL --> TYPES_EXPORT\n    COMMAND --> TYPES_EXPORT\n    LOGIC_PRIV --> TYPES_EXPORT\n    LOGIC_PUB --> TYPES_EXPORT\n    MARKDOWN --> TYPES_EXPORT\n    TEMPLATE --> TYPES_EXPORT\n```\n\nSources: [src/lib/core/types.ts:1-105]()\n\n### Service Provider Registration\n\nService factories are registered via the `provide()` function, which associates each TYPES symbol with a constructor function. The registration happens in [src/lib/core/provide.ts](), organized by service category.\n\n**Service Registration Pattern**\n\n| Category | Registration Example | Constructor |\n|----------|---------------------|-------------|\n| Base Services | `provide(TYPES.loggerService, () => new LoggerService())` | `LoggerService` |\n| Context Services | `provide(TYPES.executionContextService, () => new ExecutionContextService())` | `ExecutionContextService` |\n| Schema Services | `provide(TYPES.strategySchemaService, () => new StrategySchemaService())` | `StrategySchemaService` |\n| Validation Services | `provide(TYPES.strategyValidationService, () => new StrategyValidationService())` | `StrategyValidationService` |\n| Connection Services | `provide(TYPES.strategyConnectionService, () => new StrategyConnectionService())` | `StrategyConnectionService` |\n| Core Services | `provide(TYPES.strategyCoreService, () => new StrategyCoreService())` | `StrategyCoreService` |\n| Command Services | `provide(TYPES.backtestCommandService, () => new BacktestCommandService())` | `BacktestCommandService` |\n| Logic Private Services | `provide(TYPES.backtestLogicPrivateService, () => new BacktestLogicPrivateService())` | `BacktestLogicPrivateService` |\n| Logic Public Services | `provide(TYPES.backtestLogicPublicService, () => new BacktestLogicPublicService())` | `BacktestLogicPublicService` |\n| Markdown Services | `provide(TYPES.backtestMarkdownService, () => new BacktestMarkdownService())` | `BacktestMarkdownService` |\n| Template Services | `provide(TYPES.optimizerTemplateService, () => new OptimizerTemplateService())` | `OptimizerTemplateService` |\n\nSources: [src/lib/core/provide.ts:56-142]()\n\n### Service Injection and the Backtest Aggregator\n\nThe `inject()` function performs lazy dependency resolution. Services are instantiated only when first accessed, enabling circular dependency resolution and reducing initialization overhead.\n\nThe `backtest` object aggregates all injected services into a single namespace, providing a centralized access point for the entire service layer.\n\n**Backtest Object Structure**\n\n```mermaid\ngraph LR\n    subgraph \"Service Injection (src/lib/index.ts)\"\n        INJECT[\"inject() function<br/>Lazy resolution\"]\n        \n        BASE_INJ[\"baseServices<br/>loggerService: inject(TYPES.loggerService)\"]\n        CONTEXT_INJ[\"contextServices<br/>executionContextService: inject(...)<br/>methodContextService: inject(...)\"]\n        SCHEMA_INJ[\"schemaServices<br/>exchangeSchemaService: inject(...)<br/>strategySchemaService: inject(...)<br/>etc...\"]\n        CONN_INJ[\"connectionServices<br/>exchangeConnectionService: inject(...)<br/>strategyConnectionService: inject(...)<br/>etc...\"]\n        CORE_INJ[\"coreServices<br/>exchangeCoreService: inject(...)<br/>strategyCoreService: inject(...)<br/>frameCoreService: inject(...)\"]\n        \n        INJECT -.-> BASE_INJ\n        INJECT -.-> CONTEXT_INJ\n        INJECT -.-> SCHEMA_INJ\n        INJECT -.-> CONN_INJ\n        INJECT -.-> CORE_INJ\n    end\n    \n    BASE_INJ --> BACKTEST[\"backtest Object<br/>Aggregates all services<br/>Export: lib\"]\n    CONTEXT_INJ --> BACKTEST\n    SCHEMA_INJ --> BACKTEST\n    CONN_INJ --> BACKTEST\n    CORE_INJ --> BACKTEST\n```\n\nThe aggregation structure allows services to access other services through the same namespace:\n\n```typescript\n// Inside a service class\nconst strategySchema = backtest.strategySchemaService.get(strategyName);\nconst logger = backtest.loggerService;\nconst context = backtest.executionContextService.context;\n```\n\nSources: [src/lib/index.ts:61-238]()\n\n## Service Layer Organization\n\nThe service layer is organized into 11 distinct categories, each with specific responsibilities. This categorization enforces separation of concerns and prevents circular dependencies through careful layering.\n\n### Service Category Overview\n\n| Category | Purpose | Key Characteristics | Example Services |\n|----------|---------|---------------------|------------------|\n| **Base Services** | Fundamental services used throughout the system | No dependencies on other services | `LoggerService` |\n| **Context Services** | Ambient context propagation using `di-scoped` | Provide implicit context without explicit parameters | `ExecutionContextService`, `MethodContextService` |\n| **Schema Services** | Configuration storage using `ToolRegistry` pattern | Immutable schema registration and retrieval | `StrategySchemaService`, `ExchangeSchemaService` |\n| **Validation Services** | Runtime existence checks with memoization | Fast repeated validation through caching | `StrategyValidationService`, `ExchangeValidationService` |\n| **Connection Services** | Memoized client instance factories | Cache clients by unique keys to prevent redundant instantiation | `StrategyConnectionService`, `ExchangeConnectionService` |\n| **Core Services** | Business logic orchestration | Coordinate execution flow and delegate to clients | `StrategyCoreService`, `ExchangeCoreService` |\n| **Global Services** | Shared state management across strategies | Manage portfolio-wide concerns | `RiskGlobalService`, `PartialGlobalService` |\n| **Logic Private Services** | Internal async generator implementations | Stream results with backpressure control | `BacktestLogicPrivateService`, `LiveLogicPrivateService` |\n| **Logic Public Services** | External API wrappers for logic services | Public interface delegation to private implementations | `BacktestLogicPublicService`, `LiveLogicPublicService` |\n| **Command Services** | Top-level API entry points | Handle validation and delegate to logic services | `BacktestCommandService`, `LiveCommandService` |\n| **Markdown Services** | Event-driven report generation | Subscribe to emitters, accumulate data, generate reports | `BacktestMarkdownService`, `LiveMarkdownService` |\n| **Template Services** | Code generation for optimizer | Generate executable strategy code from schemas | `OptimizerTemplateService` |\n\n### Service Dependency Layers\n\nThe service architecture follows a strict layering principle to prevent circular dependencies. Lower layers have no knowledge of higher layers.\n\n**Service Dependency Hierarchy**\n\n```mermaid\ngraph TB\n    subgraph \"Layer 1: Foundation\"\n        BASE[\"Base Services<br/>LoggerService\"]\n    end\n    \n    subgraph \"Layer 2: Context\"\n        CONTEXT[\"Context Services<br/>ExecutionContextService<br/>MethodContextService\"]\n    end\n    \n    subgraph \"Layer 3: Configuration\"\n        SCHEMA[\"Schema Services<br/>Store user configs\"]\n        VALIDATION[\"Validation Services<br/>Existence checks\"]\n    end\n    \n    subgraph \"Layer 4: Client Management\"\n        CONNECTION[\"Connection Services<br/>Memoized client factories\"]\n    end\n    \n    subgraph \"Layer 5: Core Logic\"\n        CORE[\"Core Services<br/>Business logic orchestration\"]\n        GLOBAL[\"Global Services<br/>Shared state management\"]\n    end\n    \n    subgraph \"Layer 6: Execution\"\n        LOGIC_PRIV[\"Logic Private Services<br/>Async generators\"]\n    end\n    \n    subgraph \"Layer 7: Public API\"\n        LOGIC_PUB[\"Logic Public Services<br/>API wrappers\"]\n        COMMAND[\"Command Services<br/>Entry points\"]\n    end\n    \n    subgraph \"Layer 8: Reporting\"\n        MARKDOWN[\"Markdown Services<br/>Event subscribers\"]\n        TEMPLATE[\"Template Services<br/>Code generation\"]\n    end\n    \n    BASE --> CONTEXT\n    BASE --> SCHEMA\n    BASE --> VALIDATION\n    \n    CONTEXT --> CONNECTION\n    SCHEMA --> VALIDATION\n    SCHEMA --> CONNECTION\n    \n    VALIDATION --> CORE\n    CONNECTION --> CORE\n    CONNECTION --> GLOBAL\n    \n    CORE --> LOGIC_PRIV\n    GLOBAL --> LOGIC_PRIV\n    \n    LOGIC_PRIV --> LOGIC_PUB\n    \n    LOGIC_PUB --> COMMAND\n    VALIDATION --> COMMAND\n    SCHEMA --> COMMAND\n    \n    LOGIC_PRIV -.->|subscribe| MARKDOWN\n    SCHEMA --> TEMPLATE\n```\n\nSources: [src/lib/index.ts:61-238](), [src/lib/core/provide.ts:1-143]()\n\n### Service Category Implementation Details\n\nEach service category follows specific patterns and conventions:\n\n**1. Base Services** - Provide fundamental capabilities without dependencies:\n```typescript\n// LoggerService has no dependencies\nclass LoggerService {\n    log(topic: string, ...args: any[]): void;\n    debug(topic: string, ...args: any[]): void;\n    info(topic: string, ...args: any[]): void;\n    warn(topic: string, ...args: any[]): void;\n}\n```\n\n**2. Context Services** - Use `di-scoped` for context propagation:\n- `ExecutionContextService` contains: `{ symbol, when, backtest }`\n- `MethodContextService` contains: `{ strategyName, exchangeName, frameName }`\n- Both extend `di-scoped.IScopedClassRun` for `runInContext()` method\n\n**3. Schema Services** - Implement registry pattern with `ToolRegistry`:\n- `register(name: string, schema: ISchema): void`\n- `get(name: string): ISchema`\n- `has(name: string): boolean`\n- `list(): ISchema[]`\n\n**4. Validation Services** - Provide memoized existence checks:\n- `addStrategy(name: string, schema: ISchema): void` (validates no duplicates)\n- `strategyExists(name: string): boolean` (memoized)\n- `list(): ISchema[]` (returns all schemas)\n\n**5. Connection Services** - Create and cache client instances:\n- Use `functools-kit` `memoize()` decorator\n- Cache key: unique identifier (e.g., `strategyName`, `exchangeName`)\n- Return cached instance on subsequent calls with same key\n\n**6. Core Services** - Orchestrate execution:\n- Retrieve clients from connection services\n- Delegate method calls to client instances\n- Handle execution context propagation\n\n**7. Global Services** - Manage shared state:\n- Track portfolio-wide metrics\n- Coordinate cross-strategy concerns\n- Provide centralized state access\n\n**8. Logic Private Services** - Implement async generators:\n- `async *run(symbol: string)` yields results progressively\n- Handle timeframe iteration (backtest) or infinite loop (live)\n- Skip frames based on signal state\n\n**9. Logic Public Services** - Wrap private implementations:\n- Validate parameters before delegation\n- Provide public-facing API surface\n- Simplify complex private logic\n\n**10. Command Services** - Entry points for public API:\n- Validate all required schemas exist\n- Set up contexts via `MethodContextService`\n- Delegate to logic services\n\n**11. Markdown Services** - Generate reports from events:\n- Subscribe to relevant emitters\n- Accumulate events in `ReportStorage`\n- Calculate statistics on demand\n- Generate formatted markdown tables\n\nSources: [types.d.ts:1-100](), [src/lib/core/provide.ts:56-142]()\n\n## Context Propagation Architecture\n\nBacktest Kit uses the `di-scoped` library to propagate ambient context throughout the execution stack without explicit parameter passing. This approach eliminates parameter drilling while maintaining type safety.\n\n### Context Services\n\nTwo context services provide different levels of ambient information:\n\n**ExecutionContextService** - Runtime execution parameters:\n```typescript\ninterface IExecutionContext {\n    symbol: string;        // Trading pair (e.g., \"BTCUSDT\")\n    when: Date;           // Current timestamp for operation\n    backtest: boolean;    // true = backtest mode, false = live mode\n}\n```\n\n**MethodContextService** - Schema routing information:\n```typescript\ninterface IMethodContext {\n    exchangeName: ExchangeName;   // Which exchange schema to use\n    strategyName: StrategyName;   // Which strategy schema to use\n    frameName: FrameName;         // Which frame schema to use (empty for live)\n}\n```\n\n### Context Propagation Flow\n\n```mermaid\ngraph TB\n    subgraph \"Public API Layer\"\n        BACKTEST_RUN[\"Backtest.run()<br/>symbol: 'BTCUSDT'<br/>context: { strategyName, exchangeName, frameName }\"]\n        LIVE_RUN[\"Live.run()<br/>symbol: 'BTCUSDT'<br/>context: { strategyName, exchangeName }\"]\n    end\n    \n    subgraph \"Method Context Setup\"\n        METHOD_CTX[\"MethodContextService.runAsyncIterator()<br/>Sets: strategyName, exchangeName, frameName<br/>Wraps: async generator\"]\n    end\n    \n    subgraph \"Logic Layer\"\n        LOGIC[\"BacktestLogicPrivateService.run()<br/>Iterates timeframes<br/>For each frame:\"]\n    end\n    \n    subgraph \"Execution Context Setup\"\n        EXEC_CTX[\"ExecutionContextService.runInContext()<br/>Sets: symbol, when, backtest=true<br/>Calls: StrategyGlobalService.tick()\"]\n    end\n    \n    subgraph \"Core Service Layer\"\n        CORE[\"StrategyCoreService.tick()<br/>Accesses contexts:<br/>- executionContextService.context<br/>- methodContextService.context\"]\n    end\n    \n    subgraph \"Connection Layer\"\n        CONN[\"StrategyConnectionService.getStrategy()<br/>Uses methodContextService.context.strategyName<br/>Returns: memoized ClientStrategy\"]\n    end\n    \n    subgraph \"Client Layer\"\n        CLIENT[\"ClientStrategy.tick()<br/>Uses executionContextService.context:<br/>- symbol, when, backtest\"]\n    end\n    \n    BACKTEST_RUN --> METHOD_CTX\n    LIVE_RUN --> METHOD_CTX\n    METHOD_CTX --> LOGIC\n    LOGIC --> EXEC_CTX\n    EXEC_CTX --> CORE\n    CORE --> CONN\n    CONN --> CLIENT\n```\n\n### Context Access Pattern\n\nServices access context through the context services without receiving context as parameters:\n\n```typescript\n// Inside StrategyCoreService\nclass StrategyCoreService {\n    async tick() {\n        // Access execution context (symbol, when, backtest)\n        const execCtx = this.executionContextService.context;\n        const { symbol, when, backtest } = execCtx;\n        \n        // Access method context (strategyName, exchangeName, frameName)\n        const methodCtx = this.methodContextService.context;\n        const { strategyName, exchangeName } = methodCtx;\n        \n        // Use contexts without explicit parameters\n        const strategy = this.strategyConnectionService.getStrategy(strategyName);\n        return await strategy.tick(symbol, when, backtest);\n    }\n}\n```\n\nThe `di-scoped` library manages context scope boundaries:\n- `runInContext(callback, context)` - Execute callback with specific context\n- `runAsyncIterator(generator, context)` - Execute async generator with context\n- Context automatically available to all code within callback/generator scope\n\nSources: [types.d.ts:6-49](), [types.d.ts:296-337]()\n\n## Memoization Strategy\n\nConnection services use memoization to cache client instances, preventing redundant instantiation and improving performance. This pattern is critical for maintaining consistent state across multiple calls.\n\n### Connection Service Memoization Pattern\n\n**StrategyConnectionService Example**\n\n```mermaid\ngraph LR\n    subgraph \"StrategyConnectionService\"\n        GET_STRATEGY[\"getStrategy(strategyName)<br/>Memoized method\"]\n        CREATE[\"createStrategy(strategyName)<br/>Factory method\"]\n        CACHE[\"Memoization Cache<br/>Key: strategyName<br/>Value: ClientStrategy instance\"]\n    end\n    \n    subgraph \"First Call\"\n        CALL1[\"getStrategy('my-strategy')\"]\n        MISS1[\"Cache miss\"]\n        CREATE1[\"Create new ClientStrategy\"]\n        STORE1[\"Store in cache\"]\n        RETURN1[\"Return instance\"]\n    end\n    \n    subgraph \"Subsequent Calls\"\n        CALL2[\"getStrategy('my-strategy')\"]\n        HIT2[\"Cache hit\"]\n        RETURN2[\"Return cached instance\"]\n    end\n    \n    CALL1 --> MISS1\n    MISS1 --> CREATE1\n    CREATE1 --> STORE1\n    STORE1 --> RETURN1\n    \n    CALL2 --> HIT2\n    HIT2 --> RETURN2\n    \n    GET_STRATEGY -.->|uses| CACHE\n    CREATE -.->|creates| ClientStrategy[\"ClientStrategy instance<br/>Maintains internal state\"]\n```\n\n### Memoization Benefits\n\n| Benefit | Description | Impact |\n|---------|-------------|--------|\n| **Performance** | Avoids repeated instantiation of expensive client objects | Reduces CPU and memory overhead |\n| **State Consistency** | Same instance returned for same key ensures consistent state | Prevents duplicate signals, maintains accurate tracking |\n| **Memory Efficiency** | Single instance per unique key rather than per call | Reduces memory footprint for long-running processes |\n| **Deterministic Behavior** | Predictable instance resolution simplifies debugging | Easier to reason about system state |\n\n### Memoization Cache Keys\n\nDifferent connection services use different cache key strategies:\n\n| Connection Service | Cache Key | Example |\n|-------------------|-----------|---------|\n| `StrategyConnectionService` | `strategyName` | `\"my-strategy\"` |\n| `ExchangeConnectionService` | `exchangeName` | `\"binance\"` |\n| `FrameConnectionService` | `frameName` | `\"1d-backtest\"` |\n| `RiskConnectionService` | `riskName` | `\"conservative\"` |\n| `PartialConnectionService` | `symbol` | `\"BTCUSDT\"` |\n| `OptimizerConnectionService` | `optimizerName` | `\"llm-generator\"` |\n\n### Implementation Details\n\nConnection services implement a consistent pattern:\n\n1. **Schema Retrieval** - Get schema from schema service\n2. **Parameter Assembly** - Build client constructor parameters\n3. **Client Instantiation** - Create new client with parameters\n4. **Memoized Getter** - Cache instance by unique key\n\nExample pseudo-pattern:\n```typescript\nclass ConnectionService {\n    // Memoized getter (implemented via functools-kit memoize decorator)\n    getClient(name: string) {\n        const schema = this.schemaService.get(name);\n        return this.createClient(schema);\n    }\n    \n    // Factory method (non-memoized)\n    private createClient(schema: ISchema) {\n        return new Client({\n            ...schema,\n            logger: this.loggerService,\n            execution: this.executionContextService,\n            // ... other dependencies\n        });\n    }\n}\n```\n\nSources: [src/lib/index.ts:74-96](), [types.d.ts:102-209]()\n\n## Service Dependency Graph\n\nThe service layer exhibits a carefully designed dependency structure that avoids circular dependencies while enabling rich functionality. Dependencies flow from lower layers to higher layers, with context services providing cross-cutting concerns.\n\n### Key Service Dependencies\n\n**Command Service Dependencies**\n\n```mermaid\ngraph TB\n    subgraph \"BacktestCommandService\"\n        BCmdLogger[\"loggerService\"]\n        BCmdStratSchema[\"strategySchemaService\"]\n        BCmdRiskVal[\"riskValidationService\"]\n        BCmdLogicPub[\"backtestLogicPublicService\"]\n        BCmdStratVal[\"strategyValidationService\"]\n        BCmdExchVal[\"exchangeValidationService\"]\n        BCmdFrameVal[\"frameValidationService\"]\n    end\n    \n    subgraph \"BacktestLogicPublicService\"\n        BPubLogger[\"loggerService\"]\n        BPubLogicPriv[\"backtestLogicPrivateService\"]\n    end\n    \n    subgraph \"BacktestLogicPrivateService\"\n        BPrivLogger[\"loggerService\"]\n        BPrivStratCore[\"strategyCoreService\"]\n        BPrivExchCore[\"exchangeCoreService\"]\n        BPrivFrameCore[\"frameCoreService\"]\n        BPrivMethod[\"methodContextService\"]\n    end\n    \n    subgraph \"StrategyCoreService\"\n        SCoreLogger[\"loggerService\"]\n        SCoreStratConn[\"strategyConnectionService\"]\n        SCoreStratSchema[\"strategySchemaService\"]\n        SCoreRiskVal[\"riskValidationService\"]\n        SCoreStratVal[\"strategyValidationService\"]\n        SCoreMethod[\"methodContextService\"]\n    end\n    \n    BCmdLogicPub --> BPubLogicPriv\n    BPubLogicPriv --> BPrivStratCore\n    BPrivStratCore --> SCoreStratConn\n```\n\n### Cross-Service Communication Patterns\n\nServices communicate through well-defined patterns:\n\n**1. Direct Dependency Injection**\n- Service A injects Service B via TYPES symbol\n- Service A calls methods on Service B\n- Example: `StrategyCoreService` → `StrategyConnectionService`\n\n**2. Context-Based Communication**\n- Services read ambient context without direct coupling\n- Example: All services access `ExecutionContextService.context`\n\n**3. Event-Based Communication**\n- Services emit events to subjects\n- Other services subscribe to subjects\n- Example: `ClientStrategy` emits to `signalEmitter`, `MarkdownService` subscribes\n\n**4. Schema Registry Pattern**\n- Services store configurations in schema services\n- Other services retrieve configurations by name\n- Example: `StrategySchemaService.register()` → `StrategyConnectionService.get()`\n\n### Acyclic Dependency Enforcement\n\nThe architecture prevents circular dependencies through:\n\n| Mechanism | Description | Example |\n|-----------|-------------|---------|\n| **Layered Architecture** | Higher layers depend on lower layers, never reverse | Command → Logic → Core → Connection |\n| **Context Services** | Provide cross-cutting concerns without coupling | Services access context without depending on setter |\n| **Event System** | Decouple producers from consumers | Strategy emits signal, markdown subscribes (no direct dependency) |\n| **Registry Pattern** | Schemas stored centrally, accessed by name | Strategy registers schema, connection service retrieves it |\n\n**Dependency Flow Direction**\n\n```mermaid\ngraph LR\n    SCHEMA[\"Schema Services<br/>Configuration storage\"] --> VALIDATION[\"Validation Services<br/>Existence checks\"]\n    SCHEMA --> CONNECTION[\"Connection Services<br/>Client factories\"]\n    VALIDATION --> CORE[\"Core Services<br/>Orchestration\"]\n    CONNECTION --> CORE\n    CORE --> LOGIC_PRIV[\"Logic Private<br/>Generators\"]\n    LOGIC_PRIV --> LOGIC_PUB[\"Logic Public<br/>API wrappers\"]\n    LOGIC_PUB --> COMMAND[\"Command Services<br/>Entry points\"]\n    \n    CONTEXT[\"Context Services<br/>Ambient context\"] -.->|used by| CONNECTION\n    CONTEXT -.->|used by| CORE\n    CONTEXT -.->|used by| LOGIC_PRIV\n    \n    BASE[\"Base Services<br/>Logger\"] -.->|used by| SCHEMA\n    BASE -.->|used by| VALIDATION\n    BASE -.->|used by| CONNECTION\n    BASE -.->|used by| CORE\n```\n\nSources: [src/lib/index.ts:61-238](), [docs/uml.puml:1-507]()\n\n## Initialization Flow\n\nThe framework initialization follows a specific sequence to ensure all services are properly configured before execution begins.\n\n### Initialization Sequence\n\n```mermaid\nsequenceDiagram\n    participant Import as Module Import\n    participant Provide as provide.ts\n    participant DI as DI Container\n    participant Init as init()\n    participant Backtest as backtest Object\n    \n    Import->>Provide: Execute provide.ts\n    Note over Provide: Registers all service factories\n    Provide->>DI: provide(TYPES.loggerService, factory)\n    Provide->>DI: provide(TYPES.executionContextService, factory)\n    Provide->>DI: provide(TYPES.strategySchemaService, factory)\n    Provide->>DI: ... (all services)\n    \n    Import->>Init: Call init()\n    Note over Init: Triggers lazy resolution setup\n    Init->>DI: Initialize DI container\n    \n    Import->>Backtest: Export backtest object\n    Note over Backtest: All services available via inject()\n    \n    Backtest->>DI: First access to service\n    DI->>DI: Instantiate service (lazy)\n    DI->>Backtest: Return instance\n```\n\n### Lazy Dependency Resolution\n\nServices are instantiated only when first accessed, not during module import. This enables:\n\n1. **Circular Dependency Handling** - Services can depend on each other if resolution is lazy\n2. **Reduced Startup Time** - Only used services are instantiated\n3. **Memory Efficiency** - Unused services never allocate memory\n4. **Configuration Flexibility** - Services can be configured before first use\n\n**Lazy Resolution Example:**\n\n```typescript\n// src/lib/index.ts\nimport \"./core/provide\";  // Registers all factories (no instantiation)\nimport { inject, init } from \"./core/di\";\n\n// Services are injected but not yet instantiated\nconst backtest = {\n    loggerService: inject(TYPES.loggerService),  // Returns getter function\n    strategyCoreService: inject(TYPES.strategyCoreService),  // Returns getter function\n    // ... all other services\n};\n\ninit();  // Initialize DI container\n\nexport { backtest };  // Export service accessors\n\n// When backtest.loggerService is first accessed:\n// 1. DI container calls factory: () => new LoggerService()\n// 2. Instance is cached for future access\n// 3. Same instance returned on subsequent access\n```\n\n### Service Access Patterns\n\n| Access Pattern | Use Case | Example |\n|----------------|----------|---------|\n| **Direct Property Access** | Internal service communication | `this.loggerService.log(...)` |\n| **inject() Function** | Service injection in constructors | `inject(TYPES.loggerService)` |\n| **backtest Object** | External API implementation | `backtest.strategySchemaService.get(name)` |\n\nSources: [src/lib/index.ts:1-246](), [src/lib/core/provide.ts:1-143]()\n\n## Type Safety and IntelliSense\n\nThe framework maintains full TypeScript type safety across the entire service layer through carefully designed type exports and declarations.\n\n### Service Type Exports\n\nThe `types.d.ts` file declares all service interfaces and their relationships, enabling IDE IntelliSense and compile-time type checking:\n\n```typescript\n// Context service types\ndeclare const ExecutionContextService: (new () => {\n    readonly context: IExecutionContext;\n}) & IScopedClassRun<[context: IExecutionContext]>;\n\ntype TExecutionContextService = InstanceType<typeof ExecutionContextService>;\n```\n\n### Type Flow Through Layers\n\n```mermaid\ngraph TB\n    subgraph \"Type Definitions (types.d.ts)\"\n        INTERFACES[\"Interfaces<br/>IExchangeSchema<br/>IStrategySchema<br/>IFrameSchema<br/>etc.\"]\n        CONTRACTS[\"Contract Types<br/>DoneContract<br/>PerformanceContract<br/>etc.\"]\n        RESULT_TYPES[\"Result Types<br/>IStrategyTickResult<br/>IStrategyBacktestResult\"]\n    end\n    \n    subgraph \"Service Implementations\"\n        SCHEMA_SVC[\"Schema Services<br/>Use interface types for storage\"]\n        CONN_SVC[\"Connection Services<br/>Return typed client instances\"]\n        LOGIC_SVC[\"Logic Services<br/>Yield typed results\"]\n    end\n    \n    subgraph \"Public API\"\n        ADD_FUNCS[\"add*() functions<br/>Accept interface types\"]\n        EVENT_FUNCS[\"listen*() functions<br/>Receive typed events\"]\n        CLASS_API[\"Class methods<br/>Return typed results\"]\n    end\n    \n    INTERFACES --> SCHEMA_SVC\n    INTERFACES --> ADD_FUNCS\n    \n    CONTRACTS --> LOGIC_SVC\n    CONTRACTS --> EVENT_FUNCS\n    \n    RESULT_TYPES --> CONN_SVC\n    RESULT_TYPES --> CLASS_API\n```\n\nFull type safety is maintained from user-facing API through internal service layer to client implementations, ensuring compile-time error detection and rich IDE support.\n\nSources: [types.d.ts:1-100](), [src/index.ts:1-199]()"
                    },
                    {
                        "page_plan": {
                            "id": "4.1",
                            "title": "Service Layer & Dependency Injection"
                        },
                        "content": "# Service Layer & Dependency Injection\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/function/add.ts](src/function/add.ts)\n- [src/function/list.ts](src/function/list.ts)\n- [src/lib/core/provide.ts](src/lib/core/provide.ts)\n- [src/lib/core/types.ts](src/lib/core/types.ts)\n- [src/lib/index.ts](src/lib/index.ts)\n\n</details>\n\n\n\nThis page documents the service layer architecture and dependency injection (DI) system that powers the backtest-kit framework. The service layer provides a structured approach to organizing business logic, managing dependencies, and enabling testability through inversion of control.\n\n**Scope**: This page covers the DI container implementation, the 11 service categories, and how services are registered and resolved. For details on the actual client business logic (ClientStrategy, ClientExchange, etc.), see [Client Layer](#4.2). For memoization patterns used by connection services, see [Connection Services & Memoization](#4.3).\n\n---\n\n## Overview & Purpose\n\nThe service layer acts as the glue between the public API (addStrategy, Backtest.run, etc.) and the core business logic (ClientStrategy, ClientExchange). It provides:\n\n- **Dependency Injection**: Symbol-based tokens enable lazy instantiation and testability\n- **Separation of Concerns**: 11 distinct service categories organize responsibilities\n- **Context Propagation**: ExecutionContext and MethodContext flow through the call stack\n- **Memoization**: Connection services cache client instances by schema name\n- **Acyclic Dependencies**: Careful layering prevents circular dependency issues\n\nThe framework uses a custom DI container rather than a third-party library to maintain zero runtime dependencies and optimize for the specific patterns needed (memoization, context services, lazy initialization).\n\n**Sources**: [docs/internals.md:28-39](), [src/lib/index.ts:1-246]()\n\n---\n\n## Dependency Injection Container\n\nThe DI container consists of three core mechanisms defined across three files:\n\n### TYPES Symbol Registry\n\nThe `TYPES` object in [src/lib/core/types.ts:1-105]() defines unique Symbol identifiers for every service in the framework:\n\n```typescript\nconst baseServices = {\n    loggerService: Symbol('loggerService'),\n};\n\nconst contextServices = {\n    executionContextService: Symbol('executionContextService'),\n    methodContextService: Symbol('methodContextService'),\n};\n\nconst connectionServices = {\n    exchangeConnectionService: Symbol('exchangeConnectionService'),\n    strategyConnectionService: Symbol('strategyConnectionService'),\n    frameConnectionService: Symbol('frameConnectionService'),\n    // ... 4 more\n};\n\n// ... 8 more service categories\n\nexport const TYPES = {\n    ...baseServices,\n    ...contextServices,\n    ...connectionServices,\n    ...schemaServices,\n    ...coreServices,\n    ...globalServices,\n    ...commandServices,\n    ...logicPrivateServices,\n    ...logicPublicServices,\n    ...markdownServices,\n    ...validationServices,\n    ...templateServices,\n}\n```\n\nThe Symbol-based approach ensures:\n- **Type Safety**: TypeScript can enforce correct usage\n- **No Name Collisions**: Symbols are globally unique\n- **IDE Support**: Autocomplete works across the codebase\n\n### Registration with `provide()`\n\nThe [src/lib/core/provide.ts:1-143]() file registers factory functions for each service:\n\n```typescript\n// Base Services\n{\n    provide(TYPES.loggerService, () => new LoggerService());\n}\n\n// Context Services\n{\n    provide(TYPES.executionContextService, () => new ExecutionContextService());\n    provide(TYPES.methodContextService, () => new MethodContextService());\n}\n\n// Connection Services\n{\n    provide(TYPES.exchangeConnectionService, () => new ExchangeConnectionService());\n    provide(TYPES.strategyConnectionService, () => new StrategyConnectionService());\n    // ... 5 more\n}\n\n// ... 8 more categories\n```\n\nEach `provide()` call maps a Symbol token to a factory function. The factory is not invoked immediately—services are lazily instantiated on first use.\n\n### Resolution with `inject()` and `init()`\n\nThe [src/lib/index.ts:1-246]() file uses `inject()` to create lazy resolvers for each service:\n\n```typescript\nconst baseServices = {\n  loggerService: inject<LoggerService>(TYPES.loggerService),\n};\n\nconst contextServices = {\n  executionContextService: inject<TExecutionContextService>(\n    TYPES.executionContextService\n  ),\n  methodContextService: inject<TMethodContextService>(\n    TYPES.methodContextService\n  ),\n};\n\n// ... more categories\n\nexport const backtest = {\n  ...baseServices,\n  ...contextServices,\n  ...connectionServices,\n  ...schemaServices,\n  ...coreServices,\n  ...globalServices,\n  ...commandServices,\n  ...logicPrivateServices,\n  ...logicPublicServices,\n  ...markdownServices,\n  ...validationServices,\n  ...templateServices,\n};\n\ninit();\n```\n\nThe `init()` call at the end triggers initialization of the DI container. After this point, any access to `backtest.loggerService` will instantiate the service (if not already created) and return the singleton instance.\n\n**Sources**: [src/lib/core/types.ts:1-105](), [src/lib/core/provide.ts:1-143](), [src/lib/index.ts:1-246]()\n\n---\n\n## DI Container Architecture\n\nThe following diagram shows how the three DI mechanisms work together:\n\n```mermaid\ngraph TB\n    subgraph \"types.ts - Symbol Registry\"\n        TYPES[\"TYPES Object\"]\n        LOGGER_SYM[\"Symbol('loggerService')\"]\n        EXEC_SYM[\"Symbol('executionContextService')\"]\n        STRAT_CONN_SYM[\"Symbol('strategyConnectionService')\"]\n        \n        TYPES --> LOGGER_SYM\n        TYPES --> EXEC_SYM\n        TYPES --> STRAT_CONN_SYM\n    end\n    \n    subgraph \"provide.ts - Factory Registration\"\n        PROVIDE[\"provide() Function\"]\n        LOGGER_FACTORY[\"() => new LoggerService()\"]\n        EXEC_FACTORY[\"() => new ExecutionContextService()\"]\n        STRAT_FACTORY[\"() => new StrategyConnectionService()\"]\n        \n        PROVIDE --> LOGGER_FACTORY\n        PROVIDE --> EXEC_FACTORY\n        PROVIDE --> STRAT_FACTORY\n    end\n    \n    subgraph \"index.ts - Service Aggregation\"\n        INJECT[\"inject() Function\"]\n        INIT[\"init() Function\"]\n        BACKTEST[\"backtest Object\"]\n        LOGGER_REF[\"backtest.loggerService\"]\n        EXEC_REF[\"backtest.executionContextService\"]\n        STRAT_REF[\"backtest.strategyConnectionService\"]\n        \n        INJECT --> LOGGER_REF\n        INJECT --> EXEC_REF\n        INJECT --> STRAT_REF\n        BACKTEST --> LOGGER_REF\n        BACKTEST --> EXEC_REF\n        BACKTEST --> STRAT_REF\n        INIT --> BACKTEST\n    end\n    \n    subgraph \"Runtime Instantiation\"\n        CONTAINER[\"DI Container\"]\n        LOGGER_INST[\"LoggerService Instance\"]\n        EXEC_INST[\"ExecutionContextService Instance\"]\n        STRAT_INST[\"StrategyConnectionService Instance\"]\n        \n        CONTAINER --> LOGGER_INST\n        CONTAINER --> EXEC_INST\n        CONTAINER --> STRAT_INST\n    end\n    \n    LOGGER_SYM -.->|\"maps to\"| LOGGER_FACTORY\n    EXEC_SYM -.->|\"maps to\"| EXEC_FACTORY\n    STRAT_CONN_SYM -.->|\"maps to\"| STRAT_FACTORY\n    \n    LOGGER_REF -.->|\"resolves via\"| LOGGER_SYM\n    EXEC_REF -.->|\"resolves via\"| EXEC_SYM\n    STRAT_REF -.->|\"resolves via\"| STRAT_CONN_SYM\n    \n    LOGGER_FACTORY -.->|\"creates\"| LOGGER_INST\n    EXEC_FACTORY -.->|\"creates\"| EXEC_INST\n    STRAT_FACTORY -.->|\"creates\"| STRAT_INST\n```\n\n**Sources**: [src/lib/core/types.ts:1-105](), [src/lib/core/provide.ts:1-143](), [src/lib/index.ts:1-246]()\n\n---\n\n## The 11 Service Categories\n\nThe framework organizes services into 11 distinct categories, each with a specific responsibility. This structure is reflected in both [src/lib/core/types.ts]() and [src/lib/index.ts]().\n\n### Category Summary Table\n\n| Category | Count | Responsibility | Example Services |\n|----------|-------|----------------|------------------|\n| **Base Services** | 1 | Centralized logging with context | LoggerService |\n| **Context Services** | 2 | Ambient context propagation | ExecutionContextService, MethodContextService |\n| **Schema Services** | 7 | Configuration storage (ToolRegistry pattern) | StrategySchemaService, ExchangeSchemaService |\n| **Validation Services** | 9 | Existence checks and shallow validation | StrategyValidationService, ConfigValidationService |\n| **Connection Services** | 7 | Memoized client instance factories | StrategyConnectionService, ExchangeConnectionService |\n| **Core Services** | 3 | Business logic orchestration | StrategyCoreService, ExchangeCoreService |\n| **Global Services** | 4 | Shared state management | RiskGlobalService, PartialGlobalService |\n| **Logic Services (Private)** | 3 | Internal execution implementation | BacktestLogicPrivateService, LiveLogicPrivateService |\n| **Logic Services (Public)** | 3 | External API wrappers | BacktestLogicPublicService, LiveLogicPublicService |\n| **Command Services** | 3 | Top-level API entry points | BacktestCommandService, LiveCommandService |\n| **Markdown Services** | 9 | Event-driven report generation | BacktestMarkdownService, LiveMarkdownService |\n| **Template Services** | 1 | Code generation for optimizers | OptimizerTemplateService |\n\n**Total Services**: 52\n\n**Sources**: [src/lib/core/types.ts:1-105](), [src/lib/index.ts:61-238]()\n\n---\n\n## Service Category Details\n\n### 1. Base Services\n\n**Purpose**: Provide foundational infrastructure needed by all other services.\n\n**Services**:\n- `LoggerService`: Centralized logging with automatic context injection (symbol, strategyName, timestamp). Wraps user-provided ILogger implementation.\n\n**Location**: [src/lib/index.ts:61-63]()\n\n**Usage Pattern**:\n```typescript\nbacktest.loggerService.info('methodName', { data });\nbacktest.loggerService.log('simple message');\n```\n\n### 2. Context Services\n\n**Purpose**: Propagate ambient information throughout the call stack without explicit parameter passing.\n\n**Services**:\n- `ExecutionContextService`: Manages `symbol`, `when` (timestamp), and `backtest` flag. Used by ClientStrategy to determine execution mode.\n- `MethodContextService`: Manages `strategyName`, `exchangeName`, `frameName`. Used by connection services to route operations.\n\n**Location**: [src/lib/index.ts:65-72]()\n\n**Context Flow Pattern**:\n```typescript\n// Set method context at API boundary\nMethodContextService.runInContext(() => {\n  // Set execution context per tick\n  ExecutionContextService.runInContext(() => {\n    // All services can now access context without parameters\n    strategyCoreService.tick(); // knows symbol, when, strategyName\n  }, { symbol, when, backtest });\n}, { strategyName, exchangeName, frameName });\n```\n\n**Sources**: [docs/internals.md:47](), [src/lib/index.ts:65-72]()\n\n### 3. Schema Services\n\n**Purpose**: Store immutable user-provided configurations using the ToolRegistry pattern.\n\n**Services**:\n- `StrategySchemaService`: Stores IStrategySchema objects\n- `ExchangeSchemaService`: Stores IExchangeSchema objects  \n- `FrameSchemaService`: Stores IFrameSchema objects\n- `WalkerSchemaService`: Stores IWalkerSchema objects\n- `SizingSchemaService`: Stores ISizingSchema objects\n- `RiskSchemaService`: Stores IRiskSchema objects\n- `OptimizerSchemaService`: Stores IOptimizerSchema objects\n\n**Location**: [src/lib/index.ts:98-112]()\n\n**Registration Pattern**:\n```typescript\n// From addStrategy function\nbacktest.strategySchemaService.register(\n  strategySchema.strategyName,\n  strategySchema\n);\n```\n\n**Retrieval Pattern**:\n```typescript\nconst schema = backtest.strategySchemaService.get(strategyName);\n```\n\n**Sources**: [src/function/add.ts:52-64](), [src/lib/index.ts:98-112]()\n\n### 4. Validation Services\n\n**Purpose**: Perform memoized existence checks and shallow validation of schema references.\n\n**Services**:\n- `StrategyValidationService`: Validates strategy names exist\n- `ExchangeValidationService`: Validates exchange names exist\n- `FrameValidationService`: Validates frame names exist\n- `WalkerValidationService`: Validates walker names exist\n- `SizingValidationService`: Validates sizing names exist\n- `RiskValidationService`: Validates risk names exist and checks circular dependencies in riskList\n- `OptimizerValidationService`: Validates optimizer names exist\n- `ConfigValidationService`: Validates GLOBAL_CONFIG parameters\n- `ColumnValidationService`: Validates report column configurations\n\n**Location**: [src/lib/index.ts:189-217]()\n\n**Usage Pattern**:\n```typescript\n// Before executing backtest, validate all required schemas exist\nawait backtest.strategyValidationService.assertExist(strategyName);\nawait backtest.exchangeValidationService.assertExist(exchangeName);\nawait backtest.frameValidationService.assertExist(frameName);\n```\n\n**List Pattern**:\n```typescript\n// Used by listStrategies() function\nconst strategies = await backtest.strategyValidationService.list();\n```\n\n**Sources**: [src/function/list.ts:78-81](), [src/lib/index.ts:189-217]()\n\n### 5. Connection Services\n\n**Purpose**: Create and cache (memoize) client instances by unique keys to prevent redundant instantiation.\n\n**Services**:\n- `StrategyConnectionService`: Creates ClientStrategy instances per `symbol:strategyName`\n- `ExchangeConnectionService`: Creates ClientExchange instances per `exchangeName`\n- `FrameConnectionService`: Creates ClientFrame instances per `frameName`\n- `SizingConnectionService`: Creates ClientSizing instances per `sizingName`\n- `RiskConnectionService`: Creates ClientRisk or MergeRisk instances per `riskName` or `riskList`\n- `OptimizerConnectionService`: Creates ClientOptimizer instances per `optimizerName`\n- `PartialConnectionService`: Creates ClientPartial instances per `symbol`\n\n**Location**: [src/lib/index.ts:74-96]()\n\n**Memoization Pattern**: See [Connection Services & Memoization](#4.3) for details.\n\n**Sources**: [docs/internals.md:34](), [src/lib/index.ts:74-96]()\n\n### 6. Core Services\n\n**Purpose**: Orchestrate business logic by coordinating between connection services and context services.\n\n**Services**:\n- `StrategyCoreService`: Main orchestration for strategy execution. Coordinates ClientStrategy.tick() and ClientStrategy.backtest() calls.\n- `ExchangeCoreService`: Orchestrates candle fetching and VWAP calculation via ClientExchange.\n- `FrameCoreService`: Orchestrates timeframe generation via ClientFrame.\n\n**Location**: [src/lib/index.ts:114-118]()\n\n**Orchestration Example** (StrategyCoreService):\n```typescript\n// Called by BacktestLogicPrivateService\nstrategyCoreService.tick() {\n  // 1. Gets context from ExecutionContextService\n  const { symbol, when } = executionContext.get();\n  \n  // 2. Routes to correct ClientStrategy via StrategyConnectionService\n  const client = strategyConnectionService.get(symbol);\n  \n  // 3. Executes business logic\n  return client.tick(when);\n}\n```\n\n**Sources**: [src/lib/index.ts:114-118]()\n\n### 7. Global Services\n\n**Purpose**: Manage shared state that spans multiple strategies or symbols.\n\n**Services**:\n- `RiskGlobalService`: Tracks portfolio-wide risk across all strategies\n- `SizingGlobalService`: Manages position sizing calculations\n- `OptimizerGlobalService`: Coordinates optimizer execution state\n- `PartialGlobalService`: Tracks partial profit/loss events across strategies\n\n**Location**: [src/lib/index.ts:120-129]()\n\n**State Sharing Example** (RiskGlobalService):\n```typescript\n// Multiple ClientStrategy instances share the same ClientRisk instance\n// which has access to RiskGlobalService for portfolio-wide limits\n```\n\n**Sources**: [src/lib/index.ts:120-129]()\n\n### 8. Logic Services (Private)\n\n**Purpose**: Implement internal execution logic using async generators for streaming results.\n\n**Services**:\n- `BacktestLogicPrivateService`: Implements timeframe iteration loop for historical simulation\n- `LiveLogicPrivateService`: Implements infinite loop with sleep intervals for real-time trading\n- `WalkerLogicPrivateService`: Implements strategy comparison by running multiple backtests sequentially\n\n**Location**: [src/lib/index.ts:141-151]()\n\n**Async Generator Pattern**:\n```typescript\nasync *run(symbol: string) {\n  // Backtest: finite loop through timeframes\n  for (const timeframe of timeframes) {\n    const result = await strategyCoreService.tick();\n    if (result.action === 'closed') {\n      yield result; // Stream results incrementally\n    }\n  }\n}\n```\n\n**Sources**: [docs/internals.md:36](), [src/lib/index.ts:141-151]()\n\n### 9. Logic Services (Public)\n\n**Purpose**: Wrap private logic services to provide clean external API with validation and error handling.\n\n**Services**:\n- `BacktestLogicPublicService`: Public wrapper for BacktestLogicPrivateService\n- `LiveLogicPublicService`: Public wrapper for LiveLogicPrivateService\n- `WalkerLogicPublicService`: Public wrapper for WalkerLogicPrivateService\n\n**Location**: [src/lib/index.ts:153-163]()\n\n**Wrapper Pattern**:\n```typescript\n// Public service validates inputs before delegating to private service\nasync *run(symbol: string, context: IMethodContext) {\n  await this.validate(context); // Validation layer\n  return yield* privateService.run(symbol); // Delegate to private\n}\n```\n\n**Sources**: [src/lib/index.ts:153-163]()\n\n### 10. Command Services\n\n**Purpose**: Provide top-level entry points for the public API (Backtest, Live, Walker classes).\n\n**Services**:\n- `BacktestCommandService`: Entry point for Backtest.run() and Backtest.background()\n- `LiveCommandService`: Entry point for Live.run() and Live.background()\n- `WalkerCommandService`: Entry point for Walker.run() and Walker.background()\n\n**Location**: [src/lib/index.ts:131-139]()\n\n**Command Pattern**:\n```typescript\n// Command service handles method context and delegates to logic service\nrun(symbol: string, context: IMethodContext) {\n  return methodContextService.runInContext(() => {\n    return backtestLogicPublicService.run(symbol);\n  }, context);\n}\n```\n\n**Sources**: [src/lib/index.ts:131-139]()\n\n### 11. Markdown Services\n\n**Purpose**: Subscribe to event emitters, accumulate data, and generate formatted reports on demand.\n\n**Services**:\n- `BacktestMarkdownService`: Generates reports from signalBacktestEmitter\n- `LiveMarkdownService`: Generates reports from signalLiveEmitter\n- `ScheduleMarkdownService`: Tracks scheduled/opened/cancelled signals\n- `PerformanceMarkdownService`: Tracks execution timing metrics\n- `WalkerMarkdownService`: Generates strategy comparison reports\n- `HeatMarkdownService`: Generates portfolio-wide heatmaps\n- `PartialMarkdownService`: Tracks partial profit/loss events\n- `OutlineMarkdownService`: Generates outline/summary reports\n- `RiskMarkdownService`: Tracks risk rejection events\n\n**Location**: [src/lib/index.ts:165-187]()\n\n**Event Subscription Pattern**:\n```typescript\n// Markdown services subscribe to relevant emitters\nsignalBacktestEmitter.subscribe((event) => {\n  storage.append(key, event); // Max 250 events per key\n});\n\n// Generate report on demand\ngetReport() {\n  const events = storage.get(key);\n  return this.formatMarkdown(events);\n}\n```\n\n**Sources**: [docs/internals.md:37](), [src/lib/index.ts:165-187]()\n\n### 12. Template Services\n\n**Purpose**: Generate executable code from optimizer schemas.\n\n**Services**:\n- `OptimizerTemplateService`: Generates .mjs files with strategy code, LLM integration, and backtest execution logic\n\n**Location**: [src/lib/index.ts:219-223]()\n\n**Code Generation Pattern**: See [Code Generation & Templates](#10.3) for details.\n\n**Sources**: [src/lib/index.ts:219-223]()\n\n---\n\n## Service Dependency Graph\n\nThis diagram maps the dependencies between major service categories, showing how the acyclic architecture prevents circular dependencies:\n\n```mermaid\ngraph TB\n    subgraph \"Public API Layer\"\n        CMD[\"Command Services<br/>BacktestCommandService<br/>LiveCommandService<br/>WalkerCommandService\"]\n    end\n    \n    subgraph \"Orchestration Layer\"\n        LOGIC_PUB[\"Logic Services (Public)<br/>BacktestLogicPublicService<br/>LiveLogicPublicService<br/>WalkerLogicPublicService\"]\n        LOGIC_PRIV[\"Logic Services (Private)<br/>BacktestLogicPrivateService<br/>LiveLogicPrivateService<br/>WalkerLogicPrivateService\"]\n    end\n    \n    subgraph \"Business Logic Layer\"\n        CORE[\"Core Services<br/>StrategyCoreService<br/>ExchangeCoreService<br/>FrameCoreService\"]\n        CONN[\"Connection Services<br/>StrategyConnectionService<br/>ExchangeConnectionService<br/>FrameConnectionService<br/>RiskConnectionService<br/>PartialConnectionService\"]\n    end\n    \n    subgraph \"Configuration Layer\"\n        SCHEMA[\"Schema Services<br/>StrategySchemaService<br/>ExchangeSchemaService<br/>FrameSchemaService<br/>RiskSchemaService\"]\n        VAL[\"Validation Services<br/>StrategyValidationService<br/>ExchangeValidationService<br/>FrameValidationService<br/>RiskValidationService\"]\n    end\n    \n    subgraph \"Infrastructure Layer\"\n        BASE[\"Base Services<br/>LoggerService\"]\n        CTX[\"Context Services<br/>ExecutionContextService<br/>MethodContextService\"]\n        GLOBAL[\"Global Services<br/>RiskGlobalService<br/>PartialGlobalService\"]\n    end\n    \n    subgraph \"Reporting Layer\"\n        MD[\"Markdown Services<br/>BacktestMarkdownService<br/>LiveMarkdownService<br/>WalkerMarkdownService\"]\n        TMPL[\"Template Services<br/>OptimizerTemplateService\"]\n    end\n    \n    CMD --> LOGIC_PUB\n    LOGIC_PUB --> LOGIC_PRIV\n    LOGIC_PRIV --> CORE\n    CORE --> CONN\n    CONN --> SCHEMA\n    CONN --> VAL\n    VAL --> SCHEMA\n    \n    CMD --> CTX\n    LOGIC_PUB --> CTX\n    LOGIC_PRIV --> CTX\n    CORE --> CTX\n    CONN --> CTX\n    \n    CMD --> BASE\n    LOGIC_PUB --> BASE\n    LOGIC_PRIV --> BASE\n    CORE --> BASE\n    CONN --> BASE\n    SCHEMA --> BASE\n    VAL --> BASE\n    \n    CONN --> GLOBAL\n    \n    MD -.->|\"subscribes to events\"| LOGIC_PRIV\n    TMPL -.->|\"uses\"| SCHEMA\n```\n\n**Key Architectural Principles**:\n\n1. **Layered Dependencies**: Services only depend on services in the same layer or layers below\n2. **No Circular Dependencies**: The graph is acyclic (DAG)\n3. **Context Propagation**: Context services are used by all layers but don't depend on them\n4. **Infrastructure Services**: Base and Context services have no dependencies (except each other)\n5. **Reporting Independence**: Markdown services subscribe to events but don't block execution\n\n**Sources**: [docs/internals.md:28-53](), [src/lib/index.ts:1-246]()\n\n---\n\n## The Central `backtest` Object\n\nThe [src/lib/index.ts:225-238]() file exports a single `backtest` object that aggregates all 52 services:\n\n```typescript\nexport const backtest = {\n  ...baseServices,           // 1 service\n  ...contextServices,        // 2 services\n  ...connectionServices,     // 7 services\n  ...schemaServices,         // 7 services\n  ...coreServices,           // 3 services\n  ...globalServices,         // 4 services\n  ...commandServices,        // 3 services\n  ...logicPrivateServices,   // 3 services\n  ...logicPublicServices,    // 3 services\n  ...markdownServices,       // 9 services\n  ...validationServices,     // 9 services\n  ...templateServices,       // 1 service\n};\n\ninit();\n\nexport default backtest;\n```\n\n### Service Access Patterns\n\nInternal code accesses services through this object:\n\n```typescript\n// From any internal module\nimport backtest from \"../lib/index\";\n\n// Access any service\nbacktest.loggerService.info('method', { data });\nbacktest.strategyValidationService.assertExist(strategyName);\nbacktest.strategyConnectionService.get(symbol);\n```\n\n### Testability\n\nThe `backtest` object enables easy mocking for unit tests:\n\n```typescript\n// In tests, replace specific services\nconst mockLogger = { info: jest.fn(), log: jest.fn() };\nbacktest.loggerService = mockLogger;\n\n// Run code under test\nawait someFunction();\n\n// Verify mock was called\nexpect(mockLogger.info).toHaveBeenCalledWith(...);\n```\n\n**Sources**: [src/lib/index.ts:225-246]()\n\n---\n\n## Service Initialization Lifecycle\n\nThe initialization sequence follows this pattern:\n\n```mermaid\nsequenceDiagram\n    participant Import as \"import backtest\"\n    participant Provide as \"provide.ts\"\n    participant Types as \"types.ts\"\n    participant Index as \"index.ts\"\n    participant DI as \"DI Container\"\n    participant Service as \"Service Instance\"\n    \n    Import->>Types: Load TYPES symbols\n    Import->>Provide: Execute provide() calls\n    Note over Provide: Registers factories,<br/>does NOT instantiate\n    Import->>Index: Load inject() calls\n    Index->>DI: Call init()\n    Note over DI: Container ready,<br/>services still not created\n    \n    Import->>Index: Access backtest.loggerService\n    Index->>DI: Resolve TYPES.loggerService\n    DI->>Provide: Execute factory function\n    Provide->>Service: new LoggerService()\n    Service-->>DI: Instance\n    DI-->>Index: Cached instance\n    Index-->>Import: LoggerService instance\n    \n    Note over Import,Service: All subsequent accesses<br/>return cached instance\n```\n\n### Lazy Instantiation\n\nServices are created only when first accessed:\n\n```typescript\n// 1. Loading the module does NOT create services\nimport backtest from \"backtest-kit\";\n\n// 2. First access creates the service\nconst logger = backtest.loggerService; // LoggerService() constructor runs here\n\n// 3. Subsequent accesses return cached instance\nconst logger2 = backtest.loggerService; // Same instance, no new construction\n\nconsole.assert(logger === logger2); // true\n```\n\n### Service Constructor Pattern\n\nServices receive dependencies via constructor injection:\n\n```typescript\n// Example: BacktestCommandService constructor\nclass BacktestCommandService {\n  private loggerService: LoggerService;\n  private backtestLogicPublicService: BacktestLogicPublicService;\n  \n  constructor() {\n    // Inject dependencies via backtest object\n    this.loggerService = backtest.loggerService;\n    this.backtestLogicPublicService = backtest.backtestLogicPublicService;\n  }\n}\n```\n\nThis pattern enables:\n- **Circular dependency detection**: Constructor injection makes cycles impossible\n- **Clear dependency graph**: Dependencies are explicit in constructor\n- **Easy testing**: Can mock dependencies by replacing them on `backtest` object\n\n**Sources**: [src/lib/index.ts:1-246](), [src/lib/core/provide.ts:1-143]()\n\n---\n\n## Service Type Definitions and Interfaces\n\nWhile the DI container uses concrete classes, the framework also defines interfaces for major service categories to enable flexibility and testing.\n\n### Internal Service Access Pattern\n\nServices access each other through the `backtest` object, which provides concrete instances:\n\n```typescript\nclass StrategyCoreService {\n  constructor() {\n    this.loggerService = backtest.loggerService;\n    this.strategyConnectionService = backtest.strategyConnectionService;\n    this.strategySchemaService = backtest.strategySchemaService;\n    // ... etc\n  }\n}\n```\n\n### Type-Safe Resolution\n\nThe `inject<T>()` function provides type safety:\n\n```typescript\n// From index.ts\nconst baseServices = {\n  loggerService: inject<LoggerService>(TYPES.loggerService),\n};\n```\n\nTypeScript ensures:\n- `TYPES.loggerService` maps to correct factory in `provide.ts`\n- Factory returns type compatible with `LoggerService`\n- Access via `backtest.loggerService` returns correct type\n\n**Sources**: [src/lib/index.ts:61-238]()\n\n---\n\n## Summary\n\nThe service layer architecture provides:\n\n| Aspect | Implementation | Benefit |\n|--------|----------------|---------|\n| **Dependency Injection** | Symbol-based tokens + provide/inject | Testability, lazy loading, clear dependencies |\n| **Service Categories** | 11 distinct categories | Separation of concerns, clear responsibilities |\n| **Context Propagation** | ExecutionContext + MethodContext | Avoid parameter drilling, clean APIs |\n| **Memoization** | Connection services cache clients | Performance optimization, single instances |\n| **Acyclic Dependencies** | Layered architecture | No circular dependencies, maintainability |\n| **Central Object** | `backtest` aggregates all services | Single import point, easy mocking |\n| **Lazy Instantiation** | Services created on first access | Fast startup, low memory footprint |\n\nThe combination of these patterns creates a maintainable, testable, and performant architecture that scales from simple backtests to complex multi-strategy live trading systems.\n\n**Sources**: [docs/internals.md:28-53](), [src/lib/index.ts:1-246](), [src/lib/core/types.ts:1-105](), [src/lib/core/provide.ts:1-143]()"
                    },
                    {
                        "page_plan": {
                            "id": "4.2",
                            "title": "Client Layer"
                        },
                        "content": "# Client Layer\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/client/ClientStrategy.ts](src/client/ClientStrategy.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Strategy.interface.ts](src/interfaces/Strategy.interface.ts)\n- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)\n- [test/index.mjs](test/index.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThe Client Layer implements pure business logic for trading operations without dependency injection. It consists of five client classes (`ClientStrategy`, `ClientExchange`, `ClientFrame`, `ClientRisk`, `ClientPartial`) that execute core functionality like signal generation, data fetching, timeframe calculations, risk validation, and profit/loss tracking. This layer uses prototype methods instead of arrow functions for memory efficiency and is instantiated by Connection Services through memoization.\n\nFor information about how these clients are instantiated and routed through dependency injection, see [Connection Services & Memoization](#4.3). For event emission and reporting that consumes client outputs, see [Event System Architecture](#4.4).\n\n---\n\n## Client Layer Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Client Classes (Pure Business Logic)\"\n        CS[\"ClientStrategy<br/>src/client/ClientStrategy.ts\"]\n        CE[\"ClientExchange<br/>src/client/ClientExchange.ts\"]\n        CF[\"ClientFrame<br/>src/client/ClientFrame.ts\"]\n        CR[\"ClientRisk<br/>src/client/ClientRisk.ts\"]\n        CP[\"ClientPartial<br/>src/client/ClientPartial.ts\"]\n    end\n    \n    subgraph \"Interface Contracts\"\n        IS[\"IStrategy<br/>tick()<br/>backtest()<br/>getPendingSignal()<br/>stop()\"]\n        IE[\"IExchange<br/>getCandles()<br/>getNextCandles()<br/>getAveragePrice()<br/>formatPrice()\"]\n        IF[\"IFrame<br/>getTimeframe()\"]\n        IR[\"IRisk<br/>checkSignal()<br/>addSignal()<br/>removeSignal()\"]\n        IP[\"IPartial<br/>profit()<br/>loss()<br/>clear()\"]\n    end\n    \n    subgraph \"Connection Services (Memoized Factories)\"\n        SCS[\"StrategyConnectionService<br/>getStrategy() memoized\"]\n        ECS[\"ExchangeConnectionService<br/>getExchange() memoized\"]\n        FCS[\"FrameConnectionService<br/>getFrame() memoized\"]\n        RCS[\"RiskConnectionService<br/>getRisk() memoized\"]\n        PCS[\"PartialConnectionService<br/>getPartial() singleton\"]\n    end\n    \n    CS -.implements.-> IS\n    CE -.implements.-> IE\n    CF -.implements.-> IF\n    CR -.implements.-> IR\n    CP -.implements.-> IP\n    \n    SCS -->|creates & caches| CS\n    ECS -->|creates & caches| CE\n    FCS -->|creates & caches| CF\n    RCS -->|creates & caches| CR\n    PCS -->|singleton instance| CP\n    \n    CS -->|uses| CE\n    CS -->|uses| CR\n    CS -->|uses| CP\n```\n\n**Client Layer Design Principles:**\n\n| Principle | Implementation | Benefit |\n|-----------|---------------|---------|\n| **No Dependency Injection** | Clients receive dependencies via constructor params | Pure functions, easy to test |\n| **Prototype Methods** | Methods defined on prototype, not as arrow functions | Shared across instances, reduces memory |\n| **Memoization** | Connection Services cache instances by key | Prevents redundant instantiation |\n| **Interface Contracts** | Each client implements specific interface | Type safety and clear API boundaries |\n| **Stateful Instances** | Each client maintains internal state (e.g., `_pendingSignal`) | Encapsulates signal lifecycle |\n\nSources: [src/client/ClientStrategy.ts:1-1390](), [src/lib/services/connection/StrategyConnectionService.ts:1-309](), [types.d.ts:318-394]()\n\n---\n\n## ClientStrategy: Signal Lifecycle Management\n\n`ClientStrategy` is the core client responsible for managing the complete signal lifecycle from generation through closure. It implements the `IStrategy` interface and orchestrates signal validation, persistence, TP/SL monitoring, and profit/loss tracking.\n\n```mermaid\ngraph TB\n    subgraph \"ClientStrategy Internal State\"\n        PS[\"_pendingSignal: ISignalRow | null<br/>Currently active signal\"]\n        SS[\"_scheduledSignal: IScheduledSignalRow | null<br/>Scheduled signal awaiting activation\"]\n        LS[\"_lastSignalTimestamp: number | null<br/>For interval throttling\"]\n        ST[\"_isStopped: boolean<br/>Graceful shutdown flag\"]\n    end\n    \n    subgraph \"ClientStrategy Methods\"\n        TICK[\"tick(symbol, strategyName)<br/>Live monitoring loop\"]\n        BACKTEST[\"backtest(symbol, strategyName, candles)<br/>Fast historical simulation\"]\n        WAIT[\"waitForInit()<br/>Load persisted state\"]\n        GET_PENDING[\"getPendingSignal()<br/>Return active signal\"]\n        STOP[\"stop()<br/>Set shutdown flag\"]\n        SET_PENDING[\"setPendingSignal(signal)<br/>Persist to storage\"]\n        SET_SCHEDULED[\"setScheduledSignal(signal)<br/>Persist scheduled signal\"]\n    end\n    \n    subgraph \"Dependencies (Constructor Params)\"\n        EXCHANGE[\"exchange: IExchange<br/>VWAP calculation\"]\n        RISK[\"risk: IRisk<br/>Validation checks\"]\n        PARTIAL[\"partial: IPartial<br/>Profit/loss milestones\"]\n        PERSIST[\"PersistSignalAdapter<br/>Crash-safe storage\"]\n    end\n    \n    TICK -->|monitors| PS\n    TICK -->|activates| SS\n    BACKTEST -->|closes| PS\n    WAIT -->|restores| PS\n    WAIT -->|restores| SS\n    SET_PENDING -->|saves| PERSIST\n    SET_SCHEDULED -->|saves| PERSIST\n    \n    TICK -->|calls| EXCHANGE\n    TICK -->|validates| RISK\n    TICK -->|tracks| PARTIAL\n    BACKTEST -->|uses| EXCHANGE\n```\n\n**Key ClientStrategy Features:**\n\n| Feature | Implementation | Location |\n|---------|----------------|----------|\n| **Interval Throttling** | Checks `_lastSignalTimestamp` before calling `getSignal()` | [src/client/ClientStrategy.ts:341-353]() |\n| **Signal Validation** | `VALIDATE_SIGNAL_FN` checks TP/SL logic, prices, GLOBAL_CONFIG | [src/client/ClientStrategy.ts:45-330]() |\n| **Scheduled Signals** | Monitors price activation and SL breach before entry | [src/client/ClientStrategy.ts:610-644]() |\n| **Crash Recovery** | `waitForInit()` loads persisted signals from disk | [src/client/ClientStrategy.ts:491-552]() |\n| **Graceful Shutdown** | `_isStopped` prevents new signals, allows active to close | [src/client/ClientStrategy.ts:336-338]() |\n| **VWAP Pricing** | Uses `exchange.getAveragePrice()` for all entry/exit prices | [src/client/ClientStrategy.ts:354-356]() |\n\n**ClientStrategy Constructor Parameters:**\n\n```typescript\ninterface IStrategyParams {\n    symbol: string;                      // Trading pair\n    interval: SignalInterval;            // Throttling interval (1m, 5m, etc)\n    strategyName: StrategyName;          // Unique identifier\n    getSignal: (symbol, when) => ISignalDto | null;  // User-defined logic\n    callbacks?: Partial<IStrategyCallbacks>;  // Lifecycle hooks\n    riskName: RiskName;                  // Risk profile identifier\n    exchange: IExchange;                 // Data source client\n    risk: IRisk;                         // Risk validator client\n    partial: IPartial;                   // Profit/loss tracker\n    logger: ILogger;                     // Logging service\n    execution: TExecutionContextService; // Context propagation\n    method: TMethodContextService;       // Schema name routing\n}\n```\n\nSources: [src/client/ClientStrategy.ts:1-1390](), [src/interfaces/Strategy.interface.ts:76-95](), [types.d.ts:318-389]()\n\n---\n\n## ClientExchange: Data Source Integration\n\n`ClientExchange` implements the `IExchange` interface to fetch historical candles, calculate VWAP, and format prices/quantities according to exchange precision rules. It wraps the user-provided `IExchangeSchema` and adds temporal context awareness.\n\n```mermaid\ngraph LR\n    subgraph \"ClientExchange Methods\"\n        GC[\"getCandles(symbol, interval, limit)<br/>Fetch backwards from execution context\"]\n        GNC[\"getNextCandles(symbol, interval, limit)<br/>Fetch forwards (backtest only)\"]\n        GAP[\"getAveragePrice(symbol)<br/>VWAP from last 5 1m candles\"]\n        FP[\"formatPrice(symbol, price)<br/>Exchange precision\"]\n        FQ[\"formatQuantity(symbol, quantity)<br/>Exchange precision\"]\n    end\n    \n    subgraph \"User-Provided Schema\"\n        SCHEMA[\"IExchangeSchema<br/>exchangeName<br/>getCandles()<br/>formatPrice()<br/>formatQuantity()\"]\n    end\n    \n    subgraph \"Context Services\"\n        EXEC[\"ExecutionContextService<br/>symbol, when, backtest\"]\n    end\n    \n    GC -->|delegates to| SCHEMA\n    GNC -->|delegates to| SCHEMA\n    GAP -->|calls getCandles| GC\n    GAP -->|calculates VWAP| VWAP[\"Σ(typicalPrice × volume) / Σ(volume)\"]\n    FP -->|delegates to| SCHEMA\n    FQ -->|delegates to| SCHEMA\n    \n    GC -->|reads context| EXEC\n    GNC -->|reads context| EXEC\n```\n\n**VWAP Calculation Logic:**\n\nThe `getAveragePrice()` method fetches the last 5 one-minute candles and calculates Volume Weighted Average Price:\n\n```\nTypical Price = (High + Low + Close) / 3\nVWAP = Σ(Typical Price × Volume) / Σ(Volume)\n```\n\nIf total volume is zero (illiquid market), falls back to simple average of close prices.\n\n**ClientExchange Responsibilities:**\n\n| Responsibility | Method | Implementation |\n|----------------|--------|----------------|\n| **Historical Data** | `getCandles()` | Fetches backwards from `execution.context.when` | \n| **Future Data (Backtest)** | `getNextCandles()` | Fetches forwards from `execution.context.when` |\n| **Realistic Entry/Exit** | `getAveragePrice()` | VWAP prevents look-ahead bias |\n| **Exchange Precision** | `formatPrice()`, `formatQuantity()` | Delegates to user schema |\n| **Anomaly Detection** | Validates candle data | Checks for NaN, Infinity, incomplete candles |\n\nSources: [src/client/ClientExchange.ts]() (inferred from types), [types.d.ts:159-205](), [src/client/ClientStrategy.ts:478-489]()\n\n---\n\n## ClientFrame: Timeframe Generation\n\n`ClientFrame` implements the `IFrame` interface to generate arrays of timestamps for backtest iteration. It converts user-defined `IFrameSchema` (startDate, endDate, interval) into a sequence of `Date` objects.\n\n```mermaid\ngraph TB\n    subgraph \"ClientFrame Method\"\n        GT[\"getTimeframe(symbol, frameName)<br/>Returns Date[] for backtest\"]\n    end\n    \n    subgraph \"Frame Schema Configuration\"\n        SCHEMA[\"IFrameSchema<br/>frameName: string<br/>interval: FrameInterval<br/>startDate: Date<br/>endDate: Date<br/>callbacks?: onTimeframe\"]\n    end\n    \n    subgraph \"Generated Timeframe\"\n        TF[\"[Date(2024-01-01 00:00),<br/>Date(2024-01-01 00:01),<br/>Date(2024-01-01 00:02),<br/>...]\"]\n    end\n    \n    GT -->|reads config| SCHEMA\n    GT -->|generates| TF\n    GT -->|triggers| CB[\"callbacks.onTimeframe(timeframe, startDate, endDate, interval)\"]\n```\n\n**Frame Interval Types:**\n\n| Interval Type | Values | Use Case |\n|--------------|---------|----------|\n| **Minutes** | `1m`, `3m`, `5m`, `15m`, `30m` | High-frequency strategies |\n| **Hours** | `1h`, `2h`, `4h`, `6h`, `8h`, `12h` | Swing trading |\n| **Days** | `1d`, `3d` | Position trading |\n\n**ClientFrame Timeframe Generation:**\n\nThe `getTimeframe()` method generates timestamps by:\n1. Starting at `startDate`\n2. Incrementing by `interval` milliseconds\n3. Continuing until `endDate` (inclusive)\n4. Calling `callbacks.onTimeframe()` with result\n\nThis deterministic array enables backtest orchestration to iterate through history minute-by-minute (or at configured interval granularity).\n\nSources: [types.d.ts:219-294](), [src/interfaces/Frame.interface.ts]() (inferred from types)\n\n---\n\n## ClientRisk: Portfolio-Level Risk Management\n\n`ClientRisk` implements the `IRisk` interface to validate signals before opening positions. It tracks active positions across strategies and enforces user-defined risk rules through custom validation functions.\n\n```mermaid\ngraph TB\n    subgraph \"ClientRisk Methods\"\n        CHECK[\"checkSignal(params)<br/>Validate before opening\"]\n        ADD[\"addSignal(symbol, context)<br/>Track new position\"]\n        REMOVE[\"removeSignal(symbol, context)<br/>Remove closed position\"]\n    end\n    \n    subgraph \"Risk Validation Pipeline\"\n        V1[\"Validation 1<br/>Max concurrent positions\"]\n        V2[\"Validation 2<br/>Max exposure per symbol\"]\n        V3[\"Validation 3<br/>Custom user logic\"]\n        VN[\"Validation N<br/>...\"]\n    end\n    \n    subgraph \"Active Position Tracking\"\n        POS[\"Map<symbol, IRiskActivePosition[]><br/>Current positions across strategies\"]\n    end\n    \n    CHECK -->|runs| V1\n    V1 -->|runs| V2\n    V2 -->|runs| V3\n    V3 -->|runs| VN\n    VN -->|checks| POS\n    \n    ADD -->|updates| POS\n    REMOVE -->|updates| POS\n```\n\n**IRiskValidationPayload Structure:**\n\n```typescript\ninterface IRiskValidationPayload {\n    symbol: string;                    // Trading pair\n    pendingSignal: ISignalDto;         // Signal to validate\n    strategyName: StrategyName;        // Requesting strategy\n    exchangeName: ExchangeName;        // Exchange identifier\n    currentPrice: number;              // VWAP price\n    timestamp: number;                 // Event time\n    activePositionCount: number;       // Total active positions\n    activePositions: IRiskActivePosition[];  // Position details\n}\n```\n\n**ClientRisk Validation Flow:**\n\n1. **Pre-Opening Check**: `checkSignal()` called before signal creation\n2. **Validation Execution**: Each validation function receives `IRiskValidationPayload`\n3. **Rejection Handling**: Any thrown error rejects the signal\n4. **Position Tracking**: `addSignal()` after opening, `removeSignal()` after closing\n5. **Event Emission**: Rejected signals emit to `riskSubject`\n\nSources: [types.d.ts:339-483](), [src/client/ClientRisk.ts]() (inferred from types), [src/lib/services/connection/StrategyConnectionService.ts:27-31]()\n\n---\n\n## ClientPartial: Profit/Loss Milestone Tracking\n\n`ClientPartial` implements the `IPartial` interface to monitor unrealized profit/loss milestones (10%, 20%, 30%, etc) during active signal monitoring. It uses Set-based deduplication to emit each level only once per signal.\n\n```mermaid\ngraph TB\n    subgraph \"ClientPartial Methods\"\n        PROFIT[\"profit(symbol, data, currentPrice, revenuePercent, backtest, when)<br/>Track profit milestones\"]\n        LOSS[\"loss(symbol, data, currentPrice, lossPercent, backtest, when)<br/>Track loss milestones\"]\n        CLEAR[\"clear(symbol, data, priceClose, backtest)<br/>Reset on signal close\"]\n    end\n    \n    subgraph \"Internal State (Per Signal)\"\n        STATE[\"Map<signalId, IPartialState><br/>profitLevels: Set<PartialLevel><br/>lossLevels: Set<PartialLevel>\"]\n    end\n    \n    subgraph \"Partial Levels\"\n        LEVELS[\"PartialLevel = 10 | 20 | 30 | 40 | 50 | 60 | 70 | 80 | 90 | 100\"]\n    end\n    \n    subgraph \"Event Emission\"\n        PROFIT_EVENT[\"partialProfitSubject.next()<br/>PartialProfitContract\"]\n        LOSS_EVENT[\"partialLossSubject.next()<br/>PartialLossContract\"]\n    end\n    \n    PROFIT -->|checks| STATE\n    PROFIT -->|emits new levels| PROFIT_EVENT\n    PROFIT -->|updates| STATE\n    \n    LOSS -->|checks| STATE\n    LOSS -->|emits new levels| LOSS_EVENT\n    LOSS -->|updates| STATE\n    \n    CLEAR -->|deletes| STATE\n    CLEAR -->|persists| PERSIST[\"PersistPartialAdapter\"]\n```\n\n**Partial Level Detection Example:**\n\n```\nSignal opens at $50,000\n\nPrice rises to $54,000 → 8% profit → No event (below 10%)\nPrice rises to $55,000 → 10% profit → Emit partialProfitSubject (level 10)\nPrice rises to $60,000 → 20% profit → Emit partialProfitSubject (level 20)\nPrice rises to $59,000 → 18% profit → No event (level 20 already emitted)\nPrice rises to $65,000 → 30% profit → Emit partialProfitSubject (level 30)\n```\n\n**ClientPartial State Persistence:**\n\n- **In-Memory State**: `Map<signalId, IPartialState>` with `Set<PartialLevel>`\n- **Disk Persistence**: `PersistPartialAdapter` serializes Sets to arrays\n- **Crash Recovery**: State restored on `waitForInit()`\n\nSources: [types.d.ts:486-639](), [src/client/ClientPartial.ts]() (inferred from types)\n\n---\n\n## Prototype Methods Pattern: Memory Efficiency\n\nAll client classes use **prototype methods** instead of arrow functions to share method implementations across instances. This reduces memory consumption when many client instances exist (e.g., multiple symbols, strategies, timeframes).\n\n```mermaid\ngraph TB\n    subgraph \"Anti-Pattern: Arrow Functions (High Memory)\"\n        I1[\"ClientStrategy Instance 1<br/>tick: () => {...} (unique)\"]\n        I2[\"ClientStrategy Instance 2<br/>tick: () => {...} (unique)\"]\n        I3[\"ClientStrategy Instance 3<br/>tick: () => {...} (unique)\"]\n    end\n    \n    subgraph \"Pattern: Prototype Methods (Low Memory)\"\n        P1[\"ClientStrategy Instance 1<br/>_pendingSignal, _lastSignalTimestamp\"]\n        P2[\"ClientStrategy Instance 2<br/>_pendingSignal, _lastSignalTimestamp\"]\n        P3[\"ClientStrategy Instance 3<br/>_pendingSignal, _lastSignalTimestamp\"]\n        PROTO[\"ClientStrategy.prototype<br/>tick() (shared)<br/>backtest() (shared)<br/>waitForInit() (shared)\"]\n    end\n    \n    I1 -.each has own copy.-> I2\n    I2 -.each has own copy.-> I3\n    \n    P1 -->|references| PROTO\n    P2 -->|references| PROTO\n    P3 -->|references| PROTO\n```\n\n**Prototype Method Implementation:**\n\n```typescript\nclass ClientStrategy {\n    constructor(params: IStrategyParams) {\n        this.params = params;\n        this._pendingSignal = null;        // Instance-specific state\n        this._scheduledSignal = null;      // Instance-specific state\n        this._lastSignalTimestamp = null;  // Instance-specific state\n        this._isStopped = false;           // Instance-specific state\n    }\n\n    // Prototype method (shared across instances)\n    tick(symbol: string, strategyName: StrategyName): Promise<IStrategyTickResult> {\n        // Implementation uses 'this' to access instance state\n    }\n}\n```\n\n**Memory Efficiency Comparison:**\n\n| Approach | Memory per Instance | Total for 100 Instances |\n|----------|---------------------|-------------------------|\n| **Arrow Functions** | ~50KB (each method copy) | ~5MB |\n| **Prototype Methods** | ~1KB (state only) | ~100KB |\n| **Savings** | 98% reduction | 98% reduction |\n\nSources: [src/client/ClientStrategy.ts:1-100](), [docs/internals.md:30]()\n\n---\n\n## Client Instantiation & Memoization\n\nConnection Services create client instances using **memoization** to prevent redundant instantiation. Each client is cached by a unique key (e.g., `symbol:strategyName` for `ClientStrategy`).\n\n```mermaid\ngraph TB\n    subgraph \"Connection Service Pattern\"\n        CS[\"StrategyConnectionService\"]\n        MEMO[\"memoize(keyFn, factoryFn)<br/>functools-kit\"]\n        CACHE[\"Cache: Map<string, ClientStrategy>\"]\n    end\n    \n    subgraph \"First Call\"\n        CALL1[\"getStrategy('BTCUSDT', 'my-strategy')\"]\n        KEY1[\"Key: 'BTCUSDT:my-strategy'\"]\n        CREATE1[\"new ClientStrategy({...})\"]\n        STORE1[\"Cache['BTCUSDT:my-strategy'] = instance\"]\n    end\n    \n    subgraph \"Subsequent Calls\"\n        CALL2[\"getStrategy('BTCUSDT', 'my-strategy')\"]\n        KEY2[\"Key: 'BTCUSDT:my-strategy'\"]\n        LOOKUP2[\"Cache['BTCUSDT:my-strategy']\"]\n        RETURN2[\"Return cached instance\"]\n    end\n    \n    CS -->|uses| MEMO\n    MEMO -->|stores in| CACHE\n    \n    CALL1 -->|generates| KEY1\n    KEY1 -->|not found| CREATE1\n    CREATE1 -->|saves| STORE1\n    \n    CALL2 -->|generates| KEY2\n    KEY2 -->|found| LOOKUP2\n    LOOKUP2 -->|returns| RETURN2\n```\n\n**Memoization Keys by Client:**\n\n| Client | Memoization Key | Example |\n|--------|----------------|---------|\n| **ClientStrategy** | `${symbol}:${strategyName}` | `\"BTCUSDT:my-strategy\"` |\n| **ClientExchange** | `${exchangeName}` | `\"binance\"` |\n| **ClientFrame** | `${frameName}` | `\"1d-backtest\"` |\n| **ClientRisk** | `${riskName}` | `\"max-positions\"` |\n| **ClientPartial** | Singleton (no key) | Single instance |\n\n**StrategyConnectionService.getStrategy() Implementation:**\n\n```typescript\nprivate getStrategy = memoize(\n    ([symbol, strategyName]) => `${symbol}:${strategyName}`,  // Key function\n    (symbol: string, strategyName: StrategyName) => {         // Factory function\n        const {\n            riskName = \"\",\n            riskList = [],\n            getSignal,\n            interval,\n            callbacks,\n        } = this.strategySchemaService.get(strategyName);\n        return new ClientStrategy({\n            symbol,\n            interval,\n            execution: this.executionContextService,\n            method: this.methodContextService,\n            logger: this.loggerService,\n            partial: this.partialConnectionService,\n            exchange: this.exchangeConnectionService,\n            risk: GET_RISK_FN({ riskName, riskList }, this),\n            riskName,\n            strategyName,\n            getSignal,\n            callbacks,\n        });\n    }\n);\n```\n\n**Cache Clearing:**\n\nConnection Services expose a `clear()` method to invalidate cached instances:\n\n- `clear()` - Clear all cached instances\n- `clear({ symbol, strategyName })` - Clear specific instance\n\nThis is useful for resetting state during testing or releasing resources.\n\nSources: [src/lib/services/connection/StrategyConnectionService.ts:120-151](), [src/lib/services/connection/StrategyConnectionService.ts:292-305]()\n\n---\n\n## Client Layer Summary\n\n| Client Class | Interface | Primary Responsibility | State Management |\n|-------------|-----------|----------------------|------------------|\n| **ClientStrategy** | `IStrategy` | Signal lifecycle (generate → monitor → close) | `_pendingSignal`, `_scheduledSignal`, `_lastSignalTimestamp`, `_isStopped` |\n| **ClientExchange** | `IExchange` | Data fetching, VWAP calculation, precision formatting | Stateless (delegates to user schema) |\n| **ClientFrame** | `IFrame` | Timeframe generation for backtest iteration | Stateless (pure calculation) |\n| **ClientRisk** | `IRisk` | Pre-opening validation, active position tracking | `Map<symbol, IRiskActivePosition[]>` |\n| **ClientPartial** | `IPartial` | Profit/loss milestone detection and emission | `Map<signalId, IPartialState>` |\n\nThe Client Layer follows a **pure business logic** pattern:\n- No dependency injection (receives dependencies via constructor)\n- Prototype methods for memory efficiency\n- Memoized instantiation via Connection Services\n- Clear interface contracts for type safety\n- Stateful instances encapsulate domain logic\n\nThis design separates concerns between orchestration (Service Layer) and execution (Client Layer), enabling testability, maintainability, and memory-optimized performance.\n\nSources: [src/client/ClientStrategy.ts:1-1390](), [src/lib/services/connection/StrategyConnectionService.ts:1-309](), [types.d.ts:1-1500]()"
                    },
                    {
                        "page_plan": {
                            "id": "4.3",
                            "title": "Connection Services & Memoization"
                        },
                        "content": "# Connection Services & Memoization\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [docs/classes/StrategyConnectionService.md](docs/classes/StrategyConnectionService.md)\n- [docs/index.md](docs/index.md)\n- [docs/interfaces/IStrategy.md](docs/interfaces/IStrategy.md)\n- [docs/interfaces/IStrategySchema.md](docs/interfaces/IStrategySchema.md)\n- [docs/types/IStrategyBacktestResult.md](docs/types/IStrategyBacktestResult.md)\n- [src/client/ClientStrategy.ts](src/client/ClientStrategy.ts)\n- [src/function/add.ts](src/function/add.ts)\n- [src/function/list.ts](src/function/list.ts)\n- [src/interfaces/Strategy.interface.ts](src/interfaces/Strategy.interface.ts)\n- [src/lib/core/provide.ts](src/lib/core/provide.ts)\n- [src/lib/core/types.ts](src/lib/core/types.ts)\n- [src/lib/index.ts](src/lib/index.ts)\n- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)\n- [test/index.mjs](test/index.mjs)\n\n</details>\n\n\n\n## Purpose and Scope\n\nConnection Services implement a **memoized factory pattern** that sits between the Core Services layer and the Client Layer. They cache client instances (ClientStrategy, ClientExchange, etc.) by unique keys and route method calls to the appropriate cached instance. This architecture prevents redundant instantiation, ensures proper initialization, and centralizes event emission after operations complete.\n\nFor information about the Client Layer implementations that Connection Services instantiate, see [Client Layer](#4.2). For the overall service architecture and dependency injection, see [Service Layer & Dependency Injection](#4.1).\n\n---\n\n## Connection Services Overview\n\nThe framework defines six connection services, each responsible for managing a specific domain client:\n\n| Connection Service | Client Managed | Cache Key | Primary Purpose |\n|-------------------|----------------|-----------|-----------------|\n| `StrategyConnectionService` | `ClientStrategy` | `symbol:strategyName` | Routes strategy execution (tick, backtest, signal monitoring) |\n| `ExchangeConnectionService` | `ClientExchange` | `exchangeName` | Routes data fetching (candles, VWAP, price formatting) |\n| `FrameConnectionService` | `ClientFrame` | `frameName` | Routes timeframe generation for backtesting |\n| `RiskConnectionService` | `ClientRisk` | `riskName` | Routes risk validation and position tracking |\n| `PartialConnectionService` | `ClientPartial` | (singleton) | Routes partial profit/loss monitoring |\n| `OptimizerConnectionService` | `ClientOptimizer` | `optimizerName` | Routes LLM-based strategy generation |\n\nAll connection services follow the same pattern:\n1. **Schema Lookup**: Retrieve configuration from corresponding SchemaService\n2. **Memoization**: Cache client instances using `functools-kit` `memoize()`\n3. **Routing**: Delegate method calls to cached client\n4. **Event Emission**: Broadcast results to event system\n\n**Sources:** [src/lib/services/connection/StrategyConnectionService.ts:1-309](), [src/lib/index.ts:74-96](), [src/lib/core/types.ts:10-18]()\n\n---\n\n## Memoization Pattern\n\nConnection Services use **memoization** to prevent creating duplicate client instances for the same context. The `memoize()` function from `functools-kit` caches function results based on a computed cache key.\n\n```mermaid\ngraph TB\n    subgraph \"First Call Sequence\"\n        Call1[\"strategyCoreService.tick(symbol, strategyName)\"]\n        ConnCheck1[\"strategyConnectionService.getStrategy(symbol, strategyName)\"]\n        CacheMiss1[\"Cache miss: key not found\"]\n        Create1[\"new ClientStrategy(params)\"]\n        Store1[\"Store in cache with key 'symbol:strategyName'\"]\n        Return1[\"Return ClientStrategy instance\"]\n    end\n    \n    subgraph \"Subsequent Calls\"\n        Call2[\"strategyCoreService.tick(symbol, strategyName)\"]\n        ConnCheck2[\"strategyConnectionService.getStrategy(symbol, strategyName)\"]\n        CacheHit2[\"Cache hit: key found\"]\n        Return2[\"Return cached ClientStrategy instance\"]\n    end\n    \n    Call1 --> ConnCheck1\n    ConnCheck1 --> CacheMiss1\n    CacheMiss1 --> Create1\n    Create1 --> Store1\n    Store1 --> Return1\n    \n    Call2 --> ConnCheck2\n    ConnCheck2 --> CacheHit2\n    CacheHit2 --> Return2\n    \n    style CacheMiss1 fill:#ffeeee\n    style CacheHit2 fill:#eeffee\n```\n\n**Memoization Benefits:**\n\n1. **Performance**: Avoid re-instantiating clients with complex initialization\n2. **State Preservation**: Maintain client internal state across calls (e.g., `_pendingSignal`, `_lastSignalTimestamp`)\n3. **Memory Efficiency**: Single instance per unique key instead of creating instances per call\n4. **Consistency**: Same client instance guarantees consistent behavior for a given context\n\n**Cache Key Strategy:**\n\n- **StrategyConnectionService**: `${symbol}:${strategyName}` (one instance per symbol-strategy pair)\n- **ExchangeConnectionService**: `exchangeName` (one instance per exchange)\n- **FrameConnectionService**: `frameName` (one instance per timeframe configuration)\n- **RiskConnectionService**: `riskName` (one instance per risk profile)\n\n**Sources:** [src/lib/services/connection/StrategyConnectionService.ts:120-151](), [functools-kit documentation](https://www.npmjs.com/package/functools-kit)\n\n---\n\n## StrategyConnectionService Deep Dive\n\n`StrategyConnectionService` is the most complex connection service, demonstrating all key patterns used across connection services.\n\n### Architecture\n\n```mermaid\ngraph TB\n    Core[\"StrategyCoreService<br/>(orchestration)\"]\n    Conn[\"StrategyConnectionService<br/>(memoized routing)\"]\n    Client[\"ClientStrategy<br/>(business logic)\"]\n    Schema[\"StrategySchemaService<br/>(configuration)\"]\n    ExchConn[\"ExchangeConnectionService\"]\n    RiskConn[\"RiskConnectionService\"]\n    PartialConn[\"PartialConnectionService\"]\n    ExecCtx[\"ExecutionContextService<br/>(symbol, when, backtest flag)\"]\n    MethodCtx[\"MethodContextService<br/>(strategyName, exchangeName)\"]\n    \n    Core -->|\"tick(symbol, strategyName)\"| Conn\n    Conn -->|\"getStrategy(symbol, strategyName)\"| Client\n    Conn -->|\"lookup config\"| Schema\n    Conn -->|\"inject\"| ExchConn\n    Conn -->|\"inject\"| RiskConn\n    Conn -->|\"inject\"| PartialConn\n    Conn -->|\"inject\"| ExecCtx\n    Conn -->|\"inject\"| MethodCtx\n    Client -->|\"uses\"| ExchConn\n    Client -->|\"uses\"| RiskConn\n    Client -->|\"uses\"| PartialConn\n    Client -->|\"reads\"| ExecCtx\n    Client -->|\"reads\"| MethodCtx\n```\n\n**Sources:** [src/lib/services/connection/StrategyConnectionService.ts:89-151]()\n\n### Key Methods\n\n#### getStrategy (Memoized Factory)\n\nThe private `getStrategy` method is the core of the memoization pattern:\n\n```typescript\nprivate getStrategy = memoize(\n  ([symbol, strategyName]) => `${symbol}:${strategyName}`,\n  (symbol: string, strategyName: StrategyName) => {\n    const {\n      riskName = \"\",\n      riskList = [],\n      getSignal,\n      interval,\n      callbacks,\n    } = this.strategySchemaService.get(strategyName);\n    return new ClientStrategy({\n      symbol,\n      interval,\n      execution: this.executionContextService,\n      method: this.methodContextService,\n      logger: this.loggerService,\n      partial: this.partialConnectionService,\n      exchange: this.exchangeConnectionService,\n      risk: GET_RISK_FN({ riskName, riskList }, this),\n      riskName,\n      strategyName,\n      getSignal,\n      callbacks,\n    });\n  }\n);\n```\n\n**Implementation Details:**\n\n1. **Cache Key Function**: First parameter to `memoize()` computes `symbol:strategyName` string\n2. **Factory Function**: Second parameter creates `ClientStrategy` with injected dependencies\n3. **Schema Lookup**: Retrieves strategy configuration via `strategySchemaService.get()`\n4. **Dependency Injection**: Passes all required services to ClientStrategy constructor\n5. **Risk Merging**: Uses `GET_RISK_FN` to handle single `riskName` or multiple `riskList` profiles\n\n**Sources:** [src/lib/services/connection/StrategyConnectionService.ts:120-151]()\n\n#### tick (Live Execution Router)\n\nRoutes live trading ticks to the appropriate ClientStrategy instance:\n\n```typescript\npublic tick = async (\n  symbol: string,\n  strategyName: StrategyName\n): Promise<IStrategyTickResult> => {\n  this.loggerService.log(\"strategyConnectionService tick\", {\n    symbol,\n    strategyName,\n  });\n  const strategy = this.getStrategy(symbol, strategyName);\n  await strategy.waitForInit();\n  const tick = await strategy.tick(symbol, strategyName);\n  {\n    if (this.executionContextService.context.backtest) {\n      await signalBacktestEmitter.next(tick);\n    }\n    if (!this.executionContextService.context.backtest) {\n      await signalLiveEmitter.next(tick);\n    }\n    await signalEmitter.next(tick);\n  }\n  return tick;\n};\n```\n\n**Execution Flow:**\n\n1. **Logging**: Records method invocation for debugging\n2. **Retrieval**: Gets cached ClientStrategy via `getStrategy()`\n3. **Initialization**: Ensures strategy is ready via `waitForInit()` (restores persisted signals in live mode)\n4. **Delegation**: Calls `strategy.tick()` to execute business logic\n5. **Event Emission**: Broadcasts result to mode-specific and global emitters\n6. **Return**: Passes result back to caller\n\n**Sources:** [src/lib/services/connection/StrategyConnectionService.ts:207-228]()\n\n#### backtest (Backtest Router)\n\nRoutes backtest execution to the appropriate ClientStrategy instance:\n\n```typescript\npublic backtest = async (\n  symbol: string,\n  strategyName: StrategyName,\n  candles: ICandleData[]\n): Promise<IStrategyBacktestResult> => {\n  this.loggerService.log(\"strategyConnectionService backtest\", {\n    symbol,\n    strategyName,\n    candleCount: candles.length,\n  });\n  const strategy = this.getStrategy(symbol, strategyName);\n  await strategy.waitForInit();\n  const tick = await strategy.backtest(symbol, strategyName, candles);\n  {\n    if (this.executionContextService.context.backtest) {\n      await signalBacktestEmitter.next(tick);\n    }\n    await signalEmitter.next(tick);\n  }\n  return tick;\n};\n```\n\n**Key Differences from tick():**\n\n- Accepts `candles` array for fast backtesting\n- Only emits to `signalBacktestEmitter` and `signalEmitter` (no live emitter)\n- Returns `IStrategyBacktestResult` (always closed or cancelled, never idle/active)\n\n**Sources:** [src/lib/services/connection/StrategyConnectionService.ts:241-261]()\n\n#### clear (Cache Management)\n\nClears cached ClientStrategy instances to force re-initialization:\n\n```typescript\npublic clear = async (ctx?: {\n  symbol: string;\n  strategyName: StrategyName;\n}): Promise<void> => {\n  this.loggerService.log(\"strategyConnectionService clear\", {\n    ctx,\n  });\n  if (ctx) {\n    const key = `${ctx.symbol}:${ctx.strategyName}`;\n    this.getStrategy.clear(key);\n  } else {\n    this.getStrategy.clear();\n  }\n};\n```\n\n**Use Cases:**\n\n- **Specific Clear**: `clear({ symbol, strategyName })` removes single instance\n- **Global Clear**: `clear()` removes all cached instances\n- **Reset State**: Forces fresh ClientStrategy on next call (useful for testing)\n- **Memory Management**: Release resources for strategies no longer needed\n\n**Sources:** [src/lib/services/connection/StrategyConnectionService.ts:292-305]()\n\n---\n\n## Other Connection Services\n\n### ExchangeConnectionService\n\nManages `ClientExchange` instances for fetching market data.\n\n**Cache Key:** `exchangeName`\n\n**Routed Methods:**\n- `getCandles(symbol, interval, since, limit)` - Fetch historical candle data\n- `getAveragePrice(symbol)` - Calculate VWAP from last 5 1m candles\n- `formatPrice(symbol, price)` - Format price for exchange\n- `formatQuantity(symbol, quantity)` - Format quantity for exchange\n\n**Implementation Notes:**\n- Uses `CANDLES_BUFFER_SIZE` to maintain rolling window of recent candles\n- Detects anomalous prices using median calculation\n- Retries failed requests with `retry()` from `functools-kit`\n- Validates candle completeness (detects missing timestamps)\n\n**Sources:** Files not shown, but follows same pattern as StrategyConnectionService\n\n### FrameConnectionService\n\nManages `ClientFrame` instances for timeframe generation.\n\n**Cache Key:** `frameName`\n\n**Routed Methods:**\n- `getTimeframes()` - Generate array of timestamps from startDate to endDate at specified interval\n\n**Implementation Notes:**\n- Returns immutable array of Date objects\n- Validates that endDate > startDate\n- Ensures interval divides evenly into total duration\n\n**Sources:** Files not shown, but follows same pattern as StrategyConnectionService\n\n### RiskConnectionService\n\nManages `ClientRisk` instances for risk validation.\n\n**Cache Key:** `riskName`\n\n**Routed Methods:**\n- `checkSignal(args)` - Validate signal against risk limits and custom validations\n- `addSignal(symbol, context)` - Track new active position\n- `removeSignal(symbol, context)` - Remove closed position\n\n**Implementation Notes:**\n- Maintains global state of active positions across all strategies\n- Executes custom validation functions from `IRiskSchema.validations`\n- Supports `MergeRisk` for combining multiple risk profiles\n- Uses `RiskGlobalService` for portfolio-wide tracking\n\n**Sources:** [src/lib/services/connection/StrategyConnectionService.ts:33-67]() shows risk merging logic\n\n### PartialConnectionService\n\nManages a singleton `ClientPartial` instance for partial profit/loss tracking.\n\n**Cache Key:** None (singleton pattern)\n\n**Routed Methods:**\n- `profit(symbol, signal, currentPrice, percentTp, backtest, when)` - Track profit milestones\n- `loss(symbol, signal, currentPrice, percentSl, backtest, when)` - Track loss milestones\n- `clear(symbol, signal, currentPrice, backtest)` - Reset tracking on signal close\n\n**Implementation Notes:**\n- Emits `partialProfitSubject` and `partialLossSubject` events\n- Tracks 10%, 20%, 30%... milestones\n- Prevents duplicate emissions for same milestone\n- Used by `ClientStrategy.tick()` to monitor unrealized P&L\n\n**Sources:** [src/lib/services/connection/StrategyConnectionService.ts:106-108]()\n\n### OptimizerConnectionService\n\nManages `ClientOptimizer` instances for LLM-based strategy generation.\n\n**Cache Key:** `optimizerName`\n\n**Routed Methods:**\n- `getData(symbol)` - Fetch training data from all sources\n- `getCode(symbol, data)` - Generate strategy code using LLM\n- `dump(symbol, code)` - Write generated code to file\n\n**Implementation Notes:**\n- Integrates with Ollama for LLM inference\n- Uses `OptimizerTemplateService` for code generation templates\n- Manages conversation history across multiple data sources\n- Emits progress events during data collection\n\n**Sources:** Files not shown, but follows same pattern as StrategyConnectionService\n\n---\n\n## Cache Management and Lifecycle\n\n### Cache Lifecycle\n\n```mermaid\nstateDiagram-v2\n    [*] --> Empty: Initial state\n    \n    Empty --> Populated: First call creates instance\n    Populated --> Populated: Subsequent calls return cached instance\n    Populated --> Cleared: clear(key) called\n    Cleared --> Empty: Cache entry removed\n    \n    Empty --> PopulatedMultiple: Multiple keys cached\n    PopulatedMultiple --> PopulatedMultiple: Calls with different keys\n    PopulatedMultiple --> Empty: clear() with no args\n    \n    note right of Populated\n        Cache key examples:\n        - \"BTCUSDT:my-strategy\"\n        - \"ETHUSDT:my-strategy\"\n        - \"binance\" (exchange)\n        - \"conservative\" (risk)\n    end note\n    \n    note right of Cleared\n        Cleared entries force\n        re-instantiation on\n        next call with same key\n    end note\n```\n\n**Sources:** [src/lib/services/connection/StrategyConnectionService.ts:292-305]()\n\n### Memory Implications\n\n**Per-Symbol-Strategy Caching:**\n\nFor a backtest with 100 symbols and 5 strategies:\n- Without memoization: 100 × 5 × iterations = thousands of ClientStrategy instantiations\n- With memoization: 100 × 5 = 500 cached instances, reused across all iterations\n\n**Memory Trade-offs:**\n\n- **Cached State**: Each ClientStrategy stores `_pendingSignal`, `_scheduledSignal`, `_lastSignalTimestamp`\n- **Service References**: Shared references to injected services (not duplicated)\n- **Client Methods**: Prototype methods, not duplicated per instance\n\n**Clearing Strategy:**\n\n- **After Backtest**: No clear needed, let garbage collection handle it\n- **Long-Running Live**: Call `clear()` periodically to release unused strategies\n- **Testing**: Call `clear()` between tests to ensure clean state\n\n**Sources:** [src/client/ClientStrategy.ts:1-1544]() shows internal state\n\n---\n\n## Integration with Service Layer\n\n### Dependency Flow\n\n```mermaid\ngraph TB\n    subgraph \"Command Layer\"\n        BacktestCmd[\"BacktestCommandService\"]\n        LiveCmd[\"LiveCommandService\"]\n    end\n    \n    subgraph \"Logic Layer\"\n        BacktestLogic[\"BacktestLogicPrivateService\"]\n        LiveLogic[\"LiveLogicPrivateService\"]\n    end\n    \n    subgraph \"Core Layer\"\n        StrategyCore[\"StrategyCoreService\"]\n        ExchangeCore[\"ExchangeCoreService\"]\n    end\n    \n    subgraph \"Connection Layer (This Document)\"\n        StrategyConn[\"StrategyConnectionService\"]\n        ExchangeConn[\"ExchangeConnectionService\"]\n        RiskConn[\"RiskConnectionService\"]\n        PartialConn[\"PartialConnectionService\"]\n    end\n    \n    subgraph \"Client Layer\"\n        ClientStrategy[\"ClientStrategy<br/>(memoized instances)\"]\n        ClientExchange[\"ClientExchange<br/>(memoized instances)\"]\n        ClientRisk[\"ClientRisk<br/>(memoized instances)\"]\n        ClientPartial[\"ClientPartial<br/>(singleton)\"]\n    end\n    \n    subgraph \"Schema Layer\"\n        StrategySchema[\"StrategySchemaService\"]\n        ExchangeSchema[\"ExchangeSchemaService\"]\n        RiskSchema[\"RiskSchemaService\"]\n    end\n    \n    BacktestCmd --> BacktestLogic\n    LiveCmd --> LiveLogic\n    BacktestLogic --> StrategyCore\n    LiveLogic --> StrategyCore\n    StrategyCore --> StrategyConn\n    ExchangeCore --> ExchangeConn\n    \n    StrategyConn -->|\"getStrategy()<br/>(memoized)\"| ClientStrategy\n    ExchangeConn -->|\"getExchange()<br/>(memoized)\"| ClientExchange\n    RiskConn -->|\"getRisk()<br/>(memoized)\"| ClientRisk\n    PartialConn -->|\"singleton\"| ClientPartial\n    \n    StrategyConn -->|\"lookup config\"| StrategySchema\n    ExchangeConn -->|\"lookup config\"| ExchangeSchema\n    RiskConn -->|\"lookup config\"| RiskSchema\n    \n    ClientStrategy -->|\"uses\"| ExchangeConn\n    ClientStrategy -->|\"uses\"| RiskConn\n    ClientStrategy -->|\"uses\"| PartialConn\n```\n\n**Sources:** [src/lib/index.ts:1-246](), [src/lib/core/provide.ts:1-143]()\n\n### Dependency Injection Pattern\n\nConnection Services are injected into Core Services via the DI container:\n\n```typescript\n// Core Services depend on Connection Services\nclass StrategyCoreService {\n  private readonly strategyConnectionService = inject<StrategyConnectionService>(\n    TYPES.strategyConnectionService\n  );\n  \n  // Routes calls to connection service\n  async tick(symbol: string, strategyName: StrategyName) {\n    return await this.strategyConnectionService.tick(symbol, strategyName);\n  }\n}\n```\n\n**Injection Flow:**\n\n1. `provide()` registers factory functions in [src/lib/core/provide.ts:66-72]()\n2. `inject()` retrieves services lazily via TYPES symbols\n3. Connection Services inject other services (Schema, Context, etc.)\n4. Clients receive fully-configured dependencies via constructor\n\n**Sources:** [src/lib/core/provide.ts:66-72](), [src/lib/core/types.ts:10-18](), [src/lib/index.ts:74-96]()\n\n---\n\n## Comparison: Connection vs Core Services\n\n| Aspect | Connection Services | Core Services |\n|--------|-------------------|---------------|\n| **Purpose** | Route & cache client instances | Orchestrate business logic |\n| **State** | Stateless (delegates to clients) | Stateless (delegates to connections) |\n| **Caching** | Memoize client instances | No caching |\n| **Dependencies** | Schema, Context, Logger | Connection, Context, Schema |\n| **Event Emission** | After client operations | N/A |\n| **Examples** | StrategyConnectionService | StrategyCoreService |\n| **Method Pattern** | `getClient()` + `client.method()` | `connectionService.method()` |\n\n**Layering Rationale:**\n\n- **Core Services**: High-level orchestration (e.g., iterate through timeframes)\n- **Connection Services**: Instance routing and caching\n- **Client Layer**: Pure business logic (e.g., signal validation)\n\nThis separation enables:\n- Testing clients in isolation\n- Swapping caching strategies without changing business logic\n- Centralizing event emission logic\n\n**Sources:** Architecture inferred from overall system design\n\n---\n\n## Summary\n\nConnection Services implement a **memoized factory pattern** that:\n\n1. **Cache client instances** by unique keys (symbol:strategy, exchangeName, etc.)\n2. **Route method calls** to the appropriate cached client\n3. **Inject dependencies** from Schema and Context services\n4. **Ensure initialization** via `waitForInit()` before operations\n5. **Emit events** after operations complete\n\nThe memoization strategy prevents redundant instantiation, preserves client state across calls, and centralizes event emission. This architecture sits between the Core Services (orchestration) and Client Layer (business logic), providing clean separation of concerns and efficient resource management.\n\n**Key Takeaways:**\n\n- Use `memoize()` from `functools-kit` with computed cache keys\n- StrategyConnectionService is the most complex, demonstrating all patterns\n- Cache management via `clear()` enables testing and memory control\n- Connection Services are stateless routers, not stateful coordinators\n\n**Sources:** [src/lib/services/connection/StrategyConnectionService.ts:1-309](), [src/lib/index.ts:74-96](), [src/lib/core/types.ts:10-18](), [src/lib/core/provide.ts:66-72]()"
                    },
                    {
                        "page_plan": {
                            "id": "4.4",
                            "title": "Event System Architecture"
                        },
                        "content": "# Event System Architecture\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/lib/services/markdown/BacktestMarkdownService.ts](src/lib/services/markdown/BacktestMarkdownService.ts)\n- [src/lib/services/markdown/HeatMarkdownService.ts](src/lib/services/markdown/HeatMarkdownService.ts)\n- [src/lib/services/markdown/LiveMarkdownService.ts](src/lib/services/markdown/LiveMarkdownService.ts)\n- [src/lib/services/markdown/PartialMarkdownService.ts](src/lib/services/markdown/PartialMarkdownService.ts)\n- [src/lib/services/markdown/PerformanceMarkdownService.ts](src/lib/services/markdown/PerformanceMarkdownService.ts)\n- [src/lib/services/markdown/RiskMarkdownService.ts](src/lib/services/markdown/RiskMarkdownService.ts)\n- [src/lib/services/markdown/ScheduleMarkdownService.ts](src/lib/services/markdown/ScheduleMarkdownService.ts)\n- [src/lib/services/markdown/WalkerMarkdownService.ts](src/lib/services/markdown/WalkerMarkdownService.ts)\n- [src/model/Column.model.ts](src/model/Column.model.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document describes the event-driven architecture of Backtest Kit, including the 13+ event emitters, their purposes, event flow patterns, markdown service consumers, public API listeners, and memory management strategies. The event system enables real-time monitoring, reporting, and integration with external systems without coupling producers to consumers.\n\nFor information about how strategies generate events, see [3.1 - Signals & Signal Lifecycle](#3.1). For information about execution modes that produce events, see [5 - Execution Modes](#5). For information about report generation from accumulated events, see [9 - Reporting & Monitoring](#9).\n\n---\n\n## Event Emitter Registry\n\nThe framework provides 13 distinct `Subject` emitters organized by functional area. All emitters are defined in [src/config/emitters.ts:1-133]() using the `functools-kit` Subject pattern.\n\n### Signal Event Emitters\n\n| Emitter | Type | Purpose | Emission Source |\n|---------|------|---------|-----------------|\n| `signalEmitter` | `Subject<IStrategyTickResult>` | Global signal events (all modes) | ClientStrategy.tick() |\n| `signalBacktestEmitter` | `Subject<IStrategyTickResult>` | Backtest-only signals | BacktestLogicPrivateService |\n| `signalLiveEmitter` | `Subject<IStrategyTickResult>` | Live-only signals | LiveLogicPrivateService |\n\n**Three-Tier Signal Emission**: The system emits each signal event to three subjects simultaneously. This enables consumers to selectively subscribe to all signals (`signalEmitter`), only backtest signals (`signalBacktestEmitter`), or only live signals (`signalLiveEmitter`) without filtering logic.\n\nSources: [src/config/emitters.ts:15-31](), [types.d.ts:888-892]()\n\n---\n\n### Execution State Emitters\n\n| Emitter | Type | Purpose | Emission Source |\n|---------|------|---------|-----------------|\n| `doneBacktestSubject` | `Subject<DoneContract>` | Backtest completion | BacktestLogicPublicService |\n| `doneLiveSubject` | `Subject<DoneContract>` | Live execution stop | LiveLogicPublicService |\n| `doneWalkerSubject` | `Subject<DoneContract>` | Walker completion | WalkerLogicPublicService |\n| `progressBacktestEmitter` | `Subject<ProgressBacktestContract>` | Backtest progress % | BacktestLogicPrivateService |\n\n**Completion Events**: Each execution mode has its own completion subject that emits a `DoneContract` containing context about what finished (symbol, strategyName, exchangeName, backtest flag).\n\nSources: [src/config/emitters.ts:47-68](), [src/function/event.ts:157-249]()\n\n---\n\n### Walker Event Emitters\n\n| Emitter | Type | Purpose | Emission Source |\n|---------|------|---------|-----------------|\n| `walkerEmitter` | `Subject<WalkerContract>` | Strategy comparison progress | WalkerLogicPrivateService |\n| `walkerCompleteSubject` | `Subject<WalkerCompleteContract>` | Walker final results | WalkerLogicPrivateService |\n| `walkerStopSubject` | `Subject<WalkerStopContract>` | Walker cancellation | WalkerLogicPublicService.stop() |\n| `progressWalkerEmitter` | `Subject<ProgressWalkerContract>` | Walker progress events | WalkerLogicPrivateService |\n\n**Walker Progress**: `walkerEmitter` emits after each strategy completes, providing incremental results. `walkerCompleteSubject` emits once with final aggregated results for all strategies.\n\nSources: [src/config/emitters.ts:88-106](), [src/lib/services/markdown/WalkerMarkdownService.ts:420-438]()\n\n---\n\n### Risk & Partial Event Emitters\n\n| Emitter | Type | Purpose | Emission Source |\n|---------|------|---------|-----------------|\n| `riskSubject` | `Subject<RiskContract>` | Risk validation rejections | ClientRisk.checkSignal() |\n| `partialProfitSubject` | `Subject<PartialProfitContract>` | Profit level milestones (10%, 20%...) | ClientPartial.profit() |\n| `partialLossSubject` | `Subject<PartialLossContract>` | Loss level milestones (10%, 20%...) | ClientPartial.loss() |\n\n**Rejection-Only Emission**: `riskSubject` emits ONLY when signals fail validation, preventing spam from allowed signals.\n\nSources: [src/config/emitters.ts:114-131](), [types.d.ts:486-497]()\n\n---\n\n### Error & Performance Emitters\n\n| Emitter | Type | Purpose | Emission Source |\n|---------|------|---------|-----------------|\n| `errorEmitter` | `Subject<Error>` | Recoverable errors | Background execution error handlers |\n| `exitEmitter` | `Subject<Error>` | Fatal errors requiring termination | Walker/Optimizer critical failures |\n| `performanceEmitter` | `Subject<PerformanceContract>` | Execution timing metrics | PerformanceCoreService |\n| `validationSubject` | `Subject<Error>` | Risk validation errors | ClientRisk validation failures |\n\n**Error Severity Distinction**: `errorEmitter` allows execution to continue (e.g., single tick failure in live mode), while `exitEmitter` signals unrecoverable errors that should terminate the process.\n\nSources: [src/config/emitters.ts:33-86](), [src/function/event.ts:251-282]()\n\n---\n\n## Event Flow Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Event Producers\"\n        ClientStrategy[\"ClientStrategy.tick()\"]\n        BacktestLogic[\"BacktestLogicPrivateService\"]\n        LiveLogic[\"LiveLogicPrivateService\"]\n        WalkerLogic[\"WalkerLogicPrivateService\"]\n        ClientRisk[\"ClientRisk.checkSignal()\"]\n        ClientPartial[\"ClientPartial.profit()/loss()\"]\n    end\n    \n    subgraph \"Event Emitters (Subject Pattern)\"\n        signalEmitter[\"signalEmitter\"]\n        signalBacktestEmitter[\"signalBacktestEmitter\"]\n        signalLiveEmitter[\"signalLiveEmitter\"]\n        doneBacktestSubject[\"doneBacktestSubject\"]\n        doneLiveSubject[\"doneLiveSubject\"]\n        progressBacktestEmitter[\"progressBacktestEmitter\"]\n        walkerEmitter[\"walkerEmitter\"]\n        walkerCompleteSubject[\"walkerCompleteSubject\"]\n        riskSubject[\"riskSubject\"]\n        partialProfitSubject[\"partialProfitSubject\"]\n        partialLossSubject[\"partialLossSubject\"]\n        performanceEmitter[\"performanceEmitter\"]\n        errorEmitter[\"errorEmitter\"]\n        exitEmitter[\"exitEmitter\"]\n    end\n    \n    subgraph \"Markdown Service Consumers\"\n        BacktestMarkdownService[\"BacktestMarkdownService\"]\n        LiveMarkdownService[\"LiveMarkdownService\"]\n        WalkerMarkdownService[\"WalkerMarkdownService\"]\n        ScheduleMarkdownService[\"ScheduleMarkdownService\"]\n        HeatMarkdownService[\"HeatMarkdownService\"]\n        PerformanceMarkdownService[\"PerformanceMarkdownService\"]\n        PartialMarkdownService[\"PartialMarkdownService\"]\n        RiskMarkdownService[\"RiskMarkdownService\"]\n    end\n    \n    subgraph \"Public API Listeners\"\n        listenSignal[\"listenSignal() with queued wrapper\"]\n        listenSignalBacktest[\"listenSignalBacktest() with queued wrapper\"]\n        listenSignalLive[\"listenSignalLive() with queued wrapper\"]\n        listenDone[\"listenDone*() with queued wrapper\"]\n        listenPartial[\"listenPartial*() with queued wrapper\"]\n        listenRisk[\"listenRisk() with queued wrapper\"]\n        listenPerformance[\"listenPerformance() with queued wrapper\"]\n        listenError[\"listenError() with queued wrapper\"]\n    end\n    \n    ClientStrategy --> signalEmitter\n    ClientStrategy --> signalBacktestEmitter\n    ClientStrategy --> signalLiveEmitter\n    \n    BacktestLogic --> signalBacktestEmitter\n    BacktestLogic --> doneBacktestSubject\n    BacktestLogic --> progressBacktestEmitter\n    BacktestLogic --> performanceEmitter\n    \n    LiveLogic --> signalLiveEmitter\n    LiveLogic --> doneLiveSubject\n    LiveLogic --> performanceEmitter\n    \n    WalkerLogic --> walkerEmitter\n    WalkerLogic --> walkerCompleteSubject\n    \n    ClientRisk --> riskSubject\n    ClientPartial --> partialProfitSubject\n    ClientPartial --> partialLossSubject\n    \n    signalBacktestEmitter --> BacktestMarkdownService\n    signalLiveEmitter --> LiveMarkdownService\n    signalEmitter --> ScheduleMarkdownService\n    signalEmitter --> HeatMarkdownService\n    walkerEmitter --> WalkerMarkdownService\n    performanceEmitter --> PerformanceMarkdownService\n    partialProfitSubject --> PartialMarkdownService\n    partialLossSubject --> PartialMarkdownService\n    riskSubject --> RiskMarkdownService\n    \n    signalEmitter --> listenSignal\n    signalBacktestEmitter --> listenSignalBacktest\n    signalLiveEmitter --> listenSignalLive\n    doneBacktestSubject --> listenDone\n    doneLiveSubject --> listenDone\n    partialProfitSubject --> listenPartial\n    partialLossSubject --> listenPartial\n    riskSubject --> listenRisk\n    performanceEmitter --> listenPerformance\n    errorEmitter --> listenError\n```\n\n**Key Flow Characteristics**:\n\n1. **Producer Decoupling**: Event producers never reference consumers directly. They only call `.next()` on subjects.\n2. **Selective Subscription**: Consumers choose which emitters to subscribe to based on their needs.\n3. **Automatic Initialization**: Markdown services use `singleshot(async () => emitter.subscribe(this.tick))` pattern for lazy subscription.\n\nSources: [src/config/emitters.ts:1-133](), [src/lib/services/markdown/BacktestMarkdownService.ts:456-460](), [src/lib/services/markdown/LiveMarkdownService.ts:605-608]()\n\n---\n\n## Markdown Service Subscription Pattern\n\nAll markdown services follow a consistent subscription pattern using `memoize`, `singleshot`, and `ReportStorage` classes.\n\n```mermaid\ngraph TB\n    subgraph \"Markdown Service Initialization\"\n        Service[\"MarkdownService instance\"]\n        Init[\"init() with singleshot\"]\n        Subscribe[\"emitter.subscribe(this.tick)\"]\n    end\n    \n    subgraph \"Event Accumulation\"\n        Tick[\"tick(event) handler\"]\n        GetStorage[\"getStorage(symbol, strategyName) memoized\"]\n        ReportStorage[\"ReportStorage instance\"]\n        AddEvent[\"addEvent() / addSignal()\"]\n        EventList[\"_eventList / _signalList array\"]\n        MaxEventsCheck[\"length > MAX_EVENTS check\"]\n        Pop[\"array.pop() trim oldest\"]\n    end\n    \n    subgraph \"Report Generation\"\n        GetData[\"getData() returns statistics\"]\n        GetReport[\"getReport() returns markdown\"]\n        Dump[\"dump() writes to file\"]\n        Calculate[\"Calculate stats (win rate, Sharpe, etc)\"]\n        FormatTable[\"Format markdown table\"]\n        WriteFile[\"writeFile() to ./dump/\"]\n    end\n    \n    Service --> Init\n    Init --> Subscribe\n    \n    Subscribe --> Tick\n    Tick --> GetStorage\n    GetStorage --> ReportStorage\n    Tick --> AddEvent\n    AddEvent --> EventList\n    AddEvent --> MaxEventsCheck\n    MaxEventsCheck --> Pop\n    \n    ReportStorage --> GetData\n    ReportStorage --> GetReport\n    ReportStorage --> Dump\n    \n    GetData --> Calculate\n    GetReport --> FormatTable\n    Dump --> WriteFile\n```\n\n**Pattern Implementation**:\n\n| Service | Emitter | Storage Key | Event Type | MAX_EVENTS |\n|---------|---------|-------------|------------|------------|\n| `BacktestMarkdownService` | `signalBacktestEmitter` | `${symbol}:${strategyName}` | Closed signals only | 250 |\n| `LiveMarkdownService` | `signalLiveEmitter` | `${symbol}:${strategyName}` | All tick results | 250 |\n| `WalkerMarkdownService` | `walkerEmitter` | `${walkerName}` | Strategy results | N/A |\n| `ScheduleMarkdownService` | `signalEmitter` | `${symbol}:${strategyName}` | Scheduled/cancelled | 250 |\n| `HeatMarkdownService` | `signalEmitter` | `${strategyName}` | Closed signals by symbol | 250 per symbol |\n| `PerformanceMarkdownService` | `performanceEmitter` | `${symbol}:${strategyName}` | Performance metrics | 10000 |\n| `PartialMarkdownService` | `partialProfit/LossSubject` | `${symbol}:${strategyName}` | Partial level events | 250 |\n| `RiskMarkdownService` | `riskSubject` | `${symbol}:${strategyName}` | Rejection events | 250 |\n\nSources: [src/lib/services/markdown/BacktestMarkdownService.ts:282-461](), [src/lib/services/markdown/LiveMarkdownService.ts:423-609](), [src/lib/services/markdown/HeatMarkdownService.ts:434-465]()\n\n---\n\n## ReportStorage Pattern\n\nEach markdown service contains an inner `ReportStorage` class that encapsulates event accumulation and report generation logic.\n\n```mermaid\nclassDiagram\n    class ReportStorage {\n        -_eventList: Event[]\n        +addEvent(event)\n        +getData(): Promise~Statistics~\n        +getReport(): Promise~string~\n        +dump(): Promise~void~\n    }\n    \n    class BacktestReportStorage {\n        -_signalList: IStrategyTickResultClosed[]\n        +addSignal(data)\n        +getData(): Promise~BacktestStatisticsModel~\n        +getReport(strategyName, columns): Promise~string~\n        +dump(strategyName, path, columns): Promise~void~\n    }\n    \n    class LiveReportStorage {\n        -_eventList: TickEvent[]\n        +addIdleEvent(currentPrice)\n        +addOpenedEvent(data)\n        +addActiveEvent(data)\n        +addClosedEvent(data)\n        +getData(): Promise~LiveStatisticsModel~\n        +getReport(strategyName, columns): Promise~string~\n        +dump(strategyName, path, columns): Promise~void~\n    }\n    \n    class HeatmapStorage {\n        -symbolData: Map~string IStrategyTickResultClosed[]~\n        +addSignal(data)\n        -calculateSymbolStats(symbol, signals): IHeatmapRow\n        +getData(): Promise~HeatmapStatisticsModel~\n        +getReport(strategyName, columns): Promise~string~\n        +dump(strategyName, path, columns): Promise~void~\n    }\n    \n    ReportStorage <|-- BacktestReportStorage\n    ReportStorage <|-- LiveReportStorage\n    ReportStorage <|-- HeatmapStorage\n```\n\n**Responsibilities**:\n\n1. **Event Accumulation**: Maintains bounded arrays with MAX_EVENTS limit via `unshift()` + `pop()` pattern\n2. **Statistics Calculation**: Implements metrics (Sharpe ratio, win rate, PNL) with safe math checks\n3. **Report Generation**: Formats markdown tables using configurable `ColumnModel<T>[]` arrays\n4. **File Persistence**: Writes reports to `./dump/{mode}/` directories\n\n**Idle Event Optimization**: `LiveReportStorage` replaces the last idle event instead of accumulating all idle ticks, preventing memory bloat during long idle periods [src/lib/services/markdown/LiveMarkdownService.ts:88-115]().\n\nSources: [src/lib/services/markdown/BacktestMarkdownService.ts:72-253](), [src/lib/services/markdown/LiveMarkdownService.ts:78-391](), [src/lib/services/markdown/HeatMarkdownService.ts:82-406]()\n\n---\n\n## Public API Listener Functions\n\nThe `src/function/event.ts` module provides 20+ user-facing listener functions that wrap emitters with `queued()` processing.\n\n### Queued Processing Pattern\n\n```mermaid\ngraph TB\n    subgraph \"Without queued()\"\n        Emit1[\"emit event 1\"]\n        Emit2[\"emit event 2\"]\n        Emit3[\"emit event 3\"]\n        Callback1A[\"callback(event1) starts\"]\n        Callback2A[\"callback(event2) starts\"]\n        Callback3A[\"callback(event3) starts\"]\n        Callback1B[\"callback(event1) completes\"]\n        Callback2B[\"callback(event2) completes\"]\n        Callback3B[\"callback(event3) completes\"]\n        \n        Emit1 --> Callback1A\n        Emit2 --> Callback2A\n        Emit3 --> Callback3A\n        \n        Callback1A -.-> Callback1B\n        Callback2A -.-> Callback2B\n        Callback3A -.-> Callback3B\n        \n        Note1[\"Concurrent execution risk:<br/>callbacks can interleave\"]\n    end\n    \n    subgraph \"With queued()\"\n        QEmit1[\"emit event 1\"]\n        QEmit2[\"emit event 2\"]\n        QEmit3[\"emit event 3\"]\n        QCallback1A[\"callback(event1) starts\"]\n        QCallback1B[\"callback(event1) completes\"]\n        QCallback2A[\"callback(event2) starts\"]\n        QCallback2B[\"callback(event2) completes\"]\n        QCallback3A[\"callback(event3) starts\"]\n        QCallback3B[\"callback(event3) completes\"]\n        \n        QEmit1 --> QCallback1A\n        QCallback1A --> QCallback1B\n        QCallback1B --> QCallback2A\n        QCallback2A --> QCallback2B\n        QCallback2B --> QCallback3A\n        \n        QEmit2 -.-> QCallback2A\n        QEmit3 -.-> QCallback3A\n        \n        Note2[\"Sequential execution:<br/>next callback waits for previous\"]\n    end\n```\n\n**Why Queued Processing?**: Without `queued()`, async callbacks can execute concurrently, causing race conditions in database writes, file operations, or shared state mutations. The `queued()` wrapper from `functools-kit` ensures callbacks execute sequentially.\n\nSources: [src/function/event.ts:14-14](), [src/function/event.ts:70-73]()\n\n---\n\n### Listener Function Signatures\n\n**Basic Listeners**:\n```typescript\n// Subscribe to all signals (backtest + live)\nlistenSignal(fn: (event: IStrategyTickResult) => void): () => void\n\n// Subscribe to backtest signals only\nlistenSignalBacktest(fn: (event: IStrategyTickResult) => void): () => void\n\n// Subscribe to live signals only\nlistenSignalLive(fn: (event: IStrategyTickResult) => void): () => void\n```\n\n**Once Listeners with Filtering**:\n```typescript\n// Listen once with predicate filter\nlistenSignalOnce(\n  filterFn: (event: IStrategyTickResult) => boolean,\n  fn: (event: IStrategyTickResult) => void\n): () => void\n\n// Wait for specific done event\nlistenDoneBacktestOnce(\n  filterFn: (contract: DoneContract) => boolean,\n  fn: (contract: DoneContract) => void\n): () => void\n```\n\n**Specialized Listeners**:\n```typescript\n// Risk rejection events\nlistenRisk(fn: (contract: RiskContract) => void): () => void\n\n// Partial profit/loss milestones\nlistenPartialProfit(fn: (contract: PartialProfitContract) => void): () => void\nlistenPartialLoss(fn: (contract: PartialLossContract) => void): () => void\n\n// Performance metrics\nlistenPerformance(fn: (contract: PerformanceContract) => void): () => void\n\n// Walker progress\nlistenWalker(fn: (contract: WalkerContract) => void): () => void\nlistenWalkerComplete(fn: (contract: WalkerCompleteContract) => void): () => void\n```\n\nAll listener functions return an unsubscribe function that can be called to stop listening.\n\nSources: [src/function/event.ts:45-456](), [src/index.ts:28-57]()\n\n---\n\n## Event Contracts\n\nAll events use type-safe contracts defined in `src/contract/` directory. Contracts ensure consumers receive properly structured data.\n\n### Signal Event Contracts\n\n**IStrategyTickResult** (Discriminated Union):\n```typescript\ntype IStrategyTickResult = \n  | IStrategyTickResultIdle      // action: \"idle\"\n  | IStrategyTickResultScheduled // action: \"scheduled\"\n  | IStrategyTickResultOpened    // action: \"opened\"\n  | IStrategyTickResultActive    // action: \"active\"\n  | IStrategyTickResultClosed    // action: \"closed\"\n  | IStrategyTickResultCancelled // action: \"cancelled\"\n```\n\nEach variant contains:\n- `action`: Discriminator field for type narrowing\n- `signal`: Signal data (or null for idle)\n- `currentPrice`: Current VWAP price\n- `strategyName`, `exchangeName`, `symbol`: Context information\n\nSources: [types.d.ts:767-888]()\n\n---\n\n### Completion Event Contracts\n\n**DoneContract**:\n```typescript\ninterface DoneContract {\n  backtest: boolean;          // Execution mode\n  symbol: string;             // Trading pair\n  strategyName: StrategyName; // Strategy identifier\n  exchangeName: ExchangeName; // Exchange identifier\n}\n```\n\nEmitted by `doneBacktestSubject`, `doneLiveSubject`, `doneWalkerSubject` to signal completion of background execution.\n\nSources: [types.d.ts:1000-1019]()\n\n---\n\n### Progress Event Contracts\n\n**ProgressBacktestContract**:\n```typescript\ninterface ProgressBacktestContract {\n  symbol: string;\n  strategyName: StrategyName;\n  exchangeName: ExchangeName;\n  frameName: FrameName;\n  currentIndex: number;    // Current timeframe index\n  totalFrames: number;     // Total timeframes\n  percentComplete: number; // 0-100\n}\n```\n\n**WalkerContract**:\n```typescript\ninterface WalkerContract {\n  walkerName: WalkerName;\n  symbol: string;\n  strategyName: StrategyName;      // Current strategy\n  currentStrategy: number;         // Index of current\n  totalStrategies: number;         // Total to test\n  stats: BacktestStatisticsModel;  // Current results\n  metricValue: number | null;      // Current metric\n  bestStrategy: StrategyName;      // Best so far\n  bestMetric: number | null;       // Best value so far\n}\n```\n\nSources: [types.d.ts:1043-1079](), [types.d.ts:1091-1138]()\n\n---\n\n### Risk & Partial Event Contracts\n\n**RiskContract**:\n```typescript\ninterface RiskContract {\n  symbol: string;\n  strategyName: StrategyName;\n  exchangeName: ExchangeName;\n  pendingSignal: ISignalDto;\n  activePositionCount: number;\n  comment: string;          // Rejection reason\n  timestamp: number;        // Rejection time\n}\n```\n\n**PartialProfitContract / PartialLossContract**:\n```typescript\ninterface PartialProfitContract {\n  symbol: string;\n  data: ISignalRow;\n  currentPrice: number;\n  level: PartialLevel;      // 10 | 20 | 30 | ... | 100\n  backtest: boolean;\n  timestamp: number;\n}\n```\n\nSources: [types.d.ts:1190-1232]()\n\n---\n\n## Memory Management & Bounded Queues\n\nAll markdown services implement bounded event storage to prevent memory leaks during long-running executions.\n\n### MAX_EVENTS Configuration\n\n```mermaid\ngraph TB\n    subgraph \"Event Storage Limits\"\n        BacktestLimit[\"BacktestMarkdownService<br/>MAX_EVENTS = 250\"]\n        LiveLimit[\"LiveMarkdownService<br/>MAX_EVENTS = 250\"]\n        ScheduleLimit[\"ScheduleMarkdownService<br/>MAX_EVENTS = 250\"]\n        HeatLimit[\"HeatMarkdownService<br/>MAX_EVENTS = 250 per symbol\"]\n        PerformanceLimit[\"PerformanceMarkdownService<br/>MAX_EVENTS = 10000\"]\n        PartialLimit[\"PartialMarkdownService<br/>MAX_EVENTS = 250\"]\n        RiskLimit[\"RiskMarkdownService<br/>MAX_EVENTS = 250\"]\n    end\n    \n    subgraph \"Trim Pattern\"\n        Unshift[\"array.unshift(newEvent)\"]\n        CheckLength[\"if length > MAX_EVENTS\"]\n        Pop[\"array.pop()\"]\n        \n        Unshift --> CheckLength\n        CheckLength --> Pop\n    end\n    \n    BacktestLimit --> Unshift\n    LiveLimit --> Unshift\n    ScheduleLimit --> Unshift\n    HeatLimit --> Unshift\n    PerformanceLimit --> Unshift\n    PartialLimit --> Unshift\n    RiskLimit --> Unshift\n```\n\n**Trim Strategy**:\n1. New events inserted at array start via `unshift()`\n2. Check if length exceeds MAX_EVENTS\n3. Remove oldest event via `pop()` if over limit\n4. Result: Most recent N events always retained\n\n**Idle Event Deduplication**: `LiveMarkdownService` implements additional optimization by replacing consecutive idle events instead of accumulating them [src/lib/services/markdown/LiveMarkdownService.ts:99-105]().\n\nSources: [src/lib/services/markdown/BacktestMarkdownService.ts:69-92](), [src/lib/services/markdown/LiveMarkdownService.ts:88-115](), [src/lib/services/markdown/PerformanceMarkdownService.ts:74-96]()\n\n---\n\n## Integration Examples\n\n### Example 1: Real-Time Signal Monitoring\n\n```typescript\nimport { listenSignalLive } from 'backtest-kit';\n\nconst unsubscribe = listenSignalLive((event) => {\n  if (event.action === 'opened') {\n    console.log(`Signal opened: ${event.signal.position} at ${event.currentPrice}`);\n    // Send Telegram notification\n  } else if (event.action === 'closed') {\n    console.log(`Signal closed: ${event.closeReason}, PNL: ${event.pnl.pnlPercentage}%`);\n    // Log to database\n  }\n});\n\n// Later: stop listening\nunsubscribe();\n```\n\n### Example 2: Waiting for Specific Event\n\n```typescript\nimport { listenSignalOnce } from 'backtest-kit';\n\n// Wait for first take profit on BTCUSDT\nlistenSignalOnce(\n  (event) => \n    event.action === 'closed' && \n    event.closeReason === 'take_profit' && \n    event.symbol === 'BTCUSDT',\n  (event) => {\n    console.log('First TP hit!', event.pnl.pnlPercentage);\n  }\n);\n```\n\n### Example 3: Risk Rejection Monitoring\n\n```typescript\nimport { listenRisk } from 'backtest-kit';\n\nlistenRisk((rejection) => {\n  console.error(`Risk rejection for ${rejection.symbol}:`);\n  console.error(`  Strategy: ${rejection.strategyName}`);\n  console.error(`  Reason: ${rejection.comment}`);\n  console.error(`  Active positions: ${rejection.activePositionCount}`);\n});\n```\n\nSources: [src/function/event.ts:54-105](), [src/function/event.ts:370-399]()\n\n---\n\n## Memoized Storage Instances\n\nMarkdown services use `memoize` from `functools-kit` to create storage instances keyed by symbol and strategy name.\n\n```mermaid\ngraph TB\n    subgraph \"First Call\"\n        FirstCall[\"getStorage('BTCUSDT', 'my-strategy')\"]\n        FirstKey[\"Generate key: 'BTCUSDT:my-strategy'\"]\n        FirstCreate[\"new ReportStorage()\"]\n        FirstCache[\"Cache in memoize Map\"]\n        FirstReturn[\"Return instance\"]\n        \n        FirstCall --> FirstKey\n        FirstKey --> FirstCreate\n        FirstCreate --> FirstCache\n        FirstCache --> FirstReturn\n    end\n    \n    subgraph \"Subsequent Calls\"\n        NextCall[\"getStorage('BTCUSDT', 'my-strategy')\"]\n        NextKey[\"Generate key: 'BTCUSDT:my-strategy'\"]\n        NextLookup[\"Lookup in memoize Map\"]\n        NextReturn[\"Return cached instance\"]\n        \n        NextCall --> NextKey\n        NextKey --> NextLookup\n        NextLookup --> NextReturn\n    end\n    \n    FirstCache -.->|Same key| NextLookup\n```\n\n**Isolation Benefits**:\n- Each symbol-strategy pair gets isolated storage\n- Cross-symbol contamination impossible\n- `BTCUSDT:my-strategy` and `ETHUSDT:my-strategy` accumulate separately\n- `BTCUSDT:strategy-a` and `BTCUSDT:strategy-b` accumulate separately\n\nSources: [src/lib/services/markdown/BacktestMarkdownService.ts:286-293](), [src/lib/services/markdown/LiveMarkdownService.ts:427-434](), [src/lib/services/markdown/HeatMarkdownService.ts:438-445]()\n\n---\n\n## Performance Considerations\n\n### Event Emission Cost\n\n**Low Overhead**: Each `Subject.next()` call iterates through subscribers and invokes callbacks. With typical subscriber counts (1-3 markdown services + 0-2 user listeners), overhead is negligible.\n\n**Async Generator Streaming**: Events do not accumulate in framework memory. They flow through emitters to consumers immediately, maintaining constant memory usage.\n\n### Bounded Queue Benefits\n\n**Memory Ceiling**: MAX_EVENTS limits ensure memory usage plateaus after initial ramp-up:\n- 250 events × 8 services × 200 bytes/event ≈ 400KB per symbol-strategy pair\n- 10,000 performance events × 150 bytes/event ≈ 1.5MB per symbol-strategy pair\n\n**Circular Buffer Pattern**: `unshift()` + `pop()` implements a circular buffer that discards old data automatically, preventing unbounded growth during long-running live trading.\n\nSources: [src/lib/services/markdown/BacktestMarkdownService.ts:69-70](), [src/lib/services/markdown/PerformanceMarkdownService.ts:75-75]()\n\n---\n\n## Summary\n\nThe event system provides:\n\n1. **13+ Emitters**: Covering signals, progress, completion, risk, partial, performance, and errors\n2. **Three-Tier Signal Emission**: Global, backtest-only, and live-only subscriptions\n3. **Markdown Service Consumers**: 8 services that automatically subscribe, accumulate, and generate reports\n4. **Queued Processing**: Sequential async callback execution prevents race conditions\n5. **Type-Safe Contracts**: Discriminated unions and explicit interfaces for all events\n6. **Bounded Queues**: MAX_EVENTS limits prevent memory leaks\n7. **Memoized Storage**: Isolated accumulation per symbol-strategy pair\n\nThe architecture decouples event producers from consumers, enabling flexible monitoring, reporting, and integration without modifying core execution logic.\n\nSources: [src/config/emitters.ts:1-133](), [src/function/event.ts:1-456](), [src/lib/services/markdown/BacktestMarkdownService.ts:1-464](), [src/lib/services/markdown/LiveMarkdownService.ts:1-612]()"
                    },
                    {
                        "page_plan": {
                            "id": "4.5",
                            "title": "Data Flow Patterns"
                        },
                        "content": "# Data Flow Patterns\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/client/ClientStrategy.ts](src/client/ClientStrategy.ts)\n- [src/interfaces/Strategy.interface.ts](src/interfaces/Strategy.interface.ts)\n- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)\n- [src/lib/services/logic/private/BacktestLogicPrivateService.ts](src/lib/services/logic/private/BacktestLogicPrivateService.ts)\n- [src/lib/services/logic/private/LiveLogicPrivateService.ts](src/lib/services/logic/private/LiveLogicPrivateService.ts)\n- [src/lib/services/logic/private/WalkerLogicPrivateService.ts](src/lib/services/logic/private/WalkerLogicPrivateService.ts)\n- [test/index.mjs](test/index.mjs)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page documents the end-to-end data flow patterns in Backtest Kit, tracing how data moves from user configuration through validation, execution, signal processing, and finally to reporting. It maps the transformation of data structures at each stage and identifies the specific services, classes, and methods that handle each transformation.\n\nFor information about the service layer architecture and dependency injection patterns, see [Service Layer & Dependency Injection](#4.1). For details on client implementations, see [Client Layer](#4.2). For the event-driven architecture, see [Event System Architecture](#4.4). For execution mode specifics, see [Execution Modes](#5).\n\nThis page focuses on **how data flows** rather than **what components do**. It serves as a reference for understanding the complete journey of trading signals from conception to completion.\n\n---\n\n## Configuration Phase: User Input to Schema Storage\n\nThe data flow begins when users call registration functions to define their trading strategies, exchanges, and risk parameters. This phase transforms user-provided JavaScript objects into validated, immutable schema entries stored in registry services.\n\n### Configuration Registration Flow\n\n```mermaid\ngraph LR\n    User[\"User Code\"] -->|\"addStrategy()\"| StratGlobal[\"StrategyGlobalService\"]\n    User -->|\"addExchange()\"| ExchGlobal[\"ExchangeGlobalService\"]\n    User -->|\"addFrame()\"| FrameGlobal[\"FrameGlobalService\"]\n    User -->|\"addRisk()\"| RiskGlobal[\"RiskGlobalService\"]\n    User -->|\"addWalker()\"| WalkGlobal[\"WalkerGlobalService\"]\n    \n    StratGlobal -->|\"IStrategySchema\"| StratVal[\"StrategyValidationService<br/>shallow validation\"]\n    ExchGlobal -->|\"IExchangeSchema\"| ExchVal[\"ExchangeValidationService<br/>shallow validation\"]\n    FrameGlobal -->|\"IFrameSchema\"| FrameVal[\"FrameValidationService<br/>shallow validation\"]\n    RiskGlobal -->|\"IRiskSchema\"| RiskVal[\"RiskValidationService<br/>shallow validation\"]\n    WalkGlobal -->|\"IWalkerSchema\"| WalkVal[\"WalkerValidationService<br/>shallow validation\"]\n    \n    StratVal -->|\"store in ToolRegistry\"| StratSchema[\"StrategySchemaService\"]\n    ExchVal -->|\"store in ToolRegistry\"| ExchSchema[\"ExchangeSchemaService\"]\n    FrameVal -->|\"store in ToolRegistry\"| FrameSchema[\"FrameSchemaService\"]\n    RiskVal -->|\"store in ToolRegistry\"| RiskSchema[\"RiskSchemaService\"]\n    WalkVal -->|\"store in ToolRegistry\"| WalkSchema[\"WalkerSchemaService\"]\n```\n\n**Sources:** [src/lib/services/global/StrategyGlobalService.ts](), [src/lib/services/schema/StrategySchemaService.ts](), [src/lib/services/validation/StrategyValidationService.ts]()\n\n### Data Transformation: User Objects to Schema Entries\n\n| Input Type | Validation Layer | Storage Format | Registry Key |\n|------------|------------------|----------------|--------------|\n| `IStrategySchema` | `StrategyValidationService` checks for duplicate names | Stored in `ToolRegistry<IStrategySchema>` | `strategyName: string` |\n| `IExchangeSchema` | `ExchangeValidationService` checks for duplicate names | Stored in `ToolRegistry<IExchangeSchema>` | `exchangeName: string` |\n| `IFrameSchema` | `FrameValidationService` checks for duplicate names | Stored in `ToolRegistry<IFrameSchema>` | `frameName: string` |\n| `IRiskSchema` | `RiskValidationService` checks for duplicate names | Stored in `ToolRegistry<IRiskSchema>` | `riskName: string` |\n| `IWalkerSchema` | `WalkerValidationService` validates strategy list | Stored in `ToolRegistry<IWalkerSchema>` | `walkerName: string` |\n\n**Sources:** [src/interfaces/Strategy.interface.ts:132-151](), [src/interfaces/Exchange.interface.ts](), [src/interfaces/Frame.interface.ts](), [src/interfaces/Risk.interface.ts](), [src/interfaces/Walker.interface.ts]()\n\n---\n\n## Execution Initiation: API Call to Context Setup\n\nWhen users invoke `Backtest.run()`, `Live.run()`, or `Walker.run()`, the framework validates all schema references, establishes execution contexts, and routes operations to the appropriate services. This phase prepares the runtime environment before any signal processing begins.\n\n### Execution Startup Flow (Backtest Mode)\n\n```mermaid\ngraph TB\n    UserCall[\"Backtest.run(symbol, context)\"] --> BtCmd[\"BacktestCommandService.run()\"]\n    \n    BtCmd --> Validate{{\"Validate schema names<br/>exist in registries\"}}\n    \n    Validate -->|\"strategyName\"| StratVal[\"StrategyValidationService.validate()\"]\n    Validate -->|\"exchangeName\"| ExchVal[\"ExchangeValidationService.validate()\"]\n    Validate -->|\"frameName\"| FrameVal[\"FrameValidationService.validate()\"]\n    \n    StratVal --> MethodCtx[\"MethodContextService.runInContext()<br/>strategyName, exchangeName, frameName\"]\n    ExchVal --> MethodCtx\n    FrameVal --> MethodCtx\n    \n    MethodCtx --> BtLogicPub[\"BacktestLogicPublicService.run()\"]\n    BtLogicPub --> BtLogicPriv[\"BacktestLogicPrivateService.run()\"]\n    \n    BtLogicPriv --> FrameCore[\"FrameCoreService.getTimeframe()\"]\n    FrameCore -->|\"Date[]\"| TimeframeLoop[\"Iterate timeframes\"]\n    \n    TimeframeLoop --> ExecCtx[\"ExecutionContextService.runInContext()<br/>symbol, when, backtest=true\"]\n    \n    ExecCtx --> StratCore[\"StrategyCoreService.tick()\"]\n```\n\n**Sources:** [src/lib/services/command/BacktestCommandService.ts](), [src/lib/services/logic/public/BacktestLogicPublicService.ts](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:62-78](), [src/lib/services/context/MethodContextService.ts](), [src/lib/services/context/ExecutionContextService.ts]()\n\n### Context Propagation Pattern\n\nThe framework uses ambient context services (`MethodContextService` and `ExecutionContextService`) to propagate configuration without explicit parameter passing. This pattern uses the `di-scoped` library to maintain context throughout the call stack.\n\n```mermaid\ngraph LR\n    MethodContext[\"MethodContextService<br/>{strategyName, exchangeName, frameName}\"] -->|\"ambient context\"| Services[\"All Services\"]\n    ExecContext[\"ExecutionContextService<br/>{symbol, when, backtest}\"] -->|\"ambient context\"| Services\n    \n    Services --> StratCore[\"StrategyCoreService<br/>reads contexts\"]\n    Services --> StratConn[\"StrategyConnectionService<br/>reads contexts\"]\n    Services --> ExchCore[\"ExchangeCoreService<br/>reads contexts\"]\n```\n\n**Sources:** [src/lib/services/context/MethodContextService.ts](), [src/lib/services/context/ExecutionContextService.ts](), [src/lib/services/core/StrategyCoreService.ts]()\n\n---\n\n## Signal Generation: Tick to Signal Creation\n\nDuring execution, the framework calls `ClientStrategy.tick()` on each timeframe to generate trading signals. This process involves throttling checks, user function invocation, multi-stage validation, risk checks, and persistence decisions.\n\n### Signal Generation Data Flow\n\n```mermaid\ngraph TB\n    TickCall[\"StrategyCoreService.tick(symbol, when, backtest)\"] --> ConnRoute[\"StrategyConnectionService.tick()\"]\n    \n    ConnRoute --> GetStrat[\"getStrategy(symbol, strategyName)<br/>memoized ClientStrategy instance\"]\n    \n    GetStrat --> WaitInit[\"ClientStrategy.waitForInit()<br/>restore persisted signal\"]\n    \n    WaitInit --> TickMethod[\"ClientStrategy.tick(symbol, strategyName)\"]\n    \n    TickMethod --> Throttle{{\"Check interval throttling<br/>INTERVAL_MINUTES[interval]\"}}\n    \n    Throttle -->|\"not throttled\"| GetAvgPrice[\"exchange.getAveragePrice()<br/>VWAP from last 5 candles\"]\n    \n    GetAvgPrice --> UserFunc[\"user getSignal(symbol, when)<br/>returns ISignalDto | null\"]\n    \n    UserFunc -->|\"ISignalDto\"| ValidateSignal[\"VALIDATE_SIGNAL_FN<br/>7-stage validation\"]\n    \n    ValidateSignal --> RiskCheck[\"risk.checkSignal()<br/>portfolio limits, custom rules\"]\n    \n    RiskCheck -->|\"pass\"| PriceCheck{{\"priceOpen specified?\"}}\n    \n    PriceCheck -->|\"no\"| ImmediateSignal[\"Create ISignalRow<br/>priceOpen = currentPrice<br/>_isScheduled = false\"]\n    \n    PriceCheck -->|\"yes\"| ActivationCheck{{\"priceOpen reached?\"}}\n    \n    ActivationCheck -->|\"yes\"| ImmediateSignal\n    ActivationCheck -->|\"no\"| ScheduledSignal[\"Create IScheduledSignalRow<br/>_isScheduled = true\"]\n    \n    ImmediateSignal --> Persist[\"PersistSignalAdapter.writeSignalData()\"]\n    ScheduledSignal --> PersistSched[\"PersistScheduleAdapter.writeScheduleData()\"]\n    \n    Persist --> RiskAdd[\"risk.addSignal()\"]\n    PersistSched --> ReturnSched[\"Return IStrategyTickResultScheduled\"]\n    \n    RiskAdd --> ReturnOpened[\"Return IStrategyTickResultOpened\"]\n    \n    Throttle -->|\"throttled\"| ReturnNull[\"Return null<br/>no signal generation\"]\n    UserFunc -->|\"null\"| ReturnNull\n    RiskCheck -->|\"fail\"| ReturnNull\n```\n\n**Sources:** [src/client/ClientStrategy.ts:332-476](), [src/lib/services/connection/StrategyConnectionService.ts:207-228](), [src/lib/services/core/StrategyCoreService.ts]()\n\n### Signal Validation Pipeline\n\nThe `VALIDATE_SIGNAL_FN` performs comprehensive validation before any signal activates:\n\n| Validation Stage | Check | GLOBAL_CONFIG Parameter | Failure Reason |\n|-----------------|-------|-------------------------|----------------|\n| 1. Schema Fields | Required fields present (`id`, `symbol`, `position`, etc.) | N/A | Missing required data |\n| 2. Finite Prices | All prices are finite numbers > 0 | N/A | NaN or Infinity detected |\n| 3. TP/SL Logic | Long: `TP > open > SL`<br/>Short: `SL > open > TP` | N/A | Invalid price relationships |\n| 4. TP Distance | TP far enough to cover fees | `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` | Profit too small (< 0.2%) |\n| 5. SL Min Distance | SL not too close (instant stop) | `CC_MIN_STOPLOSS_DISTANCE_PERCENT` | Stop too tight |\n| 6. SL Max Distance | SL not too far (risk limit) | `CC_MAX_STOPLOSS_DISTANCE_PERCENT` | Risk too high |\n| 7. Signal Lifetime | Duration within limits | `CC_MAX_SIGNAL_LIFETIME_MINUTES` | Signal too long (blocks risk) |\n\n**Sources:** [src/client/ClientStrategy.ts:45-330](), [src/config/params.ts]()\n\n---\n\n## Signal Processing: Active Monitoring to Closure\n\nOnce a signal opens, the framework monitors it on every tick, checking for take profit, stop loss, or time expiration conditions. For backtest mode, the `backtest()` method processes multiple candles efficiently.\n\n### Live Mode Monitoring Flow\n\n```mermaid\ngraph TB\n    LiveLoop[\"LiveLogicPrivateService.run()<br/>while(true) loop\"] --> CreateWhen[\"when = new Date()<br/>real-time timestamp\"]\n    \n    CreateWhen --> TickCall[\"StrategyCoreService.tick()\"]\n    \n    TickCall --> GetPending[\"getPendingSignal()<br/>retrieve active signal\"]\n    \n    GetPending -->|\"null\"| CallGetSignal[\"Call GET_SIGNAL_FN<br/>check for new signal\"]\n    GetPending -->|\"ISignalRow\"| MonitorActive[\"Monitor active signal\"]\n    \n    MonitorActive --> GetVWAP[\"exchange.getAveragePrice()<br/>current VWAP\"]\n    \n    GetVWAP --> CheckTP{{\"Long: currentPrice >= TP?<br/>Short: currentPrice <= TP?\"}}\n    CheckTP -->|\"yes\"| CloseTp[\"CLOSE_PENDING_SIGNAL_FN<br/>closeReason='take_profit'\"]\n    \n    CheckTP -->|\"no\"| CheckSL{{\"Long: currentPrice <= SL?<br/>Short: currentPrice >= SL?\"}}\n    CheckSL -->|\"yes\"| CloseSL[\"CLOSE_PENDING_SIGNAL_FN<br/>closeReason='stop_loss'\"]\n    \n    CheckSL -->|\"no\"| CheckTime{{\"elapsedTime >= minuteEstimatedTime?\"}}\n    CheckTime -->|\"yes\"| CloseTime[\"CLOSE_PENDING_SIGNAL_FN<br/>closeReason='time_expired'\"]\n    \n    CheckTime -->|\"no\"| PartialCheck[\"Check partial profit/loss<br/>emit partial events\"]\n    \n    CloseTp --> CleanUp[\"Delete persisted signal<br/>risk.removeSignal()<br/>partial.clear()\"]\n    CloseSL --> CleanUp\n    CloseTime --> CleanUp\n    \n    CleanUp --> CalcPNL[\"toProfitLossDto()<br/>apply fees & slippage\"]\n    \n    CalcPNL --> EmitClosed[\"Return IStrategyTickResultClosed\"]\n    \n    PartialCheck --> EmitActive[\"Return IStrategyTickResultActive\"]\n    \n    CallGetSignal --> EmitIdle[\"Return IStrategyTickResultIdle\"]\n    \n    EmitClosed --> Sleep[\"sleep(TICK_TTL)<br/>1 minute + 1ms\"]\n    EmitActive --> Sleep\n    EmitIdle --> Sleep\n    \n    Sleep --> LiveLoop\n```\n\n**Sources:** [src/lib/services/logic/private/LiveLogicPrivateService.ts:63-175](), [src/client/ClientStrategy.ts:901-1023](), [src/helpers/toProfitLossDto.ts]()\n\n### Backtest Mode Fast Processing Flow\n\n```mermaid\ngraph TB\n    OpenedResult[\"IStrategyTickResultOpened<br/>signal just created\"] --> GetCandles[\"ExchangeCoreService.getNextCandles()<br/>fetch minuteEstimatedTime + buffer\"]\n    \n    GetCandles -->|\"ICandleData[]\"| CallBacktest[\"StrategyConnectionService.backtest()\"]\n    \n    CallBacktest --> ClientBacktest[\"ClientStrategy.backtest(symbol, strategyName, candles)\"]\n    \n    ClientBacktest --> ScheduledCheck{{\"_scheduledSignal exists?\"}}\n    \n    ScheduledCheck -->|\"yes\"| MonitorScheduled[\"Monitor scheduled signal activation\"]\n    ScheduledCheck -->|\"no\"| MonitorPending[\"Monitor pending signal\"]\n    \n    MonitorScheduled --> CandleLoop1[\"For each candle:<br/>check if SL hit before activation\"]\n    CandleLoop1 -->|\"SL hit\"| CancelScheduled[\"Return IStrategyTickResultCancelled\"]\n    CandleLoop1 -->|\"priceOpen reached\"| ActivateSignal[\"Convert to ISignalRow<br/>update pendingAt\"]\n    \n    ActivateSignal --> MonitorPending\n    \n    MonitorPending --> CandleLoop2[\"For each candle:<br/>calc VWAP, check TP/SL/time\"]\n    \n    CandleLoop2 -->|\"TP/SL/time hit\"| ReturnClosed[\"Return IStrategyTickResultClosed\"]\n    \n    CandleLoop2 -->|\"all candles exhausted\"| TimeExpired[\"Force close at last candle<br/>closeReason='time_expired'\"]\n    \n    TimeExpired --> ReturnClosed\n```\n\n**Sources:** [src/client/ClientStrategy.ts:1190-1484](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:304-431]()\n\n---\n\n## Event Propagation: Signal Results to Event Consumers\n\nAfter each tick or signal closure, the framework emits events through RxJS Subject-based emitters. Multiple markdown services subscribe to these events to accumulate data for report generation.\n\n### Event Flow Architecture\n\n```mermaid\ngraph LR\n    ClientStrat[\"ClientStrategy.tick()<br/>or ClientStrategy.backtest()\"] --> ConnService[\"StrategyConnectionService<br/>after operation completes\"]\n    \n    ConnService --> EmitCheck{{\"Check execution mode\"}}\n    \n    EmitCheck -->|\"backtest=true\"| EmitBT[\"signalBacktestEmitter.next(result)\"]\n    EmitCheck -->|\"backtest=false\"| EmitLive[\"signalLiveEmitter.next(result)\"]\n    \n    EmitBT --> EmitGlobal[\"signalEmitter.next(result)\"]\n    EmitLive --> EmitGlobal\n    \n    EmitGlobal --> Subscribers[\"Event Subscribers\"]\n    \n    Subscribers --> BTMd[\"BacktestMarkdownService<br/>filters action='closed'\"]\n    Subscribers --> LiveMd[\"LiveMarkdownService<br/>all actions\"]\n    Subscribers --> SchedMd[\"ScheduleMarkdownService<br/>filters scheduled/cancelled\"]\n    Subscribers --> HeatMd[\"HeatMarkdownService<br/>cross-symbol aggregation\"]\n    Subscribers --> UserListeners[\"User listenSignal* callbacks\"]\n    \n    BTMd --> Storage[\"ReportStorage<br/>bounded queue (250 events)\"]\n    LiveMd --> Storage\n    SchedMd --> Storage\n    HeatMd --> Storage\n```\n\n**Sources:** [src/lib/services/connection/StrategyConnectionService.ts:217-227](), [src/config/emitters.ts](), [src/lib/services/markdown/BacktestMarkdownService.ts](), [src/lib/services/markdown/LiveMarkdownService.ts]()\n\n### Event Filtering and Storage Pattern\n\nEach markdown service subscribes to specific events and maintains a bounded event queue:\n\n| Markdown Service | Event Filter | Queue Bound | Storage Key |\n|------------------|--------------|-------------|-------------|\n| `BacktestMarkdownService` | `action === \"closed\"` | 250 events | `${symbol}:${strategyName}` |\n| `LiveMarkdownService` | All actions (idle, opened, active, closed) | 250 events | `${symbol}:${strategyName}` |\n| `ScheduleMarkdownService` | `action === \"scheduled\" \\|\\| \"cancelled\"` | 250 events | `${symbol}:${strategyName}` |\n| `HeatMarkdownService` | `action === \"closed\"` | No bound (portfolio-wide) | `portfolio` |\n| `PartialMarkdownService` | Partial profit/loss events | 250 events | `${symbol}:${strategyName}` |\n| `RiskMarkdownService` | Risk rejection events | 250 events | `${symbol}:${strategyName}` |\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts](), [src/lib/services/markdown/LiveMarkdownService.ts](), [src/classes/ReportStorage.ts]()\n\n---\n\n## Report Generation: Accumulated Events to Statistics\n\nThe final stage transforms accumulated event data into statistical models and formatted markdown reports. This process calculates metrics like Sharpe ratio, win rate, and PNL using safe math functions.\n\n### Statistics Calculation Flow\n\n```mermaid\ngraph TB\n    UserCall[\"Backtest.getData(symbol, strategyName)\"] --> MarkdownService[\"BacktestMarkdownService.getData()\"]\n    \n    MarkdownService --> GetEvents[\"ReportStorage.get(key)<br/>retrieve bounded event list\"]\n    \n    GetEvents -->|\"IStrategyTickResultClosed[]\"| FilterClosed[\"Filter closed signals only\"]\n    \n    FilterClosed --> CalcBasic[\"Calculate basic counts<br/>totalSignals, winCount, lossCount\"]\n    \n    CalcBasic --> CalcWinRate[\"winRate = winCount / totalSignals * 100<br/>with safeDiv()\"]\n    \n    CalcWinRate --> CalcPNL[\"totalPnl = sum(pnl.pnlPercentage)<br/>avgPnl = totalPnl / totalSignals\"]\n    \n    CalcPNL --> CalcStdDev[\"stdDev = sqrt(variance)<br/>using safeDiv() for division\"]\n    \n    CalcStdDev --> CalcSharpe[\"sharpeRatio = avgPnl / stdDev<br/>annualizedSharpeRatio = sharpeRatio * sqrt(365)\"]\n    \n    CalcSharpe --> CalcCertainty[\"certaintyRatio = avgWin / abs(avgLoss)<br/>with safeDiv()\"]\n    \n    CalcCertainty --> CalcYearly[\"expectedYearlyReturns = avgPnl * tradesPerYear<br/>based on avg duration\"]\n    \n    CalcYearly --> ReturnStats[\"Return BacktestStatisticsModel\"]\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts](), [src/model/BacktestStatisticsModel.ts](), [src/helpers/safeDiv.ts]()\n\n### Report Formatting and Dump\n\n```mermaid\ngraph LR\n    UserCall[\"Backtest.getReport(symbol, strategyName)\"] --> GetData[\"BacktestMarkdownService.getData()<br/>BacktestStatisticsModel\"]\n    \n    GetData --> FormatTable[\"Format markdown table<br/>columns from ColumnConfig\"]\n    \n    FormatTable --> FormatStats[\"Format statistics section<br/>winRate, sharpeRatio, etc.\"]\n    \n    FormatStats --> ReturnMd[\"Return markdown string\"]\n    \n    UserDump[\"Backtest.dump(symbol, strategyName)\"] --> GetReport[\"BacktestMarkdownService.getReport()\"]\n    \n    GetReport --> WritePath[\"./dump/backtest/<br/>write {symbol}_{strategyName}.md\"]\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts](), [src/classes/BacktestCommandService.ts]()\n\n---\n\n## Cross-Cutting Data Flows\n\n### Persistence and Recovery Flow\n\n```mermaid\ngraph LR\n    SetPending[\"ClientStrategy.setPendingSignal(signal)\"] --> PersistWrite[\"PersistSignalAdapter.writeSignalData()<br/>atomic file write\"]\n    \n    PersistWrite --> FileWrite[\"fs.writeFile(tmpPath)<br/>fs.rename(tmpPath, finalPath)\"]\n    \n    LiveRestart[\"Live.run() after crash\"] --> WaitInit[\"ClientStrategy.waitForInit()\"]\n    \n    WaitInit --> PersistRead[\"PersistSignalAdapter.readSignalData()\"]\n    \n    PersistRead --> FileRead[\"fs.readFile(finalPath)<br/>JSON.parse()\"]\n    \n    FileRead --> Restore[\"Restore _pendingSignal<br/>call onActive callback\"]\n```\n\n**Sources:** [src/client/ClientStrategy.ts:491-552](), [src/classes/Persist.ts]()\n\n### Memoization and Caching Pattern\n\n```mermaid\ngraph TB\n    FirstCall[\"StrategyConnectionService.getStrategy<br/>first call for 'BTCUSDT:my-strategy'\"] --> CreateClient[\"new ClientStrategy({...params})<br/>initialize instance\"]\n    \n    CreateClient --> Cache[\"Store in memoize cache<br/>key = 'BTCUSDT:my-strategy'\"]\n    \n    SecondCall[\"StrategyConnectionService.getStrategy<br/>subsequent call 'BTCUSDT:my-strategy'\"] --> CheckCache{{\"Cache hit?\"}}\n    \n    CheckCache -->|\"yes\"| ReturnCached[\"Return cached ClientStrategy<br/>same instance\"]\n    \n    CheckCache -->|\"no\"| CreateClient\n```\n\n**Sources:** [src/lib/services/connection/StrategyConnectionService.ts:120-151]()\n\n---\n\n## Complete End-to-End Flow Summary\n\n```mermaid\ngraph TB\n    subgraph \"1. Configuration\"\n        A1[\"addStrategy()\"] --> A2[\"StrategySchemaService<br/>ToolRegistry storage\"]\n    end\n    \n    subgraph \"2. Execution Initiation\"\n        B1[\"Backtest.run()\"] --> B2[\"Validate schemas\"]\n        B2 --> B3[\"MethodContextService.runInContext()\"]\n        B3 --> B4[\"BacktestLogicPrivateService.run()\"]\n    end\n    \n    subgraph \"3. Signal Generation\"\n        C1[\"FrameCoreService.getTimeframe()\"] --> C2[\"For each timeframe\"]\n        C2 --> C3[\"ExecutionContextService.runInContext()\"]\n        C3 --> C4[\"StrategyConnectionService.tick()\"]\n        C4 --> C5[\"ClientStrategy.tick()\"]\n        C5 --> C6[\"User getSignal()\"]\n        C6 --> C7[\"VALIDATE_SIGNAL_FN\"]\n        C7 --> C8[\"risk.checkSignal()\"]\n    end\n    \n    subgraph \"4. Signal Processing\"\n        D1[\"PersistSignalAdapter.writeSignalData()\"] --> D2[\"ClientStrategy.backtest()\"]\n        D2 --> D3[\"Monitor TP/SL/time\"]\n        D3 --> D4[\"CLOSE_PENDING_SIGNAL_FN\"]\n        D4 --> D5[\"toProfitLossDto()\"]\n    end\n    \n    subgraph \"5. Event Emission\"\n        E1[\"signalBacktestEmitter.next()\"] --> E2[\"BacktestMarkdownService\"]\n        E1 --> E3[\"LiveMarkdownService\"]\n        E1 --> E4[\"User listeners\"]\n    end\n    \n    subgraph \"6. Report Generation\"\n        F1[\"ReportStorage.get()\"] --> F2[\"Calculate statistics\"]\n        F2 --> F3[\"Format markdown\"]\n        F3 --> F4[\"Backtest.dump()\"]\n    end\n    \n    A2 --> B1\n    B4 --> C1\n    C8 --> D1\n    D5 --> E1\n    E2 --> F1\n    E3 --> F1\n```\n\n**Sources:** All service files in [src/lib/services/](), [src/client/ClientStrategy.ts](), [src/classes/]()"
                    },
                    {
                        "page_plan": {
                            "id": "5",
                            "title": "Execution Modes"
                        },
                        "content": "# Execution Modes\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Heat.ts](src/classes/Heat.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Partial.ts](src/classes/Partial.ts)\n- [src/classes/Performance.ts](src/classes/Performance.ts)\n- [src/classes/Risk.ts](src/classes/Risk.ts)\n- [src/classes/Schedule.ts](src/classes/Schedule.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [src/lib/services/logic/private/BacktestLogicPrivateService.ts](src/lib/services/logic/private/BacktestLogicPrivateService.ts)\n- [src/lib/services/logic/private/LiveLogicPrivateService.ts](src/lib/services/logic/private/LiveLogicPrivateService.ts)\n- [src/lib/services/logic/private/WalkerLogicPrivateService.ts](src/lib/services/logic/private/WalkerLogicPrivateService.ts)\n- [test/spec/columns.test.mjs](test/spec/columns.test.mjs)\n\n</details>\n\n\n\nThis document describes the three execution modes provided by Backtest Kit: **Backtest**, **Live**, and **Walker**. Each mode uses the same core strategy execution logic but differs in orchestration, time progression, and result streaming patterns. For details on the strategy lifecycle within these modes, see [Signals & Signal Lifecycle](#3.1). For information on async generator implementation details, see [Async Generator Patterns](#5.4).\n\n---\n\n## Overview\n\nBacktest Kit provides three distinct execution modes, each optimized for different use cases:\n\n| Mode | Purpose | Time Progression | Generator Type | Primary Output |\n|------|---------|------------------|----------------|----------------|\n| **Backtest** | Historical simulation | Pre-determined timeframes | Finite async generator | Closed signals with PNL |\n| **Live** | Real-time trading | Real-time (`new Date()`) | Infinite async generator | Opened/closed signals |\n| **Walker** | Strategy comparison | Orchestrates multiple backtests | Finite async generator | Comparative statistics |\n\nAll three modes share the same core execution components (`StrategyCoreService`, `ClientStrategy`) to ensure identical signal logic between testing and production.\n\n**Sources:** [src/classes/Backtest.ts:1-601](), [src/classes/Live.ts:1-600](), [src/classes/Walker.ts:1-600](), Diagram 2 from high-level architecture\n\n---\n\n## Architecture: Mode-Specific Orchestration\n\n```mermaid\ngraph TB\n    subgraph \"Public API Layer\"\n        BacktestClass[\"Backtest.run(symbol, context)<br/>Backtest.background(symbol, context)\"]\n        LiveClass[\"Live.run(symbol, context)<br/>Live.background(symbol, context)\"]\n        WalkerClass[\"Walker.run(symbol, context)<br/>Walker.background(symbol, context)\"]\n    end\n    \n    subgraph \"Instance Management\"\n        BacktestInstance[\"BacktestInstance<br/>Per symbol:strategyName<br/>Memoized\"]\n        LiveInstance[\"LiveInstance<br/>Per symbol:strategyName<br/>Memoized\"]\n        WalkerInstance[\"WalkerInstance<br/>Per symbol:walkerName<br/>Memoized\"]\n    end\n    \n    subgraph \"Orchestration Services\"\n        BacktestLogic[\"BacktestLogicPrivateService.run()<br/>Timeframe iteration<br/>Async generator\"]\n        LiveLogic[\"LiveLogicPrivateService.run()<br/>Infinite loop + sleep<br/>Async generator\"]\n        WalkerLogic[\"WalkerLogicPrivateService.run()<br/>Sequential backtests<br/>Async generator\"]\n    end\n    \n    subgraph \"Shared Core Execution\"\n        StrategyCore[\"StrategyCoreService<br/>tick() - Signal state machine<br/>backtest() - Fast TP/SL detection\"]\n        ClientStrategy[\"ClientStrategy instances<br/>Signal lifecycle management<br/>VWAP pricing\"]\n    end\n    \n    subgraph \"Supporting Services\"\n        FrameCore[\"FrameCoreService<br/>getTimeframe()\"]\n        ExchangeCore[\"ExchangeCoreService<br/>getNextCandles()\"]\n        MarkdownServices[\"BacktestMarkdownService<br/>LiveMarkdownService<br/>WalkerMarkdownService\"]\n    end\n    \n    BacktestClass --> BacktestInstance\n    LiveClass --> LiveInstance\n    WalkerClass --> WalkerInstance\n    \n    BacktestInstance --> BacktestLogic\n    LiveInstance --> LiveLogic\n    WalkerInstance --> WalkerLogic\n    \n    BacktestLogic --> FrameCore\n    BacktestLogic --> StrategyCore\n    BacktestLogic --> ExchangeCore\n    \n    LiveLogic --> StrategyCore\n    \n    WalkerLogic --> BacktestLogic\n    WalkerLogic --> MarkdownServices\n    \n    StrategyCore --> ClientStrategy\n    \n    style BacktestClass fill:#e3f2fd,stroke:#1976d2,stroke-width:2px\n    style LiveClass fill:#fff3e0,stroke:#f57c00,stroke-width:2px\n    style WalkerClass fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    style StrategyCore fill:#c8e6c9,stroke:#388e3c,stroke-width:3px\n```\n\n**Execution Mode Architecture**\n\nThis diagram shows how each execution mode uses mode-specific orchestration services while sharing the same core strategy execution logic. Instance management ensures isolated state per symbol-strategy or symbol-walker pair.\n\n**Sources:** [src/classes/Backtest.ts:359-600](), [src/classes/Live.ts:376-600](), [src/classes/Walker.ts:431-600](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:1-347](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:1-179](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:1-235]()\n\n---\n\n## Backtest Mode: Historical Simulation\n\nBacktest mode executes strategies over historical data with deterministic time progression. It iterates through pre-defined timeframes minute-by-minute, calling strategy logic at each interval.\n\n### Entry Points\n\nThe `Backtest` singleton provides two methods for execution:\n\n```typescript\n// Async iterator pattern - yields results\nfor await (const result of Backtest.run(symbol, {\n  strategyName, exchangeName, frameName\n})) {\n  console.log(result.pnl.pnlPercentage);\n}\n\n// Background execution - fire and forget\nconst cancel = Backtest.background(symbol, {\n  strategyName, exchangeName, frameName\n});\n```\n\nBoth methods delegate to `BacktestInstance` which maintains isolated state per `symbol:strategyName` pair using memoization.\n\n**Sources:** [src/classes/Backtest.ts:378-400](), [src/classes/Backtest.ts:423-443]()\n\n### Orchestration Flow\n\nThe `BacktestLogicPrivateService.run()` method implements the core backtest loop:\n\n```mermaid\ngraph TB\n    Start[\"BacktestLogicPrivateService.run(symbol)\"]\n    GetFrames[\"Get timeframes from FrameCoreService<br/>startDate → endDate at interval\"]\n    LoopStart[\"i = 0<br/>while i < timeframes.length\"]\n    EmitProgress[\"Emit progressBacktestEmitter<br/>progress = i / totalFrames\"]\n    CheckStop1{{\"Check getStopped()<br/>before tick?\"}}\n    CallTick[\"await StrategyCoreService.tick()<br/>symbol, when=timeframes[i], backtest=true\"]\n    TickResult{{\"result.action?\"}}\n    CheckStop2{{\"result.action === 'idle'<br/>AND getStopped()?\"}}\n    HandleScheduled[\"Handle scheduled signal:<br/>1. Calculate candles needed<br/>2. Fetch candles via getNextCandles<br/>3. Call backtest() with candles\"]\n    BacktestFast[\"StrategyCoreService.backtest()<br/>Fast TP/SL detection<br/>Bulk candle processing\"]\n    BacktestResult{{\"backtest result?\"}}\n    SkipFrames[\"Skip frames: when += minutesUsed<br/>i += minutesUsed\"]\n    YieldClosed[\"yield closed signal with PNL\"]\n    IncrementI[\"i++\"]\n    EmitFinalProgress[\"Emit final progress (100%)\"]\n    EmitPerformance[\"Emit performanceEmitter<br/>with total duration\"]\n    Done[\"End generator\"]\n    \n    Start --> GetFrames\n    GetFrames --> LoopStart\n    LoopStart --> EmitProgress\n    EmitProgress --> CheckStop1\n    CheckStop1 -->|\"stopped\"| Done\n    CheckStop1 -->|\"continue\"| CallTick\n    CallTick --> TickResult\n    TickResult -->|\"idle\"| CheckStop2\n    CheckStop2 -->|\"stopped\"| Done\n    CheckStop2 -->|\"continue\"| IncrementI\n    TickResult -->|\"active\"| IncrementI\n    TickResult -->|\"scheduled\"| HandleScheduled\n    TickResult -->|\"opened\"| HandleScheduled\n    HandleScheduled --> BacktestFast\n    BacktestFast --> BacktestResult\n    BacktestResult -->|\"closed\"| SkipFrames\n    SkipFrames --> YieldClosed\n    YieldClosed --> LoopStart\n    BacktestResult -->|\"active\"| IncrementI\n    IncrementI --> LoopStart\n    LoopStart -->|\"i >= timeframes.length\"| EmitFinalProgress\n    EmitFinalProgress --> EmitPerformance\n    EmitPerformance --> Done\n    \n    style Done fill:#c8e6c9,stroke:#388e3c\n    style YieldClosed fill:#fff9c4,stroke:#f57f17\n```\n\n**Backtest Orchestration Flow**\n\nThis diagram shows the complete backtest loop including the \"fast backtest\" optimization that skips timeframes while a signal is active.\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:62-347]()\n\n### Fast Backtest Optimization\n\nWhen a signal opens, the orchestrator switches to \"fast mode\":\n\n1. **Calculates candles needed:** `bufferMinutes + CC_SCHEDULE_AWAIT_MINUTES + minuteEstimatedTime + 1`\n2. **Fetches bulk candles:** Via `ExchangeCoreService.getNextCandles()`\n3. **Processes in one call:** `StrategyCoreService.backtest()` handles TP/SL detection across all candles\n4. **Skips timeframes:** `i += minutesUsed` to jump to signal closure timestamp\n\nThis optimization dramatically improves performance for long-running signals by avoiding per-minute `tick()` calls during active signal monitoring.\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:154-295]()\n\n### Progress Tracking\n\nThe orchestrator emits progress events after processing each timeframe:\n\n```typescript\nawait progressBacktestEmitter.next({\n  exchangeName, strategyName, symbol,\n  totalFrames,\n  processedFrames: i,\n  progress: totalFrames > 0 ? i / totalFrames : 0,\n});\n```\n\nConsumer code can listen via `listenProgressBacktest()` to display real-time progress indicators.\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:84-92]()\n\n### Graceful Shutdown\n\nBacktest supports graceful shutdown via `Backtest.stop(symbol, strategyName)`:\n\n- Sets internal `stopped` flag in `StrategyCoreService`\n- Checks flag at two points: **before tick** and **when idle**\n- Current active signal completes normally before stopping\n- Prevents partial results from incomplete backtests\n\n**Sources:** [src/classes/Backtest.ts:254-260](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:95-111](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:132-150]()\n\n---\n\n## Live Trading Mode: Real-Time Execution\n\nLive mode executes strategies continuously in real-time using an infinite loop pattern. It progresses time with `new Date()` on each iteration and includes crash-safe persistence.\n\n### Entry Points\n\nThe `Live` singleton provides two methods:\n\n```typescript\n// Async iterator - yields opened and closed signals\nfor await (const result of Live.run(symbol, {\n  strategyName, exchangeName\n})) {\n  if (result.action === \"opened\") {\n    console.log(\"New signal:\", result.signal.id);\n  }\n  if (result.action === \"closed\") {\n    console.log(\"PNL:\", result.pnl.pnlPercentage);\n  }\n}\n\n// Background execution - infinite until stopped\nconst cancel = Live.background(symbol, {\n  strategyName, exchangeName\n});\n```\n\nBoth methods delegate to `LiveInstance` which maintains isolated state per `symbol:strategyName` pair.\n\n**Sources:** [src/classes/Live.ts:398-418](), [src/classes/Live.ts:441-459]()\n\n### Orchestration Flow\n\nThe `LiveLogicPrivateService.run()` method implements the infinite monitoring loop:\n\n```mermaid\ngraph TB\n    Start[\"LiveLogicPrivateService.run(symbol)\"]\n    LoopStart[\"while true:<br/>when = new Date()\"]\n    CallTick[\"await StrategyCoreService.tick()<br/>symbol, when, backtest=false\"]\n    EmitPerformance[\"Emit performanceEmitter<br/>metricType: 'live_tick'<br/>duration: tickEndTime - tickStartTime\"]\n    TickResult{{\"result.action?\"}}\n    CheckStopIdle{{\"getStopped()?\"}}\n    CheckStopClosed{{\"getStopped()?\"}}\n    YieldResult[\"yield result<br/>opened or closed\"]\n    SleepIdle[\"await sleep(TICK_TTL)<br/>1 minute + 1ms\"]\n    SleepAfter[\"await sleep(TICK_TTL)\"]\n    Done[\"Break loop - end generator\"]\n    \n    Start --> LoopStart\n    LoopStart --> CallTick\n    CallTick --> EmitPerformance\n    EmitPerformance --> TickResult\n    \n    TickResult -->|\"idle\"| CheckStopIdle\n    CheckStopIdle -->|\"stopped\"| Done\n    CheckStopIdle -->|\"continue\"| SleepIdle\n    SleepIdle --> LoopStart\n    \n    TickResult -->|\"active\"| SleepAfter\n    TickResult -->|\"scheduled\"| SleepAfter\n    SleepAfter --> LoopStart\n    \n    TickResult -->|\"opened\"| YieldResult\n    TickResult -->|\"closed\"| YieldResult\n    YieldResult --> CheckStopClosed\n    CheckStopClosed -->|\"stopped AND closed\"| Done\n    CheckStopClosed -->|\"continue\"| SleepAfter\n    \n    style Done fill:#c8e6c9,stroke:#388e3c\n    style YieldResult fill:#fff9c4,stroke:#f57f17\n    style LoopStart fill:#e3f2fd,stroke:#1976d2\n```\n\n**Live Trading Orchestration Flow**\n\nThis diagram shows the infinite loop pattern with sleep intervals and graceful shutdown checkpoints.\n\n**Sources:** [src/lib/services/logic/private/LiveLogicPrivateService.ts:63-175]()\n\n### Sleep Interval Configuration\n\nThe orchestrator sleeps between ticks using a constant defined at the module level:\n\n```typescript\nconst TICK_TTL = 1 * 60 * 1_000 + 1; // 1 minute + 1ms\n```\n\nThis interval balances responsiveness with API rate limiting. The extra 1ms prevents exact-minute boundary issues.\n\n**Sources:** [src/lib/services/logic/private/LiveLogicPrivateService.ts:14]()\n\n### Crash-Safe Persistence\n\nLive mode automatically persists active signals to disk for crash recovery:\n\n- **Signal opened:** `ClientStrategy` calls `PersistSignalAdapter.set()` to save signal state\n- **Process crashes:** On restart, `ClientStrategy.waitForInit()` loads persisted signal\n- **Signal closed:** `PersistSignalAdapter.delete()` removes from storage\n- **Scheduled signals NOT persisted:** Only active (opened) signals are saved\n\nThis ensures crash recovery without data loss or duplicate positions.\n\n**Sources:** Referenced in Diagram 3 from high-level architecture, implemented in ClientStrategy\n\n### Result Streaming\n\nLive mode yields only **opened** and **closed** results, skipping **idle**, **active**, and **scheduled** states to reduce noise:\n\n```typescript\nif (result.action === \"idle\") {\n  await sleep(TICK_TTL);\n  continue;\n}\nif (result.action === \"active\") {\n  await sleep(TICK_TTL);\n  continue;\n}\nif (result.action === \"scheduled\") {\n  await sleep(TICK_TTL);\n  continue;\n}\n// Yield opened, closed results\nyield result as IStrategyTickResultClosed | IStrategyTickResultOpened;\n```\n\n**Sources:** [src/lib/services/logic/private/LiveLogicPrivateService.ts:141-152]()\n\n### Graceful Shutdown\n\nLive mode supports graceful shutdown via `Live.stop(symbol, strategyName)`:\n\n- **When idle:** Stops immediately after setting flag\n- **When active:** Waits for signal to close before stopping\n- **After closed:** Checks flag and stops if set\n\nThis ensures positions close properly before the trading bot terminates.\n\n**Sources:** [src/classes/Live.ts:261-267](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:119-136](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:155-171]()\n\n---\n\n## Walker Mode: Strategy Comparison\n\nWalker mode orchestrates multiple backtests sequentially to compare strategy performance. It executes each strategy's backtest, collects statistics, and ranks results by a configurable metric.\n\n### Entry Points\n\nThe `Walker` singleton provides two methods:\n\n```typescript\n// Async iterator - yields progress after each strategy\nfor await (const progress of Walker.run(symbol, {\n  walkerName\n})) {\n  console.log(`${progress.strategiesTested}/${progress.totalStrategies}`);\n  console.log(\"Best:\", progress.bestStrategy, progress.bestMetric);\n}\n\n// Background execution\nconst cancel = Walker.background(symbol, { walkerName });\n```\n\nWalker configuration is defined via `addWalker()`:\n\n```typescript\naddWalker({\n  walkerName: \"optimizer-v1\",\n  strategies: [\"strat-a\", \"strat-b\", \"strat-c\"],\n  exchangeName: \"binance\",\n  frameName: \"1d-backtest\",\n  metric: \"sharpeRatio\", // or \"winRate\", \"totalPnl\", etc.\n});\n```\n\n**Sources:** [src/classes/Walker.ts:466-485](), [src/classes/Walker.ts:505-527]()\n\n### Orchestration Flow\n\nThe `WalkerLogicPrivateService.run()` method iterates through strategies:\n\n```mermaid\ngraph TB\n    Start[\"WalkerLogicPrivateService.run()<br/>symbol, strategies, metric, context\"]\n    Init[\"strategiesTested = 0<br/>bestMetric = null<br/>bestStrategy = null<br/>stoppedStrategies = Set()\"]\n    Subscribe[\"Subscribe to walkerStopSubject<br/>Filter by symbol AND walkerName<br/>Collect stops in Set\"]\n    LoopStart[\"for each strategyName in strategies\"]\n    CheckStopped{{\"stoppedStrategies.has(strategyName)?\"}}\n    CallbackStart[\"Call onStrategyStart callback<br/>if provided\"]\n    RunBacktest[\"iterator = BacktestLogicPublicService.run()<br/>symbol, strategyName, exchangeName, frameName\"]\n    ConsumeAll[\"await resolveDocuments(iterator)<br/>Consume all backtest results\"]\n    GetStats[\"stats = BacktestMarkdownService.getData()<br/>symbol, strategyName\"]\n    ExtractMetric[\"metricValue = stats[metric]<br/>Extract configured metric\"]\n    CompareMetric{{\"metricValue > bestMetric?\"}}\n    UpdateBest[\"bestMetric = metricValue<br/>bestStrategy = strategyName\"]\n    CallbackComplete[\"Call onStrategyComplete callback<br/>if provided\"]\n    EmitProgress[\"Emit walkerEmitter with progress<br/>Yield WalkerContract\"]\n    Increment[\"strategiesTested++\"]\n    EmitComplete[\"Emit walkerCompleteSubject<br/>with final results\"]\n    Unsubscribe[\"unsubscribe() from stop signals\"]\n    Done[\"End generator\"]\n    \n    Start --> Init\n    Init --> Subscribe\n    Subscribe --> LoopStart\n    LoopStart --> CheckStopped\n    CheckStopped -->|\"stopped\"| EmitComplete\n    CheckStopped -->|\"continue\"| CallbackStart\n    CallbackStart --> RunBacktest\n    RunBacktest --> ConsumeAll\n    ConsumeAll --> GetStats\n    GetStats --> ExtractMetric\n    ExtractMetric --> CompareMetric\n    CompareMetric -->|\"yes\"| UpdateBest\n    CompareMetric -->|\"no\"| CallbackComplete\n    UpdateBest --> CallbackComplete\n    CallbackComplete --> EmitProgress\n    EmitProgress --> Increment\n    Increment --> LoopStart\n    LoopStart -->|\"all strategies done\"| EmitComplete\n    EmitComplete --> Unsubscribe\n    Unsubscribe --> Done\n    \n    style Done fill:#c8e6c9,stroke:#388e3c\n    style EmitProgress fill:#fff9c4,stroke:#f57f17\n```\n\n**Walker Orchestration Flow**\n\nThis diagram shows the sequential strategy testing pattern with real-time metric comparison and progressive result streaming.\n\n**Sources:** [src/lib/services/logic/private/WalkerLogicPrivateService.ts:68-235]()\n\n### Metric Comparison\n\nWalker supports multiple comparison metrics defined in the walker schema:\n\n```typescript\ntype WalkerMetric = \n  | \"sharpeRatio\"\n  | \"winRate\" \n  | \"totalPnl\"\n  | \"avgPnl\"\n  | \"maxDrawdown\"\n  | \"totalTrades\";\n```\n\nThe orchestrator extracts the configured metric from `BacktestStatisticsModel` and tracks the best performer:\n\n```typescript\nconst value = stats[metric];\nconst metricValue = value !== null && value !== undefined ? value : 0;\n\nif (bestMetric === null || metricValue > bestMetric) {\n  bestMetric = metricValue;\n  bestStrategy = strategyName;\n}\n```\n\n**Sources:** [src/lib/services/logic/private/WalkerLogicPrivateService.ts:172-188]()\n\n### Progressive Result Streaming\n\nWalker yields `WalkerContract` after each strategy completes, enabling real-time monitoring:\n\n```typescript\nconst contract: WalkerContract = {\n  symbol,\n  totalStrategies: strategies.length,\n  strategiesTested,\n  bestStrategy,\n  bestMetric,\n  metric,\n  strategyName: currentStrategyName,\n  currentMetric: metricValue,\n};\n\nawait walkerEmitter.next(contract);\nyield contract;\n```\n\nConsumer code receives incremental updates as each strategy finishes.\n\n**Sources:** [src/lib/services/logic/private/WalkerLogicPrivateService.ts:192-208]()\n\n### Multi-Walker Stop Signals\n\nWalker supports multiple concurrent walkers on the same symbol by filtering stop signals by both `symbol` AND `walkerName`:\n\n```typescript\nconst unsubscribe = walkerStopSubject\n  .filter((data) => \n    data.symbol === symbol && \n    data.walkerName === context.walkerName\n  )\n  .connect((data) => {\n    stoppedStrategies.add(data.strategyName);\n  });\n```\n\nThis prevents crosstalk when running multiple optimization experiments simultaneously.\n\n**Sources:** [src/lib/services/logic/private/WalkerLogicPrivateService.ts:98-111]()\n\n### Strategy Callbacks\n\nWalker supports optional callbacks for tracking progress:\n\n```typescript\naddWalker({\n  walkerName: \"optimizer\",\n  strategies: [...],\n  callbacks: {\n    onStrategyStart: (strategyName, symbol) => {\n      console.log(`Testing ${strategyName}...`);\n    },\n    onStrategyComplete: (strategyName, symbol, stats) => {\n      console.log(`${strategyName} Sharpe: ${stats.sharpeRatio}`);\n    },\n    onStrategyError: (strategyName, symbol, error) => {\n      console.error(`${strategyName} failed:`, error);\n    },\n  },\n});\n```\n\n**Sources:** [src/lib/services/logic/private/WalkerLogicPrivateService.ts:129-131](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:190-192]()\n\n---\n\n## Async Generator Patterns\n\nAll three execution modes use async generators for memory-efficient streaming. This section compares their generator characteristics.\n\n### Generator Type Comparison\n\n| Mode | Generator Type | Completion | Early Termination |\n|------|---------------|------------|-------------------|\n| Backtest | **Finite** - ends after last timeframe | Automatically completes when `i >= timeframes.length` | Supported via `break` in consumer or `Backtest.stop()` |\n| Live | **Infinite** - never completes naturally | Only stops via graceful shutdown | Supported via `break` in consumer or `Live.stop()` |\n| Walker | **Finite** - ends after last strategy | Automatically completes when all strategies tested | Supported via `break` in consumer or `Walker.stop()` |\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:62-347](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:63-175](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:68-235]()\n\n### Memory Efficiency\n\nAsync generators enable streaming without accumulating results:\n\n```typescript\n// ❌ Memory-intensive: Accumulates all results in array\nconst backtestLogic = new BacktestLogicPrivateService();\nconst allResults = await resolveDocuments(\n  backtestLogic.run(symbol)\n);\n\n// ✅ Memory-efficient: Processes results one at a time\nfor await (const result of backtestLogic.run(symbol)) {\n  processResult(result);\n  // Previous results are garbage-collected\n}\n```\n\nThis is critical for large backtests with thousands of signals.\n\n**Sources:** General async generator pattern, implemented in [src/lib/services/logic/private/BacktestLogicPrivateService.ts:62]()\n\n### Early Termination Support\n\nAll modes support early termination via consumer-side `break`:\n\n```typescript\n// Stop backtest after 10% drawdown\nfor await (const result of Backtest.run(symbol, context)) {\n  if (result.pnl.pnlPercentage < -10) {\n    console.log(\"Drawdown exceeded, stopping backtest\");\n    break; // Generator cleanup happens automatically\n  }\n}\n```\n\nConsumer break triggers generator cleanup (destructors, unsubscriptions) without requiring explicit shutdown.\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:62-347]()\n\n### Background Execution Pattern\n\nThe `background()` methods consume generators internally using `singlerun` wrapper:\n\n```typescript\nprivate task = singlerun(async (symbol: string, context: any) => {\n  this._isStopped = false;\n  this._isDone = false;\n  \n  for await (const _ of this.run(symbol, context)) {\n    if (this._isStopped) break;\n  }\n  \n  // Emit completion event\n  await doneBacktestSubject.next({...});\n  this._isDone = true;\n});\n\npublic background = (symbol: string, context: any) => {\n  this.task(symbol, context).catch((error) =>\n    exitEmitter.next(new Error(getErrorMessage(error)))\n  );\n  return () => {\n    this._isStopped = true;\n  };\n};\n```\n\nThe `singlerun` wrapper from `functools-kit` ensures only one execution per instance and provides status tracking.\n\n**Sources:** [src/classes/Backtest.ts:105-118](), [src/classes/Backtest.ts:200-235]()\n\n---\n\n## Shared Core Strategy Execution\n\nDespite different orchestration patterns, all three modes delegate to the same core services for strategy execution:\n\n```mermaid\ngraph TB\n    subgraph \"Orchestration Layer (Mode-Specific)\"\n        BacktestLogic[\"BacktestLogicPrivateService\"]\n        LiveLogic[\"LiveLogicPrivateService\"]\n        WalkerLogic[\"WalkerLogicPrivateService\"]\n    end\n    \n    subgraph \"Core Strategy Execution (Shared)\"\n        StrategyCore[\"StrategyCoreService<br/>tick() - State machine progression<br/>backtest() - Bulk candle processing<br/>clear() - State reset<br/>stop() - Graceful shutdown\"]\n        StrategyConn[\"StrategyConnectionService<br/>Memoized factory<br/>Per symbol:strategyName\"]\n        ClientStrategy[\"ClientStrategy<br/>Signal lifecycle management<br/>Validation pipeline<br/>VWAP pricing<br/>Persistence integration\"]\n    end\n    \n    subgraph \"Domain Services (Shared)\"\n        ExchangeConn[\"ExchangeConnectionService<br/>ClientExchange instances\"]\n        RiskConn[\"RiskConnectionService<br/>ClientRisk instances\"]\n        PartialConn[\"PartialConnectionService<br/>ClientPartial instances\"]\n    end\n    \n    BacktestLogic --> StrategyCore\n    LiveLogic --> StrategyCore\n    WalkerLogic --> BacktestLogic\n    \n    StrategyCore --> StrategyConn\n    StrategyConn --> ClientStrategy\n    \n    ClientStrategy --> ExchangeConn\n    ClientStrategy --> RiskConn\n    ClientStrategy --> PartialConn\n    \n    style StrategyCore fill:#c8e6c9,stroke:#388e3c,stroke-width:3px\n    style ClientStrategy fill:#ffe1e1,stroke:#cc0000,stroke-width:2px\n```\n\n**Shared Core Execution Architecture**\n\nThis diagram shows how mode-specific orchestration services converge on the same `StrategyCoreService` and `ClientStrategy` implementations.\n\n### Key Shared Components\n\n| Component | Purpose | Shared Behavior |\n|-----------|---------|-----------------|\n| `StrategyCoreService` | Strategy orchestration, state machine progression | Same `tick()` and `backtest()` logic across all modes |\n| `ClientStrategy` | Signal lifecycle, validation, pricing | Identical validation rules, VWAP calculation, TP/SL logic |\n| `StrategyConnectionService` | Memoized client factory | Same instance caching mechanism per `symbol:strategyName` |\n| `ExchangeConnectionService` | Exchange client factory | Shared candle fetching and price formatting |\n| `RiskConnectionService` | Risk client factory | Unified risk validation pipeline |\n\nThis architecture ensures **identical behavior** between backtest simulation and live trading, preventing discrepancies that could lead to unexpected production results.\n\n**Sources:** [src/lib/services/core/StrategyCoreService.ts]() (referenced but not provided), [src/lib/services/connection/StrategyConnectionService.ts]() (referenced but not provided)\n\n---\n\n## API Method Comparison\n\nThe following table summarizes the public API methods across all three execution modes:\n\n| Method | Backtest | Live | Walker | Purpose |\n|--------|----------|------|--------|---------|\n| `run(symbol, context)` | ✅ Returns finite async generator | ✅ Returns infinite async generator | ✅ Returns finite async generator | Primary execution method - yields results |\n| `background(symbol, context)` | ✅ Returns cancellation closure | ✅ Returns cancellation closure | ✅ Returns cancellation closure | Background execution - fire and forget |\n| `stop(symbol, name)` | ✅ Graceful shutdown | ✅ Graceful shutdown | ✅ Stops all strategies in walker | Sets stop flag, waits for safe point |\n| `getData(symbol, name)` | ✅ Returns `BacktestStatisticsModel` | ✅ Returns `LiveStatisticsModel` | ✅ Returns `WalkerResultsModel` | Extracts accumulated statistics |\n| `getReport(symbol, name, columns?)` | ✅ Markdown report | ✅ Markdown report | ✅ Markdown report | Generates formatted report string |\n| `dump(symbol, name, path?, columns?)` | ✅ Saves to `./dump/backtest/` | ✅ Saves to `./dump/live/` | ✅ Saves to `./dump/walker/` | Writes report to disk |\n| `list()` | ✅ Returns all instance statuses | ✅ Returns all instance statuses | ✅ Returns all instance statuses | Lists active executions |\n\n### Context Parameter Differences\n\n```typescript\n// Backtest requires frameName for timeframe generation\nBacktest.run(symbol, {\n  strategyName: \"strat-1\",\n  exchangeName: \"binance\",\n  frameName: \"1d-backtest\" // Required\n});\n\n// Live does not require frameName (uses real-time)\nLive.run(symbol, {\n  strategyName: \"strat-1\",\n  exchangeName: \"binance\"\n  // No frameName needed\n});\n\n// Walker only requires walkerName (pulls config from schema)\nWalker.run(symbol, {\n  walkerName: \"optimizer-v1\"\n  // exchangeName and frameName pulled from walker schema\n});\n```\n\n**Sources:** [src/classes/Backtest.ts:378-400](), [src/classes/Live.ts:398-418](), [src/classes/Walker.ts:466-485]()\n\n---\n\n## Mode Selection Guide\n\nUse the following criteria to choose the appropriate execution mode:\n\n| Scenario | Recommended Mode | Rationale |\n|----------|------------------|-----------|\n| Testing strategy logic on historical data | **Backtest** | Fast, deterministic, complete PNL statistics |\n| Validating strategy performance metrics | **Backtest** | Accurate Sharpe ratio, drawdown, win rate calculations |\n| Production trading deployment | **Live** | Real-time execution, crash recovery, persistence |\n| Comparing multiple strategy variants | **Walker** | Automated comparison, metric-based ranking |\n| Parameter optimization | **Walker** | Sequential testing of parameter combinations |\n| Strategy development iteration | **Backtest** | Fastest feedback loop during development |\n| Paper trading / dry run | **Live** with mock exchange | Real-time behavior without capital risk |\n\n**Sources:** General architectural patterns from [src/classes/Backtest.ts:1-601](), [src/classes/Live.ts:1-600](), [src/classes/Walker.ts:1-600]()"
                    },
                    {
                        "page_plan": {
                            "id": "5.1",
                            "title": "Backtest Mode"
                        },
                        "content": "# Backtest Mode\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Heat.ts](src/classes/Heat.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Partial.ts](src/classes/Partial.ts)\n- [src/classes/Performance.ts](src/classes/Performance.ts)\n- [src/classes/Risk.ts](src/classes/Risk.ts)\n- [src/classes/Schedule.ts](src/classes/Schedule.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [src/lib/services/logic/private/BacktestLogicPrivateService.ts](src/lib/services/logic/private/BacktestLogicPrivateService.ts)\n- [src/lib/services/logic/private/LiveLogicPrivateService.ts](src/lib/services/logic/private/LiveLogicPrivateService.ts)\n- [src/lib/services/logic/private/WalkerLogicPrivateService.ts](src/lib/services/logic/private/WalkerLogicPrivateService.ts)\n- [test/spec/columns.test.mjs](test/spec/columns.test.mjs)\n\n</details>\n\n\n\n**Purpose**: This document explains the historical simulation mode of Backtest Kit, covering timeframe iteration, fast backtest optimization, progress tracking, and deterministic execution. For real-time trading, see [Live Trading Mode](#5.2). For strategy comparison, see [Walker](#5.3).\n\n**Scope**: Backtest mode simulates trading strategies on historical data from a defined start date to end date. It provides deterministic, reproducible results by iterating through time in discrete steps without access to future data.\n\n---\n\n## Overview\n\nBacktest mode executes strategies against historical market data to evaluate performance before risking real capital. Unlike [Live Trading Mode](#5.2), which runs continuously with real-time data, backtest mode operates on a bounded timeframe with a known start and end.\n\n**Key Characteristics**:\n\n| Feature | Description |\n|---------|-------------|\n| **Time Model** | Discrete timeframes from `startDate` to `endDate` |\n| **Data Access** | Historical candles fetched from `IExchangeSchema.getCandles` |\n| **Execution** | Synchronous iteration through timeframes |\n| **Completion** | Finite - terminates when all timeframes processed |\n| **Persistence** | None - signals exist only in memory |\n| **Results** | All closed signals returned at completion |\n\n**Sources**: [README.md:17-29](), [src/classes/Backtest.ts:1-601]()\n\n---\n\n## Entry Points\n\nBacktest mode is accessed through the `Backtest` class, which provides two execution patterns:\n\n### Backtest.run() - Async Generator Pattern\n\n```typescript\nfor await (const result of Backtest.run(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\",\n  frameName: \"1d-backtest\"\n})) {\n  // result: IStrategyTickResultClosed\n  console.log(result.closeReason, result.pnl.pnlPercentage);\n}\n```\n\nYields closed signals as they complete during the backtest. Useful for:\n- Research and analysis requiring incremental results\n- Early termination based on conditions\n- Real-time processing during backtest execution\n\n### Backtest.background() - Fire-and-Forget Pattern\n\n```typescript\nconst cancel = Backtest.background(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\",\n  frameName: \"1d-backtest\"\n});\n\n// Backtest runs in background\n// Listen for completion via listenDoneBacktest()\n```\n\nConsumes results internally without yielding. Useful for:\n- Running multiple backtests in parallel\n- Callback-based processing via strategy callbacks\n- Background batch processing\n\n**Sources**: [src/classes/Backtest.ts:374-443](), [README.md:145-159]()\n\n---\n\n## Execution Architecture\n\nThe following diagram shows the class hierarchy and data flow from public API to private orchestration:\n\n```mermaid\ngraph TB\n    subgraph \"Public API Layer\"\n        BT_Utils[\"BacktestUtils<br/>(singleton)\"]\n        BT_Instance[\"BacktestInstance<br/>(per symbol:strategy)\"]\n    end\n    \n    subgraph \"Command Layer\"\n        BT_Cmd[\"BacktestCommandService\"]\n    end\n    \n    subgraph \"Logic Layer\"\n        BT_Logic_Pub[\"BacktestLogicPublicService\"]\n        BT_Logic_Priv[\"BacktestLogicPrivateService\"]\n    end\n    \n    subgraph \"Core Services\"\n        Strat_Core[\"StrategyCoreService\"]\n        Exch_Core[\"ExchangeCoreService\"]\n        Frame_Core[\"FrameCoreService\"]\n    end\n    \n    subgraph \"Context Services\"\n        Method_Ctx[\"MethodContextService<br/>(strategyName, exchangeName, frameName)\"]\n        Exec_Ctx[\"ExecutionContextService<br/>(symbol, when, backtest=true)\"]\n    end\n    \n    subgraph \"Markdown & Events\"\n        BT_MD[\"BacktestMarkdownService\"]\n        Progress_Emit[\"progressBacktestEmitter\"]\n        Done_Emit[\"doneBacktestSubject\"]\n        Perf_Emit[\"performanceEmitter\"]\n    end\n    \n    BT_Utils -->|\"run(symbol, context)\"| BT_Instance\n    BT_Utils -->|\"background(symbol, context)\"| BT_Instance\n    \n    BT_Instance -->|\"validate schemas\"| BT_Cmd\n    BT_Cmd -->|\"delegates to\"| BT_Logic_Pub\n    BT_Logic_Pub -->|\"wraps with context\"| BT_Logic_Priv\n    \n    BT_Logic_Priv -->|\"getTimeframe()\"| Frame_Core\n    BT_Logic_Priv -->|\"tick(symbol, when, true)\"| Strat_Core\n    BT_Logic_Priv -->|\"backtest(symbol, candles)\"| Strat_Core\n    BT_Logic_Priv -->|\"getNextCandles()\"| Exch_Core\n    \n    Method_Ctx -.->|\"provides context to\"| Strat_Core\n    Exec_Ctx -.->|\"provides context to\"| Strat_Core\n    \n    BT_Logic_Priv -->|\"emit progress\"| Progress_Emit\n    BT_Instance -->|\"emit done\"| Done_Emit\n    BT_Logic_Priv -->|\"emit metrics\"| Perf_Emit\n    \n    Strat_Core -->|\"emit closed signals\"| BT_MD\n    \n    style BT_Utils fill:#e1f5ff\n    style BT_Logic_Priv fill:#ffe1e1\n    style Frame_Core fill:#f0f0f0\n```\n\n**Key Components**:\n\n- **`BacktestUtils`**: Singleton managing `BacktestInstance` creation via memoization\n- **`BacktestInstance`**: Isolated execution context per `symbol:strategyName` pair\n- **`BacktestLogicPrivateService`**: Core orchestration implementing async generator pattern\n- **`FrameCoreService`**: Generates discrete timeframes from `IFrameSchema`\n- **`StrategyCoreService`**: Executes strategy logic with context propagation\n\n**Sources**: [src/classes/Backtest.ts:359-601](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:1-374]()\n\n---\n\n## Timeframe Iteration Loop\n\nThe `BacktestLogicPrivateService.run()` method implements the core iteration logic:\n\n```mermaid\ngraph TB\n    Start[\"BacktestLogicPrivateService.run()\"]\n    GetFrames[\"frameCoreService.getTimeframe()<br/>(startDate → endDate at interval)\"]\n    LoopStart{\"i < timeframes.length\"}\n    \n    GetFrame[\"when = timeframes[i]\"]\n    EmitProgress[\"progressBacktestEmitter.next()<br/>(i / totalFrames)\"]\n    \n    CheckStop1{\"strategyCoreService.getStopped()?\"}\n    \n    Tick[\"strategyCoreService.tick(symbol, when, true)\"]\n    \n    CheckStop2{\"result.action === 'idle'<br/>AND getStopped()?\"}\n    \n    CheckScheduled{\"result.action === 'scheduled'?\"}\n    \n    FetchCandles[\"exchangeCoreService.getNextCandles()<br/>(bufferMinutes + awaitMinutes + lifetime + 1)\"]\n    \n    Backtest[\"strategyCoreService.backtest()<br/>(symbol, candles, when, true)\"]\n    \n    Skip[\"Skip timeframes:<br/>i = backtestResult.frameSkip\"]\n    \n    Yield[\"yield backtestResult<br/>(IStrategyTickResultClosed)\"]\n    \n    Increment[\"i++\"]\n    \n    Done[\"Emit doneBacktestSubject<br/>Return\"]\n    \n    Start --> GetFrames\n    GetFrames --> LoopStart\n    \n    LoopStart -->|\"No\"| Done\n    LoopStart -->|\"Yes\"| GetFrame\n    \n    GetFrame --> EmitProgress\n    EmitProgress --> CheckStop1\n    \n    CheckStop1 -->|\"Yes\"| Done\n    CheckStop1 -->|\"No\"| Tick\n    \n    Tick --> CheckStop2\n    CheckStop2 -->|\"Yes\"| Done\n    CheckStop2 -->|\"No\"| CheckScheduled\n    \n    CheckScheduled -->|\"Yes\"| FetchCandles\n    CheckScheduled -->|\"No\"| Increment\n    \n    FetchCandles --> Backtest\n    Backtest --> Skip\n    Skip --> Yield\n    Yield --> Increment\n    \n    Increment --> LoopStart\n    \n    style Start fill:#e1f5ff\n    style Backtest fill:#ffe1e1\n    style Yield fill:#ccffcc\n```\n\n**Loop Variables**:\n\n| Variable | Type | Description |\n|----------|------|-------------|\n| `timeframes` | `Date[]` | Array of timestamps from `IFrameSchema` |\n| `i` | `number` | Current timeframe index |\n| `totalFrames` | `number` | Total timeframe count for progress |\n| `when` | `Date` | Current timestamp being processed |\n| `result` | `IStrategyTickResult` | Result from `tick()` call |\n\n**Sources**: [src/lib/services/logic/private/BacktestLogicPrivateService.ts:62-374]()\n\n---\n\n## Fast Backtest Optimization\n\nWhen a signal opens (or is scheduled), the system switches from minute-by-minute iteration to bulk candle processing. This optimization dramatically reduces execution time by:\n\n1. **Fetching Future Candles**: Requests all candles needed for the signal's lifetime upfront\n2. **Bulk Processing**: Calls `strategyCoreService.backtest()` which processes candles in a single pass\n3. **Frame Skipping**: Returns `frameSkip` index to jump past processed timeframes\n\n### Candle Request Calculation\n\n```\ncandlesNeeded = bufferMinutes + awaitMinutes + signalLifetime + 1\n\nWhere:\n- bufferMinutes = CC_AVG_PRICE_CANDLES_COUNT - 1  // VWAP buffer (default: 4)\n- awaitMinutes = CC_SCHEDULE_AWAIT_MINUTES         // Activation timeout (default: 120)\n- signalLifetime = signal.minuteEstimatedTime      // From signal DTO\n- +1 = Current timeframe (when)\n```\n\n### Frame Skipping Logic\n\n```mermaid\ngraph LR\n    Scheduled[\"Signal Scheduled<br/>(action='scheduled')\"]\n    FetchN[\"Fetch N candles<br/>(buffer + await + lifetime + 1)\"]\n    Backtest[\"backtest(symbol, candles, when)\"]\n    Result[\"IStrategyBacktestResult<br/>{frameSkip, ...}\"]\n    Skip[\"i = frameSkip<br/>(jump to frame after close)\"]\n    \n    Scheduled --> FetchN\n    FetchN --> Backtest\n    Backtest --> Result\n    Result --> Skip\n```\n\n**Example**:\n\n```typescript\n// Signal opens at 2025-01-01 10:00:00\n// minuteEstimatedTime = 60\n// Current frame index i = 1000\n\n// Fetch candles:\n// - 4 buffer candles (VWAP)\n// - 120 await candles (scheduled activation window)\n// - 60 lifetime candles (signal duration)\n// - 1 current candle\n// Total: 185 candles\n\nconst candles = await exchangeCoreService.getNextCandles(\n  symbol, \"1m\", 185, bufferStartTime, true\n);\n\n// Process all candles in one pass\nconst result = await strategyCoreService.backtest(\n  symbol, candles, when, true\n);\n\n// Skip ahead: result.frameSkip = 1185 (1000 + 185)\n// Next iteration processes frame 1185 instead of 1001\n```\n\n**Performance Impact**:\n\n| Approach | Frames/Signal | Execution Time |\n|----------|---------------|----------------|\n| **Without Optimization** | 60 individual `tick()` calls | ~600ms |\n| **With Optimization** | 1 `backtest()` call + frame skip | ~50ms |\n| **Speedup** | ~12x faster | |\n\n**Sources**: [src/lib/services/logic/private/BacktestLogicPrivateService.ts:154-255](), [README.md:187-199]()\n\n---\n\n## Progress Tracking\n\nThe `progressBacktestEmitter` broadcasts real-time progress updates during execution:\n\n### Progress Event Contract\n\n```typescript\ninterface ProgressBacktestContract {\n  exchangeName: string;\n  strategyName: string;\n  symbol: string;\n  totalFrames: number;\n  processedFrames: number;\n  progress: number;  // 0.0 to 1.0\n}\n```\n\n### Emission Points\n\n```mermaid\ngraph TB\n    LoopIteration[\"For each timeframe i\"]\n    EmitProgress[\"progressBacktestEmitter.next()<br/>{<br/>  processedFrames: i,<br/>  totalFrames: timeframes.length,<br/>  progress: i / totalFrames<br/>}\"]\n    ProcessFrame[\"Process frame i\"]\n    \n    LoopIteration --> EmitProgress\n    EmitProgress --> ProcessFrame\n```\n\n### Subscribing to Progress\n\n```typescript\nimport { listenProgressBacktest } from \"backtest-kit\";\n\nlistenProgressBacktest((event) => {\n  const percent = (event.progress * 100).toFixed(1);\n  console.log(`${event.symbol}:${event.strategyName} - ${percent}% (${event.processedFrames}/${event.totalFrames})`);\n});\n\n// Run backtest\nfor await (const signal of Backtest.run(\"BTCUSDT\", context)) {\n  // Process signals\n}\n```\n\n**Frequency**: Emitted on every frame iteration (typically 1-minute intervals). For a 24-hour backtest at 1-minute resolution, expect 1,440 progress events.\n\n**Sources**: [src/lib/services/logic/private/BacktestLogicPrivateService.ts:82-92](), [src/config/emitters.ts]()\n\n---\n\n## Deterministic Execution\n\nBacktest mode guarantees reproducible results through several mechanisms:\n\n### Temporal Isolation\n\nThe `ExecutionContextService` ensures strategies only access data up to the current `when` timestamp:\n\n```mermaid\ngraph LR\n    GetCandles[\"getCandles(symbol, '1h', 24)\"]\n    ExecCtx[\"ExecutionContextService<br/>(when = 2025-01-15 10:30:00)\"]\n    ExchCore[\"ExchangeCoreService<br/>getCandles()\"]\n    Filter[\"Return only candles<br/>WHERE timestamp <= when\"]\n    Strategy[\"Strategy receives<br/>candles[0..23]<br/>(no future data)\"]\n    \n    GetCandles --> ExecCtx\n    ExecCtx --> ExchCore\n    ExchCore --> Filter\n    Filter --> Strategy\n```\n\n**Mechanism**: `AsyncLocalStorage` propagates `when` context through the call stack without explicit parameters. The exchange service automatically filters candles by timestamp.\n\n### Fixed Timeframes\n\nThe `IFrameSchema` defines immutable boundaries:\n\n```typescript\naddFrame({\n  frameName: \"1d-backtest\",\n  interval: \"1m\",           // 1-minute steps\n  startDate: new Date(\"2025-01-01T00:00:00Z\"),  // Fixed start\n  endDate: new Date(\"2025-01-02T00:00:00Z\")     // Fixed end\n});\n\n// Generates array: [\n//   2025-01-01T00:00:00Z,\n//   2025-01-01T00:01:00Z,\n//   2025-01-01T00:02:00Z,\n//   ...\n//   2025-01-01T23:59:00Z\n// ]\n```\n\nRunning the same strategy on the same frame always produces:\n- Same number of timeframes\n- Same timestamps\n- Same order of execution\n\n### No External State\n\nBacktest mode:\n- Does NOT persist signals to disk (unlike Live mode)\n- Does NOT use system clock (`new Date()`)\n- Does NOT make external API calls during execution\n- Uses memoized/cached exchange data\n\n**Reproducibility Guarantee**: Given identical inputs (symbol, strategy, exchange, frame), backtest mode produces byte-identical output across runs.\n\n**Sources**: [src/lib/services/context/ExecutionContextService.ts](), [src/lib/services/core/FrameCoreService.ts](), [README.md:187-199]()\n\n---\n\n## Signal Lifecycle in Backtest Mode\n\nSignals progress through different states during backtest execution. The behavior differs from [Live Trading Mode](#5.2):\n\n### State Transitions\n\n```mermaid\nstateDiagram-v2\n    [*] --> Idle\n    \n    Idle --> Scheduled: tick() returns action='scheduled'<br/>(priceOpen not reached)\n    Idle --> Opened: tick() returns action='opened'<br/>(priceOpen reached immediately)\n    \n    Scheduled --> Cancelled: backtest() detects:<br/>- SL hit before activation<br/>- timeout (CC_SCHEDULE_AWAIT_MINUTES)<br/>- manual cancellation\n    Scheduled --> Opened: backtest() detects:<br/>price reaches priceOpen\n    \n    Opened --> Closed: backtest() detects:<br/>- priceTakeProfit reached<br/>- priceStopLoss reached<br/>- minuteEstimatedTime expired\n    \n    Cancelled --> Idle: No PNL calculated\n    Closed --> Idle: PNL calculated, yield result\n    \n    note right of Scheduled\n        NOT persisted<br/>\n        Monitored in bulk via backtest()\n    end note\n    \n    note right of Opened\n        NOT persisted (backtest mode)<br/>\n        Processed in single backtest() call\n    end note\n```\n\n### Key Differences from Live Mode\n\n| Aspect | Backtest Mode | Live Mode |\n|--------|---------------|-----------|\n| **Persistence** | None - signals in memory only | Persisted to disk via `PersistSignalAdapter` |\n| **Time Progression** | Discrete frames from `timeframes[]` | Real-time via `new Date()` |\n| **Processing** | Bulk via `backtest()` | Per-tick via `tick()` |\n| **Completion** | Finite - returns when frames exhausted | Infinite - runs until `stop()` |\n| **Signal Monitoring** | Vectorized on candle array | Event-driven per minute |\n\n### Backtest Method Signature\n\n```typescript\nclass StrategyCoreService {\n  async backtest(\n    symbol: string,\n    candles: ICandleData[],  // Array of future candles\n    when: Date,              // Signal start timestamp\n    backtest: boolean        // Always true for backtest mode\n  ): Promise<IStrategyBacktestResult>\n}\n```\n\n**Result**:\n\n```typescript\ninterface IStrategyBacktestResult {\n  action: \"closed\" | \"cancelled\";\n  signal: ISignalRow;\n  closeReason?: CloseReasonEnum;\n  pnl?: IPnl;\n  frameSkip: number;  // Next frame index to process\n}\n```\n\n**Sources**: [src/lib/services/core/StrategyCoreService.ts](), [src/lib/clients/ClientStrategy.ts]()\n\n---\n\n## Validation and Error Handling\n\nBefore execution, the system validates all schema references:\n\n```mermaid\ngraph TB\n    Run[\"Backtest.run()\"]\n    \n    Val1[\"strategyValidationService.validate()\"]\n    Val2[\"exchangeValidationService.validate()\"]\n    Val3[\"frameValidationService.validate()\"]\n    Val4[\"riskValidationService.validate()\"]\n    \n    Throw[\"Throw Error<br/>(schema not found)\"]\n    \n    Execute[\"Execute backtest\"]\n    \n    Run --> Val1\n    Val1 -->|\"Not found\"| Throw\n    Val1 -->|\"Found\"| Val2\n    Val2 -->|\"Not found\"| Throw\n    Val2 -->|\"Found\"| Val3\n    Val3 -->|\"Not found\"| Throw\n    Val3 -->|\"Found\"| Val4\n    Val4 -->|\"Not found\"| Throw\n    Val4 -->|\"Found\"| Execute\n```\n\n### Runtime Error Handling\n\nDuring execution, errors are caught and emitted without crashing the backtest:\n\n```typescript\n// From BacktestLogicPrivateService.run()\ntry {\n  result = await this.strategyCoreService.tick(symbol, when, true);\n} catch (error) {\n  console.warn(`tick failed when=${when.toISOString()}`);\n  this.loggerService.warn(\"tick failed, skipping timeframe\", { error });\n  await errorEmitter.next(error);\n  i++;  // Skip to next frame\n  continue;\n}\n```\n\n**Error Recovery Strategy**:\n1. Log error details\n2. Emit to `errorEmitter` for subscribers\n3. Skip problematic timeframe\n4. Continue with next frame\n\nThis ensures a single bad candle or strategy error doesn't halt the entire backtest.\n\n**Sources**: [src/classes/Backtest.ts:387-396](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:114-129]()\n\n---\n\n## Instance Management and Memoization\n\nThe `BacktestUtils` class uses memoization to ensure one `BacktestInstance` per `symbol:strategyName` pair:\n\n```mermaid\ngraph TB\n    Call1[\"Backtest.run('BTCUSDT', {strategyName: 'strat-a'})\"]\n    Call2[\"Backtest.run('BTCUSDT', {strategyName: 'strat-a'})\"]\n    Call3[\"Backtest.run('ETHUSDT', {strategyName: 'strat-a'})\"]\n    \n    GetInst[\"_getInstance(symbol, strategyName)\"]\n    Memo{\"Memoized instance exists?\"}\n    \n    Create[\"new BacktestInstance(symbol, strategyName)\"]\n    Return[\"Return cached instance\"]\n    \n    Call1 --> GetInst\n    Call2 --> GetInst\n    Call3 --> GetInst\n    \n    GetInst --> Memo\n    \n    Memo -->|\"No\"| Create\n    Memo -->|\"Yes\"| Return\n    \n    Create --> Return\n```\n\n**Memoization Key**: `${symbol}:${strategyName}`\n\n**Lifecycle**:\n- Instance created on first `run()` or `background()` call\n- Cached for subsequent calls with same symbol+strategy\n- Cleared manually via service layer (not exposed in public API)\n\n**Concurrency**: Each instance can only run one backtest at a time due to `singlerun` wrapper:\n\n```typescript\nprivate task = singlerun(async (symbol, context) => {\n  // ... backtest execution\n});\n```\n\nAttempting to start a second backtest on the same instance while one is running will queue the request.\n\n**Sources**: [src/classes/Backtest.ts:364-369](), [src/classes/Backtest.ts:105-118]()\n\n---\n\n## Reporting and Statistics\n\nAfter completion, retrieve results via `getData()`, `getReport()`, or `dump()`:\n\n```typescript\n// Get structured data\nconst stats = await Backtest.getData(\"BTCUSDT\", \"my-strategy\");\nconsole.log(stats.sharpeRatio, stats.winRate, stats.maxDrawdown);\n\n// Generate markdown report\nconst markdown = await Backtest.getReport(\"BTCUSDT\", \"my-strategy\");\nconsole.log(markdown);\n\n// Save to disk: ./dump/backtest/BTCUSDT_my-strategy.md\nawait Backtest.dump(\"BTCUSDT\", \"my-strategy\");\n```\n\n**Data Source**: The `BacktestMarkdownService` subscribes to `signalBacktestEmitter` and accumulates closed signals in `ReportStorage` (max 250 events per symbol:strategy pair).\n\n**Statistics Calculated**:\n\n| Metric | Description |\n|--------|-------------|\n| `totalTrades` | Count of closed signals |\n| `winningTrades` | Signals with positive PNL |\n| `losingTrades` | Signals with negative PNL |\n| `winRate` | `winningTrades / totalTrades` |\n| `totalPnl` | Sum of all PNL percentages |\n| `avgPnl` | `totalPnl / totalTrades` |\n| `maxDrawdown` | Largest peak-to-trough decline |\n| `sharpeRatio` | Risk-adjusted return metric |\n| `sortinoRatio` | Downside deviation adjusted return |\n\n**Sources**: [src/classes/Backtest.ts:276-337](), [src/lib/services/markdown/BacktestMarkdownService.ts](), [src/model/BacktestStatistics.model.ts]()\n\n---\n\n## Related Pages\n\n- [Live Trading Mode](#5.2) - Real-time execution with persistence\n- [Walker (Strategy Comparison)](#5.3) - Sequential backtest orchestration\n- [Async Generator Patterns](#5.4) - Memory-efficient streaming patterns\n- [Signals & Signal Lifecycle](#3.1) - Signal state machine details\n- [Time Execution Engine](#3.4) - Temporal context propagation\n- [VWAP Pricing & Data Handling](#3.5) - Price calculation methodology"
                    },
                    {
                        "page_plan": {
                            "id": "5.2",
                            "title": "Live Trading Mode"
                        },
                        "content": "# Live Trading Mode\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Heat.ts](src/classes/Heat.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Partial.ts](src/classes/Partial.ts)\n- [src/classes/Performance.ts](src/classes/Performance.ts)\n- [src/classes/Risk.ts](src/classes/Risk.ts)\n- [src/classes/Schedule.ts](src/classes/Schedule.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [src/config/params.ts](src/config/params.ts)\n- [src/lib/services/logic/private/BacktestLogicPrivateService.ts](src/lib/services/logic/private/BacktestLogicPrivateService.ts)\n- [src/lib/services/logic/private/LiveLogicPrivateService.ts](src/lib/services/logic/private/LiveLogicPrivateService.ts)\n- [src/lib/services/logic/private/WalkerLogicPrivateService.ts](src/lib/services/logic/private/WalkerLogicPrivateService.ts)\n- [test/README.md](test/README.md)\n- [test/config/setup.mjs](test/config/setup.mjs)\n- [test/e2e/close.test.mjs](test/e2e/close.test.mjs)\n- [test/e2e/edge.test.mjs](test/e2e/edge.test.mjs)\n- [test/e2e/other.test.mjs](test/e2e/other.test.mjs)\n- [test/e2e/persist.test.mjs](test/e2e/persist.test.mjs)\n- [test/e2e/sanitize.test.mjs](test/e2e/sanitize.test.mjs)\n- [test/e2e/sequence.test.mjs](test/e2e/sequence.test.mjs)\n- [test/spec/columns.test.mjs](test/spec/columns.test.mjs)\n\n</details>\n\n\n\n**Purpose**: This page documents the Live Trading Mode execution system, covering real-time signal execution, crash recovery, persistence, graceful shutdown, and the infinite loop architecture.\n\nFor historical simulation, see [Backtest Mode](#5.1). For strategy comparison, see [Walker](#5.3). For async generator implementation details, see [Async Generator Patterns](#5.4).\n\n---\n\n## Overview\n\nLive Trading Mode executes strategies in real-time against live market data. Unlike Backtest Mode's deterministic timeframe iteration, Live Mode operates as an **infinite loop** that continuously monitors active signals and generates new ones when idle.\n\nKey characteristics:\n- **Infinite execution**: Runs until manually stopped or crashes\n- **Real-time progression**: Uses `new Date()` for current timestamp\n- **Crash-safe persistence**: Active signals survive process restarts\n- **Graceful shutdown**: Waits for active signals to close before stopping\n- **Fixed polling interval**: Checks signal status every 1 minute + 1ms\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:1-179](), [src/classes/Live.ts:1-600](), [README.md:161-171]()\n\n---\n\n## Architecture\n\n### Execution Flow Diagram\n\n```mermaid\ngraph TD\n    LiveRun[\"Live.run(symbol, context)\"]\n    LiveBg[\"Live.background(symbol, context)\"]\n    LiveInstance[\"LiveInstance\"]\n    TaskFn[\"INSTANCE_TASK_FN\"]\n    PrivateRun[\"LiveLogicPrivateService.run()\"]\n    \n    InfiniteLoop[\"while(true)\"]\n    CreateDate[\"when = new Date()\"]\n    TickCall[\"strategyCoreService.tick(symbol, when, false)\"]\n    CheckResult{\"result.action?\"}\n    \n    IdleCheck{\"Idle & Stopped?\"}\n    ActiveSleep[\"Sleep TICK_TTL\"]\n    ScheduledSleep[\"Sleep TICK_TTL\"]\n    \n    YieldResult[\"yield result\"]\n    ClosedCheck{\"Closed & Stopped?\"}\n    ClosedSleep[\"Sleep TICK_TTL\"]\n    \n    Break[\"break\"]\n    Done[\"doneLiveSubject.next()\"]\n    \n    LiveRun --> LiveInstance\n    LiveBg --> LiveInstance\n    LiveInstance --> TaskFn\n    TaskFn --> PrivateRun\n    \n    PrivateRun --> InfiniteLoop\n    InfiniteLoop --> CreateDate\n    CreateDate --> TickCall\n    TickCall --> CheckResult\n    \n    CheckResult -->|\"idle\"| IdleCheck\n    CheckResult -->|\"active\"| ActiveSleep\n    CheckResult -->|\"scheduled\"| ScheduledSleep\n    CheckResult -->|\"opened/closed\"| YieldResult\n    \n    IdleCheck -->|\"Yes\"| Break\n    IdleCheck -->|\"No\"| ActiveSleep\n    \n    ActiveSleep --> InfiniteLoop\n    ScheduledSleep --> InfiniteLoop\n    \n    YieldResult --> ClosedCheck\n    ClosedCheck -->|\"Yes\"| Break\n    ClosedCheck -->|\"No\"| ClosedSleep\n    ClosedSleep --> InfiniteLoop\n    \n    Break --> Done\n```\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:63-175](), [src/classes/Live.ts:31-57]()\n\n### Core Loop Implementation\n\nThe infinite loop in `LiveLogicPrivateService.run()` implements the following sequence:\n\n| Step | Operation | File Reference |\n|------|-----------|----------------|\n| 1 | Create real-time date with `new Date()` | [LiveLogicPrivateService.ts:72]() |\n| 2 | Call `strategyCoreService.tick(symbol, when, false)` | [LiveLogicPrivateService.ts:76]() |\n| 3 | Handle errors and retry after sleep | [LiveLogicPrivateService.ts:77-95]() |\n| 4 | Check result action type | [LiveLogicPrivateService.ts:118-149]() |\n| 5 | Yield `opened` or `closed` results | [LiveLogicPrivateService.ts:152]() |\n| 6 | Sleep for `TICK_TTL` (1 minute + 1ms) | [LiveLogicPrivateService.ts:137-173]() |\n| 7 | Check stop conditions before continuing | [LiveLogicPrivateService.ts:119-135]() |\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:63-175]()\n\n### Sleep Interval Configuration\n\n```typescript\nconst TICK_TTL = 1 * 60 * 1_000 + 1; // 60,001 milliseconds\n```\n\nThe `TICK_TTL` constant defines the polling interval. The additional 1ms prevents timing boundary issues when candles complete exactly at minute boundaries.\n\n**Why 1 minute?**\n- Aligns with minimum candle interval (1m)\n- Balances responsiveness vs. API rate limits\n- Sufficient for monitoring TP/SL/time_expired conditions\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:14]()\n\n---\n\n## Crash Recovery\n\n### Persistence Architecture Diagram\n\n```mermaid\ngraph LR\n    subgraph \"Before Crash\"\n        OpenSignal[\"Signal Opens\"]\n        Persist[\"PersistSignalAdapter.writeValue()\"]\n        OpenSignal --> Persist\n    end\n    \n    subgraph \"Process Crash\"\n        Kill[\"Process Terminated\"]\n        Persist -.->|\"Atomic write complete\"| Kill\n    end\n    \n    subgraph \"After Restart\"\n        Restart[\"Process Restarts\"]\n        WaitInit[\"ClientStrategy.waitForInit()\"]\n        ReadValue[\"PersistSignalAdapter.readValue()\"]\n        Restore[\"Restore pendingSignal state\"]\n        Resume[\"Resume tick() monitoring\"]\n        \n        Restart --> WaitInit\n        WaitInit --> ReadValue\n        ReadValue --> Restore\n        Restore --> Resume\n    end\n    \n    Kill -.->|\"Restart\"| Restart\n```\n\n**Sources**: [src/classes/Live.ts:147-161](), [README.md:19-20]()\n\n### Persistence Strategy\n\nLive Mode implements **crash-safe persistence** through the following mechanisms:\n\n#### Signal Lifecycle and Persistence\n\n| Signal State | Persisted? | Reason |\n|--------------|-----------|---------|\n| `idle` | No | No active signal to save |\n| `scheduled` | No | Not yet activated, ephemeral |\n| `opened` | **Yes** | Active position, requires recovery |\n| `active` | **Yes** | Position monitoring TP/SL/time |\n| `closed` | No | Position completed, delete from storage |\n| `cancelled` | No | Never opened, nothing to recover |\n\n**Critical**: Only `opened` signals are persisted. This prevents storage bloat while ensuring all active positions can be recovered.\n\n**Sources**: [Diagram 3 in high-level architecture](), [src/classes/Live.ts:147-161]()\n\n#### Recovery Process\n\n```typescript\n// On restart, ClientStrategy calls:\nawait clientStrategy.waitForInit();\n// This internally:\n// 1. Calls PersistSignalAdapter.hasValue(symbol, strategyName)\n// 2. If exists, calls PersistSignalAdapter.readValue()\n// 3. Restores pendingSignal state\n// 4. Continues tick() monitoring from current Date\n```\n\nThe recovery process is **transparent** to the strategy code. When `Live.run()` starts:\n\n1. `LiveLogicPrivateService` begins infinite loop\n2. First `tick()` call triggers `waitForInit()` internally\n3. If persisted signal exists, it's restored\n4. Tick continues monitoring the restored signal's TP/SL/time conditions\n\n**Sources**: [README.md:149-161](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:63-76]()\n\n#### Atomic Write Guarantees\n\nThe `PersistSignalAdapter` interface requires **atomic writes**:\n\n```typescript\ninterface PersistBase {\n  waitForInit(): Promise<void>;\n  hasValue(symbol: string, strategyName: string): Promise<boolean>;\n  readValue(symbol: string, strategyName: string): Promise<ISignalRow>;\n  writeValue(symbol: string, strategyName: string, signal: ISignalRow): Promise<void>;\n}\n```\n\nImplementations must ensure:\n- Writes are atomic (complete or not started, no partial writes)\n- `hasValue()` returns true only after successful `writeValue()`\n- `readValue()` returns complete signal data or throws\n\n**Sources**: [Diagram 1 in high-level architecture - Persistence & Configuration cluster]()\n\n---\n\n## Graceful Shutdown\n\n### Shutdown Flow Diagram\n\n```mermaid\nstateDiagram-v2\n    [*] --> Running\n    Running --> StopRequested: Live.stop() called\n    \n    StopRequested --> CheckSignal: Check active signal\n    \n    CheckSignal --> WaitClose: Signal is opened/active\n    CheckSignal --> Immediate: Signal is idle\n    \n    WaitClose --> TickLoop: Continue tick() monitoring\n    TickLoop --> CheckResult: Result action?\n    \n    CheckResult --> WaitClose: active/scheduled\n    CheckResult --> FinalClose: closed\n    \n    FinalClose --> EmitDone: doneLiveSubject.next()\n    Immediate --> EmitDone\n    \n    EmitDone --> [*]\n```\n\n**Sources**: [src/classes/Live.ts:156-169](), [src/classes/Live.ts:222-241]()\n\n### Stop Mechanism Implementation\n\nThe graceful shutdown mechanism involves coordination between multiple components:\n\n#### 1. Setting Stop Flag\n\n```typescript\n// User calls:\nawait Live.stop(symbol, strategyName);\n\n// Internally calls:\nawait strategyCoreService.stop({ symbol, strategyName }, false);\n//                                                        ^^^^\n//                                              backtest=false\n```\n\nThe `false` parameter indicates **live mode**, which affects behavior:\n- Waits for active signals to close naturally\n- Does not force immediate cancellation\n- Allows TP/SL/time_expired conditions to complete\n\n**Sources**: [src/classes/Live.ts:261-267]()\n\n#### 2. Checking Stop Condition\n\nThe infinite loop checks for stop conditions at two points:\n\n**Point A: Idle State**\n```typescript\nif (result.action === \"idle\") {\n  if (await strategyCoreService.getStopped(symbol, strategyName)) {\n    // No active signal, safe to stop immediately\n    break;\n  }\n}\n```\n\n**Point B: After Signal Closes**\n```typescript\nif (result.action === \"closed\") {\n  if (await strategyCoreService.getStopped(symbol, strategyName)) {\n    // Signal just closed, safe to stop now\n    break;\n  }\n}\n```\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:118-171]()\n\n#### 3. Background Task Stop Handler\n\nWhen using `Live.background()`, the cancellation closure provides additional safety:\n\n```typescript\nconst cancel = Live.background(symbol, context);\n\n// Later:\ncancel(); // Calls stop AND waits for signal completion\n```\n\nThe cancellation closure:\n1. Sets stop flag via `strategyCoreService.stop()`\n2. Checks for pending signal\n3. Only emits `doneLiveSubject` if signal is closed\n4. Waits for natural completion before returning\n\n**Sources**: [src/classes/Live.ts:222-241]()\n\n### Stop Behavior Comparison\n\n| Scenario | Immediate Stop? | Signal Fate | Done Event? |\n|----------|----------------|-------------|-------------|\n| Idle (no active signal) | Yes | N/A | Yes, immediately |\n| Active signal exists | No | Completes normally (TP/SL/time) | Yes, after close |\n| Scheduled signal exists | No | Waits for activation or cancellation | Yes, after resolution |\n| Multiple stop calls | Idempotent | First stop wins | Once, after close |\n\n**Sources**: [src/classes/Live.ts:156-169](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:156-171]()\n\n---\n\n## Public API\n\n### LiveUtils Class Diagram\n\n```mermaid\nclassDiagram\n    class LiveUtils {\n        -_getInstance memoize\n        +run(symbol, context) AsyncGenerator\n        +background(symbol, context) CancelFn\n        +stop(symbol, strategyName) Promise~void~\n        +getData(symbol, strategyName) Promise~Statistics~\n        +getReport(symbol, strategyName, columns?) Promise~string~\n        +dump(symbol, strategyName, path?, columns?) Promise~void~\n        +list() Promise~Status[]~\n    }\n    \n    class LiveInstance {\n        +readonly id string\n        +readonly symbol string\n        +readonly strategyName string\n        +_isStopped boolean\n        +_isDone boolean\n        -task singlerun\n        +run(symbol, context) AsyncGenerator\n        +background(symbol, context) CancelFn\n        +stop(symbol, strategyName) Promise~void~\n        +getData(symbol, strategyName) Promise~Statistics~\n        +getReport(symbol, strategyName, columns?) Promise~string~\n        +dump(symbol, strategyName, path?, columns?) Promise~void~\n        +getStatus() Promise~Status~\n    }\n    \n    class LiveLogicPrivateService {\n        +run(symbol) AsyncGenerator~IStrategyTickResult~\n    }\n    \n    class LiveCommandService {\n        +run(symbol, context) AsyncGenerator\n    }\n    \n    LiveUtils --> LiveInstance: creates via _getInstance()\n    LiveInstance --> LiveLogicPrivateService: delegates to\n    LiveCommandService --> LiveLogicPrivateService: wraps\n```\n\n**Sources**: [src/classes/Live.ts:79-600]()\n\n### Method Reference\n\n#### Live.run()\n\n```typescript\npublic run(\n  symbol: string,\n  context: {\n    strategyName: string;\n    exchangeName: string;\n  }\n): AsyncGenerator<IStrategyTickResultClosed | IStrategyTickResultOpened>\n```\n\n**Returns**: Infinite async generator yielding `opened` and `closed` signal results\n\n**Example**:\n```typescript\nfor await (const result of Live.run(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\"\n})) {\n  if (result.action === \"opened\") {\n    console.log(\"Signal opened:\", result.signal.id);\n  } else if (result.action === \"closed\") {\n    console.log(\"PNL:\", result.pnl.pnlPercentage);\n  }\n}\n```\n\n**Behavior**:\n- Validates strategy and exchange exist\n- Clears previous markdown/state for symbol-strategy pair\n- Clears risk global service for associated risks\n- Returns instance-specific generator via `_getInstance()`\n\n**Sources**: [src/classes/Live.ts:398-418]()\n\n#### Live.background()\n\n```typescript\npublic background(\n  symbol: string,\n  context: {\n    strategyName: string;\n    exchangeName: string;\n  }\n): () => void\n```\n\n**Returns**: Cancellation closure to stop execution\n\n**Example**:\n```typescript\nconst cancel = Live.background(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\"\n});\n\n// Later, to stop:\ncancel(); // Waits for active signal to close\n```\n\n**Behavior**:\n- Consumes generator internally without yielding\n- Returns cancellation closure for graceful shutdown\n- Catches errors and emits to `exitEmitter`\n- Uses `singlerun` wrapper to prevent duplicate executions\n\n**Sources**: [src/classes/Live.ts:441-459]()\n\n#### Live.stop()\n\n```typescript\npublic stop(\n  symbol: string,\n  strategyName: string\n): Promise<void>\n```\n\n**Returns**: Promise resolving when stop flag is set\n\n**Example**:\n```typescript\nawait Live.stop(\"BTCUSDT\", \"my-strategy\");\n// Strategy will stop after current signal closes\n```\n\n**Behavior**:\n- Sets internal stop flag via `strategyCoreService.stop()`\n- Does NOT force immediate termination\n- Allows active signals to complete normally\n- Safe to call multiple times (idempotent)\n\n**Sources**: [src/classes/Live.ts:478-489]()\n\n#### Live.getData()\n\n```typescript\npublic getData(\n  symbol: string,\n  strategyName: string\n): Promise<LiveStatisticsModel>\n```\n\n**Returns**: Statistical data from all live trading events\n\n**Data includes**:\n- Closed signals count and PNL statistics\n- Opened signals count\n- Scheduled/cancelled signals tracking\n- Sharpe ratio, win rate, max drawdown\n- Average signal lifetime\n\n**Sources**: [src/classes/Live.ts:504-515]()\n\n#### Live.getReport()\n\n```typescript\npublic getReport(\n  symbol: string,\n  strategyName: string,\n  columns?: Columns[]\n): Promise<string>\n```\n\n**Returns**: Markdown formatted report string\n\n**Report includes**:\n- Summary statistics table\n- All events table (opened/closed/scheduled/cancelled)\n- Profit/loss analysis\n- Risk-adjusted metrics\n\n**Sources**: [src/classes/Live.ts:531-542]()\n\n#### Live.dump()\n\n```typescript\npublic dump(\n  symbol: string,\n  strategyName: string,\n  path?: string,\n  columns?: Columns[]\n): Promise<void>\n```\n\n**Default path**: `./dump/live/{strategyName}.md`\n\n**Example**:\n```typescript\nawait Live.dump(\"BTCUSDT\", \"my-strategy\");\n// Saves to: ./dump/live/my-strategy.md\n\nawait Live.dump(\"BTCUSDT\", \"my-strategy\", \"./reports\");\n// Saves to: ./reports/my-strategy.md\n```\n\n**Sources**: [src/classes/Live.ts:561-577]()\n\n#### Live.list()\n\n```typescript\npublic list(): Promise<Array<{\n  id: string;\n  symbol: string;\n  strategyName: string;\n  status: \"idle\" | \"running\" | \"done\";\n}>>\n```\n\n**Returns**: Status of all active live trading instances\n\n**Example**:\n```typescript\nconst statusList = await Live.list();\nstatusList.forEach(status => {\n  console.log(`${status.symbol} - ${status.strategyName}: ${status.status}`);\n});\n```\n\n**Sources**: [src/classes/Live.ts:579-600]()\n\n---\n\n## State Management\n\n### LiveInstance Lifecycle\n\nEach `symbol:strategyName` combination gets its own isolated `LiveInstance`:\n\n```mermaid\nstateDiagram-v2\n    [*] --> Created: new LiveInstance()\n    Created --> Idle: getStatus() → \"idle\"\n    \n    Idle --> Running: background() or run()\n    Running --> Running: Processing ticks\n    \n    Running --> Stopped: stop() called\n    Stopped --> Done: Signal closed\n    \n    Done --> Idle: Can restart\n    \n    note right of Created\n        LiveInstance per symbol:strategyName\n        Memoized via _getInstance()\n    end note\n    \n    note right of Running\n        _isStopped = false\n        _isDone = false\n        task.getStatus() → \"running\"\n    end note\n    \n    note right of Done\n        _isStopped = true\n        _isDone = true\n        task.getStatus() → \"done\"\n    end note\n```\n\n**Sources**: [src/classes/Live.ts:79-145]()\n\n### Instance Isolation\n\nThe `_getInstance` memoization pattern ensures:\n\n```typescript\nprivate _getInstance = memoize<\n  (symbol: string, strategyName: StrategyName) => LiveInstance\n>(\n  ([symbol, strategyName]) => `${symbol}:${strategyName}`,\n  (symbol: string, strategyName: StrategyName) => new LiveInstance(symbol, strategyName)\n);\n```\n\n**Key**: `\"BTCUSDT:my-strategy\"`\n\n**Implications**:\n- Same symbol + different strategy = separate instances\n- Different symbol + same strategy = separate instances\n- Each instance maintains independent `_isStopped` and `_isDone` flags\n- Each instance has its own `task` (singlerun wrapper)\n\n**Sources**: [src/classes/Live.ts:381-386]()\n\n### Task Status Tracking\n\nThe `task` field uses `singlerun` wrapper from `functools-kit`:\n\n```typescript\nprivate task = singlerun(async (\n  symbol: string,\n  context: { strategyName: string; exchangeName: string; }\n) => {\n  return await INSTANCE_TASK_FN(symbol, context, this);\n})\n```\n\n**Status values**:\n- `\"idle\"`: Never started or completed\n- `\"running\"`: Currently executing\n- `\"done\"`: Execution completed\n\n**Sources**: [src/classes/Live.ts:110-122]()\n\n---\n\n## Event Emission\n\n### Live Mode Event Flow\n\n```mermaid\ngraph TD\n    Tick[\"strategyCoreService.tick()\"]\n    Result{\"Result Action?\"}\n    \n    SignalEmit[\"signalEmitter.next()\"]\n    SignalLiveEmit[\"signalLiveEmitter.next()\"]\n    PerfEmit[\"performanceEmitter.next()\"]\n    ErrorEmit[\"errorEmitter.next()\"]\n    DoneEmit[\"doneLiveSubject.next()\"]\n    \n    Tick --> Result\n    \n    Result -->|\"opened\"| SignalEmit\n    Result -->|\"closed\"| SignalEmit\n    Result -->|\"scheduled\"| SignalEmit\n    Result -->|\"cancelled\"| SignalEmit\n    \n    SignalEmit --> SignalLiveEmit\n    \n    Tick -->|\"Every tick\"| PerfEmit\n    Tick -->|\"Error\"| ErrorEmit\n    \n    Result -->|\"closed + stopped\"| DoneEmit\n```\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:97-115]()\n\n### Event Types and Payloads\n\n| Event Emitter | Trigger | Payload Fields | Purpose |\n|---------------|---------|----------------|---------|\n| `signalEmitter` | Any signal event | `action`, `signal`, `pnl?` | Global signal tracking |\n| `signalLiveEmitter` | Live signal event | Same as above + `backtest=false` | Live-specific filtering |\n| `performanceEmitter` | Every tick | `metricType=\"live_tick\"`, `duration`, `symbol`, `strategyName` | Performance profiling |\n| `errorEmitter` | Tick failure | `error`, `symbol`, `when`, `message` | Error monitoring |\n| `doneLiveSubject` | Stopped + closed | `symbol`, `strategyName`, `exchangeName`, `backtest=false` | Completion tracking |\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:92-115](), [Diagram 5 in high-level architecture]()\n\n### Listening to Events\n\n```typescript\nimport {\n  listenSignalLive,\n  listenDoneLive,\n  listenPerformance,\n  listenError\n} from \"backtest-kit\";\n\nlistenSignalLive((event) => {\n  if (event.action === \"opened\") {\n    console.log(\"New position:\", event.signal.id);\n  }\n});\n\nlistenDoneLive((event) => {\n  console.log(\"Live trading stopped:\", event.strategyName);\n});\n\nlistenPerformance((event) => {\n  if (event.metricType === \"live_tick\") {\n    console.log(`Tick took ${event.duration.toFixed(2)}ms`);\n  }\n});\n\nlistenError((error) => {\n  console.error(\"Live trading error:\", error);\n});\n```\n\n**Sources**: [README.md:170-176]()\n\n---\n\n## Comparison with Backtest Mode\n\n### Key Differences\n\n| Aspect | Live Mode | Backtest Mode |\n|--------|-----------|---------------|\n| **Time Source** | `new Date()` (real-time) | `timeframes[i]` (historical) |\n| **Loop Type** | `while(true)` (infinite) | `for` loop (finite) |\n| **Completion** | Never (until stopped) | After last timeframe |\n| **Persistence** | Yes (opened signals) | No (ephemeral) |\n| **Sleep Interval** | 1 minute + 1ms | None (fast iteration) |\n| **Progress Events** | None | `progressBacktestEmitter` |\n| **Fast Backtest** | N/A (real-time only) | Yes (bulk candle processing) |\n| **Crash Recovery** | Yes (via PersistSignalAdapter) | N/A |\n| **Generator Type** | Infinite | Finite |\n| **Stop Behavior** | Graceful (waits for close) | Immediate (can stop mid-signal) |\n\n**Sources**: [Diagram 2 in high-level architecture](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:1-179](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:1-400]()\n\n### Method Signature Differences\n\n```typescript\n// Backtest requires frameName for timeframe generation\nBacktest.run(symbol, {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\",\n  frameName: \"1d-test\" // Required!\n});\n\n// Live does NOT use frameName (real-time progression)\nLive.run(symbol, {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\"\n  // No frameName needed\n});\n```\n\n**Sources**: [src/classes/Backtest.ts:378-400](), [src/classes/Live.ts:398-418]()\n\n### Context Propagation Difference\n\nBoth modes use `ExecutionContextService` and `MethodContextService`, but with different parameters:\n\n```typescript\n// Backtest context\n{\n  symbol: \"BTCUSDT\",\n  when: timeframes[i],    // Historical date\n  backtest: true\n}\n\n// Live context\n{\n  symbol: \"BTCUSDT\",\n  when: new Date(),       // Current date\n  backtest: false\n}\n```\n\nThe `backtest` flag affects:\n- Persistence behavior (only live persists)\n- Event emission filtering\n- Fast backtest availability\n- Candle fetching strategy\n\n**Sources**: [Diagram 1 in high-level architecture - Context Services]()\n\n---\n\n## Implementation Details\n\n### Error Handling Strategy\n\nLive mode implements **retry-on-error** for tick failures:\n\n```typescript\ntry {\n  result = await strategyCoreService.tick(symbol, when, false);\n} catch (error) {\n  console.warn(`tick failed when=${when.toISOString()}`);\n  this.loggerService.warn(\"tick failed, retrying after sleep\", { ... });\n  await errorEmitter.next(error);\n  await sleep(TICK_TTL);\n  continue; // Retry on next iteration\n}\n```\n\n**Rationale**:\n- Live trading cannot skip time like backtest\n- Network errors should not terminate execution\n- Sleep interval allows transient issues to resolve\n- Error is logged and emitted for monitoring\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:75-95]()\n\n### Signal State Filtering\n\nThe infinite loop only **yields** `opened` and `closed` results:\n\n```typescript\nif (result.action === \"idle\") {\n  await sleep(TICK_TTL);\n  continue; // Don't yield idle\n}\n\nif (result.action === \"active\") {\n  await sleep(TICK_TTL);\n  continue; // Don't yield active monitoring\n}\n\nif (result.action === \"scheduled\") {\n  await sleep(TICK_TTL);\n  continue; // Don't yield scheduled waiting\n}\n\n// Only yield opened/closed\nyield result as IStrategyTickResultClosed | IStrategyTickResultOpened;\n```\n\n**Why filter?**\n- `idle`: No information, just waiting\n- `active`: Signal already opened, just monitoring\n- `scheduled`: Waiting for activation, no action needed\n- `opened`/`closed`: **Actionable events** for user code\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:118-152]()\n\n### Performance Tracking\n\nEvery tick emits performance metrics:\n\n```typescript\nawait performanceEmitter.next({\n  timestamp: currentTimestamp,\n  previousTimestamp: previousEventTimestamp,\n  metricType: \"live_tick\",\n  duration: tickEndTime - tickStartTime,\n  strategyName: this.methodContextService.context.strategyName,\n  exchangeName: this.methodContextService.context.exchangeName,\n  symbol,\n  backtest: false,\n});\n```\n\nThese metrics enable:\n- Monitoring tick duration for bottlenecks\n- Detecting slow `getSignal()` implementations\n- Tracking API call latency\n- Generating performance reports via `Performance.getData()`\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts:103-115]()\n\n---\n\n## Best Practices\n\n### Production Deployment\n\n```typescript\nimport { Live, listenError, listenExit, setLogger } from \"backtest-kit\";\n\n// Configure logging\nsetLogger(console);\n\n// Handle errors without crashing\nlistenError((error) => {\n  console.error(\"Recoverable error:\", error);\n  // Send to monitoring system\n});\n\n// Handle fatal errors\nlistenExit((error) => {\n  console.error(\"FATAL ERROR:\", error);\n  process.exit(1);\n});\n\n// Start live trading\nLive.background(\"BTCUSDT\", {\n  strategyName: \"production-strategy\",\n  exchangeName: \"binance\"\n});\n\n// Health check endpoint\napp.get(\"/health\", async (req, res) => {\n  const instances = await Live.list();\n  res.json({ instances });\n});\n```\n\n**Sources**: [README.md:49-56](), [README.md:175-176]()\n\n### Graceful Process Shutdown\n\n```typescript\nconst cancelFunctions = [];\n\n// Start multiple live traders\ncancelFunctions.push(\n  Live.background(\"BTCUSDT\", { ... })\n);\ncancelFunctions.push(\n  Live.background(\"ETHUSDT\", { ... })\n);\n\n// Handle SIGTERM/SIGINT\nprocess.on(\"SIGTERM\", () => {\n  console.log(\"Gracefully shutting down...\");\n  \n  // Stop all traders\n  cancelFunctions.forEach(cancel => cancel());\n  \n  // Wait for all signals to close (handled by cancel functions)\n});\n```\n\n**Sources**: [src/classes/Live.ts:222-241]()\n\n### Monitoring Active Positions\n\n```typescript\nimport { listenSignalLive } from \"backtest-kit\";\n\nconst activePositions = new Map();\n\nlistenSignalLive((event) => {\n  if (event.action === \"opened\") {\n    activePositions.set(event.signal.id, {\n      symbol: event.symbol,\n      position: event.signal.position,\n      priceOpen: event.signal.priceOpen,\n      priceTakeProfit: event.signal.priceTakeProfit,\n      priceStopLoss: event.signal.priceStopLoss,\n      openedAt: new Date()\n    });\n  }\n  \n  if (event.action === \"closed\") {\n    const position = activePositions.get(event.signal.id);\n    console.log(`Position closed:`, {\n      ...position,\n      closeReason: event.closeReason,\n      pnl: event.pnl.pnlPercentage,\n      duration: Date.now() - position.openedAt.getTime()\n    });\n    activePositions.delete(event.signal.id);\n  }\n});\n```\n\n**Sources**: [README.md:170-171]()\n\n---\n\n**Sources**: [src/classes/Live.ts:1-600](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:1-179](), [README.md:161-171](), [Diagram 2 in high-level architecture]()"
                    },
                    {
                        "page_plan": {
                            "id": "5.3",
                            "title": "Walker (Strategy Comparison)"
                        },
                        "content": "# Walker (Strategy Comparison)\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Heat.ts](src/classes/Heat.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Partial.ts](src/classes/Partial.ts)\n- [src/classes/Performance.ts](src/classes/Performance.ts)\n- [src/classes/Risk.ts](src/classes/Risk.ts)\n- [src/classes/Schedule.ts](src/classes/Schedule.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/lib/services/logic/private/BacktestLogicPrivateService.ts](src/lib/services/logic/private/BacktestLogicPrivateService.ts)\n- [src/lib/services/logic/private/LiveLogicPrivateService.ts](src/lib/services/logic/private/LiveLogicPrivateService.ts)\n- [src/lib/services/logic/private/WalkerLogicPrivateService.ts](src/lib/services/logic/private/WalkerLogicPrivateService.ts)\n- [test/spec/columns.test.mjs](test/spec/columns.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThe Walker execution mode enables systematic comparison of multiple trading strategies on the same market data. Unlike Backtest mode ([5.1](#5.1)) which tests a single strategy, or Live mode ([5.2](#5.2)) which executes real-time trading, Walker orchestrates sequential backtests for multiple strategies and ranks them by a configurable performance metric. This allows data-driven strategy selection and hyperparameter optimization.\n\nFor information about individual backtest execution mechanics, see Backtest Mode ([5.1](#5.1)). For the shared async generator architecture used by all execution modes, see Async Generator Patterns ([5.4](#5.4)).\n\n---\n\n## Walker Schema Definition\n\nWalker execution is configured via the `IWalkerSchema` interface, which is registered using `addWalker()`. The schema defines which strategies to compare, the metric for ranking, and the execution environment (exchange and timeframe).\n\n### IWalkerSchema Interface\n\n```typescript\ninterface IWalkerSchema {\n  walkerName: WalkerName;           // Unique identifier\n  note?: string;                     // Optional documentation\n  exchangeName: ExchangeName;        // Exchange for all strategies\n  frameName: FrameName;              // Timeframe for all strategies\n  strategies: StrategyName[];        // List of strategies to compare\n  metric?: WalkerMetric;             // Optimization metric (default: \"sharpeRatio\")\n  callbacks?: Partial<IWalkerCallbacks>;  // Lifecycle event callbacks\n}\n```\n\n**Sources:** [types.d.ts:954-969]()\n\n### Supported Metrics\n\nWalker supports seven optimization metrics, all maximized (higher is better):\n\n| Metric | Type | Description |\n|--------|------|-------------|\n| `sharpeRatio` | `WalkerMetric` | Risk-adjusted return (avgPnl / stdDev) |\n| `annualizedSharpeRatio` | `WalkerMetric` | Sharpe ratio scaled by √365 |\n| `winRate` | `WalkerMetric` | Percentage of winning trades (0-100) |\n| `totalPnl` | `WalkerMetric` | Cumulative profit/loss percentage |\n| `certaintyRatio` | `WalkerMetric` | Average win divided by average loss |\n| `avgPnl` | `WalkerMetric` | Mean profit/loss per trade |\n| `expectedYearlyReturns` | `WalkerMetric` | Annualized return projection |\n\n**Sources:** [types.d.ts:949]()\n\n### Callback Hooks\n\n```typescript\ninterface IWalkerCallbacks {\n  onStrategyStart: (strategyName: StrategyName, symbol: string) => void;\n  onStrategyComplete: (\n    strategyName: StrategyName, \n    symbol: string, \n    stats: BacktestStatisticsModel, \n    metric: number | null\n  ) => void;\n}\n```\n\n**Sources:** [types.d.ts:974-979]()\n\n---\n\n## Execution Architecture\n\n### Component Hierarchy\n\n```mermaid\ngraph TB\n    subgraph \"Public API\"\n        WalkerClass[\"Walker class<br/>(WalkerUtils)\"]\n        WalkerInstance[\"WalkerInstance\"]\n    end\n    \n    subgraph \"Command Layer\"\n        WalkerCommand[\"WalkerCommandService\"]\n    end\n    \n    subgraph \"Logic Layer\"\n        WalkerLogicPub[\"WalkerLogicPublicService\"]\n        WalkerLogicPriv[\"WalkerLogicPrivateService\"]\n    end\n    \n    subgraph \"Orchestration\"\n        BacktestLogicPub[\"BacktestLogicPublicService\"]\n        BacktestLogicPriv[\"BacktestLogicPrivateService\"]\n    end\n    \n    subgraph \"Core Execution\"\n        StrategyCore[\"StrategyCoreService\"]\n        ExchangeCore[\"ExchangeCoreService\"]\n        FrameCore[\"FrameCoreService\"]\n    end\n    \n    subgraph \"Reporting\"\n        WalkerMarkdown[\"WalkerMarkdownService\"]\n        BacktestMarkdown[\"BacktestMarkdownService\"]\n    end\n    \n    subgraph \"Event System\"\n        walkerEmitter[\"walkerEmitter\"]\n        walkerCompleteSubject[\"walkerCompleteSubject\"]\n        walkerStopSubject[\"walkerStopSubject\"]\n    end\n    \n    WalkerClass --> WalkerInstance\n    WalkerInstance --> WalkerCommand\n    WalkerCommand --> WalkerLogicPub\n    WalkerLogicPub --> WalkerLogicPriv\n    \n    WalkerLogicPriv --> BacktestLogicPub\n    BacktestLogicPub --> BacktestLogicPriv\n    BacktestLogicPriv --> StrategyCore\n    BacktestLogicPriv --> ExchangeCore\n    BacktestLogicPriv --> FrameCore\n    \n    WalkerLogicPriv --> WalkerMarkdown\n    WalkerLogicPriv --> BacktestMarkdown\n    \n    WalkerLogicPriv --> walkerEmitter\n    WalkerLogicPriv --> walkerCompleteSubject\n    WalkerInstance -.->|stop signal| walkerStopSubject\n    \n    style WalkerClass fill:#f0f0f0,stroke:#333,stroke-width:2px\n    style WalkerLogicPriv fill:#e0e0e0,stroke:#333,stroke-width:2px\n```\n\n**Sources:** [src/classes/Walker.ts:1-650](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:1-264]()\n\n### Sequential Backtest Flow\n\nWalker executes strategies sequentially, not in parallel. This design ensures:\n- Deterministic execution order\n- Predictable resource usage\n- Isolated metric calculation per strategy\n- Clean event emission\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant WalkerLogicPrivateService\n    participant BacktestLogicPublicService\n    participant WalkerMarkdownService\n    participant walkerEmitter\n    \n    User->>WalkerLogicPrivateService: run(symbol, strategies, metric)\n    \n    loop For each strategy\n        WalkerLogicPrivateService->>BacktestLogicPublicService: run(symbol, strategyName, context)\n        \n        loop Timeframes\n            BacktestLogicPublicService-->>BacktestLogicPublicService: tick + backtest\n        end\n        \n        BacktestLogicPublicService-->>WalkerLogicPrivateService: Closed signals\n        \n        WalkerLogicPrivateService->>WalkerMarkdownService: getData(symbol, strategyName)\n        WalkerMarkdownService-->>WalkerLogicPrivateService: BacktestStatisticsModel\n        \n        WalkerLogicPrivateService->>WalkerLogicPrivateService: Extract metric value\n        WalkerLogicPrivateService->>WalkerLogicPrivateService: Update best strategy\n        \n        WalkerLogicPrivateService->>walkerEmitter: Emit progress\n        WalkerLogicPrivateService-->>User: yield WalkerContract\n    end\n    \n    WalkerLogicPrivateService->>walkerEmitter: Emit walkerCompleteSubject\n    WalkerLogicPrivateService-->>User: Return final results\n```\n\n**Sources:** [src/lib/services/logic/private/WalkerLogicPrivateService.ts:68-175]()\n\n---\n\n## Walker Execution Flow\n\n### WalkerLogicPrivateService.run() Implementation\n\nThe core orchestration logic in `WalkerLogicPrivateService` follows this algorithm:\n\n1. **Initialization**: Load walker schema, validate all strategy names\n2. **Sequential Execution**: Iterate through `strategies` array\n3. **Per-Strategy Backtest**: \n   - Run `BacktestLogicPublicService.run()` with context propagation\n   - Consume all closed signals from backtest\n   - Extract statistics via `BacktestMarkdownService.getData()`\n4. **Metric Extraction**: Read metric value from `BacktestStatisticsModel`\n5. **Ranking Update**: Compare with current best, update if better\n6. **Progress Emission**: Emit `WalkerContract` via `walkerEmitter`\n7. **Early Termination**: Check `walkerStopSubject` for stop signals\n8. **Completion**: Emit `walkerCompleteSubject` with final ranking\n\n**Sources:** [src/lib/services/logic/private/WalkerLogicPrivateService.ts:68-175]()\n\n### Stop Signal Handling\n\nWalker supports graceful cancellation via `walkerStopSubject`. Stop signals are filtered by `walkerName` to prevent interference when multiple walkers run simultaneously on the same symbol:\n\n```typescript\n// Stop signal emission (Walker.stop)\nfor (const strategyName of walkerSchema.strategies) {\n  await walkerStopSubject.next({ symbol, strategyName, walkerName });\n  await backtest.strategyCoreService.stop({ symbol, strategyName }, true);\n}\n```\n\n```typescript\n// Stop signal consumption (WalkerLogicPrivateService)\nconst stopPromise = resolveDocuments(\n  walkerStopSubject.toPromise((event) =>\n    event.symbol === symbol &&\n    event.strategyName === strategyName &&\n    event.walkerName === context.walkerName\n  )\n);\n\nconst shouldStop = await Promise.race([backtestPromise, stopPromise]);\n```\n\n**Sources:** [src/classes/Walker.ts:271-283](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:100-122]()\n\n---\n\n## Results and Reporting\n\n### WalkerStatisticsModel Structure\n\n```typescript\ninterface WalkerStatisticsModel {\n  walkerName: string;\n  metric: WalkerMetric;\n  strategyResults: IWalkerStrategyResult[];\n  bestStrategy: IWalkerStrategyResult | null;\n  totalStrategies: number;\n  completedStrategies: number;\n}\n\ninterface IWalkerStrategyResult {\n  strategyName: string;\n  stats: BacktestStatisticsModel;\n  metricValue: number | null;\n  rank: number;\n}\n```\n\nEach strategy result includes:\n- Full `BacktestStatisticsModel` with all backtest metrics\n- Extracted `metricValue` for the optimization metric\n- `rank` based on metric value (1 = best)\n\n**Sources:** [src/model/WalkerStatistics.model.ts:1-54]()\n\n### Real-Time Progress Tracking\n\nWalker emits progress updates after each strategy completes via `walkerEmitter`:\n\n```typescript\ninterface WalkerContract {\n  walkerName: string;\n  symbol: string;\n  strategyName: string;          // Just completed\n  stats: BacktestStatisticsModel;\n  metric: WalkerMetric;\n  metricValue: number | null;\n  bestStrategyName: string | null;\n  bestMetricValue: number | null;\n  strategiesTested: number;\n  totalStrategies: number;\n  progress: number;              // 0.0 to 1.0\n}\n```\n\n**Sources:** [src/contract/Walker.contract.ts:1-48]()\n\n### Markdown Report Generation\n\nWalker reports display comparative statistics in tabular format:\n\n| Strategy | Sharpe Ratio | Win Rate | Total PNL | Avg PNL | Signals |\n|----------|--------------|----------|-----------|---------|---------|\n| strategy-A | 2.45 ⭐ | 65.2% | 45.3% | 1.2% | 120 |\n| strategy-B | 1.87 | 72.1% | 52.1% | 1.1% | 135 |\n| strategy-C | 1.34 | 58.9% | 38.7% | 0.9% | 105 |\n\nThe best strategy (by selected metric) is marked with ⭐.\n\n**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:1-300]()\n\n---\n\n## Walker Class API\n\n### Walker.run() - Async Generator\n\nStreams progress updates as each strategy completes:\n\n```typescript\nfor await (const progress of Walker.run(\"BTCUSDT\", {\n  walkerName: \"my-optimizer\"\n})) {\n  console.log(`Tested ${progress.strategiesTested}/${progress.totalStrategies}`);\n  console.log(`Current best: ${progress.bestStrategyName} (${progress.bestMetricValue})`);\n  \n  // Early termination based on criteria\n  if (progress.bestMetricValue > 3.0) {\n    break;\n  }\n}\n```\n\n**Sources:** [src/classes/Walker.ts:378-429]()\n\n### Walker.background() - Fire-and-Forget\n\nRuns walker in background, emitting events via `listenWalker()`:\n\n```typescript\nimport { Walker, listenWalker, listenWalkerComplete } from \"backtest-kit\";\n\nconst cancel = Walker.background(\"BTCUSDT\", {\n  walkerName: \"my-optimizer\"\n});\n\nlistenWalker((progress) => {\n  console.log(`Progress: ${(progress.progress * 100).toFixed(1)}%`);\n});\n\nlistenWalkerComplete((results) => {\n  console.log(`Winner: ${results.bestStrategy?.strategyName}`);\n  cancel(); // Cleanup (already done, but safe to call)\n});\n```\n\n**Sources:** [src/classes/Walker.ts:431-481]()\n\n### Walker.stop() - Graceful Cancellation\n\nStops walker comparison, allowing current strategy to complete:\n\n```typescript\nawait Walker.stop(\"BTCUSDT\", \"my-optimizer\");\n// Current running strategy will finish its backtest\n// Subsequent strategies will not execute\n```\n\n**Sources:** [src/classes/Walker.ts:483-529]()\n\n### Walker.getData() - Retrieve Results\n\nFetches complete comparison results:\n\n```typescript\nconst results = await Walker.getData(\"BTCUSDT\", \"my-optimizer\");\n\nconsole.log(`Best: ${results.bestStrategy?.strategyName}`);\nconsole.log(`Metric: ${results.metric} = ${results.bestStrategy?.metricValue}`);\n\nresults.strategyResults\n  .sort((a, b) => (b.metricValue || 0) - (a.metricValue || 0))\n  .forEach((result, i) => {\n    console.log(`${i + 1}. ${result.strategyName}: ${result.metricValue}`);\n  });\n```\n\n**Sources:** [src/classes/Walker.ts:531-568]()\n\n### Walker.getReport() - Generate Markdown\n\nCreates formatted comparison report:\n\n```typescript\nconst markdown = await Walker.getReport(\"BTCUSDT\", \"my-optimizer\", [\n  \"strategyName\",\n  \"sharpeRatio\",\n  \"winRate\",\n  \"totalPnl\"\n]);\n\nconsole.log(markdown);\n// Outputs:\n// # Walker Comparison: my-optimizer\n// **Symbol:** BTCUSDT\n// **Metric:** sharpeRatio\n// \n// | Strategy | Sharpe Ratio | Win Rate | Total PNL |\n// |----------|--------------|----------|-----------|\n// | ... | ... | ... | ... |\n```\n\n**Sources:** [src/classes/Walker.ts:570-616]()\n\n### Walker.dump() - Save to Disk\n\nExports report to file system:\n\n```typescript\nawait Walker.dump(\"BTCUSDT\", \"my-optimizer\");\n// Saves to: ./dump/walker/my-optimizer.md\n\nawait Walker.dump(\"BTCUSDT\", \"my-optimizer\", \"./custom/reports\");\n// Saves to: ./custom/reports/my-optimizer.md\n```\n\n**Sources:** [src/classes/Walker.ts:618-650]()\n\n---\n\n## Context Propagation\n\nWalker uses `MethodContextService` to propagate execution context through the call stack:\n\n```mermaid\ngraph TB\n    subgraph \"Context Setup\"\n        Walker[\"Walker.run()\"]\n        SetContext[\"MethodContextService.runAsyncIterator()\"]\n    end\n    \n    subgraph \"Context Values\"\n        Context[\"IMethodContext:<br/>exchangeName<br/>frameName<br/>strategyName\"]\n    end\n    \n    subgraph \"Context Consumers\"\n        BacktestLogic[\"BacktestLogicPrivateService\"]\n        StrategyCore[\"StrategyCoreService\"]\n        ExchangeCore[\"ExchangeCoreService\"]\n        FrameCore[\"FrameCoreService\"]\n    end\n    \n    Walker --> SetContext\n    SetContext --> Context\n    Context -.->|implicit| BacktestLogic\n    Context -.->|implicit| StrategyCore\n    Context -.->|implicit| ExchangeCore\n    Context -.->|implicit| FrameCore\n```\n\nEach strategy execution updates `context.strategyName` while preserving `exchangeName` and `frameName`. This ensures consistent exchange and timeframe across all strategy comparisons.\n\n**Sources:** [src/lib/services/logic/private/WalkerLogicPrivateService.ts:68-175](), [src/lib/services/context/MethodContextService.ts:1-100]()\n\n---\n\n## Event System Integration\n\nWalker integrates with the framework's event system via four emitters:\n\n| Emitter | Type | Purpose |\n|---------|------|---------|\n| `walkerEmitter` | `Subject<WalkerContract>` | Progress after each strategy |\n| `walkerCompleteSubject` | `Subject<WalkerCompleteContract>` | Final results |\n| `walkerStopSubject` | `Subject<WalkerStopContract>` | Cancellation signals |\n| `progressWalkerEmitter` | `Subject<ProgressWalkerContract>` | Percentage progress |\n\n### Event Flow Diagram\n\n```mermaid\ngraph LR\n    subgraph \"Event Producers\"\n        WalkerLogic[\"WalkerLogicPrivateService\"]\n        WalkerStop[\"Walker.stop()\"]\n    end\n    \n    subgraph \"Event Emitters\"\n        walkerEmitter[\"walkerEmitter\"]\n        walkerComplete[\"walkerCompleteSubject\"]\n        walkerStop[\"walkerStopSubject\"]\n        progressWalker[\"progressWalkerEmitter\"]\n    end\n    \n    subgraph \"Event Consumers\"\n        WalkerMarkdown[\"WalkerMarkdownService\"]\n        listenWalker[\"listenWalker()\"]\n        listenComplete[\"listenWalkerComplete()\"]\n        listenProgress[\"listenWalkerProgress()\"]\n    end\n    \n    WalkerLogic --> walkerEmitter\n    WalkerLogic --> walkerComplete\n    WalkerLogic --> progressWalker\n    WalkerStop --> walkerStop\n    \n    walkerEmitter --> WalkerMarkdown\n    walkerEmitter --> listenWalker\n    walkerComplete --> listenComplete\n    progressWalker --> listenProgress\n    walkerStop -.->|cancellation| WalkerLogic\n```\n\n**Sources:** [src/config/emitters.ts:1-150](), [src/function/event.ts:1-800]()\n\n---\n\n## State Management and Cleanup\n\nWalker maintains isolated state per symbol-walker pair via memoization:\n\n```typescript\n// WalkerUtils class\nprivate _getInstance = memoize<\n  (symbol: string, walkerName: WalkerName) => WalkerInstance\n>(\n  ([symbol, walkerName]) => `${symbol}:${walkerName}`,\n  (symbol: string, walkerName: WalkerName) => new WalkerInstance(symbol, walkerName)\n);\n```\n\nEach `WalkerInstance` tracks:\n- `_isStopped`: Manual cancellation flag\n- `_isDone`: Completion flag\n- `id`: Unique random identifier\n- `task`: Singlerun-wrapped execution function\n\n**State Cleanup on Walker Start:**\n\n```typescript\nbacktest.walkerMarkdownService.clear(context.walkerName);\n\n// Clear backtest data for all strategies\nfor (const strategyName of walkerSchema.strategies) {\n  backtest.backtestMarkdownService.clear({ symbol, strategyName });\n  backtest.scheduleMarkdownService.clear({ symbol, strategyName });\n  backtest.strategyCoreService.clear({ symbol, strategyName });\n  \n  const { riskName, riskList } = backtest.strategySchemaService.get(strategyName);\n  riskName && backtest.riskGlobalService.clear(riskName);\n  riskList?.forEach((riskName) => backtest.riskGlobalService.clear(riskName));\n}\n```\n\nThis ensures each walker run starts with clean state, preventing contamination from previous executions.\n\n**Sources:** [src/classes/Walker.ts:363-370](), [src/classes/Walker.ts:162-187]()\n\n---\n\n## Walker vs. Optimizer\n\nWalker and Optimizer ([10.2](#10.2)) serve different purposes:\n\n| Aspect | Walker | Optimizer |\n|--------|--------|-----------|\n| **Purpose** | Compare existing strategies | Generate new strategies via LLM |\n| **Input** | Predefined strategy list | Market data + prompt template |\n| **Output** | Ranking by metric | Executable strategy code |\n| **Execution** | Sequential backtests | Data collection + code generation |\n| **Use Case** | Strategy selection | Strategy discovery |\n\nWalker is used for **quantitative comparison** of known strategies. Optimizer is used for **automated strategy creation** using AI.\n\n**Sources:** [src/classes/Walker.ts:1-650](), [src/classes/Optimizer.ts:1-500]()\n\n---\n\n## Performance Considerations\n\n### Memory Efficiency\n\nWalker uses async generators to stream results, avoiding accumulation of all backtest data in memory:\n\n```typescript\npublic async *run(symbol: string, strategies: StrategyName[], metric: WalkerMetric) {\n  for (const strategyName of strategies) {\n    // Backtest executed here\n    for await (const _ of this.backtestLogicPublicService.run(symbol, context)) {\n      // Results consumed and discarded\n    }\n    \n    // Only statistics retained\n    const stats = await this.backtestMarkdownService.getData(symbol, strategyName);\n    \n    // Yield progress, then continue\n    yield {\n      strategyName,\n      stats,\n      // ...\n    };\n  }\n}\n```\n\nOnly `BacktestStatisticsModel` (aggregate metrics) is retained per strategy, not individual signals.\n\n**Sources:** [src/lib/services/logic/private/WalkerLogicPrivateService.ts:68-175]()\n\n### Parallel Execution Not Supported\n\nWalker executes strategies sequentially by design. For parallel execution, run multiple `Walker.background()` instances with different walker names:\n\n```typescript\n// Parallel walker execution\nWalker.background(\"BTCUSDT\", { walkerName: \"optimizer-group-1\" });\nWalker.background(\"ETHUSDT\", { walkerName: \"optimizer-group-2\" });\nWalker.background(\"BNBUSDT\", { walkerName: \"optimizer-group-3\" });\n```\n\nEach walker operates independently with its own state.\n\n**Sources:** [src/lib/services/logic/private/WalkerLogicPrivateService.ts:68-175]()\n\n---\n\n## Example: Complete Walker Usage\n\n```typescript\nimport { \n  addWalker, \n  Walker, \n  listenWalker, \n  listenWalkerComplete \n} from \"backtest-kit\";\n\n// Define walker configuration\naddWalker({\n  walkerName: \"strategy-optimizer\",\n  exchangeName: \"binance\",\n  frameName: \"1d-backtest\",\n  strategies: [\n    \"rsi-strategy\",\n    \"macd-strategy\", \n    \"bollinger-strategy\",\n    \"ema-crossover-strategy\"\n  ],\n  metric: \"sharpeRatio\",\n  callbacks: {\n    onStrategyStart: (strategyName, symbol) => {\n      console.log(`Testing ${strategyName} on ${symbol}...`);\n    },\n    onStrategyComplete: (strategyName, symbol, stats, metric) => {\n      console.log(`${strategyName}: Sharpe = ${metric?.toFixed(2)}`);\n    }\n  }\n});\n\n// Listen to progress\nlistenWalker((progress) => {\n  console.log(`Progress: ${progress.strategiesTested}/${progress.totalStrategies}`);\n  console.log(`Current leader: ${progress.bestStrategyName}`);\n});\n\n// Listen to completion\nlistenWalkerComplete(async (results) => {\n  console.log(\"\\n=== Walker Results ===\");\n  console.log(`Best: ${results.bestStrategy?.strategyName}`);\n  console.log(`Sharpe: ${results.bestStrategy?.metricValue?.toFixed(2)}`);\n  \n  // Generate and save report\n  await Walker.dump(\"BTCUSDT\", \"strategy-optimizer\");\n  console.log(\"Report saved to ./dump/walker/strategy-optimizer.md\");\n});\n\n// Execute walker\nWalker.background(\"BTCUSDT\", {\n  walkerName: \"strategy-optimizer\"\n});\n```\n\n**Sources:** [src/function/add.ts:1-200](), [src/classes/Walker.ts:1-650](), [src/function/event.ts:1-800]()"
                    },
                    {
                        "page_plan": {
                            "id": "5.4",
                            "title": "Async Generator Patterns"
                        },
                        "content": "# Async Generator Patterns\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/lib/services/logic/private/BacktestLogicPrivateService.ts](src/lib/services/logic/private/BacktestLogicPrivateService.ts)\n- [src/lib/services/logic/private/LiveLogicPrivateService.ts](src/lib/services/logic/private/LiveLogicPrivateService.ts)\n- [src/lib/services/logic/private/WalkerLogicPrivateService.ts](src/lib/services/logic/private/WalkerLogicPrivateService.ts)\n\n</details>\n\n\n\nThis page documents the async generator patterns used throughout Backtest Kit's execution modes to enable memory-efficient streaming, early termination, and progressive result delivery. Async generators are the core architectural pattern that allows the framework to process large backtests without accumulating results in memory and support graceful shutdown in live trading.\n\nFor information about the higher-level execution orchestration, see [Execution Modes](#5). For details on how signals flow through the system, see [Signal Lifecycle](#3.1).\n\n---\n\n## Overview: Generator-Based Architecture\n\nBacktest Kit uses JavaScript async generators (`async function*`) as the primary pattern for orchestrating all three execution modes. This pattern provides:\n\n- **Streaming results**: Values are yielded one at a time without accumulating in arrays\n- **Memory efficiency**: Only the current signal state is held in memory\n- **Early termination**: Consumers can `break` from loops to stop execution\n- **Progressive updates**: Walker mode yields after each strategy completion\n- **Lazy evaluation**: Computation happens on-demand as values are consumed\n\nThe generator pattern is implemented at two layers:\n\n| Layer | Services | Purpose |\n|-------|----------|---------|\n| **Private Logic** | `BacktestLogicPrivateService`, `LiveLogicPrivateService`, `WalkerLogicPrivateService` | Core generator implementation with `async *run()` methods |\n| **Public Logic** | `BacktestLogicPublicService`, `LiveLogicPublicService`, `WalkerLogicPublicService` | Context propagation wrappers that call private services |\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:1-481](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:1-179](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:1-263](), [docs/internals.md:22-23]()\n\n---\n\n## Generator Types: Finite vs Infinite\n\nThe framework implements two distinct generator lifecycles depending on the execution mode:\n\n```mermaid\ngraph TB\n    subgraph \"Finite Generator (Backtest)\"\n        BT_START[\"Start: Get timeframes array\"]\n        BT_LOOP[\"while i < timeframes.length\"]\n        BT_TICK[\"Process timeframe at index i\"]\n        BT_YIELD[\"yield closed signal\"]\n        BT_INC[\"i++\"]\n        BT_CHECK{\"i < length?\"}\n        BT_END[\"End: Generator completes\"]\n        \n        BT_START --> BT_LOOP\n        BT_LOOP --> BT_TICK\n        BT_TICK --> BT_YIELD\n        BT_YIELD --> BT_INC\n        BT_INC --> BT_CHECK\n        BT_CHECK -->|yes| BT_LOOP\n        BT_CHECK -->|no| BT_END\n    end\n    \n    subgraph \"Infinite Generator (Live)\"\n        LIVE_START[\"Start: while(true)\"]\n        LIVE_WHEN[\"when = new Date()\"]\n        LIVE_TICK[\"tick with current time\"]\n        LIVE_YIELD[\"yield if opened/closed\"]\n        LIVE_SLEEP[\"sleep TICK_TTL (1 min)\"]\n        LIVE_STOP{\"Stop requested?\"}\n        LIVE_LOOP[\"Continue loop\"]\n        LIVE_END[\"End: Only on explicit stop\"]\n        \n        LIVE_START --> LIVE_WHEN\n        LIVE_WHEN --> LIVE_TICK\n        LIVE_TICK --> LIVE_YIELD\n        LIVE_YIELD --> LIVE_SLEEP\n        LIVE_SLEEP --> LIVE_STOP\n        LIVE_STOP -->|no| LIVE_LOOP\n        LIVE_LOOP --> LIVE_WHEN\n        LIVE_STOP -->|yes AND closed| LIVE_END\n    end\n```\n\n### Finite Generators (Backtest, Walker)\n\n**Backtest Mode** uses a traditional for-loop pattern with bounded iteration:\n\n- Fetches complete `timeframes` array at start: [src/lib/services/logic/private/BacktestLogicPrivateService.ts:69-72]()\n- Iterates with index: `while (i < timeframes.length)`\n- Advances index: `i++` after processing each frame\n- **Natural completion**: Generator exhausts when all timeframes are processed\n- **Frame skipping**: After signal closes, `i` advances to `closeTimestamp`: [src/lib/services/logic/private/BacktestLogicPrivateService.ts:403-409]()\n\n**Walker Mode** iterates through a finite list of strategies:\n\n- Uses `for (const strategyName of strategies)`: [src/lib/services/logic/private/WalkerLogicPrivateService.ts:115]()\n- Yields after each strategy backtest completes: [src/lib/services/logic/private/WalkerLogicPrivateService.ts:231]()\n- **Natural completion**: Generator exhausts when all strategies are tested\n- **Early exit**: `break` on stop signal: [src/lib/services/logic/private/WalkerLogicPrivateService.ts:125]()\n\n### Infinite Generators (Live)\n\n**Live Mode** uses an infinite loop for continuous monitoring:\n\n- Never-ending loop: `while (true)`: [src/lib/services/logic/private/LiveLogicPrivateService.ts:70]()\n- Real-time progression: `when = new Date()`: [src/lib/services/logic/private/LiveLogicPrivateService.ts:72]()\n- Sleep interval: `await sleep(TICK_TTL)` where `TICK_TTL = 1min + 1ms`: [src/lib/services/logic/private/LiveLogicPrivateService.ts:14](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:173]()\n- **Only terminates on explicit stop**: Checks `getStopped()` flag: [src/lib/services/logic/private/LiveLogicPrivateService.ts:122-136]()\n- **Graceful shutdown**: Waits for signal to close before breaking: [src/lib/services/logic/private/LiveLogicPrivateService.ts:155-170]()\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:62-477](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:63-175](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:68-259]()\n\n---\n\n## Backtest Generator: Timeframe Iteration with Fast Skip\n\nThe backtest generator implements a deterministic iteration pattern that processes historical data minute-by-minute while optimizing performance through timeframe skipping.\n\n```mermaid\ngraph TD\n    START[\"async *run(symbol)\"]\n    GET_FRAMES[\"timeframes = frameCoreService.getTimeframe()\"]\n    INIT[\"i = 0, while i < timeframes.length\"]\n    PROGRESS[\"emit progressBacktestEmitter\"]\n    TICK[\"result = strategyCoreService.tick(when, backtest=true)\"]\n    CHECK_ACTION{\"result.action?\"}\n    \n    IDLE[\"action === 'idle'\"]\n    SCHEDULED[\"action === 'scheduled'\"]\n    OPENED[\"action === 'opened'\"]\n    \n    FETCH_CANDLES_SCHED[\"getNextCandles(bufferMinutes + CC_SCHEDULE_AWAIT_MINUTES + minuteEstimatedTime)\"]\n    FETCH_CANDLES_OPEN[\"getNextCandles(bufferMinutes + minuteEstimatedTime)\"]\n    \n    BACKTEST_SCHED[\"strategyCoreService.backtest(candles)\"]\n    BACKTEST_OPEN[\"strategyCoreService.backtest(candles)\"]\n    \n    YIELD_SCHED[\"yield backtestResult\"]\n    YIELD_OPEN[\"yield backtestResult\"]\n    \n    SKIP_SCHED[\"Skip frames: while i < length && timeframes[i] < closeTimestamp\"]\n    SKIP_OPEN[\"Skip frames: while i < length && timeframes[i] < closeTimestamp\"]\n    \n    INCREMENT[\"i++\"]\n    CHECK_MORE{\"i < timeframes.length?\"}\n    END[\"End: emit final progress (100%)\"]\n    \n    START --> GET_FRAMES\n    GET_FRAMES --> INIT\n    INIT --> PROGRESS\n    PROGRESS --> TICK\n    TICK --> CHECK_ACTION\n    \n    CHECK_ACTION -->|idle| IDLE\n    CHECK_ACTION -->|scheduled| SCHEDULED\n    CHECK_ACTION -->|opened| OPENED\n    \n    IDLE --> INCREMENT\n    \n    SCHEDULED --> FETCH_CANDLES_SCHED\n    FETCH_CANDLES_SCHED --> BACKTEST_SCHED\n    BACKTEST_SCHED --> YIELD_SCHED\n    YIELD_SCHED --> SKIP_SCHED\n    SKIP_SCHED --> CHECK_MORE\n    \n    OPENED --> FETCH_CANDLES_OPEN\n    FETCH_CANDLES_OPEN --> BACKTEST_OPEN\n    BACKTEST_OPEN --> YIELD_OPEN\n    YIELD_OPEN --> SKIP_OPEN\n    SKIP_OPEN --> CHECK_MORE\n    \n    INCREMENT --> CHECK_MORE\n    CHECK_MORE -->|yes| PROGRESS\n    CHECK_MORE -->|no| END\n```\n\n### Key Implementation Details\n\n**Timeframe Generation**: \n- Calls `frameCoreService.getTimeframe()` once at start: [src/lib/services/logic/private/BacktestLogicPrivateService.ts:69-72]()\n- Stores complete array: `const timeframes = await this.frameCoreService.getTimeframe(...)`\n- Tracks progress: `processedFrames: i, totalFrames: timeframes.length`\n\n**Progress Tracking**:\n- Emits after each frame: `await progressBacktestEmitter.next({...})`: [src/lib/services/logic/private/BacktestLogicPrivateService.ts:84-92]()\n- Progress percentage: `progress: totalFrames > 0 ? i / totalFrames : 0`\n- Final 100% emission: [src/lib/services/logic/private/BacktestLogicPrivateService.ts:452-461]()\n\n**Fast Backtest Optimization**:\nWhen a signal opens (`action === \"opened\"`), the generator fetches all required candles at once and calls `strategyCoreService.backtest()`:\n\n1. **Calculate buffer**: `bufferMinutes = CC_AVG_PRICE_CANDLES_COUNT - 1` (for VWAP calculation): [src/lib/services/logic/private/BacktestLogicPrivateService.ts:317]()\n2. **Fetch candles**: `totalCandles = signal.minuteEstimatedTime + bufferMinutes`: [src/lib/services/logic/private/BacktestLogicPrivateService.ts:319]()\n3. **Process signal**: `backtestResult = await strategyCoreService.backtest(symbol, candles, when, true)`: [src/lib/services/logic/private/BacktestLogicPrivateService.ts:361-366]()\n4. **Skip timeframes**: Advances `i` to `closeTimestamp`: [src/lib/services/logic/private/BacktestLogicPrivateService.ts:403-409]()\n\nThis optimization avoids tick-by-tick processing while signals are active, drastically improving performance.\n\n**Scheduled Signal Handling**:\nFor scheduled signals (`priceOpen` not yet reached), the generator:\n\n1. Fetches extended candles: `bufferMinutes + CC_SCHEDULE_AWAIT_MINUTES + minuteEstimatedTime + 1`: [src/lib/services/logic/private/BacktestLogicPrivateService.ts:176]()\n2. Includes wait time: `CC_SCHEDULE_AWAIT_MINUTES` for activation window\n3. Monitors both activation and cancellation: `backtest()` handles both paths\n\n**Performance Metrics**:\n- Tracks frame duration: `performance.now()` before/after processing: [src/lib/services/logic/private/BacktestLogicPrivateService.ts:79](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:434]()\n- Tracks signal duration: Start when opened/scheduled, end when closed: [src/lib/services/logic/private/BacktestLogicPrivateService.ts:155](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:259]()\n- Emits `performanceEmitter` events: [src/lib/services/logic/private/BacktestLogicPrivateService.ts:391-401]()\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:62-477](), [docs/internals.md:54-66]()\n\n---\n\n## Live Generator: Infinite Loop with Real-Time Polling\n\nThe live generator implements an infinite loop that continuously monitors real-time market conditions with crash recovery and graceful shutdown support.\n\n```mermaid\ngraph TD\n    START[\"async *run(symbol)\"]\n    INIT[\"previousEventTimestamp = null\"]\n    LOOP[\"while(true)\"]\n    CREATE_WHEN[\"when = new Date()\"]\n    TICK[\"result = strategyCoreService.tick(symbol, when, backtest=false)\"]\n    PERF[\"emit performanceEmitter (tick duration)\"]\n    \n    CHECK_ACTION{\"result.action?\"}\n    \n    IDLE[\"action === 'idle'\"]\n    ACTIVE[\"action === 'active'\"]\n    SCHEDULED[\"action === 'scheduled'\"]\n    OPENED[\"action === 'opened'\"]\n    CLOSED[\"action === 'closed'\"]\n    \n    CHECK_STOP_IDLE{\"getStopped()?\"}\n    BREAK_IDLE[\"break (exit generator)\"]\n    SLEEP_IDLE[\"sleep(TICK_TTL)\"]\n    \n    SLEEP_ACTIVE[\"sleep(TICK_TTL)\"]\n    SLEEP_SCHEDULED[\"sleep(TICK_TTL)\"]\n    \n    YIELD[\"yield result (opened or closed)\"]\n    CHECK_STOP_CLOSED{\"result.action === 'closed' && getStopped()?\"}\n    BREAK_CLOSED[\"break (graceful shutdown)\"]\n    SLEEP[\"sleep(TICK_TTL)\"]\n    \n    START --> INIT\n    INIT --> LOOP\n    LOOP --> CREATE_WHEN\n    CREATE_WHEN --> TICK\n    TICK --> PERF\n    PERF --> CHECK_ACTION\n    \n    CHECK_ACTION -->|idle| IDLE\n    CHECK_ACTION -->|active| ACTIVE\n    CHECK_ACTION -->|scheduled| SCHEDULED\n    CHECK_ACTION -->|opened| OPENED\n    CHECK_ACTION -->|closed| CLOSED\n    \n    IDLE --> CHECK_STOP_IDLE\n    CHECK_STOP_IDLE -->|yes| BREAK_IDLE\n    CHECK_STOP_IDLE -->|no| SLEEP_IDLE\n    SLEEP_IDLE --> LOOP\n    \n    ACTIVE --> SLEEP_ACTIVE\n    SLEEP_ACTIVE --> LOOP\n    \n    SCHEDULED --> SLEEP_SCHEDULED\n    SLEEP_SCHEDULED --> LOOP\n    \n    OPENED --> YIELD\n    CLOSED --> YIELD\n    YIELD --> CHECK_STOP_CLOSED\n    CHECK_STOP_CLOSED -->|yes| BREAK_CLOSED\n    CHECK_STOP_CLOSED -->|no| SLEEP\n    SLEEP --> LOOP\n```\n\n### Key Implementation Details\n\n**Infinite Loop Structure**:\n- Never-ending: `while (true)`: [src/lib/services/logic/private/LiveLogicPrivateService.ts:70]()\n- Real-time timestamp: `const when = new Date()`: [src/lib/services/logic/private/LiveLogicPrivateService.ts:72]()\n- Tick interval: `TICK_TTL = 1 * 60 * 1_000 + 1` (1 minute + 1ms): [src/lib/services/logic/private/LiveLogicPrivateService.ts:14]()\n- Sleep between iterations: `await sleep(TICK_TTL)`: [src/lib/services/logic/private/LiveLogicPrivateService.ts:173]()\n\n**Selective Yielding**:\nThe generator only yields `opened` and `closed` results, filtering out `idle`, `active`, and `scheduled`:\n\n```typescript\n// Skip idle/active/scheduled - only sleep\nif (result.action === \"idle\") {\n  await sleep(TICK_TTL);\n  continue;\n}\n// ... similar for active, scheduled\n\n// Yield opened/closed\nyield result as IStrategyTickResultClosed | IStrategyTickResultOpened;\n```\n\nThis keeps the consumer loop clean and focused on actionable events: [src/lib/services/logic/private/LiveLogicPrivateService.ts:118-152]()\n\n**Crash Recovery**:\nThe live generator relies on `ClientStrategy.waitForInit()` to load persisted signal state:\n- Called automatically during `strategyCoreService.tick()` initialization\n- Reads from `PersistSignalAdapter` file storage\n- Restores `pendingSignal` if process crashed mid-signal\n- Reference: [docs/internals.md:76]()\n\n**Error Handling with Continue**:\nIf `tick()` throws an error, the generator:\n1. Logs warning: [src/lib/services/logic/private/LiveLogicPrivateService.ts:78-91]()\n2. Emits to `errorEmitter`: [src/lib/services/logic/private/LiveLogicPrivateService.ts:92]()\n3. Sleeps: `await sleep(TICK_TTL)`\n4. **Continues loop**: `continue` instead of breaking: [src/lib/services/logic/private/LiveLogicPrivateService.ts:94]()\n\nThis ensures transient errors (network issues, API rate limits) don't kill the live trading process.\n\n**Graceful Shutdown Logic**:\n\nThe generator implements two stop checks:\n\n| Condition | Location | Behavior |\n|-----------|----------|----------|\n| Idle state | [LiveLogicPrivateService.ts:118-136]() | Immediate break if no active signal |\n| Signal closed | [LiveLogicPrivateService.ts:155-170]() | Break after signal closes |\n\nThis ensures:\n- **No orphaned positions**: Never stops with active signal\n- **Clean exit**: Always waits for `action === \"closed\"`\n- **User control**: Responds to `strategyCoreService.getStopped()` flag\n\n**Performance Tracking**:\n- Measures tick duration: `performance.now()` before/after: [src/lib/services/logic/private/LiveLogicPrivateService.ts:71](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:103]()\n- Tracks delta: `previousTimestamp` for inter-tick timing: [src/lib/services/logic/private/LiveLogicPrivateService.ts:68]()\n- Emits `performanceEmitter` with `metricType: \"live_tick\"`: [src/lib/services/logic/private/LiveLogicPrivateService.ts:105-115]()\n\n**Sources:** [src/lib/services/logic/private/LiveLogicPrivateService.ts:63-175](), [docs/internals.md:69-82]()\n\n---\n\n## Walker Generator: Progressive Strategy Comparison\n\nThe walker generator orchestrates multiple backtests sequentially, yielding progress updates after each strategy completes to enable real-time comparison tracking.\n\n```mermaid\ngraph TD\n    START[\"async *run(symbol, strategies, metric, context)\"]\n    INIT[\"strategiesTested = 0, bestMetric = null, bestStrategy = null\"]\n    SUBSCRIBE[\"Subscribe to walkerStopSubject for stop signals\"]\n    \n    LOOP[\"for (const strategyName of strategies)\"]\n    CHECK_STOPPED{\"stoppedStrategies.has(strategyName)?\"}\n    BREAK[\"break (strategy stopped)\"]\n    \n    CALLBACK_START[\"walkerSchema.callbacks?.onStrategyStart()\"]\n    RUN_BACKTEST[\"iterator = backtestLogicPublicService.run()\"]\n    AWAIT[\"await resolveDocuments(iterator)\"]\n    \n    CALLBACK_ERROR[\"walkerSchema.callbacks?.onStrategyError()\"]\n    CONTINUE[\"continue (skip strategy)\"]\n    \n    GET_STATS[\"stats = backtestMarkdownService.getData()\"]\n    EXTRACT_METRIC[\"metricValue = stats[metric]\"]\n    UPDATE_BEST[\"if metricValue > bestMetric: update best\"]\n    INCREMENT[\"strategiesTested++\"]\n    \n    BUILD_CONTRACT[\"walkerContract = {...stats, metricValue, bestMetric, bestStrategy}\"]\n    EMIT_PROGRESS[\"emit progressWalkerEmitter\"]\n    CALLBACK_COMPLETE[\"walkerSchema.callbacks?.onStrategyComplete()\"]\n    EMIT_WALKER[\"emit walkerEmitter.next(walkerContract)\"]\n    YIELD[\"yield walkerContract\"]\n    \n    CHECK_MORE{\"More strategies?\"}\n    \n    UNSUBSCRIBE[\"unsubscribe() from stop signals\"]\n    CALLBACK_FINAL[\"walkerSchema.callbacks?.onComplete(finalResults)\"]\n    EMIT_COMPLETE[\"emit walkerCompleteSubject.next()\"]\n    END[\"End generator\"]\n    \n    START --> INIT\n    INIT --> SUBSCRIBE\n    SUBSCRIBE --> LOOP\n    LOOP --> CHECK_STOPPED\n    CHECK_STOPPED -->|yes| BREAK\n    CHECK_STOPPED -->|no| CALLBACK_START\n    \n    CALLBACK_START --> RUN_BACKTEST\n    RUN_BACKTEST --> AWAIT\n    AWAIT -->|error| CALLBACK_ERROR\n    CALLBACK_ERROR --> CONTINUE\n    CONTINUE --> LOOP\n    \n    AWAIT -->|success| GET_STATS\n    GET_STATS --> EXTRACT_METRIC\n    EXTRACT_METRIC --> UPDATE_BEST\n    UPDATE_BEST --> INCREMENT\n    INCREMENT --> BUILD_CONTRACT\n    BUILD_CONTRACT --> EMIT_PROGRESS\n    EMIT_PROGRESS --> CALLBACK_COMPLETE\n    CALLBACK_COMPLETE --> EMIT_WALKER\n    EMIT_WALKER --> YIELD\n    YIELD --> CHECK_MORE\n    \n    CHECK_MORE -->|yes| LOOP\n    CHECK_MORE -->|no| UNSUBSCRIBE\n    BREAK --> UNSUBSCRIBE\n    \n    UNSUBSCRIBE --> CALLBACK_FINAL\n    CALLBACK_FINAL --> EMIT_COMPLETE\n    EMIT_COMPLETE --> END\n```\n\n### Key Implementation Details\n\n**Sequential Backtest Execution**:\n- Iterates: `for (const strategyName of strategies)`: [src/lib/services/logic/private/WalkerLogicPrivateService.ts:115]()\n- Creates backtest iterator: `backtestLogicPublicService.run(symbol, context)`: [src/lib/services/logic/private/WalkerLogicPrivateService.ts:137-141]()\n- Consumes fully: `await resolveDocuments(iterator)`: [src/lib/services/logic/private/WalkerLogicPrivateService.ts:144]()\n\n**Stop Signal Management**:\nUses a `Set` to track stopped strategies with subscription filtering:\n\n```typescript\nconst stoppedStrategies = new Set<StrategyName>();\n\nconst unsubscribe = walkerStopSubject\n  .filter((data) => data.symbol === symbol && data.walkerName === context.walkerName)\n  .connect((data) => {\n    stoppedStrategies.add(data.strategyName);\n  });\n```\n\nThis enables:\n- **Per-strategy stopping**: Specific strategies can be stopped mid-comparison\n- **Symbol/walker isolation**: Filter by both `symbol` AND `walkerName`: [src/lib/services/logic/private/WalkerLogicPrivateService.ts:99]()\n- **Cleanup**: `unsubscribe()` called in `finally` block: [src/lib/services/logic/private/WalkerLogicPrivateService.ts:113](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:235]()\n\n**Metric Extraction & Ranking**:\n\n```typescript\nconst stats = await this.backtestMarkdownService.getData(symbol, strategyName);\nconst value = stats[metric];\nconst metricValue = /* safe number check */;\n\nconst isBetter = bestMetric === null || (metricValue !== null && metricValue > bestMetric);\nif (isBetter && metricValue !== null) {\n  bestMetric = metricValue;\n  bestStrategy = strategyName;\n}\n```\n\n- Extracts dynamic metric: `stats[metric]` where `metric` is configurable: [src/lib/services/logic/private/WalkerLogicPrivateService.ts:172]()\n- Safe math checking: Validates finite, non-NaN values: [src/lib/services/logic/private/WalkerLogicPrivateService.ts:173-180]()\n- Higher-is-better: Uses `>` comparison for ranking: [src/lib/services/logic/private/WalkerLogicPrivateService.ts:183-190]()\n\n**Progressive Result Yielding**:\n\nAfter each strategy completes, the generator constructs a `WalkerContract`:\n\n```typescript\nconst walkerContract: WalkerContract = {\n  walkerName, exchangeName, frameName, symbol,\n  strategyName,  // Current strategy\n  stats,          // Full statistics for current strategy\n  metricValue,    // Extracted metric value\n  metric,         // Metric being compared\n  bestMetric,     // Best value so far\n  bestStrategy,   // Best strategy so far\n  strategiesTested,\n  totalStrategies\n};\n\nawait walkerEmitter.next(walkerContract);\nyield walkerContract;\n```\n\nThis enables consumers to:\n- Track live progress: `strategiesTested / totalStrategies`\n- See running best: `bestStrategy`, `bestMetric`\n- Access full stats: Complete statistics for current strategy\n\n**Lifecycle Callbacks**:\n\nThe walker supports optional callbacks throughout execution:\n\n| Callback | Timing | Location |\n|----------|--------|----------|\n| `onStrategyStart` | Before backtest starts | [WalkerLogicPrivateService.ts:129-131]() |\n| `onStrategyError` | On backtest failure | [WalkerLogicPrivateService.ts:157-159]() |\n| `onStrategyComplete` | After successful backtest | [WalkerLogicPrivateService.ts:221-228]() |\n| `onComplete` | After all strategies tested | [WalkerLogicPrivateService.ts:254-256]() |\n\n**Final Results Emission**:\n\nAfter loop completion, the generator emits comprehensive results:\n\n```typescript\nconst finalResults = {\n  walkerName, symbol, exchangeName, frameName,\n  metric,\n  totalStrategies: strategies.length,\n  bestStrategy,\n  bestMetric,\n  bestStats: bestStrategy !== null \n    ? await this.backtestMarkdownService.getData(symbol, bestStrategy) \n    : null\n};\n\nawait walkerCompleteSubject.next(finalResults);\n```\n\n**Sources:** [src/lib/services/logic/private/WalkerLogicPrivateService.ts:68-259]()\n\n---\n\n## Memory Efficiency Through Streaming\n\nAsync generators enable constant memory usage regardless of dataset size by avoiding result accumulation.\n\n### Traditional Array Accumulation (Anti-Pattern)\n\n```typescript\n// ❌ Memory grows linearly with signals\nasync function runBacktest_WRONG(symbol: string): Promise<IStrategyTickResultClosed[]> {\n  const results: IStrategyTickResultClosed[] = []; // Growing array\n  \n  for (const when of timeframes) {\n    const result = await tick(symbol, when);\n    if (result.action === \"closed\") {\n      results.push(result); // Accumulates in memory\n    }\n  }\n  \n  return results; // All results held until end\n}\n```\n\n### Generator-Based Streaming (Actual Implementation)\n\n```typescript\n// ✅ Constant memory - yields one result at a time\nasync *run(symbol: string) {\n  for (const when of timeframes) {\n    const result = await tick(symbol, when);\n    if (result.action === \"closed\") {\n      yield result; // Consumer processes immediately\n      // result is eligible for garbage collection\n    }\n  }\n}\n```\n\nThe framework's generators maintain constant memory by:\n\n1. **No result arrays**: Never accumulating closed signals in internal arrays\n2. **Immediate yielding**: Passing results to consumer as soon as available\n3. **Lazy markdown accumulation**: `BacktestMarkdownService` subscribes to events but limits to 250 events per key: [docs/internals.md:101]()\n\n### Memory Usage Comparison\n\n| Approach | Memory Formula | 10K Signals | 100K Signals |\n|----------|---------------|-------------|--------------|\n| Array accumulation | O(n) = `n * sizeof(result)` | ~10MB | ~100MB |\n| Async generator | O(1) = `sizeof(currentResult)` | ~1KB | ~1KB |\n| Markdown service | O(min(n, 250)) | 250 events | 250 events |\n\nThe generator pattern enables processing multi-year backtests (hundreds of thousands of signals) with minimal memory footprint.\n\n**Sources:** [docs/internals.md:22](), [docs/internals.md:44](), [docs/internals.md:98](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:62-477]()\n\n---\n\n## Early Termination Support\n\nAll generators support early termination, allowing consumers to stop execution mid-stream by breaking from the `for await` loop.\n\n### Consumer-Side Termination\n\n```typescript\n// Consumer can break at any time\nfor await (const result of backtest.run(symbol, context)) {\n  console.log(result.closeReason, result.pnl.pnlPercentage);\n  \n  // Early exit on loss threshold\n  if (result.pnl.pnlPercentage < -10) {\n    break; // Generator stops immediately\n  }\n}\n```\n\nWhen the consumer breaks:\n1. Generator's next iteration is never requested\n2. Generator's `finally` blocks execute (if any)\n3. Resources are released\n4. No further computation occurs\n\n### Producer-Side Stop Mechanism\n\nThe framework also supports **producer-initiated stopping** via `getStopped()` checks:\n\n```mermaid\ngraph TD\n    CONSUMER[\"Consumer breaks from loop\"]\n    STOP_FLAG[\"User calls strategy.stop()\"]\n    \n    GENERATOR[\"Generator checks getStopped()\"]\n    \n    BACKTEST_CHECK1[\"Before tick: if getStopped() break\"]\n    BACKTEST_CHECK2[\"After idle: if getStopped() break\"]\n    BACKTEST_CHECK3[\"After closed: if getStopped() break\"]\n    \n    LIVE_CHECK1[\"Idle state: if getStopped() break\"]\n    LIVE_CHECK2[\"After closed: if getStopped() break\"]\n    \n    WALKER_CHECK[\"Before each strategy: if stopped.has(name) break\"]\n    \n    CONSUMER --> GENERATOR\n    STOP_FLAG --> GENERATOR\n    \n    GENERATOR --> BACKTEST_CHECK1\n    GENERATOR --> BACKTEST_CHECK2\n    GENERATOR --> BACKTEST_CHECK3\n    \n    GENERATOR --> LIVE_CHECK1\n    GENERATOR --> LIVE_CHECK2\n    \n    GENERATOR --> WALKER_CHECK\n```\n\n### Backtest Stop Checks\n\nThe backtest generator includes three stop checks:\n\n| Location | Condition | Line Reference |\n|----------|-----------|----------------|\n| Before tick | Always checks before processing frame | [BacktestLogicPrivateService.ts:95-110]() |\n| After idle tick | Only when no active signal | [BacktestLogicPrivateService.ts:132-150]() |\n| After signal closes | After yielding closed result | [BacktestLogicPrivateService.ts:284-300](), [BacktestLogicPrivateService.ts:413-430]() |\n\nThis ensures:\n- **Responsive stopping**: Checks on every frame\n- **Safe termination**: Never stops mid-signal (only when idle or just closed)\n- **Clean state**: Signal always completes before stopping\n\n### Live Stop Checks\n\nThe live generator includes two conditional checks:\n\n| Location | Condition | Line Reference |\n|----------|-----------|----------------|\n| Idle state | When `action === \"idle\"` | [LiveLogicPrivateService.ts:118-136]() |\n| After signal closes | When `action === \"closed\"` | [LiveLogicPrivateService.ts:155-170]() |\n\nThe logic ensures graceful shutdown:\n```typescript\nif (result.action === \"closed\") {\n  if (await this.strategyCoreService.getStopped(symbol, strategyName)) {\n    this.loggerService.info(\"stopped by user request (after signal closed)\");\n    break; // Only break after position is closed\n  }\n}\n```\n\n### Walker Stop Signals\n\nThe walker uses a different pattern with pre-filtering:\n\n```typescript\nconst stoppedStrategies = new Set<StrategyName>();\n\nwalkerStopSubject\n  .filter((data) => data.symbol === symbol && data.walkerName === context.walkerName)\n  .connect((data) => stoppedStrategies.add(data.strategyName));\n\nfor (const strategyName of strategies) {\n  if (stoppedStrategies.has(strategyName)) {\n    break; // Skip remaining strategies\n  }\n  // ... run backtest\n}\n```\n\nThis allows:\n- **Selective stopping**: Stop specific strategies, not entire walker\n- **Symbol isolation**: Filter by `symbol` AND `walkerName`\n- **No active signal disruption**: Check happens before backtest starts\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:95-110](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:132-150](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:413-430](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:118-170](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:98-126]()\n\n---\n\n## Error Handling in Generators\n\nGenerators implement error handling strategies appropriate to their execution mode, with different levels of fault tolerance.\n\n### Backtest: Try-Catch with Continue\n\nBacktest mode catches errors during `tick()` and continues processing:\n\n```typescript\nlet result: IStrategyTickResult;\ntry {\n  result = await this.strategyCoreService.tick(symbol, when, true);\n} catch (error) {\n  console.warn(`backtestLogicPrivateService tick failed when=${when.toISOString()}`);\n  this.loggerService.warn(\"tick failed, skipping timeframe\", { error });\n  await errorEmitter.next(error);\n  i++; // Skip this frame\n  continue; // Continue to next frame\n}\n```\n\nAlso catches during candle fetching and `backtest()` calls:\n- Candle fetch error: [BacktestLogicPrivateService.ts:179-202]()\n- Backtest method error: [BacktestLogicPrivateService.ts:222-242]()\n\nStrategy:\n- **Non-fatal errors**: Individual frame failures don't stop entire backtest\n- **Skip and continue**: Move to next timeframe\n- **Error emission**: Notify listeners via `errorEmitter`\n- **Logging**: Detailed context for debugging\n\n### Live: Try-Catch with Sleep-Retry\n\nLive mode uses a different strategy due to infinite loop:\n\n```typescript\nlet result: IStrategyTickResult;\ntry {\n  result = await this.strategyCoreService.tick(symbol, when, false);\n} catch (error) {\n  console.warn(`liveLogicPrivateService tick failed when=${when.toISOString()}`);\n  this.loggerService.warn(\"tick failed, retrying after sleep\", { error });\n  await errorEmitter.next(error);\n  await sleep(TICK_TTL); // Wait before retry\n  continue; // Retry on next iteration\n}\n```\n\nStrategy:\n- **Transient error tolerance**: Assumes errors are temporary (network, API limits)\n- **Sleep before retry**: `TICK_TTL` delay prevents tight error loops\n- **Never terminates**: Infinite loop continues despite errors\n- **Suitable for live trading**: Brief API outages don't kill the process\n\n### Walker: Try-Catch with Skip Strategy\n\nWalker mode catches errors during individual strategy backtests:\n\n```typescript\ntry {\n  await resolveDocuments(iterator);\n} catch (error) {\n  console.warn(`walkerLogicPrivateService backtest failed strategyName=${strategyName}`);\n  this.loggerService.warn(\"backtest failed for strategy, skipping\", { error });\n  await errorEmitter.next(error);\n  \n  if (walkerSchema.callbacks?.onStrategyError) {\n    walkerSchema.callbacks.onStrategyError(strategyName, symbol, error);\n  }\n  \n  continue; // Skip this strategy, continue to next\n}\n```\n\nStrategy:\n- **Isolation**: One strategy failure doesn't affect others\n- **Callback notification**: `onStrategyError` allows custom handling\n- **Skip and continue**: Move to next strategy\n- **Comparison integrity**: Best strategy still calculated from successful runs\n\n### Error Event Flow\n\nAll three modes follow this pattern:\n\n```mermaid\ngraph LR\n    ERROR[\"Error thrown\"]\n    CATCH[\"catch block\"]\n    LOG[\"loggerService.warn()\"]\n    EMIT[\"errorEmitter.next(error)\"]\n    LISTENER[\"listenError() subscribers\"]\n    \n    ERROR --> CATCH\n    CATCH --> LOG\n    LOG --> EMIT\n    EMIT --> LISTENER\n```\n\n- **Local logging**: `loggerService` records context\n- **Global emission**: `errorEmitter` broadcasts to subscribers\n- **User notification**: `listenError()` callbacks can handle errors: [docs/internals.md:87]()\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:114-129](), [src/lib/services/logic/private/BacktestLogicPrivateService.ts:179-202](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:74-95](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:143-161]()\n\n---\n\n## Context Propagation Through Generators\n\nAll generator patterns integrate with the framework's context services to propagate ambient information without explicit parameter threading.\n\n### Context Service Integration\n\n```mermaid\ngraph TD\n    PUBLIC[\"BacktestLogicPublicService.run(symbol, context)\"]\n    METHOD_CTX[\"MethodContextService.runInContext(context, fn)\"]\n    PRIVATE[\"BacktestLogicPrivateService.run(symbol)\"]\n    \n    EXEC_CTX[\"ExecutionContextService.runInContext({symbol, when, backtest}, fn)\"]\n    TICK[\"strategyCoreService.tick(symbol, when, backtest)\"]\n    \n    ACCESS_METHOD[\"methodContextService.context.strategyName\"]\n    ACCESS_EXEC[\"executionContextService.context.symbol\"]\n    \n    PUBLIC --> METHOD_CTX\n    METHOD_CTX --> PRIVATE\n    PRIVATE --> EXEC_CTX\n    EXEC_CTX --> TICK\n    \n    TICK --> ACCESS_METHOD\n    TICK --> ACCESS_EXEC\n```\n\n### Public Logic Layer: Method Context Setup\n\nPublic services wrap private generators with context initialization:\n\n**BacktestLogicPublicService**:\n```typescript\npublic async *run(\n  symbol: string,\n  context: { strategyName: string; exchangeName: string; frameName: string; }\n): AsyncGenerator<IStrategyBacktestResult> {\n  yield* this.methodContextService.runInContext(async () => {\n    return this.backtestLogicPrivateService.run(symbol);\n  }, context);\n}\n```\n\nThis sets `MethodContext` containing:\n- `strategyName`: Strategy being executed\n- `exchangeName`: Exchange for data fetching\n- `frameName`: Timeframe definition (backtest only)\n\n### Private Logic Layer: Execution Context per Tick\n\nPrivate services set `ExecutionContext` for each tick/frame:\n\n**BacktestLogicPrivateService** implicitly via `strategyCoreService.tick()`:\n```typescript\n// StrategyCoreService internally does:\nawait this.executionContextService.runInContext(async () => {\n  return this.strategyConnectionService.get(symbol, strategyName).tick();\n}, { symbol, when, backtest: true });\n```\n\nThis sets `ExecutionContext` containing:\n- `symbol`: Current trading pair\n- `when`: Current timestamp (historical or real-time)\n- `backtest`: Boolean flag for mode detection\n\n### Accessing Context Within Generators\n\nContext is available throughout the call stack without passing parameters:\n\n```typescript\n// In BacktestLogicPrivateService\nawait progressBacktestEmitter.next({\n  exchangeName: this.methodContextService.context.exchangeName,\n  strategyName: this.methodContextService.context.strategyName,\n  symbol, // From parameter\n  // ... other fields\n});\n```\n\n```typescript\n// In ClientStrategy (deep in call stack)\nconst candles = await getCandles(symbol, interval, count);\n// getCandles internally uses:\n// - executionContextService.context.symbol\n// - executionContextService.context.when\n// - methodContextService.context.exchangeName\n```\n\n### Benefits for Generator Pattern\n\nContext propagation enables generators to:\n1. **Avoid parameter drilling**: No need to pass `strategyName`, `exchangeName` through every function\n2. **Maintain clean signatures**: Generator methods have minimal parameters\n3. **Support nested calls**: Context automatically flows to all nested services\n4. **Enable lazy initialization**: Services can access context when needed\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:84-92](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:79-81](), [docs/internals.md:47]()\n\n---\n\n## Yield Semantics and Consumer Patterns\n\nGenerators use the `yield` keyword to pass values to consumers, with different semantics for each mode.\n\n### Backtest: Yield Closed Signals Only\n\nBacktest mode yields only when signals close:\n\n```typescript\n// Opens signal → fetches candles → calls backtest() → yields result\nif (result.action === \"opened\") {\n  // ... fetch candles, call backtest()\n  yield backtestResult; // Always IStrategyBacktestResult (closed)\n}\n\nif (result.action === \"scheduled\") {\n  // ... fetch candles, call backtest()\n  yield backtestResult; // IStrategyBacktestResult (closed or cancelled)\n}\n```\n\n**Type**: `AsyncGenerator<IStrategyBacktestResult>`\n\n**Yielded results**:\n- `IStrategyBacktestResult` with `action: \"closed\"` or `action: \"cancelled\"`\n- Contains full signal with PNL calculation\n- One yield per signal lifecycle\n\n**Consumer pattern**:\n```typescript\nfor await (const result of backtest.run(symbol, context)) {\n  // result is always closed\n  console.log(result.closeReason); // \"take_profit\" | \"stop_loss\" | \"time_expired\"\n  console.log(result.pnl.pnlPercentage);\n}\n```\n\n### Live: Yield Opened and Closed\n\nLive mode yields at signal boundaries:\n\n```typescript\n// Skip idle/active/scheduled\nif (result.action === \"idle\") {\n  await sleep(TICK_TTL);\n  continue; // Don't yield\n}\nif (result.action === \"active\") {\n  await sleep(TICK_TTL);\n  continue; // Don't yield\n}\nif (result.action === \"scheduled\") {\n  await sleep(TICK_TTL);\n  continue; // Don't yield\n}\n\n// Yield opened and closed\nyield result as IStrategyTickResultClosed | IStrategyTickResultOpened;\n```\n\n**Type**: `AsyncGenerator<IStrategyTickResultClosed | IStrategyTickResultOpened>`\n\n**Yielded results**:\n- `IStrategyTickResultOpened`: Signal just activated\n- `IStrategyTickResultClosed`: Signal closed with PNL\n\n**Consumer pattern**:\n```typescript\nfor await (const result of live.run(symbol, context)) {\n  if (result.action === \"opened\") {\n    console.log(\"New signal:\", result.signal.id);\n    // Send Telegram notification\n  }\n  if (result.action === \"closed\") {\n    console.log(\"PNL:\", result.pnl.pnlPercentage);\n    // Log trade to database\n  }\n}\n```\n\n### Walker: Yield Per Strategy Completion\n\nWalker mode yields after each strategy test:\n\n```typescript\nfor (const strategyName of strategies) {\n  // ... run backtest for strategy\n  // ... calculate stats\n  \n  const walkerContract: WalkerContract = {\n    strategyName,\n    stats,\n    metricValue,\n    bestMetric,\n    bestStrategy,\n    strategiesTested,\n    totalStrategies,\n    // ...\n  };\n  \n  await walkerEmitter.next(walkerContract);\n  yield walkerContract;\n}\n```\n\n**Type**: `AsyncGenerator<WalkerContract>`\n\n**Yielded results**:\n- `WalkerContract`: Contains stats for just-completed strategy\n- Includes running best: `bestStrategy`, `bestMetric`\n- Progress tracking: `strategiesTested / totalStrategies`\n\n**Consumer pattern**:\n```typescript\nfor await (const progress of walker.run(symbol, context)) {\n  console.log(`[${progress.strategiesTested}/${progress.totalStrategies}]`);\n  console.log(`Strategy: ${progress.strategyName}`);\n  console.log(`Metric: ${progress.metricValue}`);\n  console.log(`Best so far: ${progress.bestStrategy} (${progress.bestMetric})`);\n}\n```\n\n### Yield vs Emit Pattern\n\nThe framework uses both `yield` (generator protocol) and event emission:\n\n| Mechanism | Purpose | Persistence |\n|-----------|---------|-------------|\n| `yield` | Return value to consumer | Consumed once |\n| `await emitter.next()` | Broadcast event | Multiple subscribers |\n\nGenerators yield **and** emit:\n```typescript\nyield backtestResult; // Consumer gets result\nawait signalBacktestEmitter.next(backtestResult); // Event subscribers notified\n```\n\nThis dual approach enables:\n- **Consumer control**: Generator consumer gets direct results\n- **Observability**: Event listeners (markdown services) can monitor independently\n- **Decoupling**: Consumer and observers are independent\n\n**Sources:** [src/lib/services/logic/private/BacktestLogicPrivateService.ts:411](), [src/lib/services/logic/private/LiveLogicPrivateService.ts:152](), [src/lib/services/logic/private/WalkerLogicPrivateService.ts:231](), [docs/types/IStrategyTickResult.md:1-14]()"
                    },
                    {
                        "page_plan": {
                            "id": "6",
                            "title": "Strategy Development"
                        },
                        "content": "# Strategy Development\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/client/ClientStrategy.ts](src/client/ClientStrategy.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Strategy.interface.ts](src/interfaces/Strategy.interface.ts)\n- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)\n- [test/index.mjs](test/index.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page provides a complete guide to developing trading strategies in Backtest Kit. It covers the fundamentals of strategy creation, signal generation logic, lifecycle callbacks, and integration with the framework's execution engine.\n\nFor information about risk management and validation rules, see [Risk Management](#7). For details on execution modes (backtest, live, walker), see [Execution Modes](#5). For information on fetching and using market data, see [Exchanges & Data Sources](#8).\n\n## Strategy Overview\n\nA **strategy** in Backtest Kit is a self-contained module that generates trading signals based on market data analysis. Strategies are registered via `addStrategy()` and executed through the time execution engine, which guarantees temporal consistency and prevents look-ahead bias.\n\n### Key Characteristics\n\n| Characteristic | Description |\n|---|---|\n| **Signal Generation** | Strategies return `ISignalDto` objects with entry/exit prices and timeframes |\n| **Temporal Context** | All data access is scoped to the current execution timestamp via `ExecutionContextService` |\n| **Interval Throttling** | Configurable minimum time between signal generation attempts |\n| **Lifecycle Callbacks** | Optional hooks for signal events (onOpen, onClose, onActive, etc.) |\n| **Risk Integration** | Optional risk profile binding for portfolio-level controls |\n| **Mode Agnostic** | Same strategy code runs in backtest, live, and walker modes |\n\n### Strategy Development Flow\n\n```mermaid\ngraph TD\n    Define[\"Define Strategy Schema<br/>(IStrategySchema)\"]\n    Implement[\"Implement getSignal Function<br/>Returns ISignalDto | null\"]\n    Register[\"Register via addStrategy()<br/>Stores in StrategySchemaService\"]\n    Execute[\"Execute via Backtest/Live/Walker<br/>Creates ClientStrategy instance\"]\n    Tick[\"tick() Method<br/>Throttled by interval\"]\n    GetSignal[\"Call getSignal()<br/>with symbol, when\"]\n    Validate[\"Multi-Stage Validation<br/>VALIDATE_SIGNAL_FN\"]\n    Risk[\"Risk Check<br/>IRisk.checkSignal()\"]\n    Monitor[\"Signal Monitoring<br/>TP/SL/time_expired\"]\n    \n    Define --> Implement\n    Implement --> Register\n    Register --> Execute\n    Execute --> Tick\n    Tick --> GetSignal\n    GetSignal --> Validate\n    Validate --> Risk\n    Risk --> Monitor\n    \n    style Define fill:#f9f9f9\n    style Execute fill:#f9f9f9\n    style GetSignal fill:#f9f9f9\n```\n\n**Sources:** [types.d.ts:726-751](), [src/interfaces/Strategy.interface.ts:128-151](), [src/client/ClientStrategy.ts:332-476]()\n\n## Strategy Anatomy: Core Components\n\n### IStrategySchema Interface\n\nThe `IStrategySchema` interface defines the complete configuration for a trading strategy:\n\n```mermaid\ngraph LR\n    Schema[\"IStrategySchema\"]\n    Name[\"strategyName: string<br/>(unique identifier)\"]\n    Interval[\"interval: SignalInterval<br/>(1m, 5m, 15m, 30m, 1h)\"]\n    GetSignal[\"getSignal: Function<br/>(symbol, when) => Promise\"]\n    Callbacks[\"callbacks?: Partial<br/>IStrategyCallbacks>\"]\n    Risk[\"riskName?: string<br/>riskList?: string[]\"]\n    Note[\"note?: string<br/>(developer documentation)\"]\n    \n    Schema --> Name\n    Schema --> Interval\n    Schema --> GetSignal\n    Schema --> Callbacks\n    Schema --> Risk\n    Schema --> Note\n    \n    style Schema fill:#f9f9f9\n```\n\n**Sources:** [types.d.ts:726-751](), [src/interfaces/Strategy.interface.ts:128-151]()\n\n### Signal Data Transfer Object (ISignalDto)\n\nThe `getSignal` function returns an `ISignalDto` with the following structure:\n\n| Field | Type | Required | Description |\n|---|---|---|---|\n| `id` | string | Optional | Signal identifier (auto-generated if omitted) |\n| `position` | \"long\" \\| \"short\" | Required | Trade direction |\n| `priceOpen` | number | Optional | Entry price (if omitted, opens at current VWAP) |\n| `priceTakeProfit` | number | Required | Take profit exit price |\n| `priceStopLoss` | number | Required | Stop loss exit price |\n| `minuteEstimatedTime` | number | Required | Maximum signal lifetime in minutes |\n| `note` | string | Optional | Human-readable signal rationale |\n\n**Sources:** [types.d.ts:647-665](), [src/interfaces/Strategy.interface.ts:20-39]()\n\n## Complete Working Example\n\nBelow is a minimal but complete strategy that demonstrates all core concepts:\n\n### Basic Moving Average Crossover Strategy\n\n```typescript\nimport { addStrategy, getCandles, ISignalDto } from 'backtest-kit';\n\naddStrategy({\n  strategyName: 'ma-crossover-basic',\n  interval: '5m', // Check for signals every 5 minutes\n  note: 'Simple MA crossover with 20/50 periods',\n  \n  // Core signal generation logic\n  getSignal: async (symbol: string, when: Date): Promise<ISignalDto | null> => {\n    // Fetch historical candles (automatically scoped to 'when' timestamp)\n    const candles = await getCandles(symbol, \"1h\", 50);\n    \n    if (candles.length < 50) {\n      return null; // Insufficient data\n    }\n    \n    // Calculate moving averages\n    const closes = candles.map(c => c.close);\n    const ma20 = closes.slice(-20).reduce((a, b) => a + b, 0) / 20;\n    const ma50 = closes.slice(-50).reduce((a, b) => a + b, 0) / 50;\n    const prevMa20 = closes.slice(-21, -1).reduce((a, b) => a + b, 0) / 20;\n    const prevMa50 = closes.slice(-51, -1).reduce((a, b) => a + b, 0) / 50;\n    \n    const currentPrice = closes[closes.length - 1];\n    \n    // Bullish crossover: MA20 crosses above MA50\n    if (prevMa20 <= prevMa50 && ma20 > ma50) {\n      return {\n        position: 'long',\n        priceTakeProfit: currentPrice * 1.02, // 2% profit target\n        priceStopLoss: currentPrice * 0.99,   // 1% stop loss\n        minuteEstimatedTime: 240,             // 4 hours max\n        note: `MA20(${ma20.toFixed(2)}) > MA50(${ma50.toFixed(2)})`\n      };\n    }\n    \n    // Bearish crossover: MA20 crosses below MA50\n    if (prevMa20 >= prevMa50 && ma20 < ma50) {\n      return {\n        position: 'short',\n        priceTakeProfit: currentPrice * 0.98, // 2% profit target\n        priceStopLoss: currentPrice * 1.01,   // 1% stop loss\n        minuteEstimatedTime: 240,\n        note: `MA20(${ma20.toFixed(2)}) < MA50(${ma50.toFixed(2)})`\n      };\n    }\n    \n    return null; // No signal conditions met\n  },\n  \n  // Optional lifecycle callbacks\n  callbacks: {\n    onOpen: (symbol, signal, currentPrice, backtest) => {\n      console.log(`[${backtest ? 'BT' : 'LIVE'}] Signal opened:`, signal.id, signal.position);\n    },\n    onClose: (symbol, signal, priceClose, backtest) => {\n      console.log(`[${backtest ? 'BT' : 'LIVE'}] Signal closed:`, signal.id);\n    }\n  }\n});\n```\n\n**Sources:** [README.md:110-143](), [types.d.ts:726-751]()\n\n## Strategy Registration and Execution Flow\n\n### Registration via addStrategy()\n\n```mermaid\ngraph TD\n    User[\"Developer Code<br/>addStrategy(schema)\"]\n    Validate[\"StrategyValidationService<br/>Check for duplicate names\"]\n    Schema[\"StrategySchemaService<br/>Store in ToolRegistry\"]\n    \n    User --> Validate\n    Validate --> Schema\n    \n    subgraph \"Execution Phase (Later)\"\n        BT[\"Backtest.run(symbol, config)\"]\n        Method[\"MethodContextService.runAsyncIterator()<br/>Set strategyName context\"]\n        Conn[\"StrategyConnectionService<br/>getStrategy(symbol, strategyName)\"]\n        Client[\"ClientStrategy instance<br/>(memoized by symbol:strategyName)\"]\n        Tick[\"tick() / backtest() methods<br/>Execute strategy logic\"]\n        \n        BT --> Method\n        Method --> Conn\n        Conn --> Client\n        Client --> Tick\n    end\n    \n    Schema -.->|\"Retrieved during execution\"| Conn\n    \n    style User fill:#f9f9f9\n    style Schema fill:#f9f9f9\n    style Client fill:#f9f9f9\n```\n\n**Registration Process:**\n\n1. **Validation** - [src/lib/services/validation/StrategyValidationService.ts]() checks for duplicate strategy names\n2. **Storage** - [src/lib/services/schema/StrategySchemaService.ts]() stores schema in immutable `ToolRegistry`\n3. **Memoization** - [src/lib/services/connection/StrategyConnectionService.ts:120-151]() creates cached `ClientStrategy` instances per symbol-strategy pair\n4. **Execution** - [src/client/ClientStrategy.ts]() implements the `IStrategy` interface with `tick()` and `backtest()` methods\n\n**Sources:** [src/function/add.ts](), [src/lib/services/connection/StrategyConnectionService.ts:89-151]()\n\n### Code Entity Mapping: Strategy Execution Path\n\n```mermaid\ngraph TB\n    subgraph \"Public API Layer\"\n        addStrategy[\"addStrategy()<br/>src/function/add.ts\"]\n        Backtest[\"Backtest.run()<br/>src/classes/Backtest.ts\"]\n    end\n    \n    subgraph \"Service Layer\"\n        StrategySchema[\"StrategySchemaService<br/>src/lib/services/schema/\"]\n        StrategyValidation[\"StrategyValidationService<br/>src/lib/services/validation/\"]\n        StrategyConnection[\"StrategyConnectionService<br/>src/lib/services/connection/\"]\n        MethodContext[\"MethodContextService<br/>src/lib/services/context/\"]\n        ExecutionContext[\"ExecutionContextService<br/>src/lib/services/context/\"]\n    end\n    \n    subgraph \"Client Layer\"\n        ClientStrategy[\"ClientStrategy<br/>src/client/ClientStrategy.ts\"]\n        GET_SIGNAL_FN[\"GET_SIGNAL_FN<br/>lines 332-476\"]\n        VALIDATE_SIGNAL_FN[\"VALIDATE_SIGNAL_FN<br/>lines 45-330\"]\n    end\n    \n    subgraph \"User-Defined Logic\"\n        getSignal[\"getSignal(symbol, when)<br/>User implementation\"]\n        callbacks[\"IStrategyCallbacks<br/>onOpen, onClose, etc.\"]\n    end\n    \n    addStrategy --> StrategyValidation\n    StrategyValidation --> StrategySchema\n    \n    Backtest --> MethodContext\n    MethodContext --> StrategyConnection\n    StrategyConnection --> ClientStrategy\n    \n    ClientStrategy --> ExecutionContext\n    ClientStrategy --> GET_SIGNAL_FN\n    GET_SIGNAL_FN --> getSignal\n    getSignal --> VALIDATE_SIGNAL_FN\n    VALIDATE_SIGNAL_FN --> callbacks\n    \n    style getSignal fill:#ffffcc\n    style callbacks fill:#ffffcc\n    style ClientStrategy fill:#f9f9f9\n```\n\n**Key Code Entities:**\n\n| Code Entity | File Path | Role |\n|---|---|---|\n| `addStrategy()` | src/function/add.ts | Public API for strategy registration |\n| `StrategySchemaService` | src/lib/services/schema/ | Stores strategy schemas in ToolRegistry |\n| `StrategyConnectionService` | src/lib/services/connection/ | Memoizes and routes to ClientStrategy instances |\n| `ClientStrategy` | src/client/ClientStrategy.ts | Core strategy execution logic |\n| `GET_SIGNAL_FN` | src/client/ClientStrategy.ts:332-476 | Wrapper calling user's getSignal with throttling |\n| `VALIDATE_SIGNAL_FN` | src/client/ClientStrategy.ts:45-330 | Multi-stage signal validation (TP/SL, prices, lifetime) |\n| `IStrategySchema.getSignal` | User code | Developer-implemented signal generation logic |\n\n**Sources:** [src/function/add.ts](), [src/client/ClientStrategy.ts:1-1400](), [src/lib/services/connection/StrategyConnectionService.ts:89-151]()\n\n## Strategy Execution: tick() vs backtest()\n\n`ClientStrategy` implements two execution methods with different performance characteristics:\n\n### tick() Method - Live Trading & Step-by-Step Backtest\n\n```mermaid\ngraph TD\n    Start[\"tick(symbol, strategyName)\"]\n    Throttle[\"Interval Throttling Check<br/>Last signal + interval < now?\"]\n    GetSignal[\"GET_SIGNAL_FN<br/>Call user's getSignal()\"]\n    Timeout[\"Timeout Check<br/>CC_MAX_SIGNAL_GENERATION_SECONDS\"]\n    Validate[\"VALIDATE_SIGNAL_FN<br/>Price logic, TP/SL, lifetime\"]\n    Risk[\"Risk.checkSignal()<br/>Portfolio limits\"]\n    Active[\"Active Signal?\"]\n    Monitor[\"Monitor TP/SL/time_expired<br/>Check current VWAP\"]\n    Return[\"Return IStrategyTickResult<br/>idle, opened, active, closed\"]\n    \n    Start --> Active\n    Active -->|No| Throttle\n    Active -->|Yes| Monitor\n    Throttle -->|Too soon| Return\n    Throttle -->|OK| GetSignal\n    GetSignal --> Timeout\n    Timeout -->|Success| Validate\n    Timeout -->|Timeout| Return\n    Validate --> Risk\n    Risk --> Return\n    Monitor --> Return\n    \n    style Start fill:#f9f9f9\n    style Return fill:#f9f9f9\n```\n\n**Used by:** Live.run(), Backtest.run() (minute-by-minute iteration)\n\n**Sources:** [src/client/ClientStrategy.ts:1001-1253]()\n\n### backtest() Method - Fast Historical Processing\n\n```mermaid\ngraph TD\n    Start[\"backtest(symbol, strategyName, candles)\"]\n    Signal[\"Signal from getSignal()\"]\n    Scheduled{Is Scheduled Signal?}\n    ActivateLoop[\"Loop through candles<br/>Check priceOpen reached\"]\n    TPSLLoop[\"Loop through remaining candles<br/>Check TP/SL hit\"]\n    VWAP[\"Calculate VWAP per candle<br/>GET_AVG_PRICE_FN\"]\n    Close[\"Signal closes<br/>Return IStrategyBacktestResult\"]\n    \n    Start --> Signal\n    Signal --> Scheduled\n    Scheduled -->|Yes| ActivateLoop\n    Scheduled -->|No| TPSLLoop\n    ActivateLoop -->|Activated| TPSLLoop\n    ActivateLoop -->|Cancelled| Close\n    TPSLLoop --> VWAP\n    VWAP --> Close\n    \n    style Start fill:#f9f9f9\n    style Close fill:#f9f9f9\n```\n\n**Used by:** Backtest.run() (after signal opens, fast-forward through candles)\n\n**Performance:** Skips timeframes during active signal monitoring, processes only until signal closes\n\n**Sources:** [src/client/ClientStrategy.ts:1255-1400](), [src/client/ClientStrategy.ts:478-489]()\n\n## Signal Validation: VALIDATE_SIGNAL_FN\n\nThe framework performs comprehensive validation on all signals before they activate. This prevents invalid signals from entering the system and ensures trading logic integrity.\n\n### Validation Pipeline\n\n| Validation Stage | Checks | Config Parameters |\n|---|---|---|\n| **Schema Validation** | Required fields present, correct types | N/A |\n| **Price Positivity** | All prices > 0, finite, not NaN/Infinity | N/A |\n| **TP/SL Logic** | LONG: TP>open>SL, SHORT: SL>open>TP | N/A |\n| **Immediate Closure Prevention** | Current price not already at TP/SL | N/A |\n| **TP Distance** | TP far enough to cover fees + slippage | `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` |\n| **SL Distance (min)** | SL not too close (avoid instant stop-out) | `CC_MIN_STOPLOSS_DISTANCE_PERCENT` |\n| **SL Distance (max)** | SL not too far (protect capital) | `CC_MAX_STOPLOSS_DISTANCE_PERCENT` |\n| **Lifetime Limit** | Signal lifetime ≤ max configured minutes | `CC_MAX_SIGNAL_LIFETIME_MINUTES` |\n\n**Default Configuration:**\n- `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT`: 0.2% (covers 0.1% fee + 0.1% slippage)\n- `CC_MAX_SIGNAL_LIFETIME_MINUTES`: 10080 (7 days)\n\n**Sources:** [src/client/ClientStrategy.ts:45-330](), [src/config/params.ts]()\n\n### Validation Error Examples\n\n```typescript\n// Invalid: Take profit too close (won't cover trading costs)\n{\n  position: 'long',\n  priceOpen: 50000,\n  priceTakeProfit: 50050,  // Only 0.1% distance - REJECTED\n  priceStopLoss: 49900,\n  minuteEstimatedTime: 120\n}\n// Error: \"Long: TakeProfit too close to priceOpen (0.100%). Minimum distance: 0.200%\"\n\n// Invalid: Immediate closure scenario\n{\n  position: 'long',\n  priceOpen: 50000,\n  priceTakeProfit: 51000,\n  priceStopLoss: 50100,    // Current price at 50100 - REJECTED\n  minuteEstimatedTime: 120\n}\n// Error: \"Long immediate: currentPrice (50100) <= priceOpen (50000). Signal would be immediately closed\"\n\n// Invalid: Excessive lifetime\n{\n  position: 'long',\n  priceOpen: 50000,\n  priceTakeProfit: 51000,\n  priceStopLoss: 49000,\n  minuteEstimatedTime: 20160  // 14 days - REJECTED\n}\n// Error: \"minuteEstimatedTime too large (20160 minutes = 14.0 days). Maximum: 10080 minutes (7 days)\"\n```\n\n**Sources:** [src/client/ClientStrategy.ts:163-199]()\n\n## Scheduled Signals: Delayed Entry\n\nStrategies can create **scheduled signals** by specifying `priceOpen` in the returned `ISignalDto`. Scheduled signals wait for the market price to reach the entry point before activating.\n\n### Scheduled Signal Lifecycle\n\n```mermaid\nstateDiagram-v2\n    [*] --> getSignal: \"Throttle OK\"\n    getSignal --> Validation: \"Returns ISignalDto<br/>with priceOpen\"\n    Validation --> Scheduled: \"Price not at priceOpen yet\"\n    Validation --> Opened: \"Price already at priceOpen<br/>(immediate activation)\"\n    \n    Scheduled --> Monitoring: \"Wait for activation\"\n    Monitoring --> CheckSL: \"Every tick\"\n    CheckSL --> Cancelled: \"SL hit before entry<br/>(scheduled signal cancelled)\"\n    CheckSL --> CheckPrice: \"SL not hit\"\n    CheckPrice --> Cancelled: \"Timeout<br/>(CC_SCHEDULE_AWAIT_MINUTES)\"\n    CheckPrice --> Opened: \"priceOpen reached<br/>(activate signal)\"\n    \n    Opened --> Active: \"Persist to storage<br/>Begin TP/SL monitoring\"\n    Active --> Closed: \"TP/SL/time_expired\"\n    Cancelled --> [*]: \"No PNL\"\n    Closed --> [*]: \"Calculate PNL\"\n    \n    note right of Scheduled\n        Scheduled signals NOT persisted\n        Only active signals saved to storage\n    end note\n    \n    note right of CheckSL\n        CRITICAL: Check SL BEFORE priceOpen\n        Prevents \"activate then immediately stop\"\n    end note\n```\n\n**Key Differences from Immediate Signals:**\n\n| Aspect | Immediate Signal | Scheduled Signal |\n|---|---|---|\n| `priceOpen` field | Omitted or = current VWAP | Explicitly set to target entry price |\n| Persistence | Saved immediately on creation | NOT saved until activation |\n| Cancellation | Cannot cancel (only close via TP/SL/time) | Can cancel before activation |\n| Risk check timing | At creation | At activation (after priceOpen reached) |\n| Timeout | `minuteEstimatedTime` starts at open | `CC_SCHEDULE_AWAIT_MINUTES` before activation |\n\n**Sources:** [src/client/ClientStrategy.ts:389-443](), [src/client/ClientStrategy.ts:554-608]()\n\n### Scheduled Signal Example\n\n```typescript\naddStrategy({\n  strategyName: 'limit-entry-strategy',\n  interval: '5m',\n  \n  getSignal: async (symbol: string, when: Date) => {\n    const candles = await getCandles(symbol, \"1h\", 24);\n    const currentPrice = candles[candles.length - 1].close;\n    \n    // Look for support level bounce\n    const support = Math.min(...candles.slice(-10).map(c => c.low));\n    \n    if (currentPrice > support * 1.02) { // Price above support\n      return {\n        position: 'long',\n        priceOpen: support * 1.005,  // SCHEDULED: Wait for price to drop to support\n        priceTakeProfit: support * 1.03,\n        priceStopLoss: support * 0.995,\n        minuteEstimatedTime: 180,\n        note: `Limit buy at support ${support.toFixed(2)}`\n      };\n    }\n    \n    return null;\n  }\n});\n```\n\n**Monitoring Logic:** [src/client/ClientStrategy.ts:610-644]() checks SL **before** priceOpen to prevent \"activate-and-immediately-cancel\" scenarios.\n\n**Sources:** [types.d.ts:693-697](), [src/client/ClientStrategy.ts:681-774]()\n\n## Best Practices\n\n### 1. Leverage Temporal Context\n\nThe framework automatically provides temporal context via `ExecutionContextService`. The `when` parameter in `getSignal()` represents the current execution time, and `getCandles()` returns data **up to** that timestamp.\n\n**Correct:**\n```typescript\ngetSignal: async (symbol: string, when: Date) => {\n  // getCandles automatically scoped to 'when' - no look-ahead bias possible\n  const candles = await getCandles(symbol, \"1h\", 100);\n  // candles[candles.length - 1].timestamp <= when.getTime()\n}\n```\n\n**Incorrect (but prevented by framework):**\n```typescript\ngetSignal: async (symbol: string, when: Date) => {\n  // This would be dangerous in other frameworks - but here it's safe!\n  // getCandles CANNOT return future data relative to 'when'\n  const candles = await getCandles(symbol, \"1h\", 100);\n  // Framework guarantees no look-ahead bias\n}\n```\n\n**Sources:** [README.md:186-199](), [src/lib/services/context/ExecutionContextService.ts]()\n\n### 2. Choose Appropriate Interval Throttling\n\nThe `interval` parameter determines minimum time between `getSignal()` calls. Choose based on strategy computation cost and market data requirements:\n\n| Strategy Type | Recommended Interval | Reason |\n|---|---|---|\n| Simple indicators (MA, RSI) | 1m - 5m | Fast computation, frequent updates useful |\n| Complex ML models | 15m - 1h | Expensive computation, less frequent checks acceptable |\n| News/sentiment analysis | 5m - 30m | API rate limits, data freshness |\n| High-frequency patterns | 1m | Need rapid signal generation |\n\n**Sources:** [types.d.ts:642-646](), [src/client/ClientStrategy.ts:340-353]()\n\n### 3. Handle Insufficient Data Gracefully\n\nAlways check for sufficient candle history before calculations:\n\n```typescript\ngetSignal: async (symbol: string, when: Date) => {\n  const candles = await getCandles(symbol, \"1h\", 100);\n  \n  if (candles.length < 100) {\n    return null; // Not enough data - skip this tick\n  }\n  \n  // Safe to proceed with calculations\n}\n```\n\n**Sources:** [demo/backtest/src/strategy.mjs](), [README.md:123-127]()\n\n### 4. Use Lifecycle Callbacks for Monitoring\n\nCallbacks provide observability into strategy execution without cluttering signal logic:\n\n```typescript\naddStrategy({\n  strategyName: 'monitored-strategy',\n  interval: '5m',\n  getSignal: async (symbol, when) => { /* ... */ },\n  \n  callbacks: {\n    onOpen: (symbol, signal, currentPrice, backtest) => {\n      // Log to monitoring service\n      logger.info('Signal opened', { signal: signal.id, price: currentPrice });\n    },\n    \n    onActive: (symbol, signal, currentPrice, backtest) => {\n      // Track unrealized PNL\n      const pnl = calculateUnrealizedPnl(signal, currentPrice);\n      metrics.gauge('unrealized_pnl', pnl);\n    },\n    \n    onClose: (symbol, signal, priceClose, backtest) => {\n      // Log final outcome\n      logger.info('Signal closed', { signal: signal.id, closePrice: priceClose });\n    },\n    \n    onPartialProfit: (symbol, signal, currentPrice, revenuePercent, backtest) => {\n      // Alert on milestone\n      if (revenuePercent >= 10) {\n        alerts.send(`Signal ${signal.id} reached ${revenuePercent}% profit`);\n      }\n    }\n  }\n});\n```\n\nAvailable callbacks: `onTick`, `onOpen`, `onActive`, `onIdle`, `onClose`, `onSchedule`, `onCancel`, `onPartialProfit`, `onPartialLoss`, `onWrite`\n\n**Sources:** [types.d.ts:698-726](), [src/interfaces/Strategy.interface.ts:96-126]()\n\n### 5. Integrate Risk Management\n\nBind risk profiles to strategies for portfolio-level controls:\n\n```typescript\n// Define risk profile (see Risk Management page)\naddRisk({\n  riskName: 'conservative',\n  validations: [\n    ({ activePositionCount }) => {\n      if (activePositionCount >= 3) throw new Error('Max 3 concurrent positions');\n    }\n  ]\n});\n\n// Bind to strategy\naddStrategy({\n  strategyName: 'my-strategy',\n  interval: '5m',\n  riskName: 'conservative',  // Single risk profile\n  // OR\n  riskList: ['conservative', 'size-limits'],  // Multiple profiles\n  getSignal: async (symbol, when) => { /* ... */ }\n});\n```\n\n**Sources:** [types.d.ts:743-750](), [src/lib/services/connection/StrategyConnectionService.ts:33-67]()\n\n### 6. Test with Walker Mode\n\nUse Walker mode to compare multiple strategy variants before live deployment:\n\n```typescript\n// Register strategy variants\naddStrategy({ strategyName: 'ma-20-50', /* ... */ });\naddStrategy({ strategyName: 'ma-50-200', /* ... */ });\naddStrategy({ strategyName: 'ma-10-30', /* ... */ });\n\n// Compare them\naddWalker({\n  walkerName: 'ma-comparison',\n  exchangeName: 'binance',\n  frameName: '1-month-backtest',\n  strategies: ['ma-20-50', 'ma-50-200', 'ma-10-30'],\n  metric: 'sharpeRatio'\n});\n\nawait Walker.run('BTCUSDT', { walkerName: 'ma-comparison' });\n// Returns ranked results by Sharpe ratio\n```\n\n**Sources:** [README.md](), [Walker section in page 5.3](#5.3)\n\n---\n\n**Related Pages:**\n- [Signal Lifecycle](#3.1) - Detailed signal state machine and transitions\n- [Risk Management](#7) - Portfolio limits and validation rules\n- [Multi-Timeframe Analysis](#6.4) - Using multiple timeframes in strategies\n- [getCandles API](#12.1) - Data fetching reference"
                    },
                    {
                        "page_plan": {
                            "id": "6.1",
                            "title": "Strategy Schema Definition"
                        },
                        "content": "# Strategy Schema Definition\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [docs/classes/StrategyConnectionService.md](docs/classes/StrategyConnectionService.md)\n- [docs/index.md](docs/index.md)\n- [docs/interfaces/IStrategy.md](docs/interfaces/IStrategy.md)\n- [docs/interfaces/IStrategySchema.md](docs/interfaces/IStrategySchema.md)\n- [docs/types/IStrategyBacktestResult.md](docs/types/IStrategyBacktestResult.md)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis page documents the `IStrategySchema` interface, which defines the complete configuration for a trading strategy in Backtest Kit. The schema specifies signal generation logic, execution intervals, lifecycle callbacks, and risk management integration.\n\nFor information about implementing the `getSignal` function and signal generation patterns, see [Signal Generation (getSignal)](#6.2). For details about callback implementations and event handling, see [Strategy Callbacks](#6.3). For multi-timeframe analysis patterns within strategies, see [Multi-Timeframe Analysis](#6.4).\n\n---\n\n## Overview\n\nThe `IStrategySchema` interface serves as the registration contract for trading strategies. When you call `addStrategy()`, you provide an object conforming to this schema, which is validated and stored in `StrategySchemaService`. The framework uses this schema to instantiate `ClientStrategy` objects that execute your trading logic.\n\n**Sources:** [types.d.ts:724-747](), [src/index.ts:11-18]()\n\n---\n\n## Core Schema Structure\n\nThe strategy schema consists of seven primary properties:\n\n| Property | Type | Required | Description |\n|----------|------|----------|-------------|\n| `strategyName` | `string` | Yes | Unique identifier for the strategy |\n| `note` | `string` | No | Developer documentation/comments |\n| `interval` | `SignalInterval` | Yes | Minimum time between `getSignal` calls |\n| `getSignal` | `function` | Yes | Signal generation function |\n| `callbacks` | `Partial<IStrategyCallbacks>` | No | Lifecycle event handlers |\n| `riskName` | `string` | No | Single risk profile identifier |\n| `riskList` | `string[]` | No | Multiple risk profile identifiers |\n\n**Sources:** [types.d.ts:724-747]()\n\n### Strategy Schema Component Relationships\n\n```mermaid\ngraph TB\n    subgraph \"IStrategySchema Definition\"\n        Schema[\"IStrategySchema\"]\n        Schema --> StrategyName[\"strategyName: string<br/>(required, unique)\"]\n        Schema --> Note[\"note?: string<br/>(optional documentation)\"]\n        Schema --> Interval[\"interval: SignalInterval<br/>(required throttling)\"]\n        Schema --> GetSignal[\"getSignal: function<br/>(required logic)\"]\n        Schema --> Callbacks[\"callbacks?: Partial&lt;IStrategyCallbacks&gt;<br/>(optional event handlers)\"]\n        Schema --> RiskName[\"riskName?: string<br/>(optional single risk profile)\"]\n        Schema --> RiskList[\"riskList?: string[]<br/>(optional multiple risk profiles)\"]\n    end\n    \n    subgraph \"Registration Flow\"\n        AddStrategy[\"addStrategy(schema)\"]\n        Validate[\"StrategyValidationService.validateStrategySchema()\"]\n        Store[\"StrategySchemaService.setStrategy()\"]\n        Registry[\"ToolRegistry&lt;IStrategySchema&gt;\"]\n    end\n    \n    subgraph \"Runtime Usage\"\n        Connection[\"StrategyConnectionService\"]\n        ClientStrat[\"ClientStrategy instance\"]\n        Core[\"StrategyCoreService\"]\n    end\n    \n    Schema --> AddStrategy\n    AddStrategy --> Validate\n    Validate --> Store\n    Store --> Registry\n    \n    Registry -.->|retrieves schema| Connection\n    Connection -->|instantiates| ClientStrat\n    Core -->|orchestrates| Connection\n    \n    GetSignal -.->|implemented in| ClientStrat\n    Callbacks -.->|invoked by| ClientStrat\n    RiskName -.->|passed to| ClientStrat\n    RiskList -.->|passed to| ClientStrat\n```\n\n**Sources:** [types.d.ts:724-747](), [src/function/add.ts:1-100](), [docs/classes/StrategyConnectionService.md:1-145]()\n\n---\n\n## Strategy Name and Documentation\n\n### strategyName\n\nThe `strategyName` property is a unique string identifier for your strategy. This name is used throughout the system to reference the strategy in backtest runs, live trading, walker comparisons, and reporting.\n\n**Type:** `string` (alias `StrategyName`)  \n**Required:** Yes  \n**Uniqueness:** Must be unique across all registered strategies\n\n**Validation:** The `StrategyValidationService` checks for duplicate strategy names during registration.\n\n**Sources:** [types.d.ts:730](), [types.d.ts:896]()\n\n### note\n\nThe `note` property provides optional documentation for developers. This string is not used by the framework runtime but appears in generated documentation and strategy listings.\n\n**Type:** `string`  \n**Required:** No  \n**Purpose:** Human-readable description, implementation notes, version tracking\n\n**Sources:** [types.d.ts:732]()\n\n---\n\n## Signal Interval and Throttling\n\nThe `interval` property defines the minimum time between consecutive `getSignal` invocations. This prevents signal spam and ensures your strategy logic runs at a predictable cadence.\n\n**Type:** `SignalInterval = \"1m\" | \"3m\" | \"5m\" | \"15m\" | \"30m\" | \"1h\"`  \n**Required:** Yes  \n**Purpose:** Throttling, rate limiting, execution timing\n\n### How Throttling Works\n\nWhen `ClientStrategy.tick()` is called repeatedly (in live mode), the framework tracks the timestamp of the last `getSignal` invocation. If the current time is within the interval window, `getSignal` is **not called**, and the strategy continues monitoring any active signal. Only when the interval has elapsed will `getSignal` be invoked again.\n\n### Interval Selection Guidelines\n\n| Interval | Use Case | Typical Strategy Type |\n|----------|----------|----------------------|\n| `\"1m\"` | High-frequency scalping | Very short-term momentum |\n| `\"5m\"` | Active intraday trading | Short-term breakouts |\n| `\"15m\"` | Standard intraday | Swing detection |\n| `\"30m\"` | Longer intraday | Trend following |\n| `\"1h\"` | Position trading | Multi-hour analysis |\n\n**Important:** The interval does NOT affect how often the framework calls `tick()` in live mode. It only controls when `getSignal` is re-evaluated. The framework calls `tick()` approximately every `TICK_TTL` (1 minute + 1ms by default).\n\n**Sources:** [types.d.ts:645](), [types.d.ts:734]()\n\n### Throttling Implementation Flow\n\n```mermaid\ngraph TB\n    Tick[\"ClientStrategy.tick()\"]\n    CheckActive{\"Active signal<br/>exists?\"}\n    CheckInterval{\"Interval<br/>elapsed?\"}\n    CallGetSignal[\"Call getSignal()\"]\n    MonitorSignal[\"Monitor TP/SL/Time\"]\n    ReturnActive[\"Return active result\"]\n    ReturnIdle[\"Return idle result\"]\n    \n    Tick --> CheckActive\n    CheckActive -->|Yes| MonitorSignal\n    CheckActive -->|No| CheckInterval\n    CheckInterval -->|Yes| CallGetSignal\n    CheckInterval -->|No| ReturnIdle\n    MonitorSignal --> ReturnActive\n    CallGetSignal --> MonitorSignal\n    \n    Note1[\"Interval check compares<br/>current time vs last getSignal<br/>invocation timestamp\"]\n    CheckInterval -.-> Note1\n```\n\n**Sources:** [types.d.ts:645](), [types.d.ts:734]()\n\n---\n\n## The getSignal Function\n\nThe `getSignal` function is the core of your strategy logic. It receives market context (symbol and timestamp) and returns either a signal to execute or `null` if no opportunity exists.\n\n### Function Signature\n\n```typescript\ngetSignal: (symbol: string, when: Date) => Promise<ISignalDto | null>\n```\n\n**Parameters:**\n- `symbol`: Trading pair (e.g., `\"BTCUSDT\"`)\n- `when`: Current timestamp from execution context\n\n**Returns:**\n- `ISignalDto` object: A valid signal to execute\n- `null`: No signal at this time\n\n**Sources:** [types.d.ts:740]()\n\n### ISignalDto Structure\n\nThe returned signal must conform to `ISignalDto`:\n\n| Property | Type | Required | Description |\n|----------|------|----------|-------------|\n| `id` | `string` | No | Signal ID (auto-generated if omitted) |\n| `position` | `\"long\" \\| \"short\"` | Yes | Trade direction |\n| `note` | `string` | No | Human-readable reason |\n| `priceOpen` | `number` | No | Entry price (omit for immediate entry) |\n| `priceTakeProfit` | `number` | Yes | Take profit target |\n| `priceStopLoss` | `number` | Yes | Stop loss exit |\n| `minuteEstimatedTime` | `number` | Yes | Max lifetime in minutes |\n\n**Sources:** [types.d.ts:647-665]()\n\n### Signal Return Semantics\n\n#### Immediate Entry (priceOpen omitted)\n\nWhen `priceOpen` is **not provided**, the signal opens immediately at the current VWAP price. The framework:\n\n1. Validates the signal structure and TP/SL logic\n2. Runs risk checks\n3. If approved, creates an `ISignalRow` with `priceOpen = currentPrice`\n4. Persists the signal\n5. Returns `IStrategyTickResultOpened`\n\n#### Scheduled Entry (priceOpen provided)\n\nWhen `priceOpen` **is provided**, the signal becomes scheduled. The framework:\n\n1. Validates the signal structure and TP/SL logic\n2. Checks if `priceOpen` is reachable (not already past SL)\n3. Returns `IStrategyTickResultScheduled`\n4. On subsequent ticks, monitors if price reaches `priceOpen` **before** SL\n5. If activated: converts to pending signal, persists, returns `IStrategyTickResultOpened`\n6. If SL hit first or timeout: returns `IStrategyTickResultCancelled`\n\n**Critical:** Scheduled signals are **not persisted** until activation. If the system crashes, scheduled signals are lost. Only opened signals persist.\n\n**Sources:** [types.d.ts:740](), [types.d.ts:647-665]()\n\n### Signal Generation Decision Tree\n\n```mermaid\ngraph TB\n    GetSignal[\"getSignal(symbol, when)\"]\n    CheckMarket{\"Analyze market<br/>conditions\"}\n    ReturnNull[\"return null\"]\n    CreateDto[\"Create ISignalDto\"]\n    SetPriceOpen{\"Include<br/>priceOpen?\"}\n    ImmediateEntry[\"Immediate Entry<br/>priceOpen = undefined\"]\n    ScheduledEntry[\"Scheduled Entry<br/>priceOpen = specific price\"]\n    \n    Validation[\"Multi-stage validation<br/>TP/SL logic, distances,<br/>GLOBAL_CONFIG checks\"]\n    RiskCheck[\"Risk validation<br/>portfolio limits,<br/>custom rules\"]\n    \n    OpenImmediate[\"IStrategyTickResultOpened<br/>signal persisted\"]\n    CreateScheduled[\"IStrategyTickResultScheduled<br/>NOT persisted, monitored\"]\n    \n    GetSignal --> CheckMarket\n    CheckMarket -->|\"No opportunity\"| ReturnNull\n    CheckMarket -->|\"Opportunity found\"| CreateDto\n    CreateDto --> SetPriceOpen\n    SetPriceOpen -->|No| ImmediateEntry\n    SetPriceOpen -->|Yes| ScheduledEntry\n    \n    ImmediateEntry --> Validation\n    ScheduledEntry --> Validation\n    \n    Validation --> RiskCheck\n    RiskCheck -->|Immediate| OpenImmediate\n    RiskCheck -->|Scheduled| CreateScheduled\n```\n\n**Sources:** [types.d.ts:740](), [types.d.ts:647-665]()\n\n---\n\n## Signal Validation Requirements\n\nBefore a signal is accepted, the framework performs multiple validation stages. Your `getSignal` function must return signals that satisfy these constraints:\n\n### Price Validation\n\n1. All prices must be positive, finite numbers (not NaN, not Infinity)\n2. **LONG signals:**\n   - `priceTakeProfit > priceOpen > priceStopLoss`\n3. **SHORT signals:**\n   - `priceStopLoss > priceOpen > priceTakeProfit`\n\n### Distance Validation (GLOBAL_CONFIG)\n\n- **Take Profit Distance:** Must be at least `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` (default 0.2%) to cover fees (0.1%) + slippage (0.1%)\n- **Stop Loss Distance:** Must not exceed `CC_MAX_STOPLOSS_DISTANCE_PERCENT` (default 50%)\n\n### Lifetime Validation\n\n- `minuteEstimatedTime` must be ≤ `CC_MAX_SIGNAL_LIFETIME_MINUTES` (default 10080 = 1 week)\n\n### Scheduled Signal Specific\n\nFor signals with `priceOpen`:\n- `priceOpen` must be reachable (not already past SL threshold)\n- Scheduled signals that don't activate within `CC_SCHEDULE_AWAIT_MINUTES` (default 120) are auto-cancelled\n\n**Sources:** [types.d.ts:647-665]()\n\n---\n\n## Strategy Callbacks\n\nThe `callbacks` property allows you to register event handlers that are invoked during the signal lifecycle. All callbacks are optional.\n\n**Type:** `Partial<IStrategyCallbacks>`  \n**Required:** No\n\n### Available Callbacks\n\n| Callback | When Invoked | Parameters |\n|----------|--------------|------------|\n| `onTick` | Every tick | `symbol, result, backtest` |\n| `onOpen` | Signal opens | `symbol, data, currentPrice, backtest` |\n| `onActive` | Signal monitored | `symbol, data, currentPrice, backtest` |\n| `onIdle` | No active signal | `symbol, currentPrice, backtest` |\n| `onClose` | Signal closes | `symbol, data, priceClose, backtest` |\n| `onSchedule` | Scheduled signal created | `symbol, data, currentPrice, backtest` |\n| `onCancel` | Scheduled signal cancelled | `symbol, data, currentPrice, backtest` |\n| `onWrite` | Signal persisted | `symbol, data, backtest` |\n| `onPartialProfit` | Profit milestone hit | `symbol, data, currentPrice, revenuePercent, backtest` |\n| `onPartialLoss` | Loss milestone hit | `symbol, data, currentPrice, lossPercent, backtest` |\n\n**Sources:** [types.d.ts:699-723]()\n\n### Callback Lifecycle Flow\n\n```mermaid\nstateDiagram-v2\n    [*] --> Idle: No active signal\n    \n    Idle --> onTick_idle: \"tick() called\"\n    onTick_idle --> onIdle: \"Emit idle state\"\n    onIdle --> CheckGetSignal: \"Interval elapsed?\"\n    \n    CheckGetSignal --> onTick_idle: \"No signal\"\n    CheckGetSignal --> Scheduled: \"Signal with priceOpen\"\n    CheckGetSignal --> Opened: \"Signal without priceOpen\"\n    \n    Scheduled --> onSchedule: \"Emit scheduled\"\n    onSchedule --> onTick_scheduled: \"Monitor activation\"\n    onTick_scheduled --> Opened: \"Price reaches priceOpen\"\n    onTick_scheduled --> Cancelled: \"SL hit or timeout\"\n    \n    Opened --> onOpen: \"Emit open\"\n    onOpen --> onWrite: \"Persist signal\"\n    onWrite --> Active: \"Begin monitoring\"\n    \n    Active --> onTick_active: \"tick() called\"\n    onTick_active --> onActive: \"Emit active\"\n    onActive --> onPartialProfit: \"Profit milestone\"\n    onActive --> onPartialLoss: \"Loss milestone\"\n    onActive --> Closed: \"TP/SL/time_expired\"\n    \n    onPartialProfit --> Active: \"Continue\"\n    onPartialLoss --> Active: \"Continue\"\n    \n    Closed --> onClose: \"Emit close\"\n    onClose --> onWrite_delete: \"Delete persisted signal\"\n    onWrite_delete --> [*]\n    \n    Cancelled --> onCancel: \"Emit cancel\"\n    onCancel --> [*]\n```\n\n**Sources:** [types.d.ts:699-723]()\n\n### Callback Use Cases\n\n- **onTick:** Debug logging, custom monitoring, external API updates\n- **onOpen:** Notification systems, database logging, order submission (live mode)\n- **onActive:** Real-time dashboards, progress tracking\n- **onClose:** PNL reporting, strategy analysis, cleanup\n- **onSchedule/onCancel:** Pending order tracking, limit order monitoring\n- **onPartialProfit/onPartialLoss:** Risk adjustment, partial profit taking alerts\n\n**Sources:** [types.d.ts:699-723]()\n\n---\n\n## Risk Management Integration\n\nStrategies can optionally integrate with the risk management system by specifying one or more risk profiles. Risk checks are performed **before** a signal is accepted.\n\n### Single Risk Profile (riskName)\n\nSpecify a single risk profile identifier:\n\n```typescript\n{\n  strategyName: \"my-strategy\",\n  riskName: \"conservative\",\n  // ...\n}\n```\n\nThe framework instantiates `ClientRisk` with the specified profile and calls `checkSignal()` before opening positions.\n\n**Sources:** [types.d.ts:744]()\n\n### Multiple Risk Profiles (riskList)\n\nSpecify multiple risk profiles that must **all** approve:\n\n```typescript\n{\n  strategyName: \"my-strategy\",\n  riskList: [\"portfolio-limit\", \"time-window\", \"correlation-check\"],\n  // ...\n}\n```\n\nThe framework instantiates `MergeRisk` which aggregates validations from all profiles. A signal is rejected if **any** profile rejects it.\n\n**Sources:** [types.d.ts:746]()\n\n### Risk Check Flow\n\n```mermaid\ngraph TB\n    Signal[\"getSignal() returns<br/>ISignalDto\"]\n    Validation[\"Signal validation<br/>(TP/SL logic, distances)\"]\n    CheckRisk{\"Risk profile<br/>configured?\"}\n    NoRisk[\"No risk checks\"]\n    RiskCheck[\"ClientRisk.checkSignal()<br/>or MergeRisk.checkSignal()\"]\n    Approved{\"All validations<br/>pass?\"}\n    OpenSignal[\"Open signal<br/>IStrategyTickResultOpened\"]\n    Reject[\"Reject signal<br/>Emit riskSubject\"]\n    \n    Signal --> Validation\n    Validation --> CheckRisk\n    CheckRisk -->|No riskName/riskList| NoRisk\n    CheckRisk -->|Yes| RiskCheck\n    NoRisk --> OpenSignal\n    RiskCheck --> Approved\n    Approved -->|Yes| OpenSignal\n    Approved -->|No| Reject\n    \n    Note1[\"Risk validations receive<br/>IRiskValidationPayload:<br/>- pendingSignal<br/>- currentPrice<br/>- activePositionCount<br/>- activePositions[]\"]\n    RiskCheck -.-> Note1\n```\n\n**Sources:** [types.d.ts:744-746](), [types.d.ts:413-426]()\n\n### Risk vs No Risk\n\n| Aspect | With Risk Profile | Without Risk Profile |\n|--------|-------------------|---------------------|\n| Validation | Custom portfolio rules apply | Only GLOBAL_CONFIG checks |\n| Rejection | Can be rejected by risk logic | Only rejected by invalid TP/SL |\n| Position Tracking | Tracked in `RiskGlobalService` | Not tracked |\n| Event Emission | Emits to `riskSubject` on rejection | No risk events |\n| Use Case | Complex multi-strategy portfolios | Simple single-strategy systems |\n\n**Sources:** [types.d.ts:744-746]()\n\n---\n\n## Registration and Usage\n\n### Registration via addStrategy()\n\nStrategies are registered using the global `addStrategy()` function:\n\n```typescript\nimport { addStrategy } from \"backtest-kit\";\n\naddStrategy({\n  strategyName: \"momentum-breakout\",\n  note: \"Detects momentum breakouts on 5m timeframe\",\n  interval: \"5m\",\n  getSignal: async (symbol, when) => {\n    // Your logic here\n    return null; // or ISignalDto\n  },\n  callbacks: {\n    onOpen: (symbol, data, currentPrice, backtest) => {\n      console.log(`Signal opened: ${data.id}`);\n    },\n  },\n  riskName: \"conservative\",\n});\n```\n\n**Sources:** [README.md:66-142](), [src/index.ts:11-18]()\n\n### Internal Storage and Retrieval\n\n1. `addStrategy()` delegates to `StrategySchemaService.setStrategy()`\n2. Schema is stored in `ToolRegistry<IStrategySchema>` with `strategyName` as key\n3. `StrategyValidationService.validateStrategySchema()` checks for duplicates\n4. During execution, `StrategyConnectionService` retrieves schemas and instantiates `ClientStrategy` objects\n5. `ClientStrategy` uses the schema's `getSignal` function and callbacks\n\n**Sources:** [src/function/add.ts:1-100](), [docs/classes/StrategyConnectionService.md:1-145]()\n\n### Runtime Instantiation\n\n```mermaid\ngraph TB\n    subgraph \"Registration Time\"\n        AddStrategy[\"addStrategy(schema)\"]\n        SchemaService[\"StrategySchemaService.setStrategy()\"]\n        Registry[\"ToolRegistry&lt;IStrategySchema&gt;\"]\n    end\n    \n    subgraph \"Execution Time\"\n        BacktestRun[\"Backtest.run() or Live.run()\"]\n        ConnectionService[\"StrategyConnectionService.getStrategy()\"]\n        Memoize{\"Instance cached?\"}\n        CreateClient[\"new ClientStrategy(params)\"]\n        CachedClient[\"Return cached instance\"]\n        Tick[\"ClientStrategy.tick()\"]\n    end\n    \n    AddStrategy --> SchemaService\n    SchemaService --> Registry\n    \n    BacktestRun --> ConnectionService\n    ConnectionService --> Memoize\n    Memoize -->|No| CreateClient\n    Memoize -->|Yes| CachedClient\n    CreateClient --> Tick\n    CachedClient --> Tick\n    \n    Registry -.->|\"retrieves by strategyName\"| ConnectionService\n    \n    Note1[\"Memoization key:<br/>symbol:strategyName<br/>(e.g., 'BTCUSDT:momentum-breakout')\"]\n    Memoize -.-> Note1\n```\n\n**Sources:** [docs/classes/StrategyConnectionService.md:70-80](), [src/function/add.ts:1-100]()\n\n---\n\n## Schema Validation Rules\n\nWhen `addStrategy()` is called, the framework validates:\n\n1. **strategyName uniqueness:** No duplicate strategy names\n2. **interval validity:** Must be one of the allowed `SignalInterval` values\n3. **getSignal presence:** Function must be provided\n4. **riskName/riskList mutual exclusivity:** Cannot specify both simultaneously\n5. **Referenced risk profiles exist:** If `riskName` or `riskList` specified, those profiles must be registered via `addRisk()`\n\n**Sources:** [src/function/add.ts:1-100]()\n\n---\n\n## Complete Example\n\n```typescript\nimport { addStrategy, getCandles, ISignalDto } from \"backtest-kit\";\nimport { v4 as uuid } from \"uuid\";\n\naddStrategy({\n  strategyName: \"rsi-oversold\",\n  note: \"Buys when RSI < 30, sells when RSI > 70\",\n  interval: \"15m\",\n  \n  getSignal: async (symbol, when): Promise<ISignalDto | null> => {\n    // Fetch historical data\n    const candles = await getCandles(symbol, \"1h\", 24);\n    \n    // Calculate RSI (simplified)\n    const rsi = calculateRSI(candles);\n    const currentPrice = candles[candles.length - 1].close;\n    \n    // Entry condition: RSI oversold\n    if (rsi < 30) {\n      return {\n        id: uuid(),\n        position: \"long\",\n        note: `RSI oversold: ${rsi.toFixed(2)}`,\n        // Immediate entry (priceOpen omitted)\n        priceTakeProfit: currentPrice * 1.03, // 3% profit target\n        priceStopLoss: currentPrice * 0.98,   // 2% stop loss\n        minuteEstimatedTime: 1440,            // 24 hours max\n      };\n    }\n    \n    // No opportunity\n    return null;\n  },\n  \n  callbacks: {\n    onOpen: (symbol, data, currentPrice, backtest) => {\n      console.log(`[${symbol}] Signal opened: ${data.note}`);\n    },\n    onClose: (symbol, data, priceClose, backtest) => {\n      console.log(`[${symbol}] Signal closed at ${priceClose}`);\n    },\n    onPartialProfit: (symbol, data, currentPrice, revenuePercent, backtest) => {\n      console.log(`[${symbol}] Partial profit: ${revenuePercent.toFixed(2)}%`);\n    },\n  },\n  \n  riskName: \"conservative\",\n});\n```\n\n**Sources:** [README.md:66-142](), [types.d.ts:724-747]()\n\n---\n\n## Summary Table\n\n| Component | File Reference | Purpose |\n|-----------|----------------|---------|\n| `IStrategySchema` | [types.d.ts:724-747]() | Schema interface definition |\n| `SignalInterval` | [types.d.ts:645]() | Throttling interval type |\n| `ISignalDto` | [types.d.ts:647-665]() | Return type for getSignal |\n| `IStrategyCallbacks` | [types.d.ts:699-723]() | Lifecycle event handlers |\n| `addStrategy()` | [src/index.ts:11-18]() | Registration function |\n| `StrategySchemaService` | [docs/classes/StrategySchemaService.md:1-50]() | Schema storage |\n| `StrategyConnectionService` | [docs/classes/StrategyConnectionService.md:1-145]() | Instance routing |\n| `ClientStrategy` | [types.d.ts:724-747]() | Strategy execution implementation |\n\n**Sources:** [types.d.ts:724-747](), [src/index.ts:11-18](), [docs/classes/StrategyConnectionService.md:1-145]()"
                    },
                    {
                        "page_plan": {
                            "id": "6.2",
                            "title": "Signal Generation (getSignal)"
                        },
                        "content": "# Signal Generation (getSignal)\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/client/ClientStrategy.ts](src/client/ClientStrategy.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Strategy.interface.ts](src/interfaces/Strategy.interface.ts)\n- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)\n- [test/index.mjs](test/index.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis document explains how to implement the `getSignal` function, which is the core signal generation logic for trading strategies in Backtest Kit. The `getSignal` function analyzes market conditions and returns trading signals or null when no opportunity exists.\n\nFor strategy schema configuration and registration, see [Strategy Schema Definition](#6.1). For handling signal lifecycle events, see [Strategy Callbacks](#6.3). For analyzing multiple timeframes within `getSignal`, see [Multi-Timeframe Analysis](#6.4). For throttling behavior that limits `getSignal` calls, see [Interval Throttling](#6.5).\n\n---\n\n## Function Contract\n\nThe `getSignal` function is defined in the `IStrategySchema` interface as a required property that returns a promise resolving to either an `ISignalDto` object or `null`.\n\n```typescript\ngetSignal: (symbol: string, when: Date) => Promise<ISignalDto | null>\n```\n\n**Parameters:**\n- `symbol` - Trading pair symbol (e.g., \"BTCUSDT\")\n- `when` - Current execution timestamp (temporal context)\n\n**Return Value:**\n- `ISignalDto` - Signal to open a position\n- `null` - No trading opportunity detected\n\nThe framework calls `getSignal` at intervals specified by the strategy's `interval` property [types.d.ts:734](). Interval throttling ensures the function is not called more frequently than configured, preventing signal spam.\n\n**Sources:** [src/interfaces/Strategy.interface.ts:139-144](), [types.d.ts:728-747]()\n\n---\n\n## Signal Data Transfer Object (ISignalDto)\n\nThe `ISignalDto` interface defines the structure returned by `getSignal`. All fields except `id` are required for complete signal specification.\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `id` | `string` | Optional | Signal identifier (auto-generated if omitted) |\n| `position` | `\"long\" \\| \"short\"` | **Required** | Trade direction |\n| `note` | `string` | Optional | Human-readable reason for signal |\n| `priceOpen` | `number` | Optional | Entry price (omit for immediate market order) |\n| `priceTakeProfit` | `number` | **Required** | Take profit target price |\n| `priceStopLoss` | `number` | **Required** | Stop loss exit price |\n| `minuteEstimatedTime` | `number` | **Required** | Expected duration before time_expired |\n\n**Key Constraints:**\n- **Long position:** `priceTakeProfit > priceOpen > priceStopLoss`\n- **Short position:** `priceStopLoss > priceOpen > priceTakeProfit`\n- `minuteEstimatedTime` must be positive integer\n\nIf `priceOpen` is omitted, the signal opens immediately at current VWAP. If `priceOpen` is specified, the signal becomes scheduled and waits for price to reach entry point.\n\n**Sources:** [src/interfaces/Strategy.interface.ts:20-39](), [types.d.ts:641-665]()\n\n---\n\n## Immediate vs Scheduled Signals\n\n```mermaid\ngraph TD\n    GetSignal[\"getSignal() returns ISignalDto\"]\n    CheckPriceOpen{\"priceOpen specified?\"}\n    CheckActivation{\"Current price reached priceOpen?\"}\n    \n    ImmediateSignal[\"Create ISignalRow (immediate)<br/>priceOpen = currentPrice<br/>_isScheduled = false\"]\n    \n    ScheduledSignal[\"Create IScheduledSignalRow<br/>priceOpen = dto.priceOpen<br/>_isScheduled = true\"]\n    \n    ActivateImmediately[\"Create ISignalRow (activated)<br/>priceOpen = dto.priceOpen<br/>_isScheduled = false\"]\n    \n    GetSignal --> CheckPriceOpen\n    \n    CheckPriceOpen -->|No| ImmediateSignal\n    CheckPriceOpen -->|Yes| CheckActivation\n    \n    CheckActivation -->|Yes| ActivateImmediately\n    CheckActivation -->|No| ScheduledSignal\n    \n    ImmediateSignal --> Persist[\"Persist to storage<br/>Begin TP/SL monitoring\"]\n    ActivateImmediately --> Persist\n    ScheduledSignal --> WaitActivation[\"Wait for price to reach priceOpen<br/>Monitor for SL breach or timeout\"]\n    \n    WaitActivation -->|Activated| Persist\n    WaitActivation -->|Cancelled| NoPosition[\"No position opened\"]\n```\n\n**Immediate Signals (Market Orders):**\nWhen `priceOpen` is omitted in the returned `ISignalDto`, the signal opens immediately at current VWAP price. The framework sets `priceOpen` equal to the current market price and persists the signal for TP/SL monitoring.\n\n**Scheduled Signals (Limit Orders):**\nWhen `priceOpen` is specified in the returned `ISignalDto`, the signal enters scheduled state and waits for price to reach entry point. The signal activates when:\n- **Long:** `currentPrice <= priceOpen` (price drops to entry)\n- **Short:** `currentPrice >= priceOpen` (price rises to entry)\n\nScheduled signals are cancelled if:\n- Stop loss is breached before activation\n- Timeout expires (`CC_SCHEDULE_AWAIT_MINUTES` configuration)\n\nThe activation check happens in [src/client/ClientStrategy.ts:389-443]() within `GET_SIGNAL_FN`.\n\n**Sources:** [src/client/ClientStrategy.ts:332-462](), [src/interfaces/Strategy.interface.ts:64-73]()\n\n---\n\n## Temporal Context and Look-Ahead Bias Prevention\n\n```mermaid\ngraph LR\n    subgraph \"ExecutionContextService (di-scoped)\"\n        Context[\"context: IExecutionContext<br/>- symbol<br/>- when: Date<br/>- backtest: boolean\"]\n    end\n    \n    subgraph \"getSignal Implementation\"\n        GetSignalFn[\"getSignal(symbol, when)\"]\n        GetCandlesFn[\"getCandles(symbol, interval, limit)\"]\n        AnalyzeMarket[\"Analyze indicators, patterns,<br/>market conditions\"]\n        ReturnSignal[\"Return ISignalDto or null\"]\n    end\n    \n    subgraph \"ClientExchange\"\n        FetchCandles[\"getCandles() checks<br/>execution.context.when\"]\n        FilterData[\"Filter data <= when<br/>Prevent look-ahead bias\"]\n        ReturnCandles[\"Return ICandleData[]\"]\n    end\n    \n    Context -->|Propagates via AsyncLocalStorage| GetSignalFn\n    GetSignalFn --> GetCandlesFn\n    GetCandlesFn --> FetchCandles\n    FetchCandles --> FilterData\n    FilterData --> ReturnCandles\n    ReturnCandles --> AnalyzeMarket\n    AnalyzeMarket --> ReturnSignal\n```\n\nThe `when` parameter passed to `getSignal` represents the current execution timestamp. This timestamp is also stored in `ExecutionContextService.context.when` and propagates through `AsyncLocalStorage` to all downstream operations.\n\nWhen `getCandles()` is called within `getSignal`, it automatically uses the temporal context from `ExecutionContextService` to fetch only historical data up to `when`. This architectural pattern makes look-ahead bias architecturally impossible:\n\n1. `getSignal(symbol, when)` is called with current timestamp\n2. `ExecutionContextService.context.when` is set to this timestamp\n3. Any `getCandles()` call fetches data filtered by `when`\n4. Future data beyond `when` is inaccessible\n\nThis temporal isolation works identically in both backtest and live modes, ensuring strategies behave consistently across environments.\n\n**Sources:** [types.d.ts:6-18](), [src/interfaces/Strategy.interface.ts:139-144](), [README.md:189-199]()\n\n---\n\n## Using getCandles for Market Analysis\n\nThe `getCandles()` function is the primary way to access market data within `getSignal`. It fetches OHLCV candles from the configured exchange while respecting temporal context.\n\n```typescript\nimport { getCandles } from 'backtest-kit';\n\nasync function getSignal(symbol: string, when: Date): Promise<ISignalDto | null> {\n  // Fetch last 24 one-hour candles (up to 'when')\n  const candles1h = await getCandles(symbol, \"1h\", 24);\n  \n  // Fetch last 48 fifteen-minute candles\n  const candles15m = await getCandles(symbol, \"15m\", 48);\n  \n  // Fetch last 60 one-minute candles\n  const candles1m = await getCandles(symbol, \"1m\", 60);\n  \n  // Analyze candles for patterns, indicators, etc.\n  const shouldEnterLong = analyzeMarketConditions(candles1h, candles15m, candles1m);\n  \n  if (shouldEnterLong) {\n    return {\n      position: \"long\",\n      priceTakeProfit: candles1m[candles1m.length - 1].close * 1.02,\n      priceStopLoss: candles1m[candles1m.length - 1].close * 0.99,\n      minuteEstimatedTime: 120,\n      note: \"Strong uptrend detected on 1h timeframe\"\n    };\n  }\n  \n  return null; // No opportunity\n}\n```\n\n**Available Intervals:**\n`\"1m\"`, `\"3m\"`, `\"5m\"`, `\"15m\"`, `\"30m\"`, `\"1h\"`, `\"2h\"`, `\"4h\"`, `\"6h\"`, `\"8h\"`\n\nFor detailed multi-timeframe analysis patterns, see [Multi-Timeframe Analysis](#6.4).\n\n**Sources:** [src/function/exchange.ts:29-47](), [types.d.ts:82-100]()\n\n---\n\n## Return Value Semantics\n\n```mermaid\nstateDiagram-v2\n    [*] --> GetSignalCalled: Framework calls getSignal()\n    \n    GetSignalCalled --> AnalyzeMarket: Fetch candles, analyze\n    \n    AnalyzeMarket --> ReturnNull: No opportunity detected\n    AnalyzeMarket --> ReturnSignal: Opportunity detected\n    \n    ReturnNull --> Idle: Signal remains idle<br/>No position opened\n    ReturnSignal --> Validate: Framework validates signal\n    \n    Validate --> RiskCheck: VALIDATE_SIGNAL_FN passes\n    RiskCheck --> CheckExisting: Risk.checkSignal() passes\n    \n    CheckExisting --> Scheduled: priceOpen specified\n    CheckExisting --> Immediate: priceOpen omitted\n    \n    Scheduled --> WaitActivation\n    Immediate --> OpenPosition\n    \n    Validate --> Rejected: Validation fails\n    RiskCheck --> Rejected: Risk check fails\n    \n    Rejected --> Idle\n    \n    Idle --> [*]: Continue monitoring\n    WaitActivation --> [*]: Wait for activation or cancel\n    OpenPosition --> [*]: Begin TP/SL monitoring\n```\n\n**Returning `null`:**\nWhen `getSignal` returns `null`, the strategy remains in idle state. The framework:\n- Does not create any signal\n- Does not emit any events (except `onIdle` callback)\n- Continues calling `getSignal` at configured intervals\n\n**Returning `ISignalDto`:**\nWhen `getSignal` returns a signal object, the framework:\n1. Validates the signal structure and price relationships\n2. Checks risk limits via `IRisk.checkSignal()`\n3. Creates `ISignalRow` with auto-generated ID\n4. Persists signal (if immediate) or queues for activation (if scheduled)\n5. Begins TP/SL/time monitoring\n\nValidation failures result in the signal being rejected without opening any position. Risk check failures are logged and emitted via `riskSubject`.\n\n**Sources:** [src/client/ClientStrategy.ts:332-476](), [src/interfaces/Strategy.interface.ts:139-144]()\n\n---\n\n## Signal Validation Pipeline\n\nAfter `getSignal` returns an `ISignalDto`, the framework applies multi-stage validation before creating a position. All validation occurs in `VALIDATE_SIGNAL_FN` at [src/client/ClientStrategy.ts:45-330]().\n\n```mermaid\ngraph TD\n    ReturnSignal[\"getSignal returns ISignalDto\"]\n    \n    V1[\"Validate Required Fields<br/>id, position, symbol, etc.\"]\n    V2[\"Validate Price Finiteness<br/>No NaN/Infinity\"]\n    V3[\"Validate Price Positivity<br/>All prices > 0\"]\n    V4[\"Validate TP/SL Logic<br/>LONG: TP > priceOpen > SL<br/>SHORT: SL > priceOpen > TP\"]\n    V5[\"Validate No Immediate Close<br/>Current price between TP and SL\"]\n    V6[\"Validate TP Distance<br/>>= CC_MIN_TAKEPROFIT_DISTANCE_PERCENT\"]\n    V7[\"Validate SL Range<br/>CC_MIN/MAX_STOPLOSS_DISTANCE_PERCENT\"]\n    V8[\"Validate Signal Lifetime<br/><= CC_MAX_SIGNAL_LIFETIME_MINUTES\"]\n    \n    RiskCheck[\"Risk.checkSignal()<br/>Portfolio limits, custom rules\"]\n    \n    CreateSignal[\"Create ISignalRow<br/>with auto-generated ID\"]\n    RejectSignal[\"Reject Signal<br/>Log error, emit riskSubject\"]\n    \n    ReturnSignal --> V1\n    V1 --> V2\n    V2 --> V3\n    V3 --> V4\n    V4 --> V5\n    V5 --> V6\n    V6 --> V7\n    V7 --> V8\n    V8 --> RiskCheck\n    \n    RiskCheck -->|Pass| CreateSignal\n    RiskCheck -->|Fail| RejectSignal\n    \n    V1 -->|Fail| RejectSignal\n    V2 -->|Fail| RejectSignal\n    V3 -->|Fail| RejectSignal\n    V4 -->|Fail| RejectSignal\n    V5 -->|Fail| RejectSignal\n    V6 -->|Fail| RejectSignal\n    V7 -->|Fail| RejectSignal\n    V8 -->|Fail| RejectSignal\n```\n\n### Validation Stages\n\n**Stage 1: Required Fields**\nValidates presence of mandatory fields: `id`, `position`, `symbol`, `exchangeName`, `strategyName`, `_isScheduled`.\n\n**Stage 2: Price Finiteness**\nEnsures all price values (`currentPrice`, `priceOpen`, `priceTakeProfit`, `priceStopLoss`) are finite numbers, not `NaN` or `Infinity`.\n\n**Stage 3: Price Positivity**\nValidates all prices are positive values greater than zero.\n\n**Stage 4: TP/SL Logic**\nVerifies take profit and stop loss are positioned correctly relative to entry price:\n- **Long:** `priceTakeProfit > priceOpen > priceStopLoss`\n- **Short:** `priceStopLoss > priceOpen > priceTakeProfit`\n\n**Stage 5: Immediate Close Prevention**\nFor immediate signals (no `priceOpen`), ensures current price is between TP and SL. Prevents signals that would close instantly.\n\nFor scheduled signals, ensures `priceOpen` is between TP and SL. Prevents signals that would close immediately upon activation.\n\n**Stage 6: Minimum TP Distance**\nEnforces `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` (default 0.2%) to ensure take profit covers trading fees (0.1%) and slippage (0.1%).\n\n**Stage 7: SL Range Limits**\nEnforces:\n- `CC_MIN_STOPLOSS_DISTANCE_PERCENT` - Minimum SL buffer to avoid instant stop-outs\n- `CC_MAX_STOPLOSS_DISTANCE_PERCENT` - Maximum SL to limit capital exposure\n\n**Stage 8: Signal Lifetime**\nValidates `minuteEstimatedTime <= CC_MAX_SIGNAL_LIFETIME_MINUTES` to prevent eternal positions that block risk limits.\n\n### Global Configuration Parameters\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` | 0.2% | Minimum TP distance to cover fees/slippage |\n| `CC_MIN_STOPLOSS_DISTANCE_PERCENT` | 0.05% | Minimum SL buffer to prevent instant stop-out |\n| `CC_MAX_STOPLOSS_DISTANCE_PERCENT` | 10% | Maximum SL to protect capital |\n| `CC_MAX_SIGNAL_LIFETIME_MINUTES` | 10080 (7 days) | Maximum signal duration to prevent deadlock |\n\nThese parameters are configurable via `setConfig()`. See [GLOBAL_CONFIG Parameters](#11.1) for complete configuration reference.\n\n**Sources:** [src/client/ClientStrategy.ts:45-330](), [src/config/params.ts:1-100]()\n\n---\n\n## Example: Simple Moving Average Crossover\n\nThis example demonstrates a basic signal generation strategy using moving average crossovers.\n\n```typescript\nimport { addStrategy, getCandles, ISignalDto } from 'backtest-kit';\n\naddStrategy({\n  strategyName: \"sma-crossover\",\n  interval: \"5m\",\n  riskName: \"demo\",\n  \n  getSignal: async (symbol: string, when: Date): Promise<ISignalDto | null> => {\n    // Fetch last 50 hourly candles\n    const candles = await getCandles(symbol, \"1h\", 50);\n    \n    if (candles.length < 50) {\n      return null; // Insufficient data\n    }\n    \n    // Calculate 20-period and 50-period SMAs\n    const sma20 = calculateSMA(candles.slice(-20));\n    const sma50 = calculateSMA(candles.slice(-50));\n    const sma20Prev = calculateSMA(candles.slice(-21, -1));\n    const sma50Prev = calculateSMA(candles.slice(-51, -1));\n    \n    const currentPrice = candles[candles.length - 1].close;\n    \n    // Bullish crossover: SMA20 crosses above SMA50\n    if (sma20 > sma50 && sma20Prev <= sma50Prev) {\n      return {\n        position: \"long\",\n        priceTakeProfit: currentPrice * 1.025, // 2.5% profit target\n        priceStopLoss: currentPrice * 0.985,   // 1.5% stop loss\n        minuteEstimatedTime: 240,              // 4 hours\n        note: `SMA20 (${sma20.toFixed(2)}) crossed above SMA50 (${sma50.toFixed(2)})`\n      };\n    }\n    \n    // Bearish crossover: SMA20 crosses below SMA50\n    if (sma20 < sma50 && sma20Prev >= sma50Prev) {\n      return {\n        position: \"short\",\n        priceTakeProfit: currentPrice * 0.975, // 2.5% profit target\n        priceStopLoss: currentPrice * 1.015,   // 1.5% stop loss\n        minuteEstimatedTime: 240,              // 4 hours\n        note: `SMA20 (${sma20.toFixed(2)}) crossed below SMA50 (${sma50.toFixed(2)})`\n      };\n    }\n    \n    return null; // No crossover detected\n  }\n});\n\nfunction calculateSMA(candles: ICandleData[]): number {\n  const sum = candles.reduce((acc, c) => acc + c.close, 0);\n  return sum / candles.length;\n}\n```\n\n**Sources:** [demo/backtest/src/index.mjs:1-100](), [README.md:112-143]()\n\n---\n\n## Example: Scheduled Signal with Limit Order\n\nThis example shows how to create scheduled signals that wait for a specific entry price.\n\n```typescript\nimport { addStrategy, getCandles, ISignalDto } from 'backtest-kit';\n\naddStrategy({\n  strategyName: \"support-bounce\",\n  interval: \"15m\",\n  riskName: \"demo\",\n  \n  getSignal: async (symbol: string, when: Date): Promise<ISignalDto | null> => {\n    const candles = await getCandles(symbol, \"1h\", 100);\n    \n    if (candles.length < 100) {\n      return null;\n    }\n    \n    const currentPrice = candles[candles.length - 1].close;\n    \n    // Calculate support level (lowest low in last 50 candles)\n    const supportLevel = Math.min(...candles.slice(-50).map(c => c.low));\n    \n    // Check if price is approaching support (within 2%)\n    const distanceToSupport = ((currentPrice - supportLevel) / currentPrice) * 100;\n    \n    if (distanceToSupport > 0 && distanceToSupport < 2) {\n      // Place limit buy order at support level\n      return {\n        position: \"long\",\n        priceOpen: supportLevel,              // Wait for price to reach support\n        priceTakeProfit: supportLevel * 1.03, // 3% profit target\n        priceStopLoss: supportLevel * 0.97,   // 3% stop loss\n        minuteEstimatedTime: 360,             // 6 hours\n        note: `Limit buy at support level ${supportLevel.toFixed(2)}`\n      };\n    }\n    \n    return null;\n  }\n});\n```\n\nIn this example:\n1. Signal is created when price approaches support\n2. `priceOpen` is set to support level (scheduled signal)\n3. Signal waits for price to drop to `priceOpen`\n4. If price reaches support, signal activates and opens position\n5. If price never reaches support or SL is breached first, signal cancels\n\n**Sources:** [src/interfaces/Strategy.interface.ts:139-144](), [src/client/ClientStrategy.ts:389-443]()\n\n---\n\n## Example: LLM-Powered Signal Generation\n\nThis example integrates an LLM (Ollama) for AI-driven signal generation based on multi-timeframe analysis.\n\n```typescript\nimport { addStrategy, getCandles, ISignalDto } from 'backtest-kit';\nimport { v4 as uuid } from 'uuid';\nimport { generateSignalWithLLM } from './llm-helper';\n\naddStrategy({\n  strategyName: \"llm-strategy\",\n  interval: \"5m\",\n  riskName: \"demo\",\n  \n  getSignal: async (symbol: string, when: Date): Promise<ISignalDto | null> => {\n    // Fetch multiple timeframes\n    const candles1h = await getCandles(symbol, \"1h\", 24);\n    const candles15m = await getCandles(symbol, \"15m\", 48);\n    const candles5m = await getCandles(symbol, \"5m\", 60);\n    const candles1m = await getCandles(symbol, \"1m\", 60);\n    \n    // Prepare market data for LLM\n    const marketData = {\n      symbol,\n      timestamp: when,\n      candles1h,\n      candles15m,\n      candles5m,\n      candles1m,\n      indicators: calculateIndicators(candles1h, candles15m)\n    };\n    \n    // Generate signal using LLM\n    const signal = await generateSignalWithLLM(marketData);\n    \n    if (!signal) {\n      return null;\n    }\n    \n    // Add unique ID for tracking\n    return {\n      ...signal,\n      id: uuid()\n    };\n  }\n});\n\nfunction calculateIndicators(candles1h, candles15m) {\n  // Calculate RSI, MACD, Bollinger Bands, etc.\n  return {\n    rsi: calculateRSI(candles1h),\n    macd: calculateMACD(candles1h),\n    trend: detectTrend(candles15m)\n  };\n}\n```\n\nThe LLM analyzes market conditions and returns a structured signal object matching `ISignalDto`. For complete LLM integration examples, see the demo projects at [demo/optimization/]() and [demo/backtest/]().\n\n**Sources:** [README.md:111-142](), [demo/optimization/src/index.mjs:1-200]()\n\n---\n\n## Signal Flow Summary\n\n```mermaid\nsequenceDiagram\n    participant Framework as Framework (ClientStrategy)\n    participant User as getSignal Implementation\n    participant Exchange as ClientExchange\n    participant Risk as ClientRisk\n    \n    Note over Framework: Interval throttle check passes\n    \n    Framework->>User: getSignal(symbol, when)\n    \n    User->>Exchange: getCandles(symbol, \"1h\", 24)\n    Exchange-->>User: ICandleData[]\n    \n    User->>User: Analyze market conditions\n    \n    alt Signal Detected\n        User-->>Framework: ISignalDto\n        Framework->>Framework: VALIDATE_SIGNAL_FN(signal)\n        \n        alt Validation Passes\n            Framework->>Risk: checkSignal(params)\n            Risk-->>Framework: true/false\n            \n            alt Risk Check Passes\n                Framework->>Framework: Create ISignalRow with UUID\n                \n                alt Immediate Signal\n                    Framework->>Framework: Persist to storage\n                    Framework->>Framework: Begin TP/SL monitoring\n                else Scheduled Signal\n                    Framework->>Framework: Wait for priceOpen activation\n                end\n            else Risk Check Fails\n                Framework->>Framework: Reject signal, emit riskSubject\n            end\n        else Validation Fails\n            Framework->>Framework: Reject signal, log error\n        end\n    else No Signal\n        User-->>Framework: null\n        Framework->>Framework: Remain idle\n    end\n```\n\n**Sources:** [src/client/ClientStrategy.ts:332-476](), [src/lib/services/connection/StrategyConnectionService.ts:206-228]()"
                    },
                    {
                        "page_plan": {
                            "id": "6.3",
                            "title": "Strategy Callbacks"
                        },
                        "content": "# Strategy Callbacks\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/client/ClientStrategy.ts](src/client/ClientStrategy.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Strategy.interface.ts](src/interfaces/Strategy.interface.ts)\n- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)\n- [test/index.mjs](test/index.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis page documents the `IStrategyCallbacks` interface and its lifecycle hooks for monitoring and responding to signal state changes. Strategy callbacks provide optional event handlers that execute synchronously during strategy execution, enabling custom logging, notifications, and state management. For information about the broader signal lifecycle and state machine, see [Signals & Signal Lifecycle](#3.1). For details on the asynchronous event system that complements callbacks, see [Event Listeners](#9.1).\n\n---\n\n## Overview\n\nThe `IStrategyCallbacks` interface defines 10 optional lifecycle hooks that fire during signal state transitions. Callbacks are registered via the `callbacks` field in `IStrategySchema` when calling `addStrategy()`. Unlike the global event emitter system, callbacks are strategy-specific and execute inline during signal processing.\n\n**Key Characteristics:**\n- Optional—all callbacks default to no-op if not provided\n- Synchronous execution within the strategy tick cycle\n- Scoped to the specific strategy instance\n- Receives both backtest and live mode events\n\n**Sources:** [src/interfaces/Strategy.interface.ts:100-126](), [types.d.ts:699-723]()\n\n---\n\n## IStrategyCallbacks Interface Structure\n\n```mermaid\ngraph TB\n    subgraph IStrategyCallbacks[\"IStrategyCallbacks Interface\"]\n        onTick[\"onTick(symbol, result, backtest)\"]\n        onOpen[\"onOpen(symbol, data, currentPrice, backtest)\"]\n        onActive[\"onActive(symbol, data, currentPrice, backtest)\"]\n        onIdle[\"onIdle(symbol, currentPrice, backtest)\"]\n        onClose[\"onClose(symbol, data, priceClose, backtest)\"]\n        onSchedule[\"onSchedule(symbol, data, currentPrice, backtest)\"]\n        onCancel[\"onCancel(symbol, data, currentPrice, backtest)\"]\n        onWrite[\"onWrite(symbol, data, backtest)\"]\n        onPartialProfit[\"onPartialProfit(symbol, data, currentPrice, revenuePercent, backtest)\"]\n        onPartialLoss[\"onPartialLoss(symbol, data, currentPrice, lossPercent, backtest)\"]\n    end\n    \n    subgraph Invocation[\"Callback Invocation Context\"]\n        ClientStrategy[\"ClientStrategy class\"]\n        TickMethod[\"tick() method\"]\n        BacktestMethod[\"backtest() method\"]\n        \n        ClientStrategy --> TickMethod\n        ClientStrategy --> BacktestMethod\n    end\n    \n    subgraph Parameters[\"Common Parameters\"]\n        Symbol[\"symbol: Trading pair\"]\n        Backtest[\"backtest: Execution mode flag\"]\n        Data[\"data: ISignalRow or IScheduledSignalRow\"]\n        CurrentPrice[\"currentPrice: VWAP price\"]\n    end\n    \n    TickMethod --> onTick\n    TickMethod --> onOpen\n    TickMethod --> onActive\n    TickMethod --> onIdle\n    TickMethod --> onClose\n    TickMethod --> onSchedule\n    TickMethod --> onCancel\n    \n    BacktestMethod --> onTick\n    BacktestMethod --> onOpen\n    BacktestMethod --> onClose\n    \n    onPartialProfit --> CurrentPrice\n    onPartialLoss --> CurrentPrice\n    onOpen --> Data\n    onActive --> Data\n    onClose --> Data\n    \n    style IStrategyCallbacks fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style Invocation fill:#e8f4f8,stroke:#333,stroke-width:2px\n```\n\n**Sources:** [src/interfaces/Strategy.interface.ts:100-126](), [src/client/ClientStrategy.ts:1-1700]()\n\n---\n\n## Callback Lifecycle Hooks\n\n### onTick\n\nCalled on every tick with the complete tick result, regardless of signal state. This is the most frequently invoked callback and executes before any other callbacks in the same tick.\n\n**Signature:**\n```typescript\nonTick: (symbol: string, result: IStrategyTickResult, backtest: boolean) => void\n```\n\n**Parameters:**\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `symbol` | `string` | Trading pair (e.g., \"BTCUSDT\") |\n| `result` | `IStrategyTickResult` | Discriminated union of tick results |\n| `backtest` | `boolean` | `true` for backtest mode, `false` for live |\n\n**Use Cases:**\n- Comprehensive tick-by-tick logging\n- Custom metrics collection\n- Real-time monitoring dashboards\n\n**Invocation Points:**\n- [src/client/ClientStrategy.ts:599-606]() - After scheduled signal timeout cancellation\n- [src/client/ClientStrategy.ts:765-772]() - After scheduled signal activation\n- [src/client/ClientStrategy.ts:792-799]() - During scheduled signal monitoring\n\n**Sources:** [src/interfaces/Strategy.interface.ts:102](), [types.d.ts:704]()\n\n---\n\n### onOpen\n\nCalled immediately after a signal is validated, persisted, and becomes active. This hook fires **after** risk validation passes but **before** the signal enters active monitoring.\n\n**Signature:**\n```typescript\nonOpen: (symbol: string, data: ISignalRow, currentPrice: number, backtest: boolean) => void\n```\n\n**Parameters:**\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `symbol` | `string` | Trading pair |\n| `data` | `ISignalRow` | Complete signal with generated ID |\n| `currentPrice` | `number` | VWAP price at signal open |\n| `backtest` | `boolean` | Execution mode flag |\n\n**Use Cases:**\n- Send trade entry notifications\n- Log position opening to external systems\n- Update portfolio tracking\n\n**Invocation Points:**\n- [src/client/ClientStrategy.ts:747-754]() - After scheduled signal activation\n- [src/client/ClientStrategy.ts:862-869]() - After immediate signal creation\n\n**Sources:** [src/interfaces/Strategy.interface.ts:104](), [types.d.ts:706]()\n\n---\n\n### onActive\n\nCalled during each tick while a signal is being monitored (TP/SL checks). This callback executes repeatedly until the signal closes.\n\n**Signature:**\n```typescript\nonActive: (symbol: string, data: ISignalRow, currentPrice: number, backtest: boolean) => void\n```\n\n**Parameters:**\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `symbol` | `string` | Trading pair |\n| `data` | `ISignalRow` | Active signal being monitored |\n| `currentPrice` | `number` | Current VWAP price |\n| `backtest` | `boolean` | Execution mode flag |\n\n**Use Cases:**\n- Track unrealized PNL changes\n- Monitor distance to TP/SL\n- Update live dashboards with active position status\n\n**Invocation Points:**\n- [src/client/ClientStrategy.ts:512-522]() - During crash recovery initialization\n- [src/client/ClientStrategy.ts:906-916]() - During active signal monitoring in tick()\n\n**Sources:** [src/interfaces/Strategy.interface.ts:106](), [types.d.ts:708]()\n\n---\n\n### onIdle\n\nCalled when no active or scheduled signal exists for the strategy-symbol pair. This indicates the strategy is waiting to generate a new signal.\n\n**Signature:**\n```typescript\nonIdle: (symbol: string, currentPrice: number, backtest: boolean) => void\n```\n\n**Parameters:**\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `symbol` | `string` | Trading pair |\n| `currentPrice` | `number` | Current VWAP price |\n| `backtest` | `boolean` | Execution mode flag |\n\n**Use Cases:**\n- Log idle state for monitoring\n- Track strategy inactivity periods\n- Trigger alerts if idle too long\n\n**Invocation Points:**\n- [src/client/ClientStrategy.ts:924-936]() - When no signal exists during tick()\n\n**Sources:** [src/interfaces/Strategy.interface.ts:108](), [types.d.ts:710]()\n\n---\n\n### onClose\n\nCalled when a signal completes (take profit, stop loss, or time expiration). This is the final lifecycle hook for a successful signal.\n\n**Signature:**\n```typescript\nonClose: (symbol: string, data: ISignalRow, priceClose: number, backtest: boolean) => void\n```\n\n**Parameters:**\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `symbol` | `string` | Trading pair |\n| `data` | `ISignalRow` | Closed signal with full history |\n| `priceClose` | `number` | Final exit price (VWAP) |\n| `backtest` | `boolean` | Execution mode flag |\n\n**Use Cases:**\n- Send trade exit notifications\n- Calculate and log realized PNL\n- Update external tracking systems\n\n**Invocation Points:**\n- [src/client/ClientStrategy.ts:988-998]() - After signal closes via TP/SL/time\n\n**Sources:** [src/interfaces/Strategy.interface.ts:110-115](), [types.d.ts:712]()\n\n---\n\n### onSchedule\n\nCalled when a scheduled signal (limit order) is created. This occurs when `getSignal` returns a signal with `priceOpen` specified and the current price has not yet reached the entry level.\n\n**Signature:**\n```typescript\nonSchedule: (symbol: string, data: IScheduledSignalRow, currentPrice: number, backtest: boolean) => void\n```\n\n**Parameters:**\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `symbol` | `string` | Trading pair |\n| `data` | `IScheduledSignalRow` | Scheduled signal awaiting activation |\n| `currentPrice` | `number` | Current VWAP price |\n| `backtest` | `boolean` | Execution mode flag |\n\n**Use Cases:**\n- Log pending limit orders\n- Track scheduled signal lifetime\n- Monitor price distance to activation\n\n**Invocation Points:**\n- [src/client/ClientStrategy.ts:540-550]() - During crash recovery for persisted scheduled signals\n- [src/client/ClientStrategy.ts:827-837]() - After scheduled signal creation\n\n**Sources:** [src/interfaces/Strategy.interface.ts:117](), [types.d.ts:714]()\n\n---\n\n### onCancel\n\nCalled when a scheduled signal is cancelled without opening a position. Cancellation occurs when the signal times out or the stop loss is hit before activation.\n\n**Signature:**\n```typescript\nonCancel: (symbol: string, data: IScheduledSignalRow, currentPrice: number, backtest: boolean) => void\n```\n\n**Parameters:**\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `symbol` | `string` | Trading pair |\n| `data` | `IScheduledSignalRow` | Cancelled scheduled signal |\n| `currentPrice` | `number` | Current VWAP price |\n| `backtest` | `boolean` | Execution mode flag |\n\n**Use Cases:**\n- Log failed limit orders\n- Track cancellation reasons (timeout vs SL)\n- Analyze scheduled signal success rate\n\n**Invocation Points:**\n- [src/client/ClientStrategy.ts:580-587]() - After scheduled signal timeout\n- Implicitly during scheduled signal SL breach (before activation)\n\n**Sources:** [src/interfaces/Strategy.interface.ts:119](), [types.d.ts:716]()\n\n---\n\n### onWrite\n\nCalled whenever a signal is written to persistence storage. This is primarily used for testing and debugging persistence logic. In backtest mode, this callback is typically not invoked since signals are not persisted.\n\n**Signature:**\n```typescript\nonWrite: (symbol: string, data: ISignalRow | null, backtest: boolean) => void\n```\n\n**Parameters:**\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `symbol` | `string` | Trading pair |\n| `data` | `ISignalRow \\| null` | Signal being written, or `null` for deletion |\n| `backtest` | `boolean` | Execution mode flag |\n\n**Use Cases:**\n- Test persistence adapter behavior\n- Debug signal serialization issues\n- Audit persistence operations\n\n**Invocation Points:**\n- [src/client/ClientStrategy.ts:1029-1053]() - In `setPendingSignal` method\n- [src/client/ClientStrategy.ts:1055-1079]() - In `setScheduledSignal` method\n\n**Sources:** [src/interfaces/Strategy.interface.ts:121](), [types.d.ts:718]()\n\n---\n\n### onPartialProfit\n\nCalled when a signal reaches a profit milestone (10%, 20%, 30%, etc.) without hitting take profit. This enables tracking of unrealized gains during position monitoring.\n\n**Signature:**\n```typescript\nonPartialProfit: (symbol: string, data: ISignalRow, currentPrice: number, revenuePercent: number, backtest: boolean) => void\n```\n\n**Parameters:**\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `symbol` | `string` | Trading pair |\n| `data` | `ISignalRow` | Active signal in profit |\n| `currentPrice` | `number` | Current VWAP price |\n| `revenuePercent` | `number` | Current profit percentage (positive value) |\n| `backtest` | `boolean` | Execution mode flag |\n\n**Use Cases:**\n- Send profit milestone notifications\n- Track trailing profit behavior\n- Analyze optimal exit timing\n\n**Invocation Points:**\n- Via `ClientPartial.profit()` method during signal monitoring\n- Only emits when crossing 10%, 20%, 30%... thresholds (deduplication via Set)\n\n**Sources:** [src/interfaces/Strategy.interface.ts:123](), [types.d.ts:720]()\n\n---\n\n### onPartialLoss\n\nCalled when a signal reaches a loss milestone (10%, 20%, 30%, etc.) without hitting stop loss. This enables tracking of unrealized losses during position monitoring.\n\n**Signature:**\n```typescript\nonPartialLoss: (symbol: string, data: ISignalRow, currentPrice: number, lossPercent: number, backtest: boolean) => void\n```\n\n**Parameters:**\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `symbol` | `string` | Trading pair |\n| `data` | `ISignalRow` | Active signal in loss |\n| `currentPrice` | `number` | Current VWAP price |\n| `lossPercent` | `number` | Current loss percentage (negative value) |\n| `backtest` | `boolean` | Execution mode flag |\n\n**Use Cases:**\n- Send loss milestone alerts\n- Monitor drawdown risk\n- Trigger emergency exit logic\n\n**Invocation Points:**\n- Via `ClientPartial.loss()` method during signal monitoring\n- Only emits when crossing -10%, -20%, -30%... thresholds (deduplication via Set)\n\n**Sources:** [src/interfaces/Strategy.interface.ts:125](), [types.d.ts:722]()\n\n---\n\n## Callback Invocation Flow\n\nThe following diagram shows the execution order of callbacks during different signal lifecycle transitions:\n\n```mermaid\nstateDiagram-v2\n    [*] --> getSignalCall: tick() invoked\n    \n    getSignalCall --> noSignal: Returns null\n    getSignalCall --> scheduledCheck: Returns signal\n    \n    noSignal --> idleState: No active signal\n    idleState --> onIdle: Callback\n    idleState --> onTick: Callback\n    idleState --> [*]\n    \n    scheduledCheck --> scheduledCreated: priceOpen not reached\n    scheduledCheck --> immediateCreated: priceOpen reached or omitted\n    \n    scheduledCreated --> onSchedule: Callback\n    scheduledCreated --> onTick: Callback\n    scheduledCreated --> waitActivation: Wait for price\n    \n    waitActivation --> checkTimeout: Each tick\n    checkTimeout --> timedOut: Timeout exceeded\n    checkTimeout --> checkSL: Timeout OK\n    \n    timedOut --> onCancel: Callback (timeout)\n    timedOut --> onTick: Callback\n    timedOut --> [*]\n    \n    checkSL --> slBreach: SL hit before activation\n    checkSL --> checkPrice: SL OK\n    \n    slBreach --> onCancel: Callback (SL breach)\n    slBreach --> onTick: Callback\n    slBreach --> [*]\n    \n    checkPrice --> activateSignal: priceOpen reached\n    checkPrice --> stillScheduled: Not yet\n    \n    stillScheduled --> onTick: Callback (scheduled active)\n    stillScheduled --> waitActivation\n    \n    activateSignal --> onOpen: Callback (activation)\n    activateSignal --> activeState\n    \n    immediateCreated --> onOpen: Callback (immediate)\n    immediateCreated --> activeState\n    \n    activeState --> persistSignal: Save to storage\n    persistSignal --> onWrite: Callback (if provided)\n    persistSignal --> monitoring\n    \n    monitoring --> checkPartial: Each tick\n    checkPartial --> profitMilestone: 10%, 20%, 30% profit\n    checkPartial --> lossMilestone: -10%, -20%, -30% loss\n    checkPartial --> onActive: Callback (monitoring)\n    \n    profitMilestone --> onPartialProfit: Callback\n    profitMilestone --> checkPartial\n    \n    lossMilestone --> onPartialLoss: Callback\n    lossMilestone --> checkPartial\n    \n    checkPartial --> checkTP: Check take profit\n    checkTP --> tpHit: TP reached\n    checkTP --> checkSL2: TP not reached\n    \n    checkSL2 --> slHit: SL reached\n    checkSL2 --> checkTime: SL not reached\n    \n    checkTime --> timeExpired: Time limit exceeded\n    checkTime --> stillActive: Time OK\n    \n    stillActive --> onTick: Callback (active)\n    stillActive --> monitoring\n    \n    tpHit --> onClose: Callback (take_profit)\n    tpHit --> deleteSignal\n    \n    slHit --> onClose: Callback (stop_loss)\n    slHit --> deleteSignal\n    \n    timeExpired --> onClose: Callback (time_expired)\n    timeExpired --> deleteSignal\n    \n    deleteSignal --> onWrite: Callback (data=null)\n    deleteSignal --> onTick: Callback (closed)\n    deleteSignal --> [*]\n    \n    note right of onTick\n        onTick executes after\n        all other callbacks\n        in the same tick\n    end note\n    \n    note right of onWrite\n        onWrite executes only\n        in live mode, not\n        during backtest\n    end note\n```\n\n**Sources:** [src/client/ClientStrategy.ts:554-1000]()\n\n---\n\n## Callbacks vs Event Emitters\n\nBacktest Kit provides two parallel mechanisms for observing strategy behavior: **callbacks** (synchronous, strategy-scoped) and **event emitters** (asynchronous, global).\n\n**Comparison Table:**\n\n| Feature | Callbacks (`IStrategyCallbacks`) | Event Emitters (`listenSignal*`) |\n|---------|----------------------------------|----------------------------------|\n| **Scope** | Per-strategy | Global (all strategies) |\n| **Execution** | Synchronous | Asynchronous (queued) |\n| **Registration** | Via `addStrategy({ callbacks })` | Via `listenSignal()` functions |\n| **Filtering** | Strategy-specific by default | Manual filtering required |\n| **Backtest Support** | Yes | Yes |\n| **Live Support** | Yes | Yes |\n| **Performance** | Inline (no queue overhead) | Queued (prevents concurrent execution) |\n\n**When to Use Callbacks:**\n- Strategy-specific logging or metrics\n- Inline validation or decision-making\n- Testing specific strategy behavior\n\n**When to Use Event Emitters:**\n- Cross-strategy monitoring\n- External system integration (webhooks, databases)\n- Decoupled application architecture\n\n**Example: Hybrid Approach**\n```typescript\naddStrategy({\n  strategyName: 'my-strategy',\n  interval: '5m',\n  getSignal: async (symbol, when) => { /* ... */ },\n  callbacks: {\n    // Strategy-specific inline logging\n    onOpen: (symbol, data, price, backtest) => {\n      console.log(`[${data.strategyName}] Opened at ${price}`);\n    },\n    onClose: (symbol, data, priceClose, backtest) => {\n      console.log(`[${data.strategyName}] Closed at ${priceClose}`);\n    }\n  }\n});\n\n// Global cross-strategy monitoring\nlistenSignal((event) => {\n  if (event.action === 'closed') {\n    // Send to external monitoring service\n    sendToDatadog({\n      metric: 'signal.closed',\n      strategy: event.strategyName,\n      pnl: event.pnl.pnlPercentage\n    });\n  }\n});\n```\n\n**Sources:** [src/interfaces/Strategy.interface.ts:100-126](), [src/function/event.ts:1-700]()\n\n---\n\n## Integration with StrategyConnectionService\n\nThe `StrategyConnectionService` acts as a router between the public API and individual `ClientStrategy` instances. Callbacks are passed through this routing layer and stored in the `ClientStrategy` instance.\n\n```mermaid\ngraph TB\n    subgraph UserCode[\"User Code\"]\n        addStrategy[\"addStrategy({ callbacks: {...} })\"]\n    end\n    \n    subgraph ServiceLayer[\"Service Layer\"]\n        StrategySchema[\"StrategySchemaService<br/>Stores IStrategySchema\"]\n        StrategyConnection[\"StrategyConnectionService<br/>Memoized factory\"]\n        ClientStrategyInstance[\"ClientStrategy instance<br/>params.callbacks\"]\n    end\n    \n    subgraph Execution[\"Execution\"]\n        TickMethod[\"tick() method\"]\n        BacktestMethod[\"backtest() method\"]\n        CallbackInvocation[\"Callback invocation<br/>if (params.callbacks?.onOpen) {...}\"]\n    end\n    \n    addStrategy --> StrategySchema\n    StrategySchema --> StrategyConnection\n    StrategyConnection --> ClientStrategyInstance\n    \n    ClientStrategyInstance --> TickMethod\n    ClientStrategyInstance --> BacktestMethod\n    \n    TickMethod --> CallbackInvocation\n    BacktestMethod --> CallbackInvocation\n    \n    CallbackInvocation --> onOpen[\"onOpen(...)\"]\n    CallbackInvocation --> onClose[\"onClose(...)\"]\n    CallbackInvocation --> onActive[\"onActive(...)\"]\n    CallbackInvocation --> onTick[\"onTick(...)\"]\n    \n    style UserCode fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style ServiceLayer fill:#e8f4f8,stroke:#333,stroke-width:2px\n    style Execution fill:#f0f0f0,stroke:#333,stroke-width:2px\n```\n\n**Key Implementation Details:**\n\n1. **Storage:** Callbacks are stored in `IStrategyParams.callbacks` field [src/interfaces/Strategy.interface.ts:79-94]()\n\n2. **Invocation Pattern:** All callbacks use optional chaining to avoid errors if not provided:\n   ```typescript\n   if (self.params.callbacks?.onOpen) {\n     self.params.callbacks.onOpen(symbol, data, currentPrice, backtest);\n   }\n   ```\n   [src/client/ClientStrategy.ts:747-754]()\n\n3. **Context Propagation:** The `backtest` flag propagates from `ExecutionContextService` to callbacks, enabling mode-specific logic\n\n**Sources:** [src/lib/services/connection/StrategyConnectionService.ts:89-150](), [src/client/ClientStrategy.ts:1-1700]()\n\n---\n\n## Common Usage Patterns\n\n### Pattern 1: Trade Execution Logging\n\n```typescript\naddStrategy({\n  strategyName: 'rsi-strategy',\n  interval: '5m',\n  getSignal: async (symbol, when) => { /* ... */ },\n  callbacks: {\n    onOpen: (symbol, data, price, backtest) => {\n      const mode = backtest ? '[BACKTEST]' : '[LIVE]';\n      console.log(`${mode} ${symbol} ${data.position} OPEN @ ${price}`);\n      console.log(`  TP: ${data.priceTakeProfit}, SL: ${data.priceStopLoss}`);\n    },\n    onClose: (symbol, data, priceClose, backtest) => {\n      const pnl = calculatePnl(data, priceClose);\n      console.log(`${symbol} CLOSE @ ${priceClose} | PNL: ${pnl}%`);\n    }\n  }\n});\n```\n\n### Pattern 2: Unrealized PNL Tracking\n\n```typescript\nconst unrealizedPnL = new Map<string, number>();\n\naddStrategy({\n  strategyName: 'momentum-strategy',\n  interval: '15m',\n  getSignal: async (symbol, when) => { /* ... */ },\n  callbacks: {\n    onOpen: (symbol, data, price) => {\n      unrealizedPnL.set(data.id, 0);\n    },\n    onPartialProfit: (symbol, data, price, revenuePercent) => {\n      unrealizedPnL.set(data.id, revenuePercent);\n      console.log(`Signal ${data.id}: Unrealized +${revenuePercent}%`);\n    },\n    onPartialLoss: (symbol, data, price, lossPercent) => {\n      unrealizedPnL.set(data.id, lossPercent);\n      console.log(`Signal ${data.id}: Unrealized ${lossPercent}%`);\n    },\n    onClose: (symbol, data, priceClose) => {\n      unrealizedPnL.delete(data.id);\n    }\n  }\n});\n```\n\n### Pattern 3: Scheduled Signal Monitoring\n\n```typescript\nconst scheduledSignals = new Map<string, Date>();\n\naddStrategy({\n  strategyName: 'breakout-strategy',\n  interval: '30m',\n  getSignal: async (symbol, when) => { /* ... */ },\n  callbacks: {\n    onSchedule: (symbol, data, currentPrice) => {\n      scheduledSignals.set(data.id, new Date(data.scheduledAt));\n      console.log(`Scheduled ${data.position} @ ${data.priceOpen}`);\n      console.log(`Current price: ${currentPrice}, waiting for entry...`);\n    },\n    onOpen: (symbol, data, price) => {\n      const scheduledTime = scheduledSignals.get(data.id);\n      const waitTime = Date.now() - scheduledTime.getTime();\n      console.log(`Signal activated after ${waitTime}ms wait`);\n      scheduledSignals.delete(data.id);\n    },\n    onCancel: (symbol, data, currentPrice) => {\n      const scheduledTime = scheduledSignals.get(data.id);\n      console.log(`Signal cancelled before activation`);\n      scheduledSignals.delete(data.id);\n    }\n  }\n});\n```\n\n### Pattern 4: Conditional Backtest vs Live Behavior\n\n```typescript\naddStrategy({\n  strategyName: 'adaptive-strategy',\n  interval: '5m',\n  getSignal: async (symbol, when) => { /* ... */ },\n  callbacks: {\n    onOpen: (symbol, data, price, backtest) => {\n      if (backtest) {\n        // Backtest: just log\n        console.log(`Backtest signal opened: ${data.id}`);\n      } else {\n        // Live: send webhook notification\n        fetch('https://api.example.com/webhooks/signal-opened', {\n          method: 'POST',\n          body: JSON.stringify({ symbol, price, position: data.position })\n        });\n      }\n    }\n  }\n});\n```\n\n**Sources:** [src/interfaces/Strategy.interface.ts:128-151]()\n\n---\n\n## Thread Safety and Execution Order\n\nCallbacks execute synchronously within the strategy tick cycle, ensuring deterministic ordering:\n\n1. **Signal state change** (e.g., idle → opened)\n2. **State-specific callback** (e.g., `onOpen`)\n3. **Always execute `onTick`** with full result\n4. **Return tick result** to caller\n\nThis ordering guarantee enables callbacks to safely modify external state before `onTick` executes. However, note that callbacks should not throw exceptions—uncaught errors will be caught by `trycatch` wrapper and logged via `errorEmitter`.\n\n**Exception Handling:**\n```typescript\n// From ClientStrategy.ts GET_SIGNAL_FN wrapper\nconst GET_SIGNAL_FN = trycatch(\n  async (self: ClientStrategy): Promise<ISignalRow | null> => {\n    // ... signal generation logic\n  },\n  {\n    defaultValue: null,\n    fallback: (error) => {\n      backtest.loggerService.warn(\"ClientStrategy exception thrown\", {\n        error: errorData(error),\n        message: getErrorMessage(error)\n      });\n      errorEmitter.next(error);\n    }\n  }\n);\n```\n[src/client/ClientStrategy.ts:332-476]()\n\n**Sources:** [src/client/ClientStrategy.ts:332-476](), [src/client/ClientStrategy.ts:554-1000]()\n\n---\n\n## Debugging and Testing Callbacks\n\n### Using onWrite for Persistence Testing\n\nThe `onWrite` callback is specifically designed for testing persistence behavior:\n\n```typescript\nconst writeLog: Array<{ symbol: string, data: ISignalRow | null }> = [];\n\naddStrategy({\n  strategyName: 'test-strategy',\n  interval: '1m',\n  getSignal: async (symbol, when) => { /* ... */ },\n  callbacks: {\n    onWrite: (symbol, data, backtest) => {\n      writeLog.push({ symbol, data });\n      if (data === null) {\n        console.log(`Signal deleted from persistence: ${symbol}`);\n      } else {\n        console.log(`Signal written to persistence: ${data.id}`);\n      }\n    }\n  }\n});\n\n// After test execution, inspect writeLog\nconsole.log(`Total writes: ${writeLog.length}`);\nconsole.log(`Deletes: ${writeLog.filter(w => w.data === null).length}`);\n```\n\n### onTick for Comprehensive State Logging\n\nSince `onTick` executes on every tick regardless of state, it's ideal for comprehensive logging:\n\n```typescript\naddStrategy({\n  strategyName: 'debug-strategy',\n  interval: '1m',\n  getSignal: async (symbol, when) => { /* ... */ },\n  callbacks: {\n    onTick: (symbol, result, backtest) => {\n      console.log(`[${new Date().toISOString()}] ${symbol} ${result.action}`);\n      \n      if (result.action === 'active') {\n        console.log(`  Progress: TP=${result.percentTp}%, SL=${result.percentSl}%`);\n      }\n      \n      if (result.action === 'closed') {\n        console.log(`  Reason: ${result.closeReason}, PNL: ${result.pnl.pnlPercentage}%`);\n      }\n    }\n  }\n});\n```\n\n**Sources:** [src/interfaces/Strategy.interface.ts:102](), [src/interfaces/Strategy.interface.ts:121]()\n\n---\n\n## Performance Considerations\n\nCallbacks execute inline during the tick cycle, so expensive operations can impact strategy performance:\n\n**Best Practices:**\n- Keep callbacks lightweight\n- Delegate heavy operations to external queues\n- Avoid synchronous I/O in callbacks\n- Use `backtest` flag to skip expensive operations during backtests\n\n**Performance-Conscious Example:**\n```typescript\nconst notificationQueue: Array<any> = [];\n\naddStrategy({\n  strategyName: 'efficient-strategy',\n  interval: '5m',\n  getSignal: async (symbol, when) => { /* ... */ },\n  callbacks: {\n    onOpen: (symbol, data, price, backtest) => {\n      // Fast: push to in-memory queue\n      if (!backtest) {\n        notificationQueue.push({ type: 'open', symbol, price });\n      }\n      // Slow operation deferred to background worker\n      // setImmediate(() => sendToExternalAPI(data));\n    }\n  }\n});\n\n// Background worker processes queue\nsetInterval(() => {\n  if (notificationQueue.length > 0) {\n    const batch = notificationQueue.splice(0, 10);\n    sendBatchNotifications(batch); // Async, non-blocking\n  }\n}, 1000);\n```\n\n**Sources:** [src/client/ClientStrategy.ts:554-1000]()"
                    },
                    {
                        "page_plan": {
                            "id": "6.4",
                            "title": "Multi-Timeframe Analysis"
                        },
                        "content": "# Multi-Timeframe Analysis\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/client/ClientStrategy.ts](src/client/ClientStrategy.ts)\n- [src/interfaces/Strategy.interface.ts](src/interfaces/Strategy.interface.ts)\n- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)\n- [test/index.mjs](test/index.mjs)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page explains how strategies can use `getCandles()` with different timeframe intervals to build comprehensive market analysis. Multi-timeframe analysis allows strategies to examine price action across multiple time scales (e.g., 1-minute, 15-minute, 1-hour) within a single signal generation function, enabling more robust trading decisions.\n\nFor general strategy development concepts, see [Strategy Development](#6). For the underlying temporal execution model that makes multi-timeframe analysis safe from look-ahead bias, see [Time Execution Engine](#3.4) and [Execution Contexts](#3.3). For signal generation basics, see [Signal Generation (getSignal)](#6.2).\n\n---\n\n## getCandles API Reference\n\nThe `getCandles()` function is the primary interface for fetching historical candle data within strategies. It automatically respects the current execution timestamp to prevent look-ahead bias.\n\n### Function Signature\n\n```typescript\ngetCandles(symbol: string, interval: string, limit: number): Promise<ICandleData[]>\n```\n\n### Parameters\n\n| Parameter | Type | Description | Example Values |\n|-----------|------|-------------|----------------|\n| `symbol` | `string` | Trading pair identifier | `\"BTCUSDT\"`, `\"ETHUSDT\"` |\n| `interval` | `string` | Candle timeframe | `\"1m\"`, `\"5m\"`, `\"15m\"`, `\"30m\"`, `\"1h\"`, `\"4h\"`, `\"1d\"` |\n| `limit` | `number` | Maximum number of candles (most recent first) | `60`, `100`, `200` |\n\n### Return Type\n\nReturns `Promise<ICandleData[]>` where `ICandleData` contains:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `timestamp` | `number` | Candle open time (Unix milliseconds) |\n| `open` | `number` | Opening price |\n| `high` | `number` | Highest price |\n| `low` | `number` | Lowest price |\n| `close` | `number` | Closing price |\n| `volume` | `number` | Trading volume |\n\n### Temporal Context Guarantees\n\n**Critical**: `getCandles()` always returns candles with `timestamp <= currentExecutionTime`. This architectural constraint makes look-ahead bias **architecturally impossible**:\n\n- ✅ Backtest mode: Returns only candles up to current iteration timestamp\n- ✅ Live mode: Returns only completed candles (never in-progress candles)\n- ✅ Multi-timeframe: All intervals automatically synchronized to same point in time\n- ✅ Same code: Identical behavior between backtest and live trading\n\n**Sources**: [README.md:187-199](), [src/interfaces/Strategy.interface.ts:144]()\n\n---\n\n## Multi-Timeframe Strategy Pattern\n\n### Basic Example\n\nThe most common pattern is to fetch multiple timeframes in the `getSignal` function and combine their analysis:\n\n```typescript\naddStrategy({\n  strategyName: 'multi-tf-strategy',\n  interval: '5m',  // Signal generation throttle (separate from analysis timeframes)\n  getSignal: async (symbol) => {\n    // Fetch multiple timeframes\n    const candles1h = await getCandles(symbol, \"1h\", 24);   // Last 24 hours\n    const candles15m = await getCandles(symbol, \"15m\", 48); // Last 12 hours\n    const candles5m = await getCandles(symbol, \"5m\", 60);   // Last 5 hours\n    const candles1m = await getCandles(symbol, \"1m\", 60);   // Last 1 hour\n\n    // Analyze higher timeframe for trend\n    const hourlyTrend = analyzeTrend(candles1h);\n    \n    // Analyze medium timeframe for momentum\n    const momentum = calculateMomentum(candles15m);\n    \n    // Use lower timeframes for entry precision\n    const entrySignal = findEntry(candles5m, candles1m);\n    \n    // Combine analysis from all timeframes\n    if (hourlyTrend === 'bullish' && momentum > 0.5 && entrySignal) {\n      return {\n        position: 'long',\n        priceTakeProfit: entrySignal.tp,\n        priceStopLoss: entrySignal.sl,\n        minuteEstimatedTime: 120,\n      };\n    }\n    \n    return null; // No signal\n  },\n});\n```\n\n**Sources**: [README.md:112-142]()\n\n### Timeframe Relationship Diagram\n\n```mermaid\ngraph TD\n    subgraph \"Strategy Execution Context\"\n        WHEN[\"ExecutionContext.when<br/>Current timestamp\"]\n    end\n    \n    subgraph \"Multi-Timeframe getCandles Calls\"\n        GET_1H[\"getCandles(symbol, '1h', 24)<br/>Returns 24 hourly candles\"]\n        GET_15M[\"getCandles(symbol, '15m', 48)<br/>Returns 48 15-min candles\"]\n        GET_5M[\"getCandles(symbol, '5m', 60)<br/>Returns 60 5-min candles\"]\n        GET_1M[\"getCandles(symbol, '1m', 60)<br/>Returns 60 1-min candles\"]\n    end\n    \n    subgraph \"Temporal Filtering\"\n        FILTER[\"All candles filtered:<br/>candle.timestamp <= when\"]\n    end\n    \n    subgraph \"Analysis Layers\"\n        TREND[\"Trend Analysis<br/>Higher timeframe (1h)<br/>Direction, strength\"]\n        MOMENTUM[\"Momentum Analysis<br/>Medium timeframe (15m)<br/>Acceleration, divergence\"]\n        ENTRY[\"Entry Timing<br/>Lower timeframes (5m, 1m)<br/>Precise entry/exit\"]\n    end\n    \n    WHEN --> GET_1H\n    WHEN --> GET_15M\n    WHEN --> GET_5M\n    WHEN --> GET_1M\n    \n    GET_1H --> FILTER\n    GET_15M --> FILTER\n    GET_5M --> FILTER\n    GET_1M --> FILTER\n    \n    FILTER --> TREND\n    FILTER --> MOMENTUM\n    FILTER --> ENTRY\n    \n    TREND --> DECISION[\"Signal Decision<br/>Combine all timeframes\"]\n    MOMENTUM --> DECISION\n    ENTRY --> DECISION\n```\n\n**Sources**: [README.md:189-198](), [src/interfaces/Strategy.interface.ts:144]()\n\n---\n\n## Execution Context and Temporal Safety\n\n### How Temporal Context Propagates\n\nThe framework uses Node.js `AsyncLocalStorage` (via `di-scoped` library) to propagate temporal context without explicit parameter passing. This ensures `getCandles()` always knows the \"current time\" regardless of call depth.\n\n```mermaid\ngraph TD\n    subgraph \"Backtest/Live Logic Layer\"\n        BACKTEST[\"BacktestLogicPrivateService<br/>or LiveLogicPrivateService\"]\n        SET_CTX[\"executionContextService.run()<br/>Sets: symbol, when, backtest\"]\n    end\n    \n    subgraph \"AsyncLocalStorage Context (di-scoped)\"\n        STORAGE[\"AsyncLocalStorage<br/>{ symbol, when, backtest }\"]\n    end\n    \n    subgraph \"Strategy Execution\"\n        STRATEGY[\"ClientStrategy.tick()<br/>Calls getSignal()\"]\n        GET_SIGNAL[\"User's getSignal function<br/>Calls getCandles()\"]\n    end\n    \n    subgraph \"Exchange Core Service\"\n        EXCHANGE_CORE[\"ExchangeCoreService.getCandles()\"]\n        READ_CTX[\"executionContextService.context<br/>Reads: when\"]\n        CLIENT_EXCH[\"ClientExchange.getCandles()\"]\n        FILTER_CANDLES[\"Filter: candle.timestamp <= when\"]\n    end\n    \n    BACKTEST --> SET_CTX\n    SET_CTX --> STORAGE\n    \n    STORAGE -.->|\"Ambient propagation\"| STRATEGY\n    STRATEGY --> GET_SIGNAL\n    GET_SIGNAL --> EXCHANGE_CORE\n    \n    EXCHANGE_CORE --> READ_CTX\n    READ_CTX --> STORAGE\n    READ_CTX --> CLIENT_EXCH\n    CLIENT_EXCH --> FILTER_CANDLES\n    \n    FILTER_CANDLES --> RETURN[\"Return filtered candles<br/>No future data\"]\n```\n\n**Key insight**: The `when` timestamp is set once at the start of each tick, then automatically available throughout the call stack. User code never needs to pass or track timestamps manually.\n\n**Sources**: [README.md:189-199](), [src/lib/services/context/ExecutionContextService.ts:1-100](), [src/client/ClientStrategy.ts:354-363]()\n\n### Temporal Filtering in Code\n\nThe temporal filtering happens at the exchange service layer. When `getCandles()` is called, the exchange service reads the current execution timestamp from context and filters results:\n\n1. **BacktestLogicPrivateService** (backtest mode) or **LiveLogicPrivateService** (live mode) sets `executionContextService.context.when` at the start of each tick\n2. User's `getSignal` function calls `getCandles(symbol, interval, limit)`\n3. **ExchangeCoreService.getCandles()** reads `executionContextService.context.when`\n4. **ClientExchange.getCandles()** fetches raw candles from exchange\n5. Framework filters: `candles.filter(c => c.timestamp <= context.when)`\n6. Returns only historical candles to user code\n\n**Sources**: [src/lib/services/context/ExecutionContextService.ts:1-50](), [src/client/ClientExchange.ts:1-200]()\n\n---\n\n## Common Multi-Timeframe Patterns\n\n### Pattern 1: Trend-Momentum-Entry Hierarchy\n\n**Use Case**: Confirm trend on higher timeframe, validate momentum on medium timeframe, time entry on lower timeframe.\n\n| Timeframe | Purpose | Typical Analysis |\n|-----------|---------|------------------|\n| `1h` or `4h` | **Trend direction** | Moving averages, trend lines, support/resistance |\n| `15m` or `30m` | **Momentum confirmation** | RSI, MACD, volume patterns |\n| `5m` or `1m` | **Entry timing** | Candlestick patterns, precise entry points |\n\n```typescript\ngetSignal: async (symbol) => {\n  const candles4h = await getCandles(symbol, \"4h\", 24);  // 4 days of trend\n  const candles15m = await getCandles(symbol, \"15m\", 48); // 12 hours momentum\n  const candles5m = await getCandles(symbol, \"5m\", 60);  // 5 hours entry\n  \n  // Higher TF: Is major trend bullish?\n  const ema50_4h = calculateEMA(candles4h, 50);\n  const trendBullish = candles4h[0].close > ema50_4h;\n  \n  // Medium TF: Is momentum building?\n  const rsi15m = calculateRSI(candles15m, 14);\n  const momentumGood = rsi15m > 50 && rsi15m < 70;\n  \n  // Lower TF: Is there a bullish engulfing pattern?\n  const entryPattern = isBullishEngulfing(candles5m);\n  \n  if (trendBullish && momentumGood && entryPattern) {\n    return { /* signal */ };\n  }\n  \n  return null;\n}\n```\n\n**Sources**: [README.md:112-142]()\n\n### Pattern 2: Multi-Timeframe Support/Resistance\n\n**Use Case**: Identify key levels across multiple timeframes for stronger support/resistance zones.\n\n```typescript\ngetSignal: async (symbol) => {\n  const candles1d = await getCandles(symbol, \"1d\", 30);  // Monthly levels\n  const candles1h = await getCandles(symbol, \"1h\", 100); // Weekly levels\n  const candles5m = await getCandles(symbol, \"5m\", 60);  // Intraday levels\n  \n  // Find support/resistance on each timeframe\n  const dailyLevels = findKeyLevels(candles1d);\n  const hourlyLevels = findKeyLevels(candles1h);\n  const currentPrice = candles5m[0].close;\n  \n  // Strong level = appears on multiple timeframes\n  const strongSupport = findConvergence(\n    dailyLevels.support,\n    hourlyLevels.support,\n    currentPrice\n  );\n  \n  if (strongSupport && isPriceNearLevel(currentPrice, strongSupport)) {\n    return {\n      position: 'long',\n      priceStopLoss: strongSupport * 0.98, // Just below support\n      priceTakeProfit: currentPrice * 1.02,\n      minuteEstimatedTime: 240,\n    };\n  }\n  \n  return null;\n}\n```\n\n### Pattern 3: Divergence Detection\n\n**Use Case**: Detect momentum divergence between price and indicators across timeframes.\n\n```typescript\ngetSignal: async (symbol) => {\n  const candles1h = await getCandles(symbol, \"1h\", 50);\n  const candles15m = await getCandles(symbol, \"15m\", 100);\n  \n  // Price making lower lows on 1h\n  const priceLowerLows = isLowerLows(candles1h);\n  \n  // RSI making higher lows on 15m (bullish divergence)\n  const rsi15m = calculateRSI(candles15m, 14);\n  const rsiHigherLows = isHigherLows(rsi15m);\n  \n  // Bullish divergence: price down, indicator up\n  if (priceLowerLows && rsiHigherLows) {\n    return { position: 'long', /* ... */ };\n  }\n  \n  return null;\n}\n```\n\n**Sources**: [README.md:112-142]()\n\n---\n\n## Performance and Caching\n\n### Candle Data Caching\n\nThe framework automatically caches candle data per execution context to avoid redundant exchange API calls:\n\n- **Within single tick**: Multiple `getCandles()` calls with same `(symbol, interval, limit)` return cached results\n- **Across ticks**: Cache is cleared between ticks to ensure fresh data\n- **Memoization key**: `${symbol}:${interval}:${limit}`\n\n### Performance Best Practices\n\n| Practice | Rationale | Example |\n|----------|-----------|---------|\n| **Store candles in variables** | Avoid redundant async calls | `const candles1h = await getCandles(...); /* reuse */` |\n| **Request appropriate limit** | Balance between data sufficiency and performance | Use 100 candles for SMA(50), not 1000 |\n| **Use standard intervals** | Leverage exchange's native timeframes | Prefer `\"1h\"` over custom aggregations |\n| **Avoid nested loops** | Minimize computational complexity | Pre-calculate indicators, don't recalculate per candle |\n\n### Rate Limiting Considerations (Live Mode)\n\nIn live trading mode, `getCandles()` makes real API calls to exchanges. Be aware of:\n\n- **Exchange rate limits**: Most exchanges limit API calls (e.g., 1200/min for Binance)\n- **Strategy interval setting**: Use appropriate `interval` in strategy schema to throttle `getSignal` calls (see [Interval Throttling](#6.5))\n- **Candle limit parameter**: Larger limits may hit rate limits faster\n- **Multiple symbols**: Each symbol makes separate API calls\n\n**Sources**: [src/client/ClientExchange.ts:1-300](), [src/client/ClientStrategy.ts:340-353]()\n\n---\n\n## Data Flow Architecture\n\n### End-to-End Data Flow\n\n```mermaid\ngraph TB\n    subgraph \"Strategy Layer\"\n        USER[\"User's getSignal function<br/>await getCandles(symbol, '1h', 24)\"]\n    end\n    \n    subgraph \"Public API Layer\"\n        PUBLIC_API[\"getCandles() function<br/>src/functions/getCandles.ts\"]\n    end\n    \n    subgraph \"Service Layer\"\n        EXEC_CTX[\"ExecutionContextService<br/>context.when (timestamp)<br/>context.backtest (boolean)\"]\n        METHOD_CTX[\"MethodContextService<br/>context.exchangeName\"]\n        EXCH_CORE[\"ExchangeCoreService<br/>getCandles(symbol, interval, limit)\"]\n    end\n    \n    subgraph \"Client Layer\"\n        EXCH_CONN[\"ExchangeConnectionService<br/>Memoized exchange instances\"]\n        CLIENT_EXCH[\"ClientExchange<br/>getCandles() implementation\"]\n    end\n    \n    subgraph \"External Integration\"\n        EXCHANGE_SCHEMA[\"IExchangeSchema<br/>User-defined getCandles<br/>(CCXT integration)\"]\n        CCXT[\"Exchange API<br/>(Binance, etc.)\"]\n    end\n    \n    subgraph \"Temporal Filtering\"\n        FILTER[\"Filter candles:<br/>timestamp <= context.when\"]\n        CACHE[\"Memoized results:<br/>symbol:interval:limit\"]\n    end\n    \n    USER --> PUBLIC_API\n    PUBLIC_API --> EXCH_CORE\n    \n    EXCH_CORE --> EXEC_CTX\n    EXCH_CORE --> METHOD_CTX\n    EXCH_CORE --> EXCH_CONN\n    \n    EXCH_CONN --> CLIENT_EXCH\n    CLIENT_EXCH --> EXCHANGE_SCHEMA\n    EXCHANGE_SCHEMA --> CCXT\n    \n    CCXT --> CLIENT_EXCH\n    CLIENT_EXCH --> FILTER\n    \n    FILTER --> EXEC_CTX\n    FILTER --> CACHE\n    CACHE --> USER\n```\n\n**Key components**:\n\n- **ExecutionContextService**: Provides temporal boundary (`when` timestamp)\n- **MethodContextService**: Provides exchange routing (`exchangeName`)\n- **ExchangeCoreService**: Orchestrates candle fetching with context\n- **ClientExchange**: Implements actual data retrieval and filtering\n- **Memoization**: Caches results by `symbol:interval:limit` key\n\n**Sources**: [src/lib/services/core/ExchangeCoreService.ts:1-100](), [src/client/ClientExchange.ts:1-300](), [src/lib/services/context/ExecutionContextService.ts:1-50]()\n\n---\n\n## Interval Throttling vs Analysis Timeframes\n\n**Important distinction**: The `interval` parameter in strategy schema (see [Interval Throttling](#6.5)) controls **how often `getSignal` is called**, while `getCandles()` timeframe parameters control **what data is analyzed**.\n\n| Concept | Purpose | Location | Example |\n|---------|---------|----------|---------|\n| **Strategy interval** | Throttles signal generation frequency | `IStrategySchema.interval` | `interval: '5m'` → getSignal called every 5 minutes |\n| **Analysis timeframes** | Specifies candle data granularity | `getCandles()` calls | `getCandles(symbol, \"1h\", 24)` → Hourly candles |\n\n### Example Configuration\n\n```typescript\naddStrategy({\n  strategyName: 'example',\n  interval: '5m',  // getSignal called every 5 minutes (throttle)\n  getSignal: async (symbol) => {\n    // But analyze multiple timeframes when called\n    const candles1h = await getCandles(symbol, \"1h\", 24);\n    const candles15m = await getCandles(symbol, \"15m\", 48);\n    const candles5m = await getCandles(symbol, \"5m\", 60);\n    \n    // ... analysis logic\n  },\n});\n```\n\nIn this example:\n- ✅ `getSignal` is called **at most** once every 5 minutes (strategy throttle)\n- ✅ When called, it analyzes 1-hour, 15-minute, AND 5-minute candles\n- ✅ All timeframes automatically synchronized to same execution timestamp\n\n**Sources**: [src/interfaces/Strategy.interface.ts:8-18](), [src/interfaces/Strategy.interface.ts:132-151](), [src/client/ClientStrategy.ts:34-42]()\n\n---\n\n## Error Handling and Edge Cases\n\n### Insufficient Historical Data\n\nWhen `limit` exceeds available historical data, `getCandles()` returns fewer candles than requested:\n\n```typescript\ngetSignal: async (symbol) => {\n  const candles = await getCandles(symbol, \"1d\", 365); // Request 1 year\n  \n  // May return fewer if exchange doesn't have 1 year history\n  if (candles.length < 100) {\n    // Not enough data for analysis\n    return null;\n  }\n  \n  // Safe to proceed\n  const sma100 = calculateSMA(candles, 100);\n  // ...\n}\n```\n\n### Incomplete Candles (Live Mode)\n\nIn live trading, the current candle is **never included** in results - only completed candles are returned:\n\n- Current time: `2025-01-15 14:32:15`\n- Fetching `getCandles(symbol, \"15m\", 10)`\n- Returns candles ending at: `2025-01-15 14:30:00` (last completed 15-minute candle)\n- **Excludes** in-progress candle from `14:30:00` to `14:45:00`\n\nThis ensures identical behavior between backtest and live modes.\n\n### Timeframe Alignment\n\nDifferent timeframes may not always align perfectly. For example:\n- 1-hour candles: `12:00`, `13:00`, `14:00`\n- 5-minute candles: `12:00`, `12:05`, `12:10`, ..., `12:55`, `13:00`\n\nThe framework handles this automatically - all intervals are aligned to their natural boundaries.\n\n**Sources**: [src/client/ClientExchange.ts:100-200](), [README.md:189-199]()\n\n---\n\n## Testing Multi-Timeframe Strategies\n\n### Backtest Mode Benefits\n\nMulti-timeframe strategies are particularly well-suited for backtesting because:\n\n1. **Deterministic**: Same execution timestamp across all `getCandles()` calls\n2. **Fast iteration**: Test years of data in seconds\n3. **No API limits**: Historical data loaded once, no rate limiting\n4. **Reproducible**: Exact same results every run\n\n### Example Test Pattern\n\n```typescript\nimport { Backtest, addStrategy, addExchange, addFrame } from 'backtest-kit';\n\n// Configure strategy with multiple timeframes\naddStrategy({\n  strategyName: 'test-multi-tf',\n  interval: '5m',\n  getSignal: async (symbol) => {\n    const candles1h = await getCandles(symbol, \"1h\", 24);\n    const candles5m = await getCandles(symbol, \"5m\", 60);\n    \n    // Test: candles should be aligned to same execution time\n    const latest1h = candles1h[0].timestamp;\n    const latest5m = candles5m[0].timestamp;\n    \n    // Both should be <= current execution time\n    // latest5m may be more recent than latest1h (finer granularity)\n    \n    // ... strategy logic\n  },\n});\n\n// Run backtest\nfor await (const event of Backtest.run('BTCUSDT', {\n  strategyName: 'test-multi-tf',\n  exchangeName: 'binance',\n  frameName: '1d-test',\n})) {\n  if (event.action === 'closed') {\n    console.log('Signal closed:', event.pnl.pnlPercentage);\n  }\n}\n```\n\n**Sources**: [README.md:145-159](), [test/e2e/other.test.mjs:1-100]()\n\n---\n\n## Best Practices Summary\n\n### ✅ Do\n\n1. **Analyze higher timeframes first**: Establish context before drilling down\n2. **Use consistent intervals**: Stick to standard intervals (`1m`, `5m`, `15m`, `1h`, `4h`, `1d`)\n3. **Cache results**: Store `getCandles()` results in variables, don't call repeatedly\n4. **Handle insufficient data**: Check `candles.length` before calculating indicators\n5. **Document timeframe choices**: Comment why each timeframe is used\n\n### ❌ Don't\n\n1. **Don't mix backtest/live logic**: Same `getSignal` function for both modes\n2. **Don't assume candle count**: Always validate `candles.length >= requiredLength`\n3. **Don't ignore temporal alignment**: Trust framework's automatic synchronization\n4. **Don't make excessive API calls**: Minimize `getCandles()` calls in live mode\n5. **Don't try to access future data**: Framework prevents this, but don't attempt workarounds\n\n### Performance Checklist\n\n- [ ] Strategy `interval` appropriately throttles signal generation\n- [ ] Candle `limit` parameters are sufficient but not excessive\n- [ ] Results stored in variables to avoid redundant calls\n- [ ] Indicators pre-calculated outside loops\n- [ ] Rate limiting considered for live trading\n\n**Sources**: [README.md:17-29](), [README.md:178-184](), [src/client/ClientStrategy.ts:340-476]()"
                    },
                    {
                        "page_plan": {
                            "id": "6.5",
                            "title": "Interval Throttling"
                        },
                        "content": "# Interval Throttling\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/client/ClientStrategy.ts](src/client/ClientStrategy.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/config/params.ts](src/config/params.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Strategy.interface.ts](src/interfaces/Strategy.interface.ts)\n- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)\n- [test/README.md](test/README.md)\n- [test/config/setup.mjs](test/config/setup.mjs)\n- [test/e2e/close.test.mjs](test/e2e/close.test.mjs)\n- [test/e2e/edge.test.mjs](test/e2e/edge.test.mjs)\n- [test/e2e/other.test.mjs](test/e2e/other.test.mjs)\n- [test/e2e/persist.test.mjs](test/e2e/persist.test.mjs)\n- [test/e2e/sanitize.test.mjs](test/e2e/sanitize.test.mjs)\n- [test/e2e/sequence.test.mjs](test/e2e/sequence.test.mjs)\n- [test/index.mjs](test/index.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis document explains the signal generation throttling mechanism that controls how frequently strategies can call `getSignal`. Throttling prevents signal spam, reduces computational load, and aligns with realistic trading frequencies.\n\nFor information about signal lifecycle and state transitions, see [Signals & Signal Lifecycle](#3.1). For details on strategy configuration, see [Strategy Schema Definition](#6.1). For multi-timeframe analysis patterns, see [Multi-Timeframe Analysis](#6.4).\n\n## Purpose and Scope\n\nInterval throttling is a core mechanism that enforces minimum time between `getSignal` invocations. This document covers:\n\n- Available `SignalInterval` types and their durations\n- Implementation details in `ClientStrategy`\n- How throttling differs from signal queue processing\n- Best practices for interval selection\n- Performance implications and debugging strategies\n\n## SignalInterval Types\n\nThe framework provides six standard intervals for throttling signal generation:\n\n| Interval | Minutes | Milliseconds | Typical Use Case |\n|----------|---------|--------------|------------------|\n| `\"1m\"` | 1 | 60,000 | High-frequency strategies, scalping |\n| `\"3m\"` | 3 | 180,000 | Short-term momentum trading |\n| `\"5m\"` | 5 | 300,000 | Intraday trading strategies |\n| `\"15m\"` | 15 | 900,000 | Swing trading setups |\n| `\"30m\"` | 30 | 1,800,000 | Position trading entries |\n| `\"1h\"` | 60 | 3,600,000 | Long-term trend following |\n\nThese intervals are defined as a union type in the type system:\n\n```typescript\ntype SignalInterval = \"1m\" | \"3m\" | \"5m\" | \"15m\" | \"30m\" | \"1h\";\n```\n\n**Sources**: [types.d.ts:12-18](), [src/interfaces/Strategy.interface.ts:12-18]()\n\n## Throttling Architecture\n\n### Component Overview\n\n```mermaid\ngraph TD\n    A[\"IStrategySchema\"] -->|\"interval property\"| B[\"ClientStrategy\"]\n    B -->|\"maintains\"| C[\"_lastSignalTimestamp\"]\n    B -->|\"uses\"| D[\"INTERVAL_MINUTES<br/>conversion table\"]\n    E[\"tick() method\"] -->|\"checks\"| C\n    C -->|\"elapsed time<br/>< intervalMs\"| F[\"Return null<br/>(throttled)\"]\n    C -->|\"elapsed time<br/>>= intervalMs\"| G[\"Call getSignal()\"]\n    G -->|\"updates\"| C\n    D -->|\"converts to ms\"| H[\"intervalMs\"]\n    H -->|\"used in\"| F\n```\n\n**Sources**: [src/client/ClientStrategy.ts:34-41](), [src/client/ClientStrategy.ts:332-476]()\n\n### State Management\n\nEach `ClientStrategy` instance maintains a private timestamp field to track when `getSignal` was last invoked:\n\n```typescript\n// Internal state (not exposed in interface)\nprivate _lastSignalTimestamp: number | null = null;\n```\n\nThis timestamp is checked on every `tick()` call before invoking the user-defined `getSignal` function.\n\n**Sources**: [src/client/ClientStrategy.ts]()\n\n## Implementation Details\n\n### Interval Conversion Table\n\nThe framework maintains a constant mapping from string intervals to numeric minutes:\n\n```typescript\nconst INTERVAL_MINUTES: Record<SignalInterval, number> = {\n  \"1m\": 1,\n  \"3m\": 3,\n  \"5m\": 5,\n  \"15m\": 15,\n  \"30m\": 30,\n  \"1h\": 60,\n};\n```\n\nThis table is used to convert the user-specified interval into milliseconds for timestamp comparison.\n\n**Sources**: [src/client/ClientStrategy.ts:34-41]()\n\n### Throttling Logic Flow\n\n```mermaid\nsequenceDiagram\n    participant TC as tick() caller\n    participant CS as ClientStrategy\n    participant TSC as _lastSignalTimestamp\n    participant GS as getSignal (user code)\n    \n    TC->>CS: tick(symbol, strategyName)\n    CS->>CS: Get currentTime\n    CS->>TSC: Read _lastSignalTimestamp\n    \n    alt First call (_lastSignalTimestamp === null)\n        CS->>TSC: Set _lastSignalTimestamp = currentTime\n        CS->>GS: Call getSignal()\n        GS-->>CS: Return ISignalDto or null\n        CS-->>TC: Return signal result\n    else Throttle check (timestamp exists)\n        CS->>CS: Calculate elapsed = currentTime - _lastSignalTimestamp\n        CS->>CS: Calculate intervalMs from INTERVAL_MINUTES\n        \n        alt elapsed < intervalMs (throttled)\n            CS-->>TC: Return null (skipped)\n        else elapsed >= intervalMs (allowed)\n            CS->>TSC: Update _lastSignalTimestamp = currentTime\n            CS->>GS: Call getSignal()\n            GS-->>CS: Return ISignalDto or null\n            CS-->>TC: Return signal result\n        end\n    end\n```\n\n**Sources**: [src/client/ClientStrategy.ts:332-353]()\n\n### Actual Implementation Code\n\nThe throttling check occurs in the `GET_SIGNAL_FN` function before calling the user's `getSignal`:\n\n```typescript\nconst currentTime = self.params.execution.context.when.getTime();\n{\n  const intervalMinutes = INTERVAL_MINUTES[self.params.interval];\n  const intervalMs = intervalMinutes * 60 * 1000;\n\n  // Check if enough time has passed since last getSignal\n  if (\n    self._lastSignalTimestamp !== null &&\n    currentTime - self._lastSignalTimestamp < intervalMs\n  ) {\n    return null; // Throttled - skip this tick\n  }\n\n  self._lastSignalTimestamp = currentTime;\n}\n```\n\n**Key Behaviors**:\n1. First call is never throttled (`_lastSignalTimestamp === null`)\n2. Timestamp is updated **before** calling `getSignal`, not after\n3. Throttled ticks return `null` immediately without executing strategy logic\n4. Error in `getSignal` doesn't prevent timestamp update (prevents retry storms)\n\n**Sources**: [src/client/ClientStrategy.ts:340-353]()\n\n## Throttling vs Signal Queue\n\nInterval throttling and signal queue processing are distinct mechanisms with different purposes:\n\n| Aspect | Interval Throttling | Signal Queue Processing |\n|--------|---------------------|------------------------|\n| **Purpose** | Control `getSignal` invocation frequency | Ensure sequential signal execution |\n| **Scope** | Controls when strategy logic runs | Controls signal activation order |\n| **State** | `_lastSignalTimestamp` | `_pendingSignal` / `_scheduledSignal` |\n| **User Control** | Configured via `interval` property | Automatic (not configurable) |\n| **Applies To** | Signal generation phase | Signal execution phase |\n| **Bypass Possible** | No | No |\n\n### Example Scenario\n\n```mermaid\ngraph TD\n    A[\"Minute 0\"] --> B[\"getSignal() called\"]\n    B --> C[\"Signal #1 generated\"]\n    C --> D[\"Signal #1 scheduled\"]\n    \n    E[\"Minute 1-4\"] --> F[\"getSignal() throttled\"]\n    F --> G[\"No new signal\"]\n    \n    H[\"Minute 5\"] --> I[\"getSignal() called\"]\n    I --> J[\"Signal #2 generated\"]\n    J --> K{\"Signal #1<br/>still active?\"}\n    K -->|Yes| L[\"Signal #2 queued<br/>(waits for #1)\"]\n    K -->|No| M[\"Signal #2 activated<br/>immediately\"]\n    \n    style F fill:#f9f9f9\n    style G fill:#f9f9f9\n```\n\nEven with throttling allowing a new `getSignal` call, the new signal waits if a previous signal is still active. Both mechanisms work together to ensure controlled, sequential signal processing.\n\n**Sources**: [src/client/ClientStrategy.ts:332-476](), test examples in [test/README.md:1-674]()\n\n## Configuration in Strategy Schema\n\n### Required Property\n\nThe `interval` is a required field in `IStrategySchema`:\n\n```typescript\ninterface IStrategySchema {\n  strategyName: StrategyName;\n  interval: SignalInterval; // Required - no default value\n  getSignal: (symbol: string, when: Date) => Promise<ISignalDto | null>;\n  callbacks?: Partial<IStrategyCallbacks>;\n  // ... other properties\n}\n```\n\n**Sources**: [types.d.ts:728-747](), [src/interfaces/Strategy.interface.ts:132-151]()\n\n### Basic Example\n\n```typescript\nimport { addStrategy } from \"backtest-kit\";\n\naddStrategy({\n  strategyName: \"momentum-5m\",\n  interval: \"5m\", // getSignal called max once per 5 minutes\n  getSignal: async (symbol, when) => {\n    const candles = await getCandles(symbol, \"5m\", 20);\n    \n    // Strategy logic using 5-minute candles\n    const momentum = calculateMomentum(candles);\n    \n    if (momentum > THRESHOLD) {\n      return {\n        position: \"long\",\n        priceTakeProfit: candles[0].close * 1.02,\n        priceStopLoss: candles[0].close * 0.98,\n        minuteEstimatedTime: 60,\n      };\n    }\n    \n    return null;\n  }\n});\n```\n\n**Sources**: [src/function/add.ts]() (addStrategy function)\n\n## Choosing the Right Interval\n\n### Decision Tree\n\n```mermaid\ngraph TD\n    A[\"Select Interval\"] --> B{\"What timeframe candles<br/>does getSignal analyze?\"}\n    \n    B -->|\"1m candles\"| C{\"High-frequency<br/>strategy?\"}\n    C -->|Yes| D[\"Use '1m' interval\"]\n    C -->|No| E[\"Use '3m' or '5m'<br/>(reduce load)\"]\n    \n    B -->|\"5m candles\"| F{\"Need immediate<br/>reaction to close?\"}\n    F -->|Yes| G[\"Use '5m' interval\"]\n    F -->|No| H[\"Use '15m' interval<br/>(wait for confirmation)\"]\n    \n    B -->|\"15m candles\"| I[\"Use '15m' interval\"]\n    B -->|\"1h candles\"| J[\"Use '1h' interval\"]\n    \n    K[\"Multi-timeframe<br/>analysis\"] --> L[\"Use longest<br/>timeframe interval\"]\n    \n    style D fill:#e1f5ff\n    style G fill:#e1f5ff\n    style I fill:#e1f5ff\n    style J fill:#e1f5ff\n```\n\n**Sources**: Pattern analysis from [src/client/ClientStrategy.ts:34-41]()\n\n### Selection Guidelines\n\n| Strategy Type | Recommended Interval | Reasoning |\n|--------------|---------------------|-----------|\n| **Scalping** | `\"1m\"` | Requires immediate reaction to price movements |\n| **Short-term Momentum** | `\"3m\"` - `\"5m\"` | Balances responsiveness with noise filtering |\n| **Intraday Swing** | `\"5m\"` - `\"15m\"` | Reduces computational load, prevents over-trading |\n| **Daily Swing** | `\"15m\"` - `\"30m\"` | Longer-term confirmation, fewer signals |\n| **Position Trading** | `\"1h\"` | Infrequent entries, long holding periods |\n\n**Rule of Thumb**: Match your throttling interval to your analysis timeframe. If you analyze 15-minute candles, use a `\"15m\"` interval.\n\n**Sources**: Best practices derived from system design\n\n### Common Anti-Patterns\n\n**❌ Anti-Pattern: Mismatched Intervals**\n\n```typescript\n// BAD: Analyzing 15m candles but checking every 1m\naddStrategy({\n  interval: \"1m\", // Too frequent!\n  getSignal: async (symbol, when) => {\n    const candles = await getCandles(symbol, \"15m\", 50);\n    // Same 15m candles fetched 15 times unnecessarily\n    return analyzeCandles(candles);\n  }\n});\n```\n\n**Issues**:\n- Wastes API calls (same data fetched 15 times)\n- Unnecessary CPU usage (same analysis repeated)\n- No benefit (15m candles don't change every minute)\n\n**✅ Correct Pattern: Matched Intervals**\n\n```typescript\n// GOOD: Match interval to analysis timeframe\naddStrategy({\n  interval: \"15m\", // Matches candle interval\n  getSignal: async (symbol, when) => {\n    const candles = await getCandles(symbol, \"15m\", 50);\n    // Fresh candles fetched once per 15 minutes\n    return analyzeCandles(candles);\n  }\n});\n```\n\n**Sources**: [src/function/exchange.ts]() (getCandles implementation)\n\n**❌ Anti-Pattern: Over-Throttling**\n\n```typescript\n// BAD: 1h interval for scalping strategy\naddStrategy({\n  interval: \"1h\", // Too slow!\n  getSignal: async (symbol, when) => {\n    const candles = await getCandles(symbol, \"1m\", 10);\n    // Scalping logic needs immediate reaction\n    return findScalpEntry(candles);\n  }\n});\n```\n\n**Issues**:\n- Misses short-term opportunities (checked once per hour)\n- Doesn't match strategy's time horizon\n- Likely to enter after optimal moment\n\n**Sources**: System design patterns\n\n## Performance Implications\n\n### Computational Cost Table\n\nThe throttling interval directly controls the number of `getSignal` invocations:\n\n| Interval | Calls per Hour | Calls per Day | Calls per Week | Relative Load |\n|----------|----------------|---------------|----------------|---------------|\n| `\"1m\"` | 60 | 1,440 | 10,080 | 100% |\n| `\"3m\"` | 20 | 480 | 3,360 | 33% |\n| `\"5m\"` | 12 | 288 | 2,016 | 20% |\n| `\"15m\"` | 4 | 96 | 672 | 6.7% |\n| `\"30m\"` | 2 | 48 | 336 | 3.3% |\n| `\"1h\"` | 1 | 24 | 168 | 1.7% |\n\n**Example Portfolio Analysis**:\n- **10 strategies with `\"5m\"` interval**: 10 × 288 = 2,880 calls/day\n- **Same portfolio with `\"15m\"`**: 10 × 96 = 960 calls/day (**66% reduction**)\n- **Same portfolio with `\"1h\"`**: 10 × 24 = 240 calls/day (**92% reduction**)\n\n**Sources**: Calculated from [src/client/ClientStrategy.ts:34-41]()\n\n### Backtest Performance\n\nIn backtest mode, throttling still applies and significantly affects execution time:\n\n```mermaid\ngraph LR\n    A[\"1-day backtest<br/>(1440 minutes)\"] --> B[\"1m interval<br/>1440 getSignal calls\"]\n    A --> C[\"5m interval<br/>288 getSignal calls\"]\n    A --> D[\"1h interval<br/>24 getSignal calls\"]\n    \n    B --> E[\"Slowest<br/>(100% baseline)\"]\n    C --> F[\"5× faster<br/>(20% of baseline)\"]\n    D --> G[\"60× faster<br/>(1.7% of baseline)\"]\n```\n\nFor a 30-day backtest analyzing 20 symbols:\n- `\"1m\"` interval: 30 × 1,440 × 20 = 864,000 calls\n- `\"5m\"` interval: 30 × 288 × 20 = 172,800 calls\n- `\"15m\"` interval: 30 × 96 × 20 = 57,600 calls\n\n**Sources**: [src/lib/services/logic/private/BacktestLogicPrivateService.ts]()\n\n### Network and API Impact\n\nWhen using external data sources (e.g., CCXT exchange APIs), throttling reduces API call frequency:\n\n| Interval | Potential API Calls (if getCandles in every getSignal) |\n|----------|--------------------------------------------------------|\n| `\"1m\"` | 1,440 per day per symbol |\n| `\"5m\"` | 288 per day per symbol |\n| `\"1h\"` | 24 per day per symbol |\n\nMost exchanges have rate limits (e.g., Binance: 1,200 requests/minute). Proper throttling prevents hitting these limits.\n\n**Sources**: Integration patterns from [src/interfaces/Exchange.interface.ts:122-155]()\n\n## Live Trading Behavior\n\n### Real-Time Throttling Loop\n\nIn live mode, the execution loop calls `tick()` approximately every minute, but throttling controls `getSignal` invocation:\n\n```mermaid\nsequenceDiagram\n    participant L as LiveLogicPrivateService\n    participant SC as StrategyCoreService\n    participant CS as ClientStrategy\n    participant GS as getSignal (user code)\n    \n    Note over L: Infinite loop with sleep\n    \n    loop Every ~1 minute\n        L->>L: when = new Date()\n        L->>SC: tick(symbol, strategyName, when)\n        SC->>CS: tick()\n        \n        alt Throttled (< 5m elapsed)\n            CS->>CS: Check timestamp\n            CS-->>SC: null (throttled)\n            SC-->>L: IStrategyTickResult (idle/active)\n        else Allowed (>= 5m elapsed)\n            CS->>GS: Call getSignal()\n            GS-->>CS: ISignalDto or null\n            CS-->>SC: IStrategyTickResult\n            SC-->>L: Result\n        end\n        \n        L->>L: await sleep(TICK_TTL)\n    end\n```\n\n**Example Timeline** (5-minute interval):\n- 10:00:00 → `tick()` called → `getSignal()` executed\n- 10:01:00 → `tick()` called → Throttled (skipped)\n- 10:02:00 → `tick()` called → Throttled (skipped)\n- 10:03:00 → `tick()` called → Throttled (skipped)\n- 10:04:00 → `tick()` called → Throttled (skipped)\n- 10:05:00 → `tick()` called → `getSignal()` executed\n\n**Sources**: [src/lib/services/logic/private/LiveLogicPrivateService.ts]()\n\n### Error Handling and Throttling\n\nIf `getSignal` throws an error, the timestamp is **still updated** to prevent error cascade loops:\n\n```typescript\nconst GET_SIGNAL_FN = trycatch(\n  async (self: ClientStrategy) => {\n    // Update timestamp BEFORE calling getSignal\n    self._lastSignalTimestamp = currentTime;\n    \n    const signal = await self.params.getSignal(/* ... */);\n    // If this throws, next tick is still throttled\n    // (prevents rapid error retry loop)\n  },\n  {\n    defaultValue: null,\n    fallback: (error) => {\n      errorEmitter.next(error); // Log error\n    }\n  }\n);\n```\n\n**Behavior**:\n- Failed `getSignal` call counts toward throttle interval\n- Prevents infinite error retry loops\n- Strategy gets another chance after interval expires\n- Errors are logged via `errorEmitter` for monitoring\n\n**Sources**: [src/client/ClientStrategy.ts:332-476]()\n\n## Interaction with Fast Backtest\n\n### Throttling During Signal Generation\n\nDuring normal ticking (signal generation phase), throttling applies:\n\n```mermaid\ngraph LR\n    A[\"tick() called<br/>every minute\"] --> B{\"Throttle<br/>check\"}\n    B -->|\"< interval\"| C[\"Return null<br/>(skip getSignal)\"]\n    B -->|\">= interval\"| D[\"Call getSignal()\"]\n    D --> E[\"Signal generated\"]\n```\n\n### No Throttling During Signal Monitoring\n\nOnce a signal is active, the \"fast backtest\" mode processes candles **without throttling**:\n\n```mermaid\ngraph TD\n    A[\"Signal opened\"] --> B[\"Enter fast backtest mode\"]\n    B --> C[\"Process ALL candles<br/>for TP/SL/time check\"]\n    C --> D[\"Check EVERY candle\"]\n    D --> E{\"TP/SL/time<br/>reached?\"}\n    E -->|No| D\n    E -->|Yes| F[\"Signal closed\"]\n    F --> G[\"Exit fast backtest\"]\n    G --> H[\"Return to normal ticking<br/>(throttled)\"]\n```\n\n**Key Point**: Throttling only applies to **signal generation**, not signal monitoring. Once a signal is active, every candle is checked for TP/SL/time_expired conditions.\n\n**Sources**: [src/client/ClientStrategy.ts:1204-1447]() (backtest method)\n\n## Advanced Patterns\n\n### Conditional Signal Generation\n\nWhile you cannot dynamically change the `interval` at runtime, you can implement conditional logic inside `getSignal` to achieve similar effects:\n\n```typescript\naddStrategy({\n  strategyName: \"adaptive-volatility\",\n  interval: \"1m\", // Minimum check frequency\n  getSignal: async (symbol, when) => {\n    const candles = await getCandles(symbol, \"1m\", 20);\n    const volatility = calculateVolatility(candles);\n    \n    // Effective throttling via application logic\n    if (volatility < LOW_VOLATILITY_THRESHOLD) {\n      return null; // Skip during calm markets\n    }\n    \n    // Only generate signals during high volatility\n    return analyzeTrend(candles);\n  }\n});\n```\n\n**Benefits**:\n- Uses `\"1m\"` for quick reaction when needed\n- Skips computation during unfavorable conditions\n- Effectively creates dynamic throttling via `return null`\n\n**Sources**: Pattern derived from [src/interfaces/Strategy.interface.ts:144]()\n\n### Multi-Timeframe Interval Selection\n\nFor strategies analyzing multiple timeframes, use the **longest** timeframe as the interval:\n\n```typescript\naddStrategy({\n  strategyName: \"multi-timeframe-trend\",\n  interval: \"15m\", // Matches longest analyzed timeframe\n  getSignal: async (symbol, when) => {\n    // Fetch multiple timeframes\n    const candles1m = await getCandles(symbol, \"1m\", 100);\n    const candles5m = await getCandles(symbol, \"5m\", 50);\n    const candles15m = await getCandles(symbol, \"15m\", 20);\n    \n    // Analyze all timeframes (called once per 15 minutes)\n    const shortTrend = analyzeTrend(candles1m);\n    const mediumTrend = analyzeTrend(candles5m);\n    const longTrend = analyzeTrend(candles15m);\n    \n    // Generate signal only if all timeframes align\n    if (shortTrend === \"up\" && mediumTrend === \"up\" && longTrend === \"up\") {\n      return { /* ... */ };\n    }\n    \n    return null;\n  }\n});\n```\n\n**Reasoning**:\n- 15-minute candles only change every 15 minutes\n- Calling `getSignal` more frequently (e.g., every 1m) wastes resources\n- Lower timeframes (1m, 5m) are fetched fresh each time\n- Prevents redundant analysis of unchanged 15m data\n\n**Sources**: [src/function/exchange.ts]() (getCandles implementation)\n\n## Debugging Throttling Issues\n\n### Common Symptoms and Solutions\n\n| Symptom | Likely Cause | Solution |\n|---------|-------------|----------|\n| Signal never appears | Interval too long OR previous signal active | Check `_lastSignalTimestamp` and `_pendingSignal` |\n| Too many API calls | Interval too short for strategy type | Increase interval to match analysis timeframe |\n| Delayed entries | Interval too long for market conditions | Decrease interval OR adjust strategy logic |\n| Backtest too slow | `\"1m\"` interval on long timeframe | Increase interval (e.g., `\"5m\"` or `\"15m\"`) |\n\n**Sources**: Analysis of common patterns\n\n### Diagnostic Logging\n\nAdd logging to observe throttling behavior:\n\n```typescript\naddStrategy({\n  strategyName: \"debug-throttle\",\n  interval: \"5m\",\n  getSignal: async (symbol, when) => {\n    console.log(`[${when.toISOString()}] getSignal CALLED`);\n    // Strategy logic...\n  },\n  callbacks: {\n    onTick: (symbol, result, backtest) => {\n      console.log(`[${new Date().toISOString()}] tick: ${result.action}`);\n    }\n  }\n});\n```\n\n**Expected Output** (5-minute interval):\n```\n[2024-01-01T10:00:00Z] tick: idle\n[2024-01-01T10:00:00Z] getSignal CALLED\n[2024-01-01T10:01:00Z] tick: idle\n[2024-01-01T10:02:00Z] tick: idle\n[2024-01-01T10:03:00Z] tick: idle\n[2024-01-01T10:04:00Z] tick: idle\n[2024-01-01T10:05:00Z] tick: idle\n[2024-01-01T10:05:00Z] getSignal CALLED\n```\n\nNotice `onTick` is called every minute, but `getSignal` is only called every 5 minutes.\n\n**Sources**: [types.d.ts:700-723]() (IStrategyCallbacks interface)\n\n## Best Practices Summary\n\n### Core Principles\n\n1. **Match Interval to Analysis Timeframe**: If your strategy analyzes 15-minute candles, use `\"15m\"` interval\n2. **Start Conservative**: Begin with longer intervals (e.g., `\"15m\"`), optimize downward only if needed\n3. **Consider Computational Cost**: Each interval reduction multiplies load (1m → 5m = 5× load increase)\n4. **Use `\"1m\"` Sparingly**: Reserve for truly high-frequency strategies that need immediate reaction\n5. **Document Rationale**: Add comments explaining your interval choice for future maintainers\n\n### Checklist for Interval Selection\n\n- [ ] Identified longest timeframe analyzed in `getSignal`\n- [ ] Set `interval` to match or exceed that timeframe\n- [ ] Verified strategy logic doesn't assume every-minute execution\n- [ ] Tested performance with chosen interval in backtest\n- [ ] Considered API rate limits if using external data sources\n- [ ] Added logging to verify throttling behavior\n- [ ] Documented interval choice in strategy `note` field\n\n**Sources**: System design analysis from [src/client/ClientStrategy.ts:34-41](), [types.d.ts:12-18]()"
                    },
                    {
                        "page_plan": {
                            "id": "7",
                            "title": "Risk Management"
                        },
                        "content": "# Risk Management\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/config/params.ts](src/config/params.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [test/README.md](test/README.md)\n- [test/config/setup.mjs](test/config/setup.mjs)\n- [test/e2e/close.test.mjs](test/e2e/close.test.mjs)\n- [test/e2e/edge.test.mjs](test/e2e/edge.test.mjs)\n- [test/e2e/other.test.mjs](test/e2e/other.test.mjs)\n- [test/e2e/persist.test.mjs](test/e2e/persist.test.mjs)\n- [test/e2e/sanitize.test.mjs](test/e2e/sanitize.test.mjs)\n- [test/e2e/sequence.test.mjs](test/e2e/sequence.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document describes the risk management system in Backtest Kit, which validates trading signals before execution and enforces portfolio-wide limits. The risk system operates at two levels: **signal-level validation** (price logic, TP/SL distances, lifetime limits) and **portfolio-level validation** (concurrent position limits, exposure constraints).\n\nFor strategy development patterns, see [Strategy Development](#6). For signal lifecycle details, see [Signals & Signal Lifecycle](#3.1). For position sizing calculations, see [Position Sizing](#7.3).\n\n## Risk Management Architecture\n\nThe risk system integrates into the signal lifecycle as a **pre-execution validation gate**. All signals pass through validation before being scheduled or opened, ensuring that only compliant signals reach the market.\n\n```mermaid\ngraph TB\n    GS[\"getSignal()\"]\n    VS[\"validateSignal()\"]\n    RC[\"checkSignal()\"]\n    RV[\"Custom Validations\"]\n    RS[\"Risk State Tracking\"]\n    SCHED[\"Scheduled Signal\"]\n    OPEN[\"Opened Signal\"]\n    REJ[\"Rejected Signal\"]\n    \n    GS -->|\"Returns ISignalDto\"| VS\n    VS -->|\"Multi-stage checks\"| VS_PRICE[\"Price Validation\"]\n    VS_PRICE -->|\"GLOBAL_CONFIG rules\"| VS_TPSL[\"TP/SL Logic\"]\n    VS_TPSL -->|\"Distance checks\"| VS_LIFE[\"Lifetime Limits\"]\n    \n    VS_LIFE -->|\"Pass\"| RC\n    VS_LIFE -->|\"Fail\"| REJ\n    \n    RC -->|\"IRiskCheckArgs\"| RV\n    RV -->|\"Custom checks\"| RS\n    \n    RS -->|\"Portfolio limits OK\"| DECISION{{\"priceOpen specified?\"}}\n    RS -->|\"Limit exceeded\"| REJ\n    \n    DECISION -->|\"Yes\"| SCHED\n    DECISION -->|\"No\"| OPEN\n    \n    REJ -->|\"Emit\"| RISK_EVENT[\"riskSubject\"]\n    \n    style VS fill:#fff3cd\n    style RC fill:#ffe1e1\n    style REJ fill:#ffcccc\n```\n\n**Sources:** [types.d.ts:342-479](), [src/config/params.ts:1-122](), [src/config/emitters.ts:131]()\n\n---\n\n## Risk Schema Definition\n\nRisk profiles are defined using `IRiskSchema` and registered via `addRisk()`. Each profile contains custom validation logic executed before signals are scheduled or opened.\n\n### IRiskSchema Interface\n\n```typescript\ninterface IRiskSchema {\n  riskName: RiskName;                               // Unique identifier\n  note?: string;                                    // Documentation\n  callbacks?: Partial<IRiskCallbacks>;              // Event handlers\n  validations: (IRiskValidation | IRiskValidationFn)[]; // Validation rules\n}\n```\n\n### IRiskValidation Structure\n\n```typescript\ninterface IRiskValidation {\n  validate: IRiskValidationFn;  // Validation function\n  note?: string;                 // Reason for rejection (logged)\n}\n\ninterface IRiskValidationFn {\n  (payload: IRiskValidationPayload): void | Promise<void>;\n  // Throws error to reject signal\n}\n```\n\n### IRiskValidationPayload\n\nThe validation payload provides complete context for risk decisions:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `symbol` | `string` | Trading pair (e.g., \"BTCUSDT\") |\n| `pendingSignal` | `ISignalDto` | Signal awaiting validation |\n| `strategyName` | `StrategyName` | Source strategy identifier |\n| `exchangeName` | `ExchangeName` | Target exchange |\n| `currentPrice` | `number` | Current VWAP price |\n| `timestamp` | `number` | Validation timestamp (ms) |\n| `activePositionCount` | `number` | Total active signals across all strategies |\n| `activePositions` | `IRiskActivePosition[]` | Details of active positions |\n\n**Sources:** [types.d.ts:382-390](), [types.d.ts:359-369]()\n\n---\n\n## Multi-Stage Signal Validation Pipeline\n\nBefore risk profile validation, signals pass through a **7-stage validation pipeline** enforced by `GLOBAL_CONFIG` parameters. This pipeline catches common errors and ensures signals meet minimum quality thresholds.\n\n```mermaid\ngraph LR\n    START[\"ISignalDto from getSignal()\"]\n    V1[\"1. Price Positivity\"]\n    V2[\"2. TP/SL Logic\"]\n    V3[\"3. TP Distance\"]\n    V4[\"4. SL Min Distance\"]\n    V5[\"5. SL Max Distance\"]\n    V6[\"6. Lifetime Limit\"]\n    V7[\"7. Candle Anomaly\"]\n    RISK[\"8. Custom Risk Validations\"]\n    PASS[\"Signal Accepted\"]\n    FAIL[\"Signal Rejected\"]\n    \n    START --> V1\n    V1 -->|\"Prices > 0, finite, not NaN\"| V2\n    V1 -.->|\"Fail\"| FAIL\n    \n    V2 -->|\"LONG: TP>open>SL<br/>SHORT: SL>open>TP\"| V3\n    V2 -.->|\"Fail\"| FAIL\n    \n    V3 -->|\"TP distance >= CC_MIN_TAKEPROFIT_DISTANCE_PERCENT\"| V4\n    V3 -.->|\"Fail\"| FAIL\n    \n    V4 -->|\"SL distance >= CC_MIN_STOPLOSS_DISTANCE_PERCENT\"| V5\n    V4 -.->|\"Fail\"| FAIL\n    \n    V5 -->|\"SL distance <= CC_MAX_STOPLOSS_DISTANCE_PERCENT\"| V6\n    V5 -.->|\"Fail\"| FAIL\n    \n    V6 -->|\"minuteEstimatedTime <= CC_MAX_SIGNAL_LIFETIME_MINUTES\"| V7\n    V6 -.->|\"Fail\"| FAIL\n    \n    V7 -->|\"No anomalous candle prices\"| RISK\n    V7 -.->|\"Fail\"| FAIL\n    \n    RISK -->|\"All validations pass\"| PASS\n    RISK -.->|\"Any throws\"| FAIL\n    \n    style FAIL fill:#ffcccc\n    style PASS fill:#ccffcc\n```\n\n**Sources:** [src/config/params.ts:26-55](), [test/e2e/sanitize.test.mjs:1-500]()\n\n### Validation Stage Details\n\n#### 1. Price Positivity Check\nEnsures all prices are positive, finite numbers:\n```typescript\npriceOpen > 0 && isFinite(priceOpen)\npriceTakeProfit > 0 && isFinite(priceTakeProfit)\npriceStopLoss > 0 && isFinite(priceStopLoss)\n```\n\n#### 2. TP/SL Logic Validation\nEnforces correct price ordering for LONG and SHORT positions:\n\n| Position | Required Logic | Rationale |\n|----------|----------------|-----------|\n| LONG | `priceTakeProfit > priceOpen > priceStopLoss` | Buy low, sell higher (TP), cut losses (SL) |\n| SHORT | `priceStopLoss > priceOpen > priceTakeProfit` | Sell high, buy lower (TP), cut losses (SL) |\n\n#### 3. Minimum TP Distance (`CC_MIN_TAKEPROFIT_DISTANCE_PERCENT`)\nDefault: **0.5%**\n\nEnsures TP is far enough from `priceOpen` to cover transaction costs:\n- Slippage: ~0.2% (0.1% entry + 0.1% exit)\n- Fees: 0.2% (0.1% entry + 0.1% exit)\n- Minimum profit buffer: 0.1%\n- **Total required: 0.5%**\n\n**Example rejection:**\n```typescript\n// priceOpen = 42000, priceTakeProfit = 42010\n// Distance = 0.024% < 0.5% → REJECTED\n// After fees/slippage, this would be a loss!\n```\n\n**Sources:** [src/config/params.ts:26-36](), [test/e2e/sanitize.test.mjs:27-122]()\n\n#### 4. Minimum SL Distance (`CC_MIN_STOPLOSS_DISTANCE_PERCENT`)\nDefault: **0.5%**\n\nPrevents signals from being immediately stopped out by normal price volatility. SL must be at least 0.5% away from `priceOpen`.\n\n#### 5. Maximum SL Distance (`CC_MAX_STOPLOSS_DISTANCE_PERCENT`)\nDefault: **20%**\n\nCaps catastrophic losses from extreme SL values. A single signal cannot risk more than 20% of the position.\n\n**Example rejection:**\n```typescript\n// priceOpen = 42000, priceStopLoss = 20000 (LONG)\n// Distance = -52.4% < -20% → REJECTED\n// One signal could lose half the portfolio!\n```\n\n**Sources:** [src/config/params.ts:42-49](), [test/e2e/sanitize.test.mjs:134-229]()\n\n#### 6. Lifetime Limit (`CC_MAX_SIGNAL_LIFETIME_MINUTES`)\nDefault: **1440 minutes (1 day)**\n\nPrevents \"eternal signals\" that block risk limits indefinitely:\n```typescript\n// minuteEstimatedTime = 50000 minutes (34 days)\n// Exceeds 1440 minute limit → REJECTED\n```\n\n**Sources:** [src/config/params.ts:51-55](), [test/e2e/sanitize.test.mjs:241-329]()\n\n#### 7. Candle Data Anomaly Detection\nValidates that historical candle data contains no anomalous prices (e.g., incomplete candles with near-zero prices from API glitches). Uses `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR` (default: 1000) to detect outliers.\n\n**Sources:** [src/config/params.ts:76-104]()\n\n---\n\n## Custom Risk Validations\n\nAfter passing `GLOBAL_CONFIG` checks, signals proceed to **custom risk validations** defined in `IRiskSchema`. These validations enforce strategy-specific or portfolio-wide constraints.\n\n### Basic Risk Profile Example\n\n```typescript\nimport { addRisk } from 'backtest-kit';\n\naddRisk({\n  riskName: 'conservative',\n  validations: [\n    // Minimum 1% TP distance\n    ({ pendingSignal, currentPrice }) => {\n      const { priceOpen = currentPrice, priceTakeProfit, position } = pendingSignal;\n      const tpDistance = position === 'long' \n        ? ((priceTakeProfit - priceOpen) / priceOpen) * 100\n        : ((priceOpen - priceTakeProfit) / priceOpen) * 100;\n      \n      if (tpDistance < 1.0) {\n        throw new Error(`TP too close: ${tpDistance.toFixed(2)}%`);\n      }\n    },\n    \n    // Minimum 2:1 reward/risk ratio\n    {\n      validate: ({ pendingSignal, currentPrice }) => {\n        const { priceOpen = currentPrice, priceTakeProfit, priceStopLoss, position } = pendingSignal;\n        const reward = position === 'long'\n          ? priceTakeProfit - priceOpen\n          : priceOpen - priceTakeProfit;\n        const risk = position === 'long'\n          ? priceOpen - priceStopLoss\n          : priceStopLoss - priceOpen;\n        \n        if (reward / risk < 2.0) {\n          throw new Error('Poor R/R ratio');\n        }\n      },\n      note: 'Reward/Risk must be at least 2:1',\n    },\n  ],\n});\n```\n\n### Attaching Risk Profiles to Strategies\n\nRisk profiles are attached to strategies via `riskName` or `riskList`:\n\n```typescript\naddStrategy({\n  strategyName: 'my-strategy',\n  interval: '5m',\n  getSignal: async (symbol, when) => { /* ... */ },\n  riskName: 'conservative',  // Single risk profile\n});\n\naddStrategy({\n  strategyName: 'multi-risk-strategy',\n  interval: '5m',\n  getSignal: async (symbol, when) => { /* ... */ },\n  riskList: ['conservative', 'max-drawdown', 'time-window'],  // Multiple profiles\n});\n```\n\n**Sources:** [types.d.ts:728-747](), [README.md:82-100]()\n\n### Portfolio-Wide Validation Example\n\n```typescript\naddRisk({\n  riskName: 'portfolio-limit',\n  validations: [\n    // Maximum 3 concurrent positions\n    ({ activePositionCount }) => {\n      if (activePositionCount >= 3) {\n        throw new Error(`Max positions reached: ${activePositionCount}/3`);\n      }\n    },\n    \n    // No new LONG if active SHORT exists on same symbol\n    ({ symbol, pendingSignal, activePositions }) => {\n      const hasOppositePosition = activePositions.some(\n        pos => pos.signal.symbol === symbol && \n               pos.signal.position !== pendingSignal.position\n      );\n      \n      if (hasOppositePosition) {\n        throw new Error('Cannot open opposite position on same symbol');\n      }\n    },\n  ],\n});\n```\n\n**Sources:** [types.d.ts:382-390]()\n\n---\n\n## Portfolio-Wide Risk Tracking\n\n`RiskGlobalService` maintains a global registry of active positions across all strategies, enabling portfolio-wide risk constraints.\n\n### RiskGlobalService Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Signal Lifecycle\"\n        OPEN[\"Signal Opened\"]\n        ACTIVE[\"Active Monitoring\"]\n        CLOSE[\"Signal Closed\"]\n    end\n    \n    subgraph \"RiskGlobalService\"\n        REGISTRY[\"Active Position Registry<br/>Map<signalId, IRiskActivePosition>\"]\n        ADD[\"addSignal()\"]\n        REMOVE[\"removeSignal()\"]\n        CHECK[\"checkSignal()\"]\n    end\n    \n    subgraph \"Validation Context\"\n        COUNT[\"activePositionCount\"]\n        POSITIONS[\"activePositions[]\"]\n        PAYLOAD[\"IRiskValidationPayload\"]\n    end\n    \n    OPEN -->|\"Call\"| ADD\n    ADD -->|\"Store\"| REGISTRY\n    \n    CHECK -->|\"Read\"| REGISTRY\n    REGISTRY -->|\"Compute\"| COUNT\n    REGISTRY -->|\"Provide\"| POSITIONS\n    COUNT --> PAYLOAD\n    POSITIONS --> PAYLOAD\n    \n    ACTIVE -->|\"Periodic\"| CHECK\n    \n    CLOSE -->|\"Call\"| REMOVE\n    REMOVE -->|\"Delete\"| REGISTRY\n    \n    style REGISTRY fill:#fff3cd\n    style PAYLOAD fill:#e1f5ff\n```\n\n**Sources:** [types.d.ts:359-369](), [types.d.ts:451-479]()\n\n### IRiskActivePosition Structure\n\n```typescript\ninterface IRiskActivePosition {\n  signal: ISignalRow;          // Complete signal details\n  strategyName: string;        // Owning strategy\n  exchangeName: string;        // Target exchange\n  openTimestamp: number;       // When position opened (ms)\n}\n```\n\n### Integration with ClientRisk\n\nThe `ClientRisk` class implements risk validation and position tracking:\n\n```typescript\ninterface IRisk {\n  checkSignal(params: IRiskCheckArgs): Promise<boolean>;\n  addSignal(symbol: string, context: { strategyName: string; riskName: string }): Promise<void>;\n  removeSignal(symbol: string, context: { strategyName: string; riskName: string }): Promise<void>;\n}\n```\n\n| Method | When Called | Purpose |\n|--------|-------------|---------|\n| `checkSignal()` | Before scheduling/opening signal | Validates against risk rules |\n| `addSignal()` | When signal opens (priceOpen reached) | Registers active position |\n| `removeSignal()` | When signal closes (TP/SL/time) | Removes active position |\n\n**Sources:** [types.d.ts:451-479]()\n\n---\n\n## MergeRisk for Multiple Risk Profiles\n\nWhen a strategy specifies `riskList` instead of `riskName`, the system uses `MergeRisk` to combine multiple risk profiles. All validations from all profiles must pass for the signal to be accepted.\n\n```mermaid\ngraph LR\n    SIGNAL[\"Pending Signal\"]\n    MERGE[\"MergeRisk\"]\n    RISK1[\"Risk Profile 1\"]\n    RISK2[\"Risk Profile 2\"]\n    RISK3[\"Risk Profile 3\"]\n    ALL_PASS{{\"All Pass?\"}}\n    ACCEPT[\"Signal Accepted\"]\n    REJECT[\"Signal Rejected\"]\n    \n    SIGNAL --> MERGE\n    MERGE --> RISK1\n    MERGE --> RISK2\n    MERGE --> RISK3\n    \n    RISK1 --> ALL_PASS\n    RISK2 --> ALL_PASS\n    RISK3 --> ALL_PASS\n    \n    ALL_PASS -->|\"Yes\"| ACCEPT\n    ALL_PASS -->|\"No\"| REJECT\n    \n    style REJECT fill:#ffcccc\n    style ACCEPT fill:#ccffcc\n```\n\n**Example:**\n```typescript\naddStrategy({\n  strategyName: 'multi-risk',\n  interval: '5m',\n  getSignal: async (symbol, when) => { /* ... */ },\n  riskList: ['conservative', 'portfolio-limit', 'trading-hours'],\n});\n```\n\nAll three profiles (`conservative`, `portfolio-limit`, `trading-hours`) will be validated sequentially. If any validation throws an error, the signal is rejected.\n\n**Sources:** [types.d.ts:728-747]()\n\n---\n\n## Risk Event Monitoring\n\nThe risk system emits events via `riskSubject` when signals are rejected. This enables real-time monitoring, alerting, and debugging.\n\n### RiskContract Structure\n\n```typescript\ninterface RiskContract {\n  symbol: string;\n  params: IRiskCheckArgs;           // Full validation context\n  activePositionCount: number;      // Portfolio state at rejection\n  comment: string;                  // Rejection reason (from validation note or \"N/A\")\n  timestamp: number;                // Rejection time (ms)\n}\n```\n\n### Listening to Risk Rejections\n\n```typescript\nimport { listenRisk } from 'backtest-kit';\n\nlistenRisk((event) => {\n  console.error(`Signal rejected on ${event.symbol}`);\n  console.error(`Reason: ${event.comment}`);\n  console.error(`Active positions: ${event.activePositionCount}`);\n  console.error(`Pending signal:`, event.params.pendingSignal);\n});\n```\n\n### Risk Event Flow\n\n```mermaid\nsequenceDiagram\n    participant Strategy as ClientStrategy\n    participant Risk as ClientRisk\n    participant Custom as Custom Validations\n    participant Emit as riskSubject\n    participant User as Event Listeners\n    \n    Strategy->>Risk: checkSignal(params)\n    Risk->>Custom: Execute validations\n    \n    alt Validation Throws Error\n        Custom-->>Risk: throw new Error(reason)\n        Risk->>Emit: Emit RiskContract\n        Emit->>User: listenRisk(event)\n        Risk-->>Strategy: return false\n    else All Pass\n        Risk-->>Strategy: return true\n    end\n```\n\n**Sources:** [src/config/emitters.ts:126-131](), [types.d.ts:431-445](), [src/function/event.ts:338-356]()\n\n---\n\n## GLOBAL_CONFIG Risk Parameters Reference\n\n### Price Validation\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` | 0.5% | Minimum TP distance from `priceOpen` (covers fees/slippage) |\n| `CC_MIN_STOPLOSS_DISTANCE_PERCENT` | 0.5% | Minimum SL distance from `priceOpen` (volatility buffer) |\n| `CC_MAX_STOPLOSS_DISTANCE_PERCENT` | 20% | Maximum SL distance (caps catastrophic losses) |\n| `CC_MAX_SIGNAL_LIFETIME_MINUTES` | 1440 | Maximum signal duration (prevents eternal signals) |\n\n### Transaction Costs\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `CC_PERCENT_FEE` | 0.1% | Fee per transaction (applied 2× for entry+exit) |\n| `CC_PERCENT_SLIPPAGE` | 0.1% | Slippage per transaction (applied 2× for entry+exit) |\n\n### Anomaly Detection\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR` | 1000 | Price deviation factor for anomaly detection |\n| `CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN` | 5 | Minimum candles for median calculation |\n\n### Scheduled Signal Timeouts\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `CC_SCHEDULE_AWAIT_MINUTES` | 120 | Maximum time to wait for scheduled signal activation |\n\n**Sources:** [src/config/params.ts:1-122]()\n\n---\n\n## Risk Validation Error Handling\n\nWhen a validation function throws an error, the signal is **immediately rejected** and the system:\n\n1. **Logs the rejection** via `LoggerService`\n2. **Emits `riskSubject` event** with rejection details\n3. **Calls `onRejected` callback** (if defined in `IRiskCallbacks`)\n4. **Returns control to strategy** (no signal is scheduled or opened)\n5. **Continues execution** (non-fatal, strategy keeps running)\n\n### Error Propagation\n\n```mermaid\ngraph TB\n    VAL[\"Validation Function\"]\n    THROW[\"throw new Error(reason)\"]\n    CATCH[\"Catch in ClientRisk.checkSignal()\"]\n    LOG[\"Log rejection\"]\n    EMIT[\"Emit riskSubject\"]\n    CB[\"Call callbacks.onRejected()\"]\n    RETURN[\"Return false\"]\n    STRAT[\"Strategy continues\"]\n    \n    VAL --> THROW\n    THROW --> CATCH\n    CATCH --> LOG\n    LOG --> EMIT\n    EMIT --> CB\n    CB --> RETURN\n    RETURN --> STRAT\n    \n    style THROW fill:#ffcccc\n    style RETURN fill:#ffffcc\n```\n\n**Important:** Risk validation errors are **non-fatal**. The system continues executing and will attempt to generate new signals on the next tick (subject to `interval` throttling).\n\n**Sources:** [types.d.ts:395-412](), [types.d.ts:372-377]()\n\n---\n\n## Best Practices\n\n### 1. Layered Risk Approach\nUse multiple risk profiles for defense in depth:\n```typescript\nriskList: ['signal-quality', 'portfolio-limit', 'market-conditions']\n```\n\n### 2. Document Validation Logic\nAlways include `note` field for rejection transparency:\n```typescript\n{\n  validate: (payload) => { /* ... */ },\n  note: 'Maximum 5 concurrent positions allowed',\n}\n```\n\n### 3. Test Edge Cases\nValidate risk logic with extreme inputs:\n- Zero/negative prices → should be caught by stage 1\n- TP distance = 0.4% → should be caught by stage 3\n- SL distance = 25% → should be caught by stage 5\n- Concurrent position limit → test with multiple strategies\n\n### 4. Monitor Risk Rejections\nAlways attach `listenRisk()` in production to track why signals are rejected:\n```typescript\nlistenRisk((event) => {\n  logToMonitoring('risk_rejection', {\n    symbol: event.symbol,\n    reason: event.comment,\n    strategy: event.params.strategyName,\n  });\n});\n```\n\n### 5. Use Appropriate GLOBAL_CONFIG Values\nAdjust validation thresholds based on asset class:\n- **Crypto**: Default values (0.5% TP/SL distances)\n- **Forex**: Tighter distances (0.2% might be sufficient)\n- **Stocks**: May need looser SL max (30% instead of 20%)\n\n**Sources:** [src/config/params.ts:1-122](), [README.md:82-100]()\n\n---\n\n## Related Documentation\n\n- **[Strategy Development](#6)**: How to implement `getSignal()` and configure `riskName`\n- **[Position Sizing](#7.3)**: `ISizingSchema` for calculating position quantities\n- **[Signals & Signal Lifecycle](#3.1)**: Full signal state machine including rejection flows\n- **[Configuration Reference](#11)**: Complete `GLOBAL_CONFIG` parameter documentation"
                    },
                    {
                        "page_plan": {
                            "id": "7.1",
                            "title": "Risk Profiles & Validation"
                        },
                        "content": "# Risk Profiles & Validation\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Heat.ts](src/classes/Heat.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Partial.ts](src/classes/Partial.ts)\n- [src/classes/Performance.ts](src/classes/Performance.ts)\n- [src/classes/Risk.ts](src/classes/Risk.ts)\n- [src/classes/Schedule.ts](src/classes/Schedule.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [test/spec/columns.test.mjs](test/spec/columns.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis page covers the **risk profile system** in Backtest Kit: defining custom validation rules via `IRiskSchema`, combining multiple risk profiles with `MergeRisk`, and the lifecycle methods (`checkSignal`, `addSignal`, `removeSignal`) that track portfolio-wide risk state.\n\n**Scope:** This page focuses on user-defined risk profiles registered via `addRisk()`. For built-in signal validation (TP/SL logic, price checks, GLOBAL_CONFIG enforcement), see [Signal Validation Pipeline](#7.2). For position sizing calculations, see [Position Sizing](#7.3). For portfolio-wide tracking via `RiskGlobalService`, see [Portfolio-Wide Limits](#7.4).\n\n---\n\n## Overview\n\nRisk profiles enable **portfolio-level risk management** beyond per-signal validation. While the signal validation pipeline ([#7.2](#7.2)) enforces basic constraints like TP/SL logic and price bounds, risk profiles add:\n\n- **Concurrent position limits** (e.g., max 3 open positions)\n- **Exposure limits** (e.g., max 20% portfolio allocation)\n- **Time-based rules** (e.g., no trading during news events)\n- **Correlation constraints** (e.g., max 2 correlated positions)\n- **Custom business logic** (any validation that accesses portfolio state)\n\nRisk profiles are **registered once** via `addRisk()` and then **referenced** by strategies using `riskName` or `riskList` fields in `IStrategySchema`.\n\n**Sources:** [types.d.ts:414-426](), [README.md:82-100]()\n\n---\n\n## Core Interfaces\n\n### IRiskSchema\n\nThe schema registered via `addRisk()`:\n\n```typescript\ninterface IRiskSchema {\n  riskName: RiskName;                           // Unique identifier\n  note?: string;                                 // Optional description\n  callbacks?: Partial<IRiskCallbacks>;           // onRejected, onAllowed\n  validations: (IRiskValidation | IRiskValidationFn)[]; // Validation rules\n}\n```\n\n**Fields:**\n- **`riskName`**: Unique identifier for this risk profile\n- **`validations`**: Array of validation rules (functions or objects with `validate` + `note`)\n- **`callbacks`**: Optional lifecycle hooks for rejected/allowed signals\n- **`note`**: Developer comment for documentation\n\n**Sources:** [types.d.ts:414-426]()\n\n---\n\n### IRiskValidation vs IRiskValidationFn\n\nValidations can be defined in **two forms**:\n\n#### 1. Function Form (IRiskValidationFn)\n\n```typescript\ntype IRiskValidationFn = (payload: IRiskValidationPayload) => void | Promise<void>;\n```\n\nA function that **throws an error** to reject the signal:\n\n```typescript\naddRisk({\n  riskName: 'max-positions',\n  validations: [\n    ({ activePositionCount }) => {\n      if (activePositionCount >= 3) {\n        throw new Error('Max 3 positions exceeded');\n      }\n    }\n  ]\n});\n```\n\n#### 2. Object Form (IRiskValidation)\n\n```typescript\ninterface IRiskValidation {\n  validate: IRiskValidationFn;  // Validation function\n  note?: string;                 // Description (used in rejection message)\n}\n```\n\nAdds a `note` field for better error messages:\n\n```typescript\naddRisk({\n  riskName: 'max-positions',\n  validations: [\n    {\n      validate: ({ activePositionCount }) => {\n        if (activePositionCount >= 3) {\n          throw new Error('Exceeded limit');\n        }\n      },\n      note: 'Max 3 concurrent positions'  // Included in RiskContract events\n    }\n  ]\n});\n```\n\n**Sources:** [types.d.ts:392-412](), [README.md:82-100]()\n\n---\n\n### IRiskValidationPayload\n\nThe payload passed to **all validation functions**:\n\n```typescript\ninterface IRiskValidationPayload extends IRiskCheckArgs {\n  pendingSignal: ISignalDto;                // Signal to validate\n  activePositionCount: number;              // Current open positions\n  activePositions: IRiskActivePosition[];   // List of open positions\n}\n\ninterface IRiskCheckArgs {\n  symbol: string;\n  pendingSignal: ISignalDto;\n  strategyName: StrategyName;\n  exchangeName: ExchangeName;\n  currentPrice: number;\n  timestamp: number;\n}\n\ninterface IRiskActivePosition {\n  signal: ISignalRow;\n  strategyName: string;\n  exchangeName: string;\n  openTimestamp: number;\n}\n```\n\n**Available Data:**\n- **`pendingSignal`**: The signal being validated (TP, SL, position, etc.)\n- **`currentPrice`**: Current VWAP price\n- **`activePositionCount`**: Number of currently open positions (all strategies)\n- **`activePositions`**: Full list of open positions with details\n- **`symbol`**, **`strategyName`**, **`exchangeName`**: Context information\n- **`timestamp`**: Current time (milliseconds)\n\n**Sources:** [types.d.ts:339-390]()\n\n---\n\n## Diagram: Risk Validation Data Flow\n\n```mermaid\ngraph TD\n    Strategy[\"Strategy<br/>getSignal() returns ISignalDto\"]\n    SignalVal[\"Signal Validation Pipeline<br/>(#7.2)<br/>TP/SL logic, price checks\"]\n    RiskCheck[\"Risk Check Orchestration<br/>StrategyCoreService\"]\n    \n    RiskCheck --> GetRisk[\"Get IRisk instance<br/>RiskConnectionService\"]\n    GetRisk --> ClientRisk[\"ClientRisk.checkSignal()<br/>or MergeRisk.checkSignal()\"]\n    \n    ClientRisk --> BuildPayload[\"Build IRiskValidationPayload<br/>+ activePositionCount<br/>+ activePositions[]\"]\n    \n    BuildPayload --> Val1[\"Validation 1<br/>validate(payload)\"]\n    BuildPayload --> Val2[\"Validation 2<br/>validate(payload)\"]\n    BuildPayload --> ValN[\"Validation N<br/>validate(payload)\"]\n    \n    Val1 -->|\"throw Error\"| Reject[\"Signal Rejected<br/>riskSubject.next()<br/>return false\"]\n    Val2 -->|\"throw Error\"| Reject\n    ValN -->|\"throw Error\"| Reject\n    \n    Val1 -->|\"pass\"| AllPass\n    Val2 -->|\"pass\"| AllPass\n    ValN -->|\"pass\"| AllPass\n    \n    AllPass[\"All validations pass\"] --> Allow[\"Signal Allowed<br/>onAllowed callback<br/>return true\"]\n    \n    Strategy --> SignalVal\n    SignalVal -->|\"valid signal\"| RiskCheck\n    \n    Allow --> OpenSignal[\"Open Signal<br/>addSignal(symbol, context)\"]\n    Reject -.-> NoOpen[\"Signal not opened\"]\n    \n    style Reject fill:#fee,stroke:#c00\n    style Allow fill:#efe,stroke:#0c0\n```\n\n**Sources:** [types.d.ts:448-479](), [src/lib/services/core/StrategyCoreService.ts]()\n\n---\n\n## The IRisk Interface\n\nAll risk implementations (both `ClientRisk` and `MergeRisk`) conform to `IRisk`:\n\n```typescript\ninterface IRisk {\n  checkSignal(params: IRiskCheckArgs): Promise<boolean>;\n  addSignal(symbol: string, context: { strategyName: string; riskName: string }): Promise<void>;\n  removeSignal(symbol: string, context: { strategyName: string; riskName: string }): Promise<void>;\n}\n```\n\n### Method: checkSignal\n\n**Purpose:** Determine if a new signal should be allowed based on current portfolio state.\n\n**Behavior:**\n- Runs **all validations** in sequence\n- If **any validation throws**, the signal is **rejected** (returns `false`)\n- If **all validations pass**, the signal is **allowed** (returns `true`)\n- Triggers `onRejected` or `onAllowed` callbacks\n\n**When Called:** Before opening a new position (after signal validation pipeline passes)\n\n**Sources:** [types.d.ts:452-458]()\n\n---\n\n### Method: addSignal\n\n**Purpose:** Register a newly opened position with the risk system.\n\n**Behavior:**\n- Called **after** signal opens successfully\n- Updates `activePositionCount` and `activePositions[]` in `RiskGlobalService`\n- Enables future `checkSignal` calls to see this position\n\n**When Called:** Immediately after opening a signal (when action = \"opened\")\n\n**Sources:** [types.d.ts:460-468]()\n\n---\n\n### Method: removeSignal\n\n**Purpose:** Unregister a closed position from the risk system.\n\n**Behavior:**\n- Called **after** signal closes (TP/SL/time_expired)\n- Decrements `activePositionCount` and removes from `activePositions[]`\n- Frees up capacity for new positions\n\n**When Called:** Immediately after closing a signal (when action = \"closed\")\n\n**Sources:** [types.d.ts:470-478]()\n\n---\n\n## Diagram: Risk Lifecycle State Machine\n\n```mermaid\nstateDiagram-v2\n    [*] --> NoSignal: \"Initial state\"\n    \n    NoSignal --> CheckingRisk: \"getSignal() returns signal\"\n    \n    CheckingRisk --> Rejected: \"checkSignal() = false<br/>(validation threw error)\"\n    CheckingRisk --> Approved: \"checkSignal() = true<br/>(all validations passed)\"\n    \n    Approved --> SignalOpened: \"Open signal<br/>addSignal(symbol, context)\"\n    \n    SignalOpened --> Active: \"Position active<br/>tracked in RiskGlobalService\"\n    \n    Active --> Closed: \"TP/SL/time_expired<br/>removeSignal(symbol, context)\"\n    \n    Closed --> NoSignal: \"Position removed<br/>from activePositions[]\"\n    \n    Rejected --> NoSignal: \"No position opened\"\n    \n    note right of CheckingRisk\n        Validations see:\n        - activePositionCount\n        - activePositions[]\n        - pendingSignal\n        - currentPrice\n    end note\n    \n    note right of Active\n        Other strategies' checkSignal()\n        calls see this position in\n        activePositions[]\n    end note\n```\n\n**Sources:** [types.d.ts:448-479]()\n\n---\n\n## Creating Custom Risk Profiles\n\n### Basic Example: Max Positions\n\n```typescript\nimport { addRisk } from 'backtest-kit';\n\naddRisk({\n  riskName: 'max-3-positions',\n  validations: [\n    ({ activePositionCount }) => {\n      if (activePositionCount >= 3) {\n        throw new Error('Max 3 positions exceeded');\n      }\n    }\n  ]\n});\n```\n\n### Example: Risk/Reward Ratio\n\n```typescript\naddRisk({\n  riskName: 'min-rr-2to1',\n  validations: [\n    ({ pendingSignal, currentPrice }) => {\n      const { priceOpen = currentPrice, priceTakeProfit, priceStopLoss, position } = pendingSignal;\n      \n      const reward = position === 'long' \n        ? priceTakeProfit - priceOpen \n        : priceOpen - priceTakeProfit;\n      \n      const risk = position === 'long' \n        ? priceOpen - priceStopLoss \n        : priceStopLoss - priceOpen;\n      \n      if (reward / risk < 2) {\n        throw new Error(`Poor R/R: ${(reward/risk).toFixed(2)}:1`);\n      }\n    }\n  ]\n});\n```\n\n### Example: Time-Based Rules\n\n```typescript\naddRisk({\n  riskName: 'no-trading-weekends',\n  validations: [\n    ({ timestamp }) => {\n      const day = new Date(timestamp).getDay();\n      if (day === 0 || day === 6) {\n        throw new Error('No trading on weekends');\n      }\n    }\n  ]\n});\n```\n\n### Example: Correlation Limits\n\n```typescript\naddRisk({\n  riskName: 'max-correlated',\n  validations: [\n    ({ symbol, activePositions, pendingSignal }) => {\n      const sameDirection = activePositions.filter(pos => \n        pos.signal.position === pendingSignal.position\n      );\n      \n      if (sameDirection.length >= 2) {\n        throw new Error('Max 2 positions in same direction');\n      }\n    }\n  ]\n});\n```\n\n**Sources:** [README.md:82-100]()\n\n---\n\n## Risk Callbacks\n\nThe `IRiskCallbacks` interface provides hooks for rejected and allowed signals:\n\n```typescript\ninterface IRiskCallbacks {\n  onRejected: (symbol: string, params: IRiskCheckArgs) => void;\n  onAllowed: (symbol: string, params: IRiskCheckArgs) => void;\n}\n```\n\n### Example: Logging Rejections\n\n```typescript\naddRisk({\n  riskName: 'max-positions',\n  validations: [\n    ({ activePositionCount }) => {\n      if (activePositionCount >= 3) throw new Error('Max 3 exceeded');\n    }\n  ],\n  callbacks: {\n    onRejected: (symbol, params) => {\n      console.warn(`Signal rejected for ${symbol}`);\n      console.warn(`Active positions: ${params.activePositionCount}`);\n    },\n    onAllowed: (symbol, params) => {\n      console.log(`Signal allowed for ${symbol}`);\n    }\n  }\n});\n```\n\n**Note:** These are **schema-level callbacks** (defined in `IRiskSchema`). They differ from the **service-level `onRejected` callback** in `IRiskParams`, which is used internally to emit events to `riskSubject`.\n\n**Sources:** [types.d.ts:371-378](), [types.d.ts:428-446]()\n\n---\n\n## Combining Multiple Risks: MergeRisk\n\n### The Composite Pattern\n\n`MergeRisk` combines multiple `IRisk` instances into a single risk checker using the **Composite pattern**:\n\n```typescript\nclass MergeRisk implements IRisk {\n  constructor(readonly _riskList: IRisk[]) {}\n  \n  async checkSignal(params: IRiskCheckArgs): Promise<boolean> {\n    const riskCheck = await Promise.all(\n      this._riskList.map(async (risk) => await risk.checkSignal(params))\n    );\n    return riskCheck.every((isSafe) => isSafe);  // Logical AND\n  }\n  \n  async addSignal(symbol: string, context: { strategyName: string; riskName: string }) {\n    await Promise.all(\n      this._riskList.map(async (risk) => await risk.addSignal(symbol, context))\n    );\n  }\n  \n  async removeSignal(symbol: string, context: { strategyName: string; riskName: string }) {\n    await Promise.all(\n      this._riskList.map(async (risk) => await risk.removeSignal(symbol, context))\n    );\n  }\n}\n```\n\n**Behavior:**\n- **`checkSignal`**: Signal is allowed **only if ALL** child risks approve (logical AND)\n- **`addSignal`**: Propagates to **all** child risks in parallel\n- **`removeSignal`**: Propagates to **all** child risks in parallel\n\n**Sources:** [src/classes/Risk.ts:42-111]()\n\n---\n\n### Using riskList in Strategies\n\nStrategies can reference **multiple risk profiles** using `riskList`:\n\n```typescript\n// Define multiple risk profiles\naddRisk({ riskName: 'max-positions', validations: [...] });\naddRisk({ riskName: 'min-rr-ratio', validations: [...] });\naddRisk({ riskName: 'time-limits', validations: [...] });\n\n// Combine them in a strategy\naddStrategy({\n  strategyName: 'my-strategy',\n  riskList: ['max-positions', 'min-rr-ratio', 'time-limits'],  // Logical AND\n  getSignal: async (symbol) => { /* ... */ }\n});\n```\n\n**Internally**, the framework creates a `MergeRisk` instance when `riskList` is used:\n\n```typescript\n// Pseudo-code representation\nconst risks = riskList.map(riskName => getRiskInstance(riskName));\nconst mergedRisk = new MergeRisk(risks);\nconst canTrade = await mergedRisk.checkSignal(params);  // All must pass\n```\n\n**Sources:** [types.d.ts:728-747](), [src/classes/Risk.ts:42-111]()\n\n---\n\n## Diagram: MergeRisk Composite Pattern\n\n```mermaid\ngraph TB\n    Strategy[\"Strategy<br/>riskList: ['r1', 'r2', 'r3']\"]\n    \n    Strategy --> GetMerged[\"RiskConnectionService<br/>creates MergeRisk instance\"]\n    \n    GetMerged --> MergeRisk[\"MergeRisk<br/>_riskList: [r1, r2, r3]\"]\n    \n    MergeRisk --> CheckAll[\"checkSignal(params)\"]\n    \n    CheckAll --> R1[\"ClientRisk('r1')<br/>checkSignal(params)\"]\n    CheckAll --> R2[\"ClientRisk('r2')<br/>checkSignal(params)\"]\n    CheckAll --> R3[\"ClientRisk('r3')<br/>checkSignal(params)\"]\n    \n    R1 --> R1Val[\"r1.validations[]<br/>run all\"]\n    R2 --> R2Val[\"r2.validations[]<br/>run all\"]\n    R3 --> R3Val[\"r3.validations[]<br/>run all\"]\n    \n    R1Val -->|\"true\"| AND[\"Promise.all()<br/>every(isSafe => isSafe)\"]\n    R2Val -->|\"true\"| AND\n    R3Val -->|\"true\"| AND\n    \n    R1Val -->|\"false\"| AND\n    R2Val -->|\"false\"| AND\n    R3Val -->|\"false\"| AND\n    \n    AND -->|\"all true\"| Allowed[\"return true<br/>Signal allowed\"]\n    AND -->|\"any false\"| Rejected[\"return false<br/>Signal rejected\"]\n    \n    style Allowed fill:#efe,stroke:#0c0\n    style Rejected fill:#fee,stroke:#c00\n```\n\n**Sources:** [src/classes/Risk.ts:42-111]()\n\n---\n\n## Risk Event Emission\n\n### riskSubject Emitter\n\nWhen a signal is **rejected** by risk validation, the framework emits a `RiskContract` event:\n\n```typescript\nexport const riskSubject = new Subject<RiskContract>();\n```\n\n**Event Payload (RiskContract):**\n\n```typescript\ninterface RiskContract {\n  symbol: string;\n  strategyName: string;\n  exchangeName: string;\n  activePositionCount: number;\n  comment: string;        // Rejection reason (from validation.note or \"N/A\")\n  timestamp: number;      // Event time (milliseconds)\n  backtest: boolean;\n}\n```\n\n**Listening for Risk Events:**\n\n```typescript\nimport { listenRisk } from 'backtest-kit';\n\nlistenRisk((event) => {\n  console.warn(`Signal rejected for ${event.symbol}`);\n  console.warn(`Reason: ${event.comment}`);\n  console.warn(`Active positions: ${event.activePositionCount}`);\n});\n```\n\n**Sources:** [src/config/emitters.ts:126-131](), [src/function/event.ts:332-366]()\n\n---\n\n### When Are Risk Events Emitted?\n\nRisk events are emitted **only when signals are rejected**, not when allowed. This prevents spam:\n\n```typescript\n// Inside ClientRisk.checkSignal()\ntry {\n  // Run all validations\n  for (const validation of validations) {\n    await validation.validate(payload);\n  }\n  // All passed - call onAllowed but DO NOT emit event\n  await this.callbacks?.onAllowed?.(params.symbol, params);\n  return true;\n} catch (error) {\n  // Validation threw - call onRejected AND emit riskSubject event\n  await this.callbacks?.onRejected?.(params.symbol, params);\n  await this.onRejected(params.symbol, params, activePositionCount, comment, timestamp);\n  return false;\n}\n```\n\n**Sources:** [types.d.ts:428-446]()\n\n---\n\n## Integration with Strategies\n\n### Using riskName (Single Risk)\n\n```typescript\naddRisk({\n  riskName: 'my-risk',\n  validations: [/* ... */]\n});\n\naddStrategy({\n  strategyName: 'my-strategy',\n  riskName: 'my-risk',  // Reference single risk profile\n  getSignal: async (symbol) => { /* ... */ }\n});\n```\n\n### Using riskList (Multiple Risks)\n\n```typescript\naddRisk({ riskName: 'risk-a', validations: [/* ... */] });\naddRisk({ riskName: 'risk-b', validations: [/* ... */] });\naddRisk({ riskName: 'risk-c', validations: [/* ... */] });\n\naddStrategy({\n  strategyName: 'my-strategy',\n  riskList: ['risk-a', 'risk-b', 'risk-c'],  // ALL must pass\n  getSignal: async (symbol) => { /* ... */ }\n});\n```\n\n**Note:** You **cannot use both** `riskName` and `riskList` in the same strategy. Use `riskList` for multiple risks.\n\n**Sources:** [types.d.ts:728-747]()\n\n---\n\n## Diagram: Code Entity Map\n\n```mermaid\ngraph TD\n    addRisk[\"addRisk()<br/>src/function/add.ts\"]\n    \n    addRisk --> SchemaService[\"RiskSchemaService<br/>stores IRiskSchema\"]\n    \n    SchemaService --> ValidationService[\"RiskValidationService<br/>validates riskName exists\"]\n    \n    ValidationService --> ConnectionService[\"RiskConnectionService<br/>memoized factory\"]\n    \n    ConnectionService -->|\"riskName only\"| ClientRisk[\"ClientRisk<br/>src/lib/client/ClientRisk.ts<br/>implements IRisk\"]\n    ConnectionService -->|\"riskList\"| MergeRisk[\"MergeRisk<br/>src/classes/Risk.ts:42-111<br/>implements IRisk\"]\n    \n    ClientRisk --> checkSignal[\"checkSignal()<br/>runs validations[]\"]\n    ClientRisk --> addSignal[\"addSignal()<br/>registers position\"]\n    ClientRisk --> removeSignal[\"removeSignal()<br/>unregisters position\"]\n    \n    MergeRisk --> checkSignalMerge[\"checkSignal()<br/>Promise.all() + every()\"]\n    MergeRisk --> addSignalMerge[\"addSignal()<br/>propagates to all\"]\n    MergeRisk --> removeSignalMerge[\"removeSignal()<br/>propagates to all\"]\n    \n    checkSignal --> Validations[\"validations[]<br/>IRiskValidationFn\"]\n    Validations --> Payload[\"IRiskValidationPayload<br/>types.d.ts:380-390\"]\n    \n    checkSignal -->|\"reject\"| riskSubject[\"riskSubject.next()<br/>src/config/emitters.ts:131\"]\n    riskSubject --> listenRisk[\"listenRisk()<br/>src/function/event.ts\"]\n    \n    addSignal --> RiskGlobalService[\"RiskGlobalService<br/>tracks activePositions\"]\n    removeSignal --> RiskGlobalService\n    \n    RiskGlobalService --> Payload\n    \n    style addRisk fill:#e1f5ff,stroke:#0066cc\n    style ClientRisk fill:#ffe1e1,stroke:#cc0000\n    style MergeRisk fill:#ffe1e1,stroke:#cc0000\n    style riskSubject fill:#fff3cd,stroke:#856404\n```\n\n**Sources:** [src/function/add.ts](), [src/lib/client/ClientRisk.ts](), [src/classes/Risk.ts:42-111](), [src/config/emitters.ts:126-131](), [types.d.ts:339-479]()\n\n---\n\n## Key Implementation Details\n\n### Validation Execution Order\n\nValidations are executed **sequentially** (not in parallel):\n\n```typescript\nfor (const validation of validations) {\n  const validateFn = typeof validation === 'function' \n    ? validation \n    : validation.validate;\n  await validateFn(payload);  // Await each validation\n}\n```\n\nThis ensures **deterministic behavior** and allows early exit on first failure.\n\n---\n\n### Error Handling\n\nRisk validations use **exception-based control flow**:\n\n- **Throw error** → Signal rejected (`checkSignal` returns `false`)\n- **Return normally** → Validation passed (continue to next validation)\n- **Async functions** → Fully supported (validations can be async)\n\n---\n\n### Performance Considerations\n\n- **Memoization**: `RiskConnectionService` caches `ClientRisk` and `MergeRisk` instances by key\n- **Parallel execution**: `MergeRisk` runs child risk checks in parallel via `Promise.all()`\n- **Early exit**: Sequential validation stops at first failure\n\n**Sources:** [src/lib/client/ClientRisk.ts](), [src/lib/services/connection/RiskConnectionService.ts]()\n\n---\n\n## Comparison Table: Risk Features\n\n| Feature | riskName (Single) | riskList (Multiple) |\n|---------|-------------------|---------------------|\n| **Implementation** | `ClientRisk` | `MergeRisk` wrapping multiple `ClientRisk` |\n| **Logic** | Run validations sequentially | Run all child risks in parallel, then AND results |\n| **Behavior** | Reject if any validation throws | Reject if any child risk rejects |\n| **Use Case** | Simple risk profile | Complex multi-dimensional risk |\n| **Performance** | Direct execution | Small overhead from composite pattern |\n| **Callbacks** | Per-risk callbacks fire | Each child risk's callbacks fire independently |\n\n**Sources:** [src/classes/Risk.ts:42-111](), [src/lib/client/ClientRisk.ts]()\n\n---\n\n## Summary\n\n- **Risk profiles** enable portfolio-level validation beyond per-signal checks\n- **`IRiskSchema`** defines validations via `addRisk()`, referenced by strategies via `riskName` or `riskList`\n- **Validations** receive `IRiskValidationPayload` with portfolio state (`activePositions`, `activePositionCount`)\n- **Exception-based**: Throw error to reject, return normally to pass\n- **`MergeRisk`** combines multiple risks with logical AND (all must pass)\n- **Lifecycle**: `checkSignal()` → `addSignal()` → `removeSignal()`\n- **Events**: Rejected signals emit to `riskSubject` (listen via `listenRisk()`)\n\n**Sources:** [types.d.ts:339-479](), [src/classes/Risk.ts:42-111](), [src/lib/client/ClientRisk.ts](), [README.md:82-100]()"
                    },
                    {
                        "page_plan": {
                            "id": "7.2",
                            "title": "Signal Validation Pipeline"
                        },
                        "content": "# Signal Validation Pipeline\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/client/ClientStrategy.ts](src/client/ClientStrategy.ts)\n- [src/config/params.ts](src/config/params.ts)\n- [src/interfaces/Strategy.interface.ts](src/interfaces/Strategy.interface.ts)\n- [src/lib/services/connection/StrategyConnectionService.ts](src/lib/services/connection/StrategyConnectionService.ts)\n- [test/README.md](test/README.md)\n- [test/config/setup.mjs](test/config/setup.mjs)\n- [test/e2e/close.test.mjs](test/e2e/close.test.mjs)\n- [test/e2e/edge.test.mjs](test/e2e/edge.test.mjs)\n- [test/e2e/other.test.mjs](test/e2e/other.test.mjs)\n- [test/e2e/persist.test.mjs](test/e2e/persist.test.mjs)\n- [test/e2e/sanitize.test.mjs](test/e2e/sanitize.test.mjs)\n- [test/e2e/sequence.test.mjs](test/e2e/sequence.test.mjs)\n- [test/index.mjs](test/index.mjs)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page documents the multi-stage validation pipeline that every trading signal passes through before execution. The validation system ensures signals meet structural, logical, and risk requirements to prevent catastrophic losses from malformed signals, protect capital from extreme risk exposure, and enforce profitability constraints that account for trading costs.\n\nFor information about defining custom risk validation rules beyond the built-in checks, see [Risk Profiles & Validation](#7.1). For portfolio-wide position limits and concurrent signal management, see [Portfolio-Wide Limits](#7.4).\n\n**Sources:** [src/client/ClientStrategy.ts:45-330](), [src/config/params.ts:1-122](), [README.md:17-29]()\n\n---\n\n## Validation Pipeline Overview\n\n```mermaid\ngraph TD\n    A[\"getSignal() returns ISignalDto\"]\n    B[\"Stage 1: Schema Validation<br/>(required fields, types)\"]\n    C[\"Stage 2: NaN/Infinity Protection<br/>(currentPrice, prices finite)\"]\n    D[\"Stage 3: Positive Price Check<br/>(all prices > 0)\"]\n    E[\"Stage 4: Position Logic<br/>(LONG/SHORT TP/SL order)\"]\n    F[\"Stage 5: Immediate Closure Prevention<br/>(price not already at TP/SL)\"]\n    G[\"Stage 6: Min TP Distance<br/>(CC_MIN_TAKEPROFIT_DISTANCE_PERCENT)\"]\n    H[\"Stage 7: Min SL Distance<br/>(CC_MIN_STOPLOSS_DISTANCE_PERCENT)\"]\n    I[\"Stage 8: Max SL Distance<br/>(CC_MAX_STOPLOSS_DISTANCE_PERCENT)\"]\n    J[\"Stage 9: Max Lifetime<br/>(CC_MAX_SIGNAL_LIFETIME_MINUTES)\"]\n    K[\"Stage 10: Time Parameter Validation<br/>(minuteEstimatedTime integer > 0)\"]\n    L[\"Stage 11: Risk Validation<br/>(IRisk.checkSignal)\"]\n    M[\"Signal Accepted\"]\n    N[\"Signal Rejected<br/>(Error thrown, logged)\"]\n    \n    A --> B\n    B -->|\"Pass\"| C\n    B -->|\"Fail\"| N\n    C -->|\"Pass\"| D\n    C -->|\"Fail\"| N\n    D -->|\"Pass\"| E\n    D -->|\"Fail\"| N\n    E -->|\"Pass\"| F\n    E -->|\"Fail\"| N\n    F -->|\"Pass\"| G\n    F -->|\"Fail\"| N\n    G -->|\"Pass\"| H\n    G -->|\"Fail\"| N\n    H -->|\"Pass\"| I\n    H -->|\"Fail\"| N\n    I -->|\"Pass\"| J\n    I -->|\"Fail\"| N\n    J -->|\"Pass\"| K\n    J -->|\"Fail\"| N\n    K -->|\"Pass\"| L\n    K -->|\"Fail\"| N\n    L -->|\"Pass\"| M\n    L -->|\"Fail\"| N\n```\n\n**Validation Pipeline Stages**\n\nThe validation occurs in `VALIDATE_SIGNAL_FN` within `ClientStrategy`, called from `GET_SIGNAL_FN` before signal creation. Each stage checks specific constraints and accumulates error messages. If any validation fails, an error with all violation descriptions is thrown, preventing signal execution.\n\n**Sources:** [src/client/ClientStrategy.ts:45-330](), [src/client/ClientStrategy.ts:332-476]()\n\n---\n\n## Schema and Type Validation\n\n### Required Fields\n\nThe first validation stage ensures all required `ISignalRow` fields are present and non-empty:\n\n| Field | Requirement | Error if Invalid |\n|-------|-------------|------------------|\n| `id` | Non-empty string | \"id is required and must be a non-empty string\" |\n| `exchangeName` | Non-empty string | \"exchangeName is required\" |\n| `strategyName` | Non-empty string | \"strategyName is required\" |\n| `symbol` | Non-empty string | \"symbol is required and must be a non-empty string\" |\n| `_isScheduled` | Boolean (not null/undefined) | \"_isScheduled is required\" |\n| `position` | \"long\" or \"short\" | 'position must be \"long\" or \"short\"' |\n\n**Sources:** [src/client/ClientStrategy.ts:49-68]()\n\n---\n\n## Price Validation\n\n### NaN and Infinity Protection\n\n**Critical**: All prices must be finite numbers. Incomplete candle data from exchanges can contain `NaN`, `Infinity`, or near-zero prices that would corrupt PNL calculations.\n\n```mermaid\ngraph LR\n    A[\"currentPrice check\"]\n    B[\"priceOpen check\"]\n    C[\"priceTakeProfit check\"]\n    D[\"priceStopLoss check\"]\n    E[\"isFinite() test\"]\n    F[\"Positive value test\"]\n    G[\"Validation Pass\"]\n    H[\"Validation Fail\"]\n    \n    A --> E\n    B --> E\n    C --> E\n    D --> E\n    \n    E -->|\"!isFinite()\"| H\n    E -->|\"isFinite()\"| F\n    F -->|\"<= 0\"| H\n    F -->|\"> 0\"| G\n```\n\n**Checks performed:**\n\n1. **Finite Number Check**: `isFinite(price)` must be true\n   - Rejects `NaN`: \"must be a finite number, got NaN\"\n   - Rejects `Infinity`: \"must be a finite number, got Infinity\"\n\n2. **Positive Price Check**: `price > 0` must be true\n   - Rejects zero: \"must be positive, got 0\"\n   - Rejects negative: \"must be positive, got -1234\"\n\n**Sources:** [src/client/ClientStrategy.ts:71-109]()\n\n---\n\n## Position Logic Validation\n\n### LONG Position Requirements\n\nFor `position: \"long\"` signals, the price order must be: **priceStopLoss < priceOpen < priceTakeProfit**\n\n```typescript\n// LONG validation checks\nif (priceTakeProfit <= priceOpen) {\n  errors.push(\"Long: priceTakeProfit must be > priceOpen\");\n}\nif (priceStopLoss >= priceOpen) {\n  errors.push(\"Long: priceStopLoss must be < priceOpen\");\n}\n```\n\n**Rationale**: For long positions, profit is made when price rises above entry, losses occur when price falls below entry.\n\n**Sources:** [src/client/ClientStrategy.ts:112-122]()\n\n### SHORT Position Requirements\n\nFor `position: \"short\"` signals, the price order must be: **priceTakeProfit < priceOpen < priceStopLoss**\n\n```typescript\n// SHORT validation checks\nif (priceTakeProfit >= priceOpen) {\n  errors.push(\"Short: priceTakeProfit must be < priceOpen\");\n}\nif (priceStopLoss <= priceOpen) {\n  errors.push(\"Short: priceStopLoss must be > priceOpen\");\n}\n```\n\n**Rationale**: For short positions, profit is made when price falls below entry, losses occur when price rises above entry.\n\n**Sources:** [src/client/ClientStrategy.ts:203-213]()\n\n---\n\n## Immediate Closure Prevention\n\n### For Immediate (Market) Signals\n\nWhen `priceOpen` equals `currentPrice` (or is omitted), the signal opens immediately. The system prevents \"open-and-immediately-close\" scenarios:\n\n**LONG Immediate Signal Checks:**\n```typescript\nif (currentPrice <= priceStopLoss) {\n  errors.push(\"Long immediate: currentPrice <= priceStopLoss. \" +\n    \"Signal would be immediately closed by stop loss.\");\n}\nif (currentPrice >= priceTakeProfit) {\n  errors.push(\"Long immediate: currentPrice >= priceTakeProfit. \" +\n    \"The profit opportunity has already passed.\");\n}\n```\n\n**Valid state for LONG**: `priceStopLoss < currentPrice < priceTakeProfit`\n\n**Sources:** [src/client/ClientStrategy.ts:125-141]()\n\n**SHORT Immediate Signal Checks:**\n```typescript\nif (currentPrice >= priceStopLoss) {\n  errors.push(\"Short immediate: currentPrice >= priceStopLoss. \" +\n    \"Signal would be immediately closed by stop loss.\");\n}\nif (currentPrice <= priceTakeProfit) {\n  errors.push(\"Short immediate: currentPrice <= priceTakeProfit. \" +\n    \"The profit opportunity has already passed.\");\n}\n```\n\n**Valid state for SHORT**: `priceTakeProfit < currentPrice < priceStopLoss`\n\n**Sources:** [src/client/ClientStrategy.ts:216-232]()\n\n### For Scheduled (Limit) Signals\n\nWhen `priceOpen` differs from `currentPrice`, the signal enters scheduled state. The system validates that `priceOpen` itself won't trigger immediate closure upon activation:\n\n**LONG Scheduled Signal Checks:**\n```typescript\nif (priceOpen <= priceStopLoss) {\n  errors.push(\"Long scheduled: priceOpen <= priceStopLoss. \" +\n    \"Signal would be immediately cancelled on activation.\");\n}\nif (priceOpen >= priceTakeProfit) {\n  errors.push(\"Long scheduled: priceOpen >= priceTakeProfit. \" +\n    \"This is logically impossible for LONG position.\");\n}\n```\n\n**Sources:** [src/client/ClientStrategy.ts:144-160]()\n\n**SHORT Scheduled Signal Checks:**\n```typescript\nif (priceOpen >= priceStopLoss) {\n  errors.push(\"Short scheduled: priceOpen >= priceStopLoss. \" +\n    \"Signal would be immediately cancelled on activation.\");\n}\nif (priceOpen <= priceTakeProfit) {\n  errors.push(\"Short scheduled: priceOpen <= priceTakeProfit. \" +\n    \"This is logically impossible for SHORT position.\");\n}\n```\n\n**Sources:** [src/client/ClientStrategy.ts:235-251]()\n\n---\n\n## Distance Requirements\n\n### Minimum TakeProfit Distance\n\n**Purpose**: Ensures profit target is far enough to cover trading costs (fees + slippage).\n\n**Configuration**: `GLOBAL_CONFIG.CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` (default: 0.5%)\n\n**Trading Cost Breakdown:**\n- Entry fee: 0.1%\n- Exit fee: 0.1%\n- Entry slippage: ~0.1%\n- Exit slippage: ~0.1%\n- **Total overhead**: ~0.4%\n\nThe default 0.5% minimum ensures at least 0.1% net profit margin after costs.\n\n**LONG TP Distance Calculation:**\n```typescript\nconst tpDistancePercent = ((priceTakeProfit - priceOpen) / priceOpen) * 100;\nif (tpDistancePercent < CC_MIN_TAKEPROFIT_DISTANCE_PERCENT) {\n  errors.push(`Long: TakeProfit too close to priceOpen (${tpDistancePercent.toFixed(3)}%). ` +\n    `Minimum distance: ${CC_MIN_TAKEPROFIT_DISTANCE_PERCENT}% to cover trading fees.`);\n}\n```\n\n**SHORT TP Distance Calculation:**\n```typescript\nconst tpDistancePercent = ((priceOpen - priceTakeProfit) / priceOpen) * 100;\nif (tpDistancePercent < CC_MIN_TAKEPROFIT_DISTANCE_PERCENT) {\n  errors.push(`Short: TakeProfit too close to priceOpen (${tpDistancePercent.toFixed(3)}%). ` +\n    `Minimum distance: ${CC_MIN_TAKEPROFIT_DISTANCE_PERCENT}% to cover trading fees.`);\n}\n```\n\n**Sources:** [src/client/ClientStrategy.ts:163-173](), [src/client/ClientStrategy.ts:254-264](), [src/config/params.ts:26-37]()\n\n### Minimum StopLoss Distance\n\n**Purpose**: Prevents instant stop-out from normal market volatility.\n\n**Configuration**: `GLOBAL_CONFIG.CC_MIN_STOPLOSS_DISTANCE_PERCENT` (default: 0.5%)\n\n**LONG SL Distance Calculation:**\n```typescript\nconst slDistancePercent = ((priceOpen - priceStopLoss) / priceOpen) * 100;\nif (slDistancePercent < CC_MIN_STOPLOSS_DISTANCE_PERCENT) {\n  errors.push(`Long: StopLoss too close to priceOpen (${slDistancePercent.toFixed(3)}%). ` +\n    `Minimum distance: ${CC_MIN_STOPLOSS_DISTANCE_PERCENT}% to avoid instant stop out.`);\n}\n```\n\n**SHORT SL Distance Calculation:**\n```typescript\nconst slDistancePercent = ((priceStopLoss - priceOpen) / priceOpen) * 100;\nif (slDistancePercent < CC_MIN_STOPLOSS_DISTANCE_PERCENT) {\n  errors.push(`Short: StopLoss too close to priceOpen (${slDistancePercent.toFixed(3)}%). ` +\n    `Minimum distance: ${CC_MIN_STOPLOSS_DISTANCE_PERCENT}% to avoid instant stop out.`);\n}\n```\n\n**Sources:** [src/client/ClientStrategy.ts:176-186](), [src/client/ClientStrategy.ts:267-277](), [src/config/params.ts:38-43]()\n\n### Maximum StopLoss Distance\n\n**Purpose**: Caps maximum loss per signal to protect capital from catastrophic single-trade losses.\n\n**Configuration**: `GLOBAL_CONFIG.CC_MAX_STOPLOSS_DISTANCE_PERCENT` (default: 20%)\n\n**Example**: With 20% limit, a single signal cannot lose more than 20% of position size, even if price drops 50%.\n\n**LONG Max SL Check:**\n```typescript\nconst slDistancePercent = ((priceOpen - priceStopLoss) / priceOpen) * 100;\nif (slDistancePercent > CC_MAX_STOPLOSS_DISTANCE_PERCENT) {\n  errors.push(`Long: StopLoss too far from priceOpen (${slDistancePercent.toFixed(3)}%). ` +\n    `Maximum distance: ${CC_MAX_STOPLOSS_DISTANCE_PERCENT}% to protect capital.`);\n}\n```\n\n**SHORT Max SL Check:**\n```typescript\nconst slDistancePercent = ((priceStopLoss - priceOpen) / priceOpen) * 100;\nif (slDistancePercent > CC_MAX_STOPLOSS_DISTANCE_PERCENT) {\n  errors.push(`Short: StopLoss too far from priceOpen (${slDistancePercent.toFixed(3)}%). ` +\n    `Maximum distance: ${CC_MAX_STOPLOSS_DISTANCE_PERCENT}% to protect capital.`);\n}\n```\n\n**Sources:** [src/client/ClientStrategy.ts:189-199](), [src/client/ClientStrategy.ts:280-290](), [src/config/params.ts:44-49]()\n\n---\n\n## Lifetime Limits\n\n### Maximum Signal Lifetime\n\n**Purpose**: Prevents \"eternal signals\" that block risk limits indefinitely, causing strategy deadlock.\n\n**Configuration**: `GLOBAL_CONFIG.CC_MAX_SIGNAL_LIFETIME_MINUTES` (default: 1,440 minutes = 1 day)\n\n**Problem Scenario**: A signal with `minuteEstimatedTime: 50000` (34 days) occupies risk limits for over a month, preventing new signals from executing even when opportunities arise.\n\n**Validation:**\n```typescript\nif (minuteEstimatedTime > CC_MAX_SIGNAL_LIFETIME_MINUTES) {\n  const days = (minuteEstimatedTime / 60 / 24).toFixed(1);\n  const maxDays = (CC_MAX_SIGNAL_LIFETIME_MINUTES / 60 / 24).toFixed(0);\n  errors.push(\n    `minuteEstimatedTime too large (${minuteEstimatedTime} minutes = ${days} days). ` +\n    `Maximum: ${CC_MAX_SIGNAL_LIFETIME_MINUTES} minutes (${maxDays} days) to prevent strategy deadlock. ` +\n    `Eternal signals block risk limits and prevent new trades.`\n  );\n}\n```\n\n**Sources:** [src/client/ClientStrategy.ts:306-315](), [src/config/params.ts:50-55]()\n\n### Time Parameter Validation\n\n**minuteEstimatedTime Requirements:**\n- Must be positive: `minuteEstimatedTime > 0`\n- Must be integer: `Number.isInteger(minuteEstimatedTime)`\n\n**scheduledAt and pendingAt Requirements:**\n- Must be positive timestamps: `> 0`\n\n**Sources:** [src/client/ClientStrategy.ts:294-322]()\n\n---\n\n## GLOBAL_CONFIG Parameters\n\n### Validation Threshold Reference\n\n| Parameter | Default | Purpose | Impact if Violated |\n|-----------|---------|---------|-------------------|\n| `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` | 0.5% | Cover trading costs | Signal rejected (TP too close) |\n| `CC_MIN_STOPLOSS_DISTANCE_PERCENT` | 0.5% | Avoid instant stop-out | Signal rejected (SL too close) |\n| `CC_MAX_STOPLOSS_DISTANCE_PERCENT` | 20% | Cap maximum loss | Signal rejected (SL too far) |\n| `CC_MAX_SIGNAL_LIFETIME_MINUTES` | 1,440 | Prevent eternal signals | Signal rejected (lifetime too long) |\n| `CC_PERCENT_FEE` | 0.1% | Fee per transaction | Used in TP distance calc |\n| `CC_PERCENT_SLIPPAGE` | 0.1% | Slippage per transaction | Used in TP distance calc |\n\n**Setting Custom Thresholds:**\n```typescript\nimport { setConfig } from 'backtest-kit';\n\nsetConfig({\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 1.0,  // Require 1% min TP\n  CC_MAX_STOPLOSS_DISTANCE_PERCENT: 10,     // Limit SL to 10%\n  CC_MAX_SIGNAL_LIFETIME_MINUTES: 720,      // Max 12 hours per signal\n});\n```\n\n**Sources:** [src/config/params.ts:1-122]()\n\n---\n\n## Risk Validation Integration\n\n### IRisk.checkSignal Execution\n\nAfter passing all built-in validation stages, signals undergo custom risk validation via `IRisk.checkSignal()`:\n\n```mermaid\ngraph TD\n    A[\"VALIDATE_SIGNAL_FN passes\"]\n    B[\"GET_SIGNAL_FN execution continues\"]\n    C[\"IRisk.checkSignal called\"]\n    D[\"Custom validations:<br/>- Portfolio limits<br/>- Time windows<br/>- Symbol restrictions<br/>- Strategy coordination\"]\n    E[\"Risk check passes\"]\n    F[\"Risk check fails\"]\n    G[\"Signal accepted,<br/>proceeds to scheduling/opening\"]\n    H[\"Signal rejected,<br/>returns null\"]\n    \n    A --> B\n    B --> C\n    C --> D\n    D --> E\n    D --> F\n    E --> G\n    F --> H\n```\n\n**Risk Check Parameters:**\n```typescript\ninterface RiskCheckParams {\n  pendingSignal: ISignalDto;\n  symbol: string;\n  strategyName: string;\n  exchangeName: string;\n  currentPrice: number;\n  timestamp: number;\n}\n```\n\n**Integration Point in GET_SIGNAL_FN:**\n```typescript\n// After VALIDATE_SIGNAL_FN passes\nif (await not(\n  self.params.risk.checkSignal({\n    pendingSignal: signal,\n    symbol: self.params.execution.context.symbol,\n    strategyName: self.params.method.context.strategyName,\n    exchangeName: self.params.method.context.exchangeName,\n    currentPrice,\n    timestamp: currentTime,\n  })\n)) {\n  return null;  // Risk check failed\n}\n```\n\nFor details on implementing custom risk validation logic, see [Risk Profiles & Validation](#7.1).\n\n**Sources:** [src/client/ClientStrategy.ts:374-387](), [src/interfaces/Risk.interface.ts]()\n\n---\n\n## Candle Data Validation\n\n### Price Anomaly Detection\n\n**Purpose**: Detect and reject incomplete/corrupt candle data from exchanges that would corrupt VWAP calculations and signal execution.\n\n**Common Exchange Issues:**\n- Incomplete candles with prices near $0 (e.g., $0.01-$1.00 for BTC)\n- Missing volume data\n- Duplicate timestamps\n- Out-of-order candles\n\n### Anomaly Detection Algorithm\n\n```mermaid\ngraph TD\n    A[\"Fetch candles from exchange\"]\n    B[\"Calculate median price<br/>from all OHLC values\"]\n    C[\"For each candle:\"]\n    D[\"Check if any price<br/>< median / 1000\"]\n    E[\"Anomaly detected\"]\n    F[\"Filter out anomalous candle\"]\n    G[\"Valid candles only\"]\n    H[\"Throw error if<br/>all candles filtered\"]\n    \n    A --> B\n    B --> C\n    C --> D\n    D -->|\"Yes\"| E\n    D -->|\"No\"| G\n    E --> F\n    F --> C\n    G --> H\n```\n\n**Parameters:**\n- `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR`: Default 1,000\n- `CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN`: Default 5 candles\n\n**Example Detection:**\n```typescript\n// Normal BTC candles: $50,000 median\n// Threshold: $50,000 / 1,000 = $50\n// Any candle with price < $50 is rejected as anomalous\n\n// Incomplete candle: { low: 0.01, high: 0.02 } → REJECTED\n// Valid candle: { low: 49,900, high: 50,100 } → ACCEPTED\n```\n\n**Implementation Location:** `ExchangeCoreService.getCandles()` performs anomaly detection before returning candles to strategies.\n\n**Sources:** [src/config/params.ts:76-104](), [src/lib/services/core/ExchangeCoreService.ts]()\n\n---\n\n## Complete Validation Flow\n\n### From Signal Generation to Acceptance\n\n```mermaid\nflowchart TD\n    Start[\"Strategy.getSignal() called<br/>(throttled by interval)\"]\n    Return[\"Returns ISignalDto | null\"]\n    Null[\"null returned<br/>(no signal this tick)\"]\n    Signal[\"ISignalDto returned\"]\n    \n    Timeout[\"Timeout check<br/>(CC_MAX_SIGNAL_GENERATION_SECONDS)\"]\n    TimeoutFail[\"Timeout exceeded<br/>Error logged, null returned\"]\n    \n    Schema[\"VALIDATE_SIGNAL_FN<br/>Stage 1-10: Built-in validation\"]\n    SchemaFail[\"Validation error<br/>Error logged, null returned\"]\n    \n    Risk[\"IRisk.checkSignal<br/>Custom risk validation\"]\n    RiskFail[\"Risk rejected<br/>null returned\"]\n    \n    Immediate{\"priceOpen<br/>specified?\"}\n    CheckPrice{\"currentPrice<br/>reached priceOpen?\"}\n    \n    Scheduled[\"Create IScheduledSignalRow<br/>_isScheduled: true\"]\n    Opened[\"Create ISignalRow<br/>_isScheduled: false\"]\n    \n    Persist[\"Persist signal to storage<br/>(opened signals only)\"]\n    Monitor[\"Begin TP/SL monitoring\"]\n    \n    Start --> Return\n    Return --> Null\n    Return --> Signal\n    \n    Signal --> Timeout\n    Timeout -->|\"< max seconds\"| Schema\n    Timeout -->|\">= max seconds\"| TimeoutFail\n    \n    Schema -->|\"Pass\"| Risk\n    Schema -->|\"Fail\"| SchemaFail\n    \n    Risk -->|\"Pass\"| Immediate\n    Risk -->|\"Fail\"| RiskFail\n    \n    Immediate -->|\"Yes, priceOpen specified\"| CheckPrice\n    Immediate -->|\"No, use currentPrice\"| Opened\n    \n    CheckPrice -->|\"Not reached\"| Scheduled\n    CheckPrice -->|\"Reached\"| Opened\n    \n    Opened --> Persist\n    Persist --> Monitor\n    \n    Scheduled --> Monitor\n    \n    style SchemaFail fill:#ffe6e6\n    style RiskFail fill:#ffe6e6\n    style TimeoutFail fill:#ffe6e6\n    style Monitor fill:#e6ffe6\n```\n\n**Key Validation Points:**\n\n1. **Timeout Guard**: `CC_MAX_SIGNAL_GENERATION_SECONDS` (default: 180s) prevents hung signal generation\n2. **Schema Validation**: `VALIDATE_SIGNAL_FN` enforces 10 stages of built-in checks\n3. **Risk Validation**: `IRisk.checkSignal` applies custom portfolio/strategy rules\n4. **Persistence**: Only opened signals persist; scheduled signals remain ephemeral until activation\n\n**Sources:** [src/client/ClientStrategy.ts:332-476](), [src/config/params.ts:56-64]()\n\n---\n\n## Validation Error Handling\n\n### Error Accumulation Pattern\n\n```typescript\nconst errors: string[] = [];\n\n// Collect all violations\nif (signal.id === '') {\n  errors.push('id is required and must be a non-empty string');\n}\nif (!isFinite(currentPrice)) {\n  errors.push(`currentPrice must be a finite number, got ${currentPrice}`);\n}\nif (signal.position === \"long\" && signal.priceTakeProfit <= signal.priceOpen) {\n  errors.push(`Long: priceTakeProfit (${signal.priceTakeProfit}) must be > priceOpen (${signal.priceOpen})`);\n}\n\n// Throw comprehensive error if any violations found\nif (errors.length > 0) {\n  throw new Error(\n    `Invalid signal for ${signal.position} position:\\n${errors.join(\"\\n\")}`\n  );\n}\n```\n\n**Error Format:**\n```\nInvalid signal for long position:\nLong: priceTakeProfit (42010) must be > priceOpen (42000)\nLong: TakeProfit too close to priceOpen (0.024%). Minimum distance: 0.5% to cover trading fees.\nminuteEstimatedTime too large (50000 minutes = 34.7 days). Maximum: 1440 minutes (1 days) to prevent strategy deadlock.\n```\n\n**Handling**: Errors are caught in `GET_SIGNAL_FN`, logged via `errorEmitter`, and signal is rejected (returns `null`).\n\n**Sources:** [src/client/ClientStrategy.ts:324-330](), [src/client/ClientStrategy.ts:463-476]()\n\n---\n\n## Test Coverage\n\n### Validation Test Suites\n\nThe validation pipeline has extensive test coverage ensuring correctness:\n\n| Test Category | Test File | Purpose |\n|---------------|-----------|---------|\n| Micro-profit rejection | `test/e2e/sanitize.test.mjs:27-122` | TP too close to cover fees |\n| Extreme SL rejection | `test/e2e/sanitize.test.mjs:134-229` | SL exceeds max distance |\n| Eternal signal rejection | `test/e2e/sanitize.test.mjs:241-340` | Lifetime exceeds limit |\n| Immediate closure prevention | `test/e2e/edge.test.mjs` | Prevents open-and-close scenarios |\n| Price anomaly detection | `test/spec/validation.test.mjs` | Corrupt candle data handling |\n\n**Example Test: Micro-Profit Rejection:**\n```typescript\n// Signal: priceOpen=42000, TP=42010 (0.024% profit)\n// After fees (0.2%) and slippage (0.2%), net PNL would be NEGATIVE\n// Expected: Signal rejected by VALIDATE_SIGNAL_FN\n\nsetConfig({\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.3,\n}, true);\n\n// Signal should be rejected, scheduledCount and openedCount remain 0\n```\n\n**Sources:** [test/e2e/sanitize.test.mjs:1-340](), [test/e2e/edge.test.mjs](), [test/spec/validation.test.mjs]()"
                    },
                    {
                        "page_plan": {
                            "id": "7.3",
                            "title": "Position Sizing"
                        },
                        "content": "# Position Sizing\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page documents the position sizing system in Backtest Kit, which calculates the quantity of assets to trade based on account balance, risk parameters, and market conditions. Position sizing strategies include fixed percentage allocation, Kelly criterion, and ATR-based volatility adjustment. For portfolio-level risk constraints and signal validation, see [Risk Management](#7). For signal generation and lifecycle, see [Signals & Signal Lifecycle](#3.1).\n\n---\n\n## Overview\n\nThe position sizing system provides pluggable strategies for determining trade quantities. Each strategy implements a calculation function that takes account balance, risk parameters, signal data, and market conditions as input, then outputs a formatted quantity suitable for order execution.\n\n**Key capabilities:**\n- Multiple built-in strategies (FixedPercentage, Kelly, ATR)\n- Custom strategy registration via `addSizing()`\n- Integration with exchange precision formatting\n- Position size analytics and reporting via `PositionSize` class\n\nSources: [src/index.ts:96-104](), [types.d.ts:1-200]()\n\n---\n\n## Architecture Overview\n\n### Core Components\n\n```mermaid\ngraph TB\n    subgraph \"Public API\"\n        addSizing[\"addSizing()<br/>Function\"]\n        listSizings[\"listSizings()<br/>Function\"]\n        PositionSizeClass[\"PositionSize<br/>Class\"]\n    end\n    \n    subgraph \"Schema Definitions\"\n        ISizingSchema[\"ISizingSchema<br/>Base Interface\"]\n        ISizingSchemaFixedPercentage[\"ISizingSchemaFixedPercentage<br/>Fixed % strategy\"]\n        ISizingSchemaKelly[\"ISizingSchemaKelly<br/>Kelly criterion\"]\n        ISizingSchemaATR[\"ISizingSchemaATR<br/>ATR-based sizing\"]\n    end\n    \n    subgraph \"Calculate Parameters\"\n        ISizingCalculateParams[\"ISizingCalculateParams<br/>Base params\"]\n        ISizingCalculateParamsFixedPercentage[\"ISizingCalculateParamsFixedPercentage<br/>Fixed % params\"]\n        ISizingCalculateParamsKelly[\"ISizingCalculateParamsKelly<br/>Kelly params\"]\n        ISizingCalculateParamsATR[\"ISizingCalculateParamsATR<br/>ATR params\"]\n    end\n    \n    subgraph \"Service Layer\"\n        SizingSchemaService[\"SizingSchemaService<br/>Registry\"]\n        SizingValidationService[\"SizingValidationService<br/>Existence checks\"]\n        SizingConnectionService[\"SizingConnectionService<br/>Memoized clients\"]\n    end\n    \n    subgraph \"Integration Points\"\n        ClientStrategy[\"ClientStrategy<br/>Signal execution\"]\n        ClientExchange[\"ClientExchange<br/>Precision formatting\"]\n        IRisk[\"IRisk<br/>Risk validation\"]\n    end\n    \n    addSizing --> SizingSchemaService\n    listSizings --> SizingSchemaService\n    PositionSizeClass --> SizingConnectionService\n    \n    ISizingSchema --> ISizingSchemaFixedPercentage\n    ISizingSchema --> ISizingSchemaKelly\n    ISizingSchema --> ISizingSchemaATR\n    \n    ISizingCalculateParams --> ISizingCalculateParamsFixedPercentage\n    ISizingCalculateParams --> ISizingCalculateParamsKelly\n    ISizingCalculateParams --> ISizingCalculateParamsATR\n    \n    SizingSchemaService --> SizingValidationService\n    SizingValidationService --> SizingConnectionService\n    \n    SizingConnectionService --> ClientStrategy\n    ClientStrategy --> ClientExchange\n    ClientStrategy --> IRisk\n    \n    ISizingSchemaFixedPercentage --> ISizingCalculateParamsFixedPercentage\n    ISizingSchemaKelly --> ISizingCalculateParamsKelly\n    ISizingSchemaATR --> ISizingCalculateParamsATR\n```\n\n**Component Responsibilities:**\n\n| Component | Purpose |\n|-----------|---------|\n| `ISizingSchema` | Base interface defining `sizingName`, `calculate` function, and strategy-specific parameters |\n| Strategy schemas | Type-safe definitions for FixedPercentage, Kelly, and ATR strategies |\n| Calculate params | Runtime parameters passed to sizing functions (balance, signal, prices, etc.) |\n| `SizingSchemaService` | Registry for storing sizing schemas via `ToolRegistry` pattern |\n| `SizingValidationService` | Memoized existence checks for sizing schema names |\n| `SizingConnectionService` | Memoized factory for creating sizing calculator instances |\n| `PositionSize` class | Public API for running calculations and generating reports |\n\nSources: [src/index.ts:93-104](), [src/index.ts:187](), [types.d.ts:93-104]()\n\n---\n\n## Sizing Strategy Types\n\n### Interface Hierarchy\n\n```mermaid\nclassDiagram\n    class ISizingSchema {\n        <<interface>>\n        +string sizingName\n        +string? note\n        +calculate(params) Promise~number~\n    }\n    \n    class ISizingSchemaFixedPercentage {\n        <<interface>>\n        +string sizingName\n        +number percentageOfBalance\n        +calculate(params) Promise~number~\n    }\n    \n    class ISizingSchemaKelly {\n        <<interface>>\n        +string sizingName\n        +number maxKellyFraction\n        +number defaultWinRate?\n        +calculate(params) Promise~number~\n    }\n    \n    class ISizingSchemaATR {\n        <<interface>>\n        +string sizingName\n        +number atrMultiplier\n        +number atrPeriod\n        +number maxRiskPercent\n        +calculate(params) Promise~number~\n    }\n    \n    class ISizingCalculateParams {\n        <<interface>>\n        +string symbol\n        +number accountBalance\n        +ISignalDto pendingSignal\n        +number currentPrice\n        +Date when\n    }\n    \n    class IPositionSizeFixedPercentageParams {\n        <<interface>>\n        +number percentageOfBalance\n    }\n    \n    class IPositionSizeKellyParams {\n        <<interface>>\n        +number winRate\n        +number riskRewardRatio\n        +number kellyFraction\n    }\n    \n    class IPositionSizeATRParams {\n        <<interface>>\n        +number atr\n        +number atrMultiplier\n        +number maxRiskPercent\n        +number stopLossDistance\n    }\n    \n    ISizingSchema <|-- ISizingSchemaFixedPercentage\n    ISizingSchema <|-- ISizingSchemaKelly\n    ISizingSchema <|-- ISizingSchemaATR\n    \n    ISizingCalculateParams <.. ISizingSchemaFixedPercentage : uses\n    ISizingCalculateParams <.. ISizingSchemaKelly : uses\n    ISizingCalculateParams <.. ISizingSchemaATR : uses\n    \n    IPositionSizeFixedPercentageParams <.. ISizingSchemaFixedPercentage : runtime\n    IPositionSizeKellyParams <.. ISizingSchemaKelly : runtime\n    IPositionSizeATRParams <.. ISizingSchemaATR : runtime\n```\n\nSources: [types.d.ts:93-104]()\n\n---\n\n## Strategy Implementations\n\n### Fixed Percentage Strategy\n\nAllocates a fixed percentage of account balance to each trade. The simplest and most common approach.\n\n**Configuration:**\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `sizingName` | `string` | Unique identifier for this sizing strategy |\n| `percentageOfBalance` | `number` | Percentage of account to risk per trade (e.g., 2.0 for 2%) |\n| `calculate` | `function` | Function that computes position quantity |\n\n**Calculate Parameters (`ISizingCalculateParamsFixedPercentage`):**\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `symbol` | `string` | Trading pair (e.g., \"BTCUSDT\") |\n| `accountBalance` | `number` | Current account balance in quote currency |\n| `pendingSignal` | `ISignalDto` | Signal with TP/SL prices |\n| `currentPrice` | `number` | Current market price (VWAP) |\n| `when` | `Date` | Current timestamp |\n\n**Example:**\n```typescript\nimport { addSizing } from 'backtest-kit';\n\naddSizing({\n  sizingName: 'fixed-2-percent',\n  percentageOfBalance: 2.0,\n  calculate: async (params) => {\n    const { accountBalance, pendingSignal, currentPrice } = params;\n    const { priceOpen = currentPrice, priceStopLoss, position } = pendingSignal;\n    \n    // Calculate stop loss distance\n    const slDistance = position === 'long' \n      ? Math.abs(priceOpen - priceStopLoss) / priceOpen\n      : Math.abs(priceStopLoss - priceOpen) / priceOpen;\n    \n    // Risk amount = balance * percentage / 100\n    const riskAmount = accountBalance * (params.percentageOfBalance / 100);\n    \n    // Quantity = riskAmount / (slDistance * priceOpen)\n    const quantity = riskAmount / (slDistance * priceOpen);\n    \n    return quantity;\n  }\n});\n```\n\n**Calculation Logic:**\n1. Determine risk amount: `accountBalance * (percentageOfBalance / 100)`\n2. Calculate stop loss distance as percentage: `|priceOpen - priceStopLoss| / priceOpen`\n3. Compute quantity: `riskAmount / (slDistance * priceOpen)`\n\nSources: [types.d.ts:93-104](), [src/index.ts:96-104]()\n\n---\n\n### Kelly Criterion Strategy\n\nRisk-adjusted sizing based on win rate and risk/reward ratio. Maximizes long-term growth rate while accounting for statistical edge.\n\n**Configuration:**\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `sizingName` | `string` | Unique identifier |\n| `maxKellyFraction` | `number` | Cap on Kelly fraction (e.g., 0.25 for quarter-Kelly) |\n| `defaultWinRate` | `number?` | Fallback win rate if no historical data available |\n| `calculate` | `function` | Kelly calculation function |\n\n**Calculate Parameters (`ISizingCalculateParamsKelly`):**\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| Base params | `ISizingCalculateParams` | Standard sizing params |\n| `winRate` | `number` | Historical win rate (0-1) |\n| `riskRewardRatio` | `number` | Average reward/risk ratio |\n| `kellyFraction` | `number` | Fraction of Kelly to use |\n\n**Kelly Formula:**\n```\nKelly % = (winRate * (riskRewardRatio + 1) - 1) / riskRewardRatio\nPosition Size = accountBalance * min(Kelly %, maxKellyFraction)\n```\n\n**Example:**\n```typescript\nimport { addSizing } from 'backtest-kit';\n\naddSizing({\n  sizingName: 'kelly-quarter',\n  maxKellyFraction: 0.25, // Quarter-Kelly for safety\n  defaultWinRate: 0.5,\n  calculate: async (params) => {\n    const { accountBalance, pendingSignal, currentPrice } = params;\n    const { priceOpen = currentPrice, priceTakeProfit, priceStopLoss, position } = pendingSignal;\n    \n    // Calculate risk/reward ratio\n    const reward = position === 'long'\n      ? (priceTakeProfit - priceOpen) / priceOpen\n      : (priceOpen - priceTakeProfit) / priceOpen;\n    const risk = position === 'long'\n      ? (priceOpen - priceStopLoss) / priceOpen\n      : (priceStopLoss - priceOpen) / priceOpen;\n    const rrRatio = reward / risk;\n    \n    // Kelly calculation\n    const winRate = params.winRate || params.defaultWinRate || 0.5;\n    const kellyPercent = (winRate * (rrRatio + 1) - 1) / rrRatio;\n    const cappedKelly = Math.max(0, Math.min(kellyPercent, params.maxKellyFraction));\n    \n    // Position size\n    const positionValue = accountBalance * cappedKelly;\n    const quantity = positionValue / priceOpen;\n    \n    return quantity;\n  }\n});\n```\n\n**Safety Considerations:**\n- Full Kelly is aggressive; use fractional Kelly (0.25-0.5) for reduced volatility\n- Cap at `maxKellyFraction` to prevent over-leveraging\n- Negative Kelly (no edge) returns 0 position size\n\nSources: [types.d.ts:93-104]()\n\n---\n\n### ATR-Based Volatility Strategy\n\nAdjusts position size based on Average True Range (ATR), scaling down during high volatility and up during low volatility.\n\n**Configuration:**\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `sizingName` | `string` | Unique identifier |\n| `atrMultiplier` | `number` | Multiplier for ATR stop distance (e.g., 2.0) |\n| `atrPeriod` | `number` | Lookback period for ATR calculation (e.g., 14) |\n| `maxRiskPercent` | `number` | Maximum % of balance to risk per trade |\n| `calculate` | `function` | ATR-based calculation |\n\n**Calculate Parameters (`ISizingCalculateParamsATR`):**\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| Base params | `ISizingCalculateParams` | Standard sizing params |\n| `atr` | `number` | Current ATR value |\n| `atrMultiplier` | `number` | Stop loss distance = ATR * multiplier |\n| `maxRiskPercent` | `number` | Risk cap as percentage |\n| `stopLossDistance` | `number` | Calculated stop loss distance |\n\n**Example:**\n```typescript\nimport { addSizing, getCandles } from 'backtest-kit';\n\naddSizing({\n  sizingName: 'atr-2x',\n  atrMultiplier: 2.0,\n  atrPeriod: 14,\n  maxRiskPercent: 3.0,\n  calculate: async (params) => {\n    const { symbol, accountBalance, pendingSignal, currentPrice } = params;\n    const { priceOpen = currentPrice, position } = pendingSignal;\n    \n    // Fetch candles for ATR calculation\n    const candles = await getCandles(symbol, '1h', params.atrPeriod + 1);\n    \n    // Calculate ATR\n    let atr = 0;\n    for (let i = 1; i < candles.length; i++) {\n      const tr = Math.max(\n        candles[i].high - candles[i].low,\n        Math.abs(candles[i].high - candles[i-1].close),\n        Math.abs(candles[i].low - candles[i-1].close)\n      );\n      atr += tr;\n    }\n    atr /= params.atrPeriod;\n    \n    // Stop loss distance based on ATR\n    const slDistance = (atr * params.atrMultiplier) / priceOpen;\n    \n    // Risk amount\n    const maxRisk = accountBalance * (params.maxRiskPercent / 100);\n    \n    // Quantity\n    const quantity = maxRisk / (slDistance * priceOpen);\n    \n    return quantity;\n  }\n});\n```\n\n**Calculation Flow:**\n1. Calculate ATR from recent candles\n2. Determine stop loss distance: `ATR * atrMultiplier / currentPrice`\n3. Calculate max risk: `accountBalance * (maxRiskPercent / 100)`\n4. Compute quantity: `maxRisk / (slDistance * priceOpen)`\n\n**Benefits:**\n- Automatically reduces position size during volatile markets\n- Increases position size during stable markets\n- Maintains consistent risk across varying market conditions\n\nSources: [types.d.ts:93-104](), [src/function/exchange.ts:59]()\n\n---\n\n## Integration with Strategy Execution\n\n### Position Sizing in Signal Lifecycle\n\n```mermaid\nsequenceDiagram\n    participant User as \"User Code\"\n    participant addSizing as \"addSizing()\"\n    participant SizingSchemaService as \"SizingSchemaService\"\n    participant ClientStrategy as \"ClientStrategy\"\n    participant SizingConnectionService as \"SizingConnectionService\"\n    participant calculate as \"calculate()<br/>Sizing Function\"\n    participant ClientExchange as \"ClientExchange\"\n    participant IExchange as \"IExchange.formatQuantity()\"\n    \n    User->>addSizing: Define sizing strategy\n    addSizing->>SizingSchemaService: Store schema in ToolRegistry\n    \n    Note over ClientStrategy: During signal execution...\n    \n    ClientStrategy->>SizingConnectionService: Get sizing calculator\n    SizingConnectionService->>SizingSchemaService: Load schema by sizingName\n    SizingConnectionService-->>ClientStrategy: Return calculator instance\n    \n    ClientStrategy->>calculate: Call with ISizingCalculateParams\n    Note over calculate: accountBalance, pendingSignal,<br/>currentPrice, symbol, when\n    calculate-->>ClientStrategy: Return raw quantity (e.g., 0.05321)\n    \n    ClientStrategy->>ClientExchange: Format quantity for exchange\n    ClientExchange->>IExchange: formatQuantity(symbol, quantity)\n    IExchange-->>ClientExchange: Formatted string (e.g., \"0.05321000\")\n    ClientExchange-->>ClientStrategy: Exchange-compliant quantity\n    \n    ClientStrategy->>ClientStrategy: Execute order with formatted quantity\n```\n\n**Integration Points:**\n\n1. **Strategy Registration (`addSizing`):**\n   - User defines sizing strategy with `sizingName` and `calculate` function\n   - `SizingSchemaService` stores schema in `ToolRegistry`\n\n2. **Signal Execution (`ClientStrategy.tick`):**\n   - When new signal created, retrieve sizing calculator via `SizingConnectionService`\n   - Call `calculate()` with current market conditions\n   - Pass raw quantity to `ClientExchange.formatQuantity()`\n\n3. **Exchange Formatting:**\n   - Exchange-specific precision rules applied\n   - Output complies with exchange lot size requirements\n\n4. **Risk Validation:**\n   - Calculated quantity validated against portfolio-level risk limits\n   - See [Portfolio-Wide Limits](#7.4) for risk integration\n\nSources: [src/index.ts:17](), [src/function/exchange.ts:63-65]()\n\n---\n\n## Public API Usage\n\n### Registering a Sizing Strategy\n\n```mermaid\ngraph LR\n    UserCode[\"User Code\"] -->|1. addSizing schema| addSizing[\"addSizing()<br/>src/function/add.ts\"]\n    addSizing -->|2. Store in registry| SizingSchemaService[\"SizingSchemaService<br/>lib/services/schema\"]\n    SizingSchemaService -->|3. Validate uniqueness| SizingValidationService[\"SizingValidationService<br/>lib/services/validation\"]\n    \n    UserCode2[\"Strategy Code\"] -->|1. Reference sizingName| IStrategySchema[\"IStrategySchema<br/>sizingName: string\"]\n    IStrategySchema -->|2. Validate exists| SizingValidationService\n    IStrategySchema -->|3. Retrieve| SizingConnectionService[\"SizingConnectionService<br/>lib/services/connection\"]\n    SizingConnectionService -->|4. Instantiate| ClientSizing[\"Sizing Calculator<br/>Memoized instance\"]\n    ClientSizing -->|5. Call calculate| CalculateFn[\"calculate(params)<br/>User-defined function\"]\n```\n\n**Method: `addSizing(schema: ISizingSchema)`**\n\nRegisters a position sizing strategy for use in trading strategies.\n\n**Parameters:**\n\n| Parameter | Type | Required | Description |\n|-----------|------|----------|-------------|\n| `schema.sizingName` | `string` | Yes | Unique identifier for this sizing strategy |\n| `schema.note` | `string` | No | Optional documentation/description |\n| `schema.calculate` | `function` | Yes | Position size calculation function |\n| Strategy params | varies | Yes | Strategy-specific parameters (e.g., `percentageOfBalance`) |\n\n**Example:**\n```typescript\nimport { addSizing } from 'backtest-kit';\n\n// Register fixed percentage strategy\naddSizing({\n  sizingName: 'conservative-1pct',\n  note: 'Conservative 1% risk per trade',\n  percentageOfBalance: 1.0,\n  calculate: async (params) => {\n    // Implementation...\n    return quantity;\n  }\n});\n```\n\nSources: [src/function/add.ts:17](), [src/index.ts:96-104]()\n\n---\n\n### Using Sizing in Strategies\n\nStrategies reference sizing by `sizingName` in their schema definition:\n\n```typescript\nimport { addStrategy, addSizing } from 'backtest-kit';\n\n// 1. Define sizing strategy\naddSizing({\n  sizingName: 'kelly-conservative',\n  maxKellyFraction: 0.25,\n  defaultWinRate: 0.55,\n  calculate: async (params) => {\n    // Kelly calculation...\n    return quantity;\n  }\n});\n\n// 2. Reference in strategy schema\naddStrategy({\n  strategyName: 'my-strategy',\n  interval: '5m',\n  sizingName: 'kelly-conservative', // Link to sizing strategy\n  getSignal: async (symbol, when) => {\n    // Signal generation...\n    return signal;\n  }\n});\n```\n\n**Execution Flow:**\n1. Strategy schema includes `sizingName` reference\n2. During signal execution, `ClientStrategy` validates sizing exists\n3. `SizingConnectionService` retrieves calculator instance (memoized)\n4. `calculate()` called with current market context\n5. Returned quantity formatted and used for order execution\n\nSources: [src/index.ts:11-17](), [types.d.ts:728-747]()\n\n---\n\n### Listing Available Strategies\n\n**Method: `listSizings(): string[]`**\n\nReturns array of all registered sizing strategy names.\n\n```typescript\nimport { addSizing, listSizings } from 'backtest-kit';\n\naddSizing({\n  sizingName: 'fixed-2pct',\n  percentageOfBalance: 2.0,\n  calculate: async (params) => { /* ... */ }\n});\n\naddSizing({\n  sizingName: 'kelly-quarter',\n  maxKellyFraction: 0.25,\n  calculate: async (params) => { /* ... */ }\n});\n\nconst sizings = listSizings();\nconsole.log(sizings); // ['fixed-2pct', 'kelly-quarter']\n```\n\nSources: [src/function/list.ts:23-25]()\n\n---\n\n## PositionSize Class - Reporting & Analytics\n\nThe `PositionSize` class provides methods for calculating position sizes across multiple scenarios and generating reports.\n\n**Class: `PositionSize`**\n\n```typescript\nclass PositionSize {\n  static run(symbol: string, options: {...}): AsyncIterableIterator<...>\n  static background(symbol: string, options: {...}): void\n  static getData(symbol: string, sizingName: string): Promise<...>\n  static getReport(symbol: string, sizingName: string, columns?: ...): string\n  static dump(symbol: string, sizingName: string, filePath?: string): Promise<void>\n  static stop(symbol: string, sizingName: string): void\n}\n```\n\n### Running Position Size Calculations\n\n**Method: `PositionSize.run(symbol, options)`**\n\nRuns position size calculations for a range of scenarios (account balances, signal prices, etc.).\n\n```typescript\nimport { PositionSize } from 'backtest-kit';\n\nfor await (const result of PositionSize.run('BTCUSDT', {\n  sizingName: 'kelly-quarter',\n  exchangeName: 'binance',\n  accountBalances: [10000, 50000, 100000], // Test different balances\n  currentPrices: [30000, 35000, 40000],    // Test different prices\n})) {\n  console.log(`Balance: $${result.accountBalance}`);\n  console.log(`Price: $${result.currentPrice}`);\n  console.log(`Quantity: ${result.quantity}`);\n  console.log(`Position Value: $${result.positionValue}`);\n}\n```\n\n**Method: `PositionSize.background(symbol, options)`**\n\nRuns calculations in the background, emitting events for monitoring.\n\n```typescript\nimport { PositionSize, listenPerformance } from 'backtest-kit';\n\nlistenPerformance((event) => {\n  console.log(`Calculation took ${event.duration}ms`);\n});\n\nPositionSize.background('BTCUSDT', {\n  sizingName: 'atr-2x',\n  exchangeName: 'binance',\n  accountBalances: [10000, 25000, 50000],\n});\n```\n\nSources: [src/classes/PositionSize:1-100]()\n\n---\n\n### Generating Reports\n\n**Method: `PositionSize.getData(symbol, sizingName)`**\n\nReturns structured data for position size calculations.\n\n```typescript\nconst data = await PositionSize.getData('BTCUSDT', 'kelly-quarter');\n\nconsole.log(data.summary);\n// {\n//   averageQuantity: 0.1234,\n//   medianQuantity: 0.1150,\n//   minQuantity: 0.0500,\n//   maxQuantity: 0.2000,\n//   totalScenarios: 27\n// }\n\nconsole.log(data.scenarios);\n// [\n//   { accountBalance: 10000, currentPrice: 30000, quantity: 0.1000, ... },\n//   { accountBalance: 10000, currentPrice: 35000, quantity: 0.0857, ... },\n//   ...\n// ]\n```\n\n**Method: `PositionSize.getReport(symbol, sizingName, columns?)`**\n\nGenerates formatted markdown report.\n\n```typescript\nconst report = PositionSize.getReport('BTCUSDT', 'kelly-quarter');\n\nconsole.log(report);\n```\n\n**Sample Output:**\n```markdown\n# Position Size Report: kelly-quarter\n\nSymbol: BTCUSDT\nStrategy: kelly-quarter\nGenerated: 2024-01-15 10:30:00\n\n## Summary Statistics\n\n| Metric | Value |\n|--------|-------|\n| Average Quantity | 0.1234 BTC |\n| Median Quantity | 0.1150 BTC |\n| Min Quantity | 0.0500 BTC |\n| Max Quantity | 0.2000 BTC |\n| Total Scenarios | 27 |\n\n## Scenarios\n\n| Balance | Price | Quantity | Position Value | Risk % |\n|---------|-------|----------|----------------|--------|\n| $10,000 | $30,000 | 0.1000 | $3,000 | 2.5% |\n| $10,000 | $35,000 | 0.0857 | $3,000 | 2.5% |\n...\n```\n\n**Method: `PositionSize.dump(symbol, sizingName, filePath?)`**\n\nSaves report to file system.\n\n```typescript\nawait PositionSize.dump('BTCUSDT', 'kelly-quarter', './reports/position-size.md');\n// Saves to ./reports/position-size.md\n```\n\nDefault path: `./dump/position-size/{symbol}_{sizingName}.md`\n\nSources: [src/classes/PositionSize:1-200]()\n\n---\n\n## Best Practices\n\n### Choosing a Sizing Strategy\n\n| Strategy | Use When | Pros | Cons |\n|----------|----------|------|------|\n| **Fixed Percentage** | Consistent risk tolerance, simple execution | Easy to understand, predictable | Doesn't adapt to market conditions |\n| **Kelly Criterion** | Optimizing long-term growth, statistical edge available | Mathematically optimal, adjusts to edge | Requires accurate win rate/RR, can be aggressive |\n| **ATR-Based** | Volatility-sensitive positioning, trend following | Adapts to volatility, reduces risk in wild markets | Requires ATR calculation, more complex |\n\n### Risk Management Integration\n\nPosition sizing works with risk validation:\n\n```typescript\nimport { addRisk, addSizing } from 'backtest-kit';\n\n// 1. Define position sizing\naddSizing({\n  sizingName: 'fixed-2pct',\n  percentageOfBalance: 2.0,\n  calculate: async (params) => { /* ... */ }\n});\n\n// 2. Define risk limits that validate position sizes\naddRisk({\n  riskName: 'portfolio-limits',\n  validations: [\n    // Max 3 concurrent positions\n    ({ activePositionCount }) => {\n      if (activePositionCount >= 3) {\n        throw new Error('Max 3 positions');\n      }\n    },\n    // Max 6% total portfolio risk\n    ({ pendingSignal, currentPrice, activePositions }) => {\n      const positionRisk = /* calculate from pendingSignal */;\n      const totalRisk = activePositions.reduce((sum, pos) => {\n        return sum + /* position risk */;\n      }, 0) + positionRisk;\n      \n      if (totalRisk > 6.0) {\n        throw new Error('Total portfolio risk exceeds 6%');\n      }\n    }\n  ]\n});\n\n// 3. Use both in strategy\naddStrategy({\n  strategyName: 'my-strategy',\n  sizingName: 'fixed-2pct',\n  riskName: 'portfolio-limits',\n  getSignal: async (symbol, when) => { /* ... */ }\n});\n```\n\n**Validation Order:**\n1. Signal generated by `getSignal()`\n2. Position quantity calculated by sizing strategy\n3. Risk validations run with calculated quantity\n4. If risk validation fails, signal rejected (see [Signal Validation Pipeline](#7.2))\n\nSources: [types.d.ts:413-426](), [types.d.ts:728-747]()\n\n---\n\n### Testing Sizing Strategies\n\nUse `PositionSize.run()` to test strategies across scenarios:\n\n```typescript\nimport { PositionSize, addSizing } from 'backtest-kit';\n\n// Define strategy\naddSizing({\n  sizingName: 'test-strategy',\n  calculate: async (params) => {\n    // Your calculation...\n    return quantity;\n  }\n});\n\n// Test across scenarios\nfor await (const result of PositionSize.run('BTCUSDT', {\n  sizingName: 'test-strategy',\n  exchangeName: 'binance',\n  accountBalances: [5000, 10000, 20000, 50000],\n  currentPrices: [25000, 30000, 35000, 40000, 45000],\n  signalConfigs: [\n    { position: 'long', priceOpen: 30000, priceTakeProfit: 33000, priceStopLoss: 29000 },\n    { position: 'short', priceOpen: 30000, priceTakeProfit: 27000, priceStopLoss: 31000 },\n  ]\n})) {\n  // Validate results\n  console.assert(result.quantity > 0, 'Quantity should be positive');\n  console.assert(result.positionValue <= result.accountBalance, 'Position value should not exceed balance');\n  \n  const riskPercent = (result.quantity * result.stopLossDistance * result.currentPrice) / result.accountBalance * 100;\n  console.assert(riskPercent <= 5.0, 'Risk should not exceed 5%');\n}\n```\n\nSources: [src/classes/PositionSize:1-100]()\n\n---\n\n## Advanced Topics\n\n### Custom Sizing Strategies\n\nImplement custom strategies by providing a `calculate` function:\n\n```typescript\nimport { addSizing, getCandles } from 'backtest-kit';\n\n// Volatility-adjusted with Bollinger Bands\naddSizing({\n  sizingName: 'bollinger-adaptive',\n  period: 20,\n  stdDevMultiplier: 2.0,\n  baseRiskPercent: 2.0,\n  calculate: async (params) => {\n    const { symbol, accountBalance, pendingSignal, currentPrice, when } = params;\n    const { priceOpen = currentPrice, priceStopLoss, position } = pendingSignal;\n    \n    // Fetch candles\n    const candles = await getCandles(symbol, '1h', params.period);\n    \n    // Calculate Bollinger Bands\n    const closes = candles.map(c => c.close);\n    const sma = closes.reduce((a, b) => a + b, 0) / closes.length;\n    const variance = closes.reduce((sum, c) => sum + Math.pow(c - sma, 2), 0) / closes.length;\n    const stdDev = Math.sqrt(variance);\n    const upperBand = sma + stdDev * params.stdDevMultiplier;\n    const lowerBand = sma - stdDev * params.stdDevMultiplier;\n    const bandWidth = (upperBand - lowerBand) / sma;\n    \n    // Adjust risk based on band width\n    // Narrow bands (low volatility) = increase position size\n    // Wide bands (high volatility) = decrease position size\n    const volatilityFactor = 1 / (1 + bandWidth * 10);\n    const adjustedRisk = params.baseRiskPercent * volatilityFactor;\n    \n    // Calculate position size\n    const slDistance = position === 'long'\n      ? Math.abs(priceOpen - priceStopLoss) / priceOpen\n      : Math.abs(priceStopLoss - priceOpen) / priceOpen;\n    \n    const riskAmount = accountBalance * (adjustedRisk / 100);\n    const quantity = riskAmount / (slDistance * priceOpen);\n    \n    return quantity;\n  }\n});\n```\n\n**Custom Strategy Considerations:**\n- Use `getCandles()` for historical data access\n- Respect temporal context (no look-ahead bias)\n- Handle edge cases (division by zero, negative values)\n- Return 0 for \"no position\" scenarios\n- Consider exchange precision limits\n\nSources: [src/function/exchange.ts:59-65]()\n\n---\n\n### Multi-Strategy Portfolio Sizing\n\nCoordinate sizing across multiple strategies:\n\n```typescript\nimport { addRisk, addSizing } from 'backtest-kit';\n\n// Global position sizing coordinator\nconst portfolioState = {\n  allocatedCapital: 0,\n  reservedCapital: 0\n};\n\naddRisk({\n  riskName: 'portfolio-coordinator',\n  validations: [\n    ({ pendingSignal, currentPrice, activePositions, strategyName }) => {\n      // Calculate total allocated capital\n      const activeCapital = activePositions.reduce((sum, pos) => {\n        return sum + pos.signal.priceOpen * /* position quantity */;\n      }, 0);\n      \n      // Calculate pending position capital\n      const pendingCapital = (pendingSignal.priceOpen || currentPrice) * /* calculated quantity */;\n      \n      // Check total allocation doesn't exceed limit\n      const totalAllocation = activeCapital + pendingCapital;\n      const accountBalance = 100000; // Get from config\n      \n      if (totalAllocation > accountBalance * 0.8) {\n        throw new Error('Portfolio allocation exceeds 80% limit');\n      }\n      \n      // Reserve capital for this position\n      portfolioState.allocatedCapital = totalAllocation;\n    }\n  ]\n});\n```\n\nSources: [types.d.ts:380-396](), [types.d.ts:413-446]()\n\n---\n\n## Summary\n\nThe position sizing system provides:\n\n1. **Multiple Strategies** - FixedPercentage, Kelly, ATR-based, and custom implementations\n2. **Type-Safe Interfaces** - Separate schemas for each strategy type with compile-time validation\n3. **Integration** - Seamless connection to signal execution, risk management, and exchange formatting\n4. **Testing & Reporting** - `PositionSize` class for scenario analysis and documentation\n5. **Flexibility** - Plugin architecture for custom sizing algorithms\n\n**Related Documentation:**\n- [Risk Management](#7) - Portfolio limits and signal validation\n- [Risk Validation Pipeline](#7.2) - How sizing interacts with risk checks\n- [Signals & Signal Lifecycle](#3.1) - Signal execution flow\n- [Exchange Configuration](#8.1) - Quantity formatting and precision\n\nSources: [src/index.ts:93-104](), [src/index.ts:187](), [src/function/add.ts:17]()"
                    },
                    {
                        "page_plan": {
                            "id": "7.4",
                            "title": "Portfolio-Wide Limits"
                        },
                        "content": "# Portfolio-Wide Limits\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Heat.ts](src/classes/Heat.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Partial.ts](src/classes/Partial.ts)\n- [src/classes/Performance.ts](src/classes/Performance.ts)\n- [src/classes/Risk.ts](src/classes/Risk.ts)\n- [src/classes/Schedule.ts](src/classes/Schedule.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/add.ts](src/function/add.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/function/list.ts](src/function/list.ts)\n- [src/index.ts](src/index.ts)\n- [src/lib/core/provide.ts](src/lib/core/provide.ts)\n- [src/lib/core/types.ts](src/lib/core/types.ts)\n- [src/lib/index.ts](src/lib/index.ts)\n- [test/spec/columns.test.mjs](test/spec/columns.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document covers portfolio-wide risk management in Backtest Kit, focusing on how the system tracks and enforces limits across multiple strategies and symbols simultaneously. Portfolio-wide limits enable cross-strategy risk analysis by maintaining a global view of all active positions.\n\nFor individual signal validation rules (price checks, TP/SL logic), see [Signal Validation Pipeline](#7.2). For position sizing calculations, see [Position Sizing](#7.3). For defining basic risk profiles, see [Risk Profiles & Validation](#7.1).\n\nThe core mechanism is **RiskGlobalService**, which maintains a centralized registry of active positions and makes this data available to all risk validation functions through the `IRiskValidationPayload` interface.\n\n---\n\n## System Architecture\n\nThe portfolio-wide risk system consists of three main components that work together to enforce limits across strategies:\n\n```mermaid\ngraph TB\n    subgraph \"Strategy Execution Layer\"\n        CS1[\"ClientStrategy<br/>(Symbol: BTCUSDT, Strategy: strat-a)\"]\n        CS2[\"ClientStrategy<br/>(Symbol: ETHUSDT, Strategy: strat-a)\"]\n        CS3[\"ClientStrategy<br/>(Symbol: BTCUSDT, Strategy: strat-b)\"]\n    end\n    \n    subgraph \"Connection Layer - Memoization\"\n        RC[\"RiskConnectionService<br/>getOrCreateRisk(riskName)\"]\n    end\n    \n    subgraph \"Client Layer - Shared Instances\"\n        CR[\"ClientRisk<br/>(riskName: 'portfolio-limit')<br/>checkSignal()<br/>addSignal()<br/>removeSignal()\"]\n    end\n    \n    subgraph \"Global State Layer\"\n        RGS[\"RiskGlobalService<br/>_positions: Map&lt;riskName, Set&lt;positionKey&gt;&gt;<br/>_positionData: Map&lt;positionKey, IRiskActivePosition&gt;\"]\n    end\n    \n    subgraph \"Schema Layer\"\n        RSS[\"RiskSchemaService<br/>get(riskName): IRiskSchema\"]\n        Schema[\"IRiskSchema<br/>- validations: IRiskValidation[]<br/>- callbacks\"]\n    end\n    \n    CS1 -->|\"uses\"| RC\n    CS2 -->|\"uses\"| RC\n    CS3 -->|\"uses\"| RC\n    \n    RC -->|\"memoized by riskName\"| CR\n    \n    CR -->|\"reads schema\"| RSS\n    RSS -->|\"returns\"| Schema\n    \n    CR -->|\"addSignal(symbol, context)\"| RGS\n    CR -->|\"removeSignal(symbol, context)\"| RGS\n    CR -->|\"checkSignal(params)\"<br/>\"queries active positions\"| RGS\n    \n    RGS -->|\"builds IRiskValidationPayload<br/>with activePositionCount<br/>and activePositions array\"| CR\n    \n    style RGS fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style CR fill:#e8f4f8,stroke:#333,stroke-width:2px\n    style RC fill:#fff9e6,stroke:#333,stroke-width:2px\n```\n\n**Key Architecture Points:**\n\n1. **Shared Instance Pattern**: Multiple `ClientStrategy` instances that use the same `riskName` share a single `ClientRisk` instance (memoized by `RiskConnectionService`)\n\n2. **Centralized State**: `RiskGlobalService` maintains two Maps:\n   - `_positions`: Tracks which position keys belong to each risk profile\n   - `_positionData`: Stores detailed `IRiskActivePosition` data for each position\n\n3. **Lifecycle Integration**: When a signal opens, `ClientRisk.addSignal()` registers it with `RiskGlobalService`. When closed, `ClientRisk.removeSignal()` unregisters it\n\n4. **Validation Context**: During `checkSignal()`, `RiskGlobalService` provides the current portfolio state through `IRiskValidationPayload`\n\n**Sources:** [src/lib/services/connection/RiskConnectionService.ts](), [src/lib/services/global/RiskGlobalService.ts](), [types.d.ts:413-479](), [src/function/add.ts:270-343]()\n\n---\n\n## Active Position Tracking\n\nThe system tracks active positions using a unique key per symbol-strategy pair and stores comprehensive position metadata:\n\n### Position Key Format\n\n```typescript\n// Position key format: \"symbol:strategyName\"\n// Example: \"BTCUSDT:my-strategy\"\nconst positionKey = `${symbol}:${strategyName}`;\n```\n\n### IRiskActivePosition Structure\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `signal` | `ISignalRow` | Complete signal data including id, position, prices, timestamps |\n| `strategyName` | `string` | Name of the strategy that opened this position |\n| `exchangeName` | `string` | Name of the exchange being used |\n| `openTimestamp` | `number` | Unix timestamp (milliseconds) when position opened |\n\n### Tracking Lifecycle\n\n```mermaid\nsequenceDiagram\n    participant CS as ClientStrategy\n    participant CR as ClientRisk\n    participant RGS as RiskGlobalService\n    \n    Note over CS: Signal passes validation,<br/>ready to open\n    \n    CS->>CR: addSignal(symbol, {strategyName, riskName})\n    CR->>RGS: addPosition(riskName, positionKey, positionData)\n    RGS->>RGS: _positions.get(riskName).add(positionKey)\n    RGS->>RGS: _positionData.set(positionKey, {signal, strategyName, exchangeName, openTimestamp})\n    RGS-->>CR: Position registered\n    CR-->>CS: Success\n    \n    Note over CS: Signal active,<br/>monitoring TP/SL\n    \n    CS->>CR: checkSignal(params) [for NEW signal]\n    CR->>RGS: getActivePositions(riskName)\n    RGS-->>CR: {activePositionCount, activePositions[]}\n    CR->>CR: Run validations with payload\n    CR-->>CS: true/false\n    \n    Note over CS: Signal closes<br/>(TP/SL/time)\n    \n    CS->>CR: removeSignal(symbol, {strategyName, riskName})\n    CR->>RGS: removePosition(riskName, positionKey)\n    RGS->>RGS: _positions.get(riskName).delete(positionKey)\n    RGS->>RGS: _positionData.delete(positionKey)\n    RGS-->>CR: Position removed\n    CR-->>CS: Success\n```\n\n**Important:** Only **opened** signals are tracked. Scheduled signals (waiting for `priceOpen`) are NOT added to the position registry until they activate.\n\n**Sources:** [types.d.ts:358-369](), [src/lib/services/global/RiskGlobalService.ts](), [src/classes/Risk.ts:42-116]()\n\n---\n\n## Validation Payload Structure\n\nDuring `checkSignal()`, custom validation functions receive an `IRiskValidationPayload` object containing both the pending signal's data and the current portfolio state:\n\n```mermaid\ngraph LR\n    subgraph \"IRiskValidationPayload Interface\"\n        direction TB\n        \n        subgraph \"From IRiskCheckArgs (pending signal)\"\n            A[\"symbol: string<br/>'BTCUSDT'\"]\n            B[\"pendingSignal: ISignalDto<br/>{position, priceOpen, priceTP, priceSL, ...}\"]\n            C[\"strategyName: string<br/>'my-strategy'\"]\n            D[\"exchangeName: string<br/>'binance'\"]\n            E[\"currentPrice: number<br/>50123.45\"]\n            F[\"timestamp: number<br/>1705320000000\"]\n        end\n        \n        subgraph \"Portfolio State (from RiskGlobalService)\"\n            G[\"activePositionCount: number<br/>3\"]\n            H[\"activePositions: IRiskActivePosition[]<br/>[{signal, strategyName, exchangeName, openTimestamp}, ...]\"]\n        end\n    end\n    \n    style G fill:#ffffcc,stroke:#666,stroke-width:2px\n    style H fill:#ffffcc,stroke:#666,stroke-width:2px\n```\n\n### Field Reference Table\n\n| Category | Field | Type | Description |\n|----------|-------|------|-------------|\n| **Pending Signal** | `symbol` | `string` | Trading pair for the new signal |\n| | `pendingSignal` | `ISignalDto` | Signal details (position, prices, time) |\n| | `strategyName` | `string` | Strategy attempting to open |\n| | `exchangeName` | `string` | Exchange being used |\n| | `currentPrice` | `number` | Current VWAP price |\n| | `timestamp` | `number` | Unix timestamp of check (ms) |\n| **Portfolio State** | `activePositionCount` | `number` | Total open positions for this risk profile |\n| | `activePositions` | `IRiskActivePosition[]` | Array of all active position details |\n\n### IRiskActivePosition Contents\n\nEach element in the `activePositions` array contains:\n\n```typescript\ninterface IRiskActivePosition {\n  signal: ISignalRow;           // Full signal data (id, position, priceOpen, etc.)\n  strategyName: string;          // Which strategy owns this position\n  exchangeName: string;          // Which exchange is being used\n  openTimestamp: number;         // When position opened (ms)\n}\n```\n\n**Sources:** [types.d.ts:382-397](), [types.d.ts:358-369](), [types.d.ts:342-356]()\n\n---\n\n## Writing Portfolio-Wide Validations\n\nCustom validation functions access portfolio state through the `IRiskValidationPayload` parameter. Validations throw errors to reject signals or return successfully to allow them.\n\n### Basic Pattern\n\n```typescript\nimport { addRisk } from \"backtest-kit\";\n\naddRisk({\n  riskName: \"portfolio-limits\",\n  validations: [\n    // Validation function signature\n    async (payload: IRiskValidationPayload) => {\n      // Access pending signal\n      const { symbol, pendingSignal, strategyName } = payload;\n      \n      // Access portfolio state\n      const { activePositionCount, activePositions } = payload;\n      \n      // Validation logic\n      if (activePositionCount >= 5) {\n        throw new Error(\"Maximum 5 concurrent positions allowed\");\n      }\n      \n      // If no error thrown, signal is allowed\n    }\n  ]\n});\n```\n\n### Accessing Active Positions\n\n```mermaid\ngraph TB\n    subgraph \"Validation Function Scope\"\n        VP[\"IRiskValidationPayload<br/>received as parameter\"]\n    end\n    \n    subgraph \"Portfolio Analysis Patterns\"\n        P1[\"Count Check<br/>activePositionCount >= maxPositions\"]\n        P2[\"Symbol Exposure<br/>activePositions.filter(p => p.signal.symbol === symbol)\"]\n        P3[\"Strategy Exposure<br/>activePositions.filter(p => p.strategyName === strategyName)\"]\n        P4[\"Position Side Balance<br/>count LONG vs SHORT positions\"]\n        P5[\"Time-Based Limits<br/>activePositions.filter(p => timestamp - p.openTimestamp < limit)\"]\n        P6[\"Price Correlation<br/>compare pendingSignal prices with active signals\"]\n    end\n    \n    VP --> P1\n    VP --> P2\n    VP --> P3\n    VP --> P4\n    VP --> P5\n    VP --> P6\n    \n    P1 -->|\"throw Error\"| Reject[\"Signal Rejected\"]\n    P2 -->|\"throw Error\"| Reject\n    P3 -->|\"throw Error\"| Reject\n    P4 -->|\"throw Error\"| Reject\n    P5 -->|\"throw Error\"| Reject\n    P6 -->|\"throw Error\"| Reject\n    \n    P1 -->|\"return\"| Allow[\"Signal Allowed\"]\n    P2 -->|\"return\"| Allow\n    P3 -->|\"return\"| Allow\n    P4 -->|\"return\"| Allow\n    P5 -->|\"return\"| Allow\n    P6 -->|\"return\"| Allow\n    \n    style Reject fill:#ffcccc,stroke:#cc0000,stroke-width:2px\n    style Allow fill:#ccffcc,stroke:#00cc00,stroke-width:2px\n```\n\n**Sources:** [types.d.ts:394-397](), [types.d.ts:382-397](), [src/function/add.ts:289-343]()\n\n---\n\n## Common Portfolio Limit Patterns\n\n### Pattern 1: Maximum Concurrent Positions\n\nEnforce a hard limit on total open positions across all strategies and symbols:\n\n```typescript\naddRisk({\n  riskName: \"max-5-positions\",\n  validations: [\n    (payload) => {\n      if (payload.activePositionCount >= 5) {\n        throw new Error(`Portfolio limit: ${payload.activePositionCount}/5 positions active`);\n      }\n    }\n  ]\n});\n```\n\n### Pattern 2: Per-Symbol Exposure Limit\n\nLimit concurrent positions on the same symbol:\n\n```typescript\naddRisk({\n  riskName: \"max-2-per-symbol\",\n  validations: [\n    (payload) => {\n      const { symbol, activePositions } = payload;\n      \n      // Count positions on this symbol\n      const symbolPositions = activePositions.filter(\n        p => p.signal.symbol === symbol\n      );\n      \n      if (symbolPositions.length >= 2) {\n        throw new Error(\n          `Symbol limit: ${symbolPositions.length}/2 positions on ${symbol}`\n        );\n      }\n    }\n  ]\n});\n```\n\n### Pattern 3: Per-Strategy Position Limit\n\nLimit how many positions a single strategy can open:\n\n```typescript\naddRisk({\n  riskName: \"max-3-per-strategy\",\n  validations: [\n    (payload) => {\n      const { strategyName, activePositions } = payload;\n      \n      // Count positions from this strategy\n      const strategyPositions = activePositions.filter(\n        p => p.strategyName === strategyName\n      );\n      \n      if (strategyPositions.length >= 3) {\n        throw new Error(\n          `Strategy limit: ${strategyName} has ${strategyPositions.length}/3 positions`\n        );\n      }\n    }\n  ]\n});\n```\n\n### Pattern 4: Directional Balance Check\n\nMaintain balance between LONG and SHORT positions:\n\n```typescript\naddRisk({\n  riskName: \"balanced-portfolio\",\n  validations: [\n    (payload) => {\n      const { pendingSignal, activePositions } = payload;\n      \n      const longCount = activePositions.filter(\n        p => p.signal.position === \"long\"\n      ).length;\n      \n      const shortCount = activePositions.filter(\n        p => p.signal.position === \"short\"\n      ).length;\n      \n      // If opening LONG and already have 3 more LONGs than SHORTs\n      if (pendingSignal.position === \"long\" && longCount - shortCount >= 3) {\n        throw new Error(\n          `Imbalanced portfolio: ${longCount} LONG vs ${shortCount} SHORT`\n        );\n      }\n      \n      // If opening SHORT and already have 3 more SHORTs than LONGs\n      if (pendingSignal.position === \"short\" && shortCount - longCount >= 3) {\n        throw new Error(\n          `Imbalanced portfolio: ${shortCount} SHORT vs ${longCount} LONG`\n        );\n      }\n    }\n  ]\n});\n```\n\n### Pattern 5: Time-Based Rate Limiting\n\nPrevent opening too many positions within a time window:\n\n```typescript\naddRisk({\n  riskName: \"rate-limiter\",\n  validations: [\n    (payload) => {\n      const { timestamp, activePositions } = payload;\n      const oneHourMs = 60 * 60 * 1000;\n      \n      // Count positions opened in last hour\n      const recentPositions = activePositions.filter(\n        p => timestamp - p.openTimestamp < oneHourMs\n      );\n      \n      if (recentPositions.length >= 10) {\n        throw new Error(\n          `Rate limit: ${recentPositions.length} positions opened in last hour`\n        );\n      }\n    }\n  ]\n});\n```\n\n### Pattern 6: Cross-Symbol Correlation Check\n\nPrevent opening correlated positions (requires external data):\n\n```typescript\naddRisk({\n  riskName: \"correlation-limit\",\n  validations: [\n    async (payload) => {\n      const { symbol, activePositions } = payload;\n      \n      // Get list of active symbols\n      const activeSymbols = [...new Set(\n        activePositions.map(p => p.signal.symbol)\n      )];\n      \n      // Check correlation with each active symbol (external API/calculation)\n      for (const activeSymbol of activeSymbols) {\n        const correlation = await getCorrelation(symbol, activeSymbol);\n        \n        if (Math.abs(correlation) > 0.8) {\n          throw new Error(\n            `High correlation: ${symbol} and ${activeSymbol} (${correlation.toFixed(2)})`\n          );\n        }\n      }\n    }\n  ]\n});\n```\n\n**Sources:** [types.d.ts:382-397](), [src/function/add.ts:289-343]()\n\n---\n\n## Multiple Risk Profiles with MergeRisk\n\nWhen a strategy specifies both `riskName` and `riskList`, the system uses `MergeRisk` to combine multiple risk profiles. A signal must pass **ALL** risk checks to be allowed:\n\n```typescript\nimport { addStrategy, addRisk } from \"backtest-kit\";\n\n// Define individual risk profiles\naddRisk({\n  riskName: \"max-positions\",\n  validations: [\n    (payload) => {\n      if (payload.activePositionCount >= 5) {\n        throw new Error(\"Max 5 positions\");\n      }\n    }\n  ]\n});\n\naddRisk({\n  riskName: \"max-per-symbol\",\n  validations: [\n    (payload) => {\n      const symbolCount = payload.activePositions.filter(\n        p => p.signal.symbol === payload.symbol\n      ).length;\n      if (symbolCount >= 2) {\n        throw new Error(\"Max 2 per symbol\");\n      }\n    }\n  ]\n});\n\naddRisk({\n  riskName: \"balanced-direction\",\n  validations: [\n    (payload) => {\n      const longCount = payload.activePositions.filter(\n        p => p.signal.position === \"long\"\n      ).length;\n      const shortCount = payload.activePositions.filter(\n        p => p.signal.position === \"short\"\n      ).length;\n      \n      if (Math.abs(longCount - shortCount) > 3) {\n        throw new Error(\"Portfolio too imbalanced\");\n      }\n    }\n  ]\n});\n\n// Strategy with combined risk checks\naddStrategy({\n  strategyName: \"multi-risk-strategy\",\n  interval: \"5m\",\n  riskList: [\"max-positions\", \"max-per-symbol\", \"balanced-direction\"],\n  getSignal: async (symbol, when) => {\n    // Signal generation logic\n    return {\n      position: \"long\",\n      priceTakeProfit: 51000,\n      priceStopLoss: 49000,\n      minuteEstimatedTime: 60\n    };\n  }\n});\n```\n\n### MergeRisk Flow Diagram\n\n```mermaid\nsequenceDiagram\n    participant CS as ClientStrategy\n    participant MR as MergeRisk\n    participant CR1 as ClientRisk<br/>(max-positions)\n    participant CR2 as ClientRisk<br/>(max-per-symbol)\n    participant CR3 as ClientRisk<br/>(balanced-direction)\n    participant RGS as RiskGlobalService\n    \n    CS->>MR: checkSignal(params)\n    \n    par Parallel Risk Checks\n        MR->>CR1: checkSignal(params)\n        CR1->>RGS: getActivePositions(\"max-positions\")\n        RGS-->>CR1: portfolio state\n        CR1->>CR1: Run validation: activePositionCount >= 5?\n        CR1-->>MR: true (allowed)\n        \n        MR->>CR2: checkSignal(params)\n        CR2->>RGS: getActivePositions(\"max-per-symbol\")\n        RGS-->>CR2: portfolio state\n        CR2->>CR2: Run validation: symbolCount >= 2?\n        CR2-->>MR: true (allowed)\n        \n        MR->>CR3: checkSignal(params)\n        CR3->>RGS: getActivePositions(\"balanced-direction\")\n        RGS-->>CR3: portfolio state\n        CR3->>CR3: Run validation: imbalance > 3?\n        CR3-->>MR: true (allowed)\n    end\n    \n    MR->>MR: Combine results: all true?\n    MR-->>CS: true (signal allowed)\n    \n    Note over CS,RGS: If ANY risk check returns false,<br/>MergeRisk returns false\n```\n\n**Key Point:** All risk checks execute in parallel via `Promise.all()`, and the signal is only allowed if all checks pass (logical AND operation).\n\n**Sources:** [src/classes/Risk.ts:42-116](), [types.d.ts:743-747](), [src/function/add.ts:270-343]()\n\n---\n\n## Integration with Strategy Execution\n\nPortfolio-wide limits integrate seamlessly into the signal lifecycle through `ClientStrategy`:\n\n```mermaid\nstateDiagram-v2\n    [*] --> CheckThrottle: getSignal returns signal\n    \n    CheckThrottle --> ValidateSchema: Throttle passed\n    \n    ValidateSchema --> ValidatePrices: Schema valid\n    \n    ValidatePrices --> ValidateTPSL: Prices valid\n    \n    ValidateTPSL --> ValidateDistance: TP/SL logic valid\n    \n    ValidateDistance --> CheckRisk: Distance checks passed\n    \n    CheckRisk --> RiskGlobalService: Query portfolio state\n    \n    RiskGlobalService --> BuildPayload: activePositionCount<br/>activePositions[]\n    \n    BuildPayload --> RunValidations: IRiskValidationPayload\n    \n    RunValidations --> ValidationLoop: Execute each validation\n    \n    ValidationLoop --> ValidationFail: Validation throws error\n    ValidationLoop --> ValidationPass: All validations pass\n    \n    ValidationFail --> RiskRejected: Emit riskSubject\n    RiskRejected --> [*]\n    \n    ValidationPass --> CheckScheduled: Risk checks passed\n    \n    CheckScheduled --> Scheduled: priceOpen not reached\n    CheckScheduled --> OpenPosition: priceOpen reached\n    \n    OpenPosition --> RegisterPosition: addSignal()\n    \n    RegisterPosition --> RiskGlobalService2: Add to _positions Map<br/>Add to _positionData Map\n    \n    RiskGlobalService2 --> Active: Position tracked\n    \n    Active --> MonitorTPSL: Monitor until close\n    \n    MonitorTPSL --> ClosePosition: TP/SL/time reached\n    \n    ClosePosition --> UnregisterPosition: removeSignal()\n    \n    UnregisterPosition --> RiskGlobalService3: Remove from _positions Map<br/>Remove from _positionData Map\n    \n    RiskGlobalService3 --> [*]\n    \n    note right of CheckRisk\n        Portfolio-wide limits checked HERE\n        Before signal activation\n        After validation\n    end note\n    \n    note right of RegisterPosition\n        Position added to portfolio state\n        Now visible to other strategies\n    end note\n    \n    note right of UnregisterPosition\n        Position removed from portfolio state\n        No longer counted in limits\n    end note\n```\n\n### Execution Flow Code Mapping\n\n| Stage | Code Location | Description |\n|-------|---------------|-------------|\n| **Risk Check** | [src/lib/client/ClientStrategy.ts]() `tick()` method | Calls `risk.checkSignal(params)` |\n| **Build Payload** | [src/lib/client/ClientRisk.ts]() `checkSignal()` | Queries `RiskGlobalService` for portfolio state |\n| **Run Validations** | [src/lib/client/ClientRisk.ts]() `checkSignal()` | Iterates through `validations` array |\n| **Register Position** | [src/lib/client/ClientRisk.ts]() `addSignal()` | Calls `RiskGlobalService.addPosition()` |\n| **Unregister Position** | [src/lib/client/ClientRisk.ts]() `removeSignal()` | Calls `RiskGlobalService.removePosition()` |\n\n**Sources:** [src/lib/client/ClientStrategy.ts](), [src/lib/client/ClientRisk.ts](), [src/lib/services/global/RiskGlobalService.ts](), [types.d.ts:448-479]()\n\n---\n\n## Monitoring Portfolio State\n\n### Risk Rejection Events\n\nWhen a signal is rejected by portfolio limits, the system emits a `RiskContract` event through `riskSubject`:\n\n```typescript\nimport { listenRisk } from \"backtest-kit\";\n\nlistenRisk((event) => {\n  console.log(`[RISK] Signal rejected for ${event.symbol}`);\n  console.log(`  Strategy: ${event.strategyName}`);\n  console.log(`  Position: ${event.position}`);\n  console.log(`  Price: ${event.currentPrice}`);\n  console.log(`  Active Positions: ${event.activePositionCount}`);\n  console.log(`  Reason: ${event.comment}`);\n  console.log(`  Timestamp: ${new Date(event.timestamp).toISOString()}`);\n});\n```\n\n### Generating Risk Reports\n\nThe `Risk` utility class provides methods to analyze rejection patterns:\n\n```typescript\nimport { Risk } from \"backtest-kit\";\n\n// Get statistical data\nconst stats = await Risk.getData(\"BTCUSDT\", \"my-strategy\");\n\nconsole.log(`Total rejections: ${stats.totalRejections}`);\nconsole.log(`Rejections by symbol:`, stats.bySymbol);\nconsole.log(`Rejections by strategy:`, stats.byStrategy);\n\n// Generate markdown report\nconst markdown = await Risk.getReport(\"BTCUSDT\", \"my-strategy\");\n\n// Save to file\nawait Risk.dump(\"BTCUSDT\", \"my-strategy\", \"./reports\");\n```\n\n### RiskStatisticsModel Structure\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `totalRejections` | `number` | Total signals rejected |\n| `bySymbol` | `Record<string, number>` | Rejection count per symbol |\n| `byStrategy` | `Record<string, number>` | Rejection count per strategy |\n| `eventList` | `RiskContract[]` | All rejection events (max 250) |\n\n**Sources:** [src/classes/Risk.ts:153-244](), [src/function/event.ts:42-43](), [src/config/emitters.ts:131]()\n\n---\n\n## Performance Considerations\n\n### Memoization Optimization\n\n`RiskConnectionService` memoizes `ClientRisk` instances by `riskName`, ensuring that multiple strategies sharing the same risk profile use the same instance. This is critical for portfolio-wide state consistency:\n\n```typescript\n// Internal implementation (conceptual)\nclass RiskConnectionService {\n  private _riskCache = new Map<string, ClientRisk>();\n  \n  getOrCreateRisk(riskName: string): ClientRisk {\n    if (!this._riskCache.has(riskName)) {\n      const schema = riskSchemaService.get(riskName);\n      const risk = new ClientRisk(schema);\n      this._riskCache.set(riskName, risk);\n    }\n    return this._riskCache.get(riskName);\n  }\n}\n```\n\n**Result:** All strategies using `riskName: \"portfolio-limits\"` share the exact same `ClientRisk` instance, which queries the same `RiskGlobalService` state.\n\n### Position Key Efficiency\n\nPosition keys are simple strings (`\"symbol:strategyName\"`), making lookups in `RiskGlobalService` Maps extremely fast (O(1) average case).\n\n### Parallel Validation with MergeRisk\n\nWhen using `riskList`, `MergeRisk` executes all risk checks in parallel via `Promise.all()`, minimizing validation latency:\n\n```typescript\n// From MergeRisk.checkSignal() implementation\nconst riskCheck = await Promise.all(\n  this._riskList.map(async (risk) => await risk.checkSignal(params))\n);\nreturn riskCheck.every((isSafe) => isSafe);\n```\n\n**Sources:** [src/lib/services/connection/RiskConnectionService.ts](), [src/classes/Risk.ts:59-67](), [src/lib/services/global/RiskGlobalService.ts]()\n\n---\n\n## Complete Example: Multi-Level Portfolio Risk\n\nThis example demonstrates a comprehensive portfolio risk system with multiple layers of protection:\n\n```typescript\nimport { addRisk, addStrategy, Backtest, listenRisk } from \"backtest-kit\";\n\n// Layer 1: Hard position limit\naddRisk({\n  riskName: \"hard-limit\",\n  validations: [\n    (payload) => {\n      const MAX = 8;\n      if (payload.activePositionCount >= MAX) {\n        throw new Error(`Hard limit: ${payload.activePositionCount}/${MAX} positions`);\n      }\n    }\n  ]\n});\n\n// Layer 2: Symbol exposure management\naddRisk({\n  riskName: \"symbol-exposure\",\n  validations: [\n    (payload) => {\n      const { symbol, activePositions } = payload;\n      const MAX_PER_SYMBOL = 2;\n      \n      const symbolPositions = activePositions.filter(\n        p => p.signal.symbol === symbol\n      );\n      \n      if (symbolPositions.length >= MAX_PER_SYMBOL) {\n        throw new Error(\n          `Symbol limit: ${symbol} has ${symbolPositions.length}/${MAX_PER_SYMBOL}`\n        );\n      }\n    }\n  ]\n});\n\n// Layer 3: Strategy-level limits\naddRisk({\n  riskName: \"strategy-limit\",\n  validations: [\n    (payload) => {\n      const { strategyName, activePositions } = payload;\n      const MAX_PER_STRATEGY = 3;\n      \n      const strategyPositions = activePositions.filter(\n        p => p.strategyName === strategyName\n      );\n      \n      if (strategyPositions.length >= MAX_PER_STRATEGY) {\n        throw new Error(\n          `Strategy limit: ${strategyName} at ${strategyPositions.length}/${MAX_PER_STRATEGY}`\n        );\n      }\n    }\n  ]\n});\n\n// Layer 4: Time-based rate limiting\naddRisk({\n  riskName: \"rate-limit\",\n  validations: [\n    (payload) => {\n      const { timestamp, activePositions } = payload;\n      const WINDOW_MS = 30 * 60 * 1000; // 30 minutes\n      const MAX_IN_WINDOW = 5;\n      \n      const recentPositions = activePositions.filter(\n        p => timestamp - p.openTimestamp < WINDOW_MS\n      );\n      \n      if (recentPositions.length >= MAX_IN_WINDOW) {\n        throw new Error(\n          `Rate limit: ${recentPositions.length} positions in last 30min`\n        );\n      }\n    }\n  ]\n});\n\n// Layer 5: Directional balance\naddRisk({\n  riskName: \"directional-balance\",\n  validations: [\n    (payload) => {\n      const { pendingSignal, activePositions } = payload;\n      const MAX_IMBALANCE = 4;\n      \n      const longs = activePositions.filter(p => p.signal.position === \"long\").length;\n      const shorts = activePositions.filter(p => p.signal.position === \"short\").length;\n      \n      const newLongs = longs + (pendingSignal.position === \"long\" ? 1 : 0);\n      const newShorts = shorts + (pendingSignal.position === \"short\" ? 1 : 0);\n      \n      if (Math.abs(newLongs - newShorts) > MAX_IMBALANCE) {\n        throw new Error(\n          `Imbalance: ${newLongs} LONG vs ${newShorts} SHORT (max diff: ${MAX_IMBALANCE})`\n        );\n      }\n    }\n  ]\n});\n\n// Strategy using all risk layers\naddStrategy({\n  strategyName: \"multi-layer-strategy\",\n  interval: \"5m\",\n  riskList: [\n    \"hard-limit\",\n    \"symbol-exposure\",\n    \"strategy-limit\",\n    \"rate-limit\",\n    \"directional-balance\"\n  ],\n  getSignal: async (symbol, when) => {\n    // Signal generation logic\n    return {\n      position: Math.random() > 0.5 ? \"long\" : \"short\",\n      priceTakeProfit: 51000,\n      priceStopLoss: 49000,\n      minuteEstimatedTime: 120\n    };\n  },\n  callbacks: {\n    onOpen: (symbol, signal, price, backtest) => {\n      console.log(`✅ Signal opened: ${symbol} ${signal.position.toUpperCase()}`);\n    }\n  }\n});\n\n// Monitor rejections\nlistenRisk((event) => {\n  console.log(`❌ Signal rejected: ${event.symbol} ${event.position.toUpperCase()}`);\n  console.log(`   Reason: ${event.comment}`);\n  console.log(`   Active: ${event.activePositionCount}`);\n});\n\n// Run backtest\nBacktest.background(\"BTCUSDT\", {\n  strategyName: \"multi-layer-strategy\",\n  exchangeName: \"my-exchange\",\n  frameName: \"1-month-backtest\"\n});\n```\n\n**This configuration ensures:**\n1. Never more than 8 total positions\n2. Max 2 positions per symbol\n3. Max 3 positions per strategy\n4. Max 5 positions opened in any 30-minute window\n5. Long/short imbalance never exceeds 4\n\n**Sources:** [types.d.ts:382-426](), [src/function/add.ts:270-343](), [src/classes/Risk.ts:42-116]()"
                    },
                    {
                        "page_plan": {
                            "id": "8",
                            "title": "Exchanges & Data Sources"
                        },
                        "content": "# Exchanges & Data Sources\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/config/params.ts](src/config/params.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [test/README.md](test/README.md)\n- [test/config/setup.mjs](test/config/setup.mjs)\n- [test/e2e/close.test.mjs](test/e2e/close.test.mjs)\n- [test/e2e/edge.test.mjs](test/e2e/edge.test.mjs)\n- [test/e2e/other.test.mjs](test/e2e/other.test.mjs)\n- [test/e2e/persist.test.mjs](test/e2e/persist.test.mjs)\n- [test/e2e/sanitize.test.mjs](test/e2e/sanitize.test.mjs)\n- [test/e2e/sequence.test.mjs](test/e2e/sequence.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page documents how to configure exchanges and data sources in Backtest Kit. Exchanges provide historical and real-time market data (OHLCV candles) and handle price/quantity formatting according to exchange-specific precision rules. The framework supports any data source that implements the required interface, including CCXT, custom APIs, databases, or CSV files.\n\nFor information about using candle data within strategies, see [Multi-Timeframe Analysis](#6.4). For execution context propagation, see [Execution Contexts](#3.3). For VWAP pricing details, see [VWAP Pricing & Data Handling](#3.5).\n\n---\n\n## Exchange Schema Definition\n\n### IExchangeSchema Interface\n\nExchanges are registered using the `IExchangeSchema` interface, which defines the contract for data fetching and formatting operations.\n\n```mermaid\ngraph TB\n    subgraph \"Exchange Registration\"\n        AddExchange[\"addExchange(schema)\"]\n        Schema[\"IExchangeSchema\"]\n        ExchangeSchemaService[\"ExchangeSchemaService<br/>(ToolRegistry)\"]\n    end\n    \n    subgraph \"Schema Methods\"\n        GetCandles[\"getCandles<br/>(symbol, interval, since, limit)\"]\n        FormatPrice[\"formatPrice<br/>(symbol, price)\"]\n        FormatQuantity[\"formatQuantity<br/>(symbol, quantity)\"]\n        Callbacks[\"callbacks?<br/>(onCandleData)\"]\n    end\n    \n    subgraph \"Runtime Access\"\n        ExchangeConnectionService[\"ExchangeConnectionService<br/>(memoized factory)\"]\n        ClientExchange[\"ClientExchange<br/>(implements IExchange)\"]\n    end\n    \n    AddExchange --> Schema\n    Schema --> ExchangeSchemaService\n    \n    Schema --> GetCandles\n    Schema --> FormatPrice\n    Schema --> FormatQuantity\n    Schema --> Callbacks\n    \n    ExchangeSchemaService --> ExchangeConnectionService\n    ExchangeConnectionService --> ClientExchange\n    \n    ClientExchange --> GetCandles\n    ClientExchange --> FormatPrice\n    ClientExchange --> FormatQuantity\n```\n\n**Interface Structure:**\n\n| Property | Type | Required | Description |\n|----------|------|----------|-------------|\n| `exchangeName` | `ExchangeName` (string) | Yes | Unique identifier for the exchange |\n| `getCandles` | Function | Yes | Fetches OHLCV candle data |\n| `formatPrice` | Function | Yes | Formats price to exchange precision |\n| `formatQuantity` | Function | Yes | Formats quantity to exchange precision |\n| `note` | string | No | Developer documentation |\n| `callbacks` | `Partial<IExchangeCallbacks>` | No | Lifecycle event callbacks |\n\n**Sources:** [types.d.ts:119-155](), [src/interfaces/Exchange.interface.ts]()\n\n---\n\n## Registering an Exchange\n\n### addExchange Function\n\nThe `addExchange` global function registers an exchange schema. The framework validates uniqueness of `exchangeName` and stores the schema in the registry.\n\n```typescript\nimport { addExchange } from 'backtest-kit';\n\naddExchange({\n  exchangeName: \"binance\",\n  note: \"Binance production data source\",\n  \n  getCandles: async (symbol, interval, since, limit) => {\n    // Implementation here\n    return candles;\n  },\n  \n  formatPrice: async (symbol, price) => {\n    return price.toFixed(2);\n  },\n  \n  formatQuantity: async (symbol, quantity) => {\n    return quantity.toFixed(8);\n  },\n  \n  callbacks: {\n    onCandleData: (symbol, interval, since, limit, data) => {\n      console.log(`Fetched ${data.length} candles`);\n    }\n  }\n});\n```\n\n**Validation:**\n- `exchangeName` must be unique (checked by `ExchangeValidationService`)\n- All required methods must be provided\n- Methods must return promises\n\n**Sources:** [src/function/add.ts](), [types.d.ts:119-155](), [README.md:70-80]()\n\n---\n\n## Data Fetching Requirements\n\n### getCandles Method Contract\n\nThe `getCandles` method is the core data fetching interface. It must return historical OHLCV candles according to the specified parameters.\n\n**Signature:**\n```typescript\ngetCandles: (\n  symbol: string,        // Trading pair (e.g., \"BTCUSDT\")\n  interval: CandleInterval,  // \"1m\" | \"3m\" | \"5m\" | \"15m\" | \"30m\" | \"1h\" | \"2h\" | \"4h\" | \"6h\" | \"8h\"\n  since: Date,          // Start date for fetching\n  limit: number         // Maximum number of candles to return\n) => Promise<ICandleData[]>\n```\n\n**ICandleData Structure:**\n\n```mermaid\ngraph LR\n    ICandleData[\"ICandleData\"]\n    \n    ICandleData --> timestamp[\"timestamp: number<br/>(Unix ms)\"]\n    ICandleData --> open[\"open: number\"]\n    ICandleData --> high[\"high: number\"]\n    ICandleData --> low[\"low: number\"]\n    ICandleData --> close[\"close: number\"]\n    ICandleData --> volume[\"volume: number\"]\n```\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `timestamp` | number | Unix timestamp in milliseconds when candle opened |\n| `open` | number | Opening price at candle start |\n| `high` | number | Highest price during candle period |\n| `low` | number | Lowest price during candle period |\n| `close` | number | Closing price at candle end |\n| `volume` | number | Trading volume during candle period |\n\n**Temporal Context:** The `since` parameter represents the current execution timestamp. In backtest mode, it corresponds to the frame iteration timestamp. In live mode, it's the current time minus the requested lookback. This ensures **look-ahead bias prevention** - strategies can never access future data.\n\n**Sources:** [types.d.ts:82-100](), [types.d.ts:128-136]()\n\n---\n\n## Internal Data Flow\n\n```mermaid\ngraph TB\n    subgraph \"Strategy Layer\"\n        GetCandlesGlobal[\"getCandles(symbol, interval, limit)<br/>Global function\"]\n    end\n    \n    subgraph \"Context Services\"\n        ExecContext[\"ExecutionContextService<br/>(symbol, when, backtest)\"]\n        MethodContext[\"MethodContextService<br/>(exchangeName, strategyName)\"]\n    end\n    \n    subgraph \"Service Layer\"\n        ExchangeCore[\"ExchangeCoreService\"]\n        ExchangeConnection[\"ExchangeConnectionService<br/>(memoized by exchangeName)\"]\n    end\n    \n    subgraph \"Client Layer\"\n        ClientExchange[\"ClientExchange<br/>(implements IExchange)\"]\n        GetCandlesMethod[\"getCandles(symbol, interval, limit)\"]\n        GetNextCandlesMethod[\"getNextCandles(symbol, interval, limit)\"]\n    end\n    \n    subgraph \"Schema Layer\"\n        SchemaGetCandles[\"schema.getCandles<br/>(symbol, interval, since, limit)\"]\n    end\n    \n    subgraph \"Validation & Processing\"\n        RetryLogic[\"Retry Logic<br/>(up to CC_GET_CANDLES_RETRY_COUNT)\"]\n        AnomalyDetection[\"Anomaly Detection<br/>(incomplete candles, price outliers)\"]\n        Callback[\"callbacks.onCandleData\"]\n    end\n    \n    GetCandlesGlobal --> ExecContext\n    GetCandlesGlobal --> MethodContext\n    \n    ExecContext --> ExchangeCore\n    MethodContext --> ExchangeCore\n    \n    ExchangeCore --> ExchangeConnection\n    ExchangeConnection --> ClientExchange\n    \n    ClientExchange --> GetCandlesMethod\n    ClientExchange --> GetNextCandlesMethod\n    \n    GetCandlesMethod --> RetryLogic\n    GetNextCandlesMethod --> RetryLogic\n    \n    RetryLogic --> SchemaGetCandles\n    SchemaGetCandles --> AnomalyDetection\n    AnomalyDetection --> Callback\n```\n\n**Key Points:**\n- `getCandles()` uses `when - (limit × interval)` to calculate `since` (backward lookup)\n- `getNextCandles()` uses `when` as `since` (forward lookup for backtest fast mode)\n- `ExecutionContextService` provides temporal context automatically\n- `ExchangeConnectionService` memoizes `ClientExchange` instances by `exchangeName`\n\n**Sources:** [src/function/exchange.ts](), [src/client/ClientExchange.ts](), [src/lib/services/core/ExchangeCoreService.ts]()\n\n---\n\n## VWAP Pricing\n\n### Volume Weighted Average Price Calculation\n\nVWAP (Volume Weighted Average Price) is used for realistic entry/exit price simulation. The framework calculates VWAP from the last N 1-minute candles (default: 5).\n\n**Formula:**\n```\nTypical Price = (High + Low + Close) / 3\nVWAP = Σ(Typical Price × Volume) / Σ(Volume)\n```\n\n```mermaid\ngraph TB\n    subgraph \"VWAP Calculation\"\n        GetAvgPrice[\"getAveragePrice(symbol)<br/>Global function\"]\n        Fetch5Candles[\"Fetch last 5 candles<br/>(1m interval)\"]\n        CalcTypical[\"Calculate Typical Price<br/>for each candle<br/>(H+L+C)/3\"]\n        WeightByVolume[\"Weight by Volume<br/>Σ(TP × Vol) / Σ(Vol)\"]\n        ReturnVWAP[\"Return VWAP\"]\n    end\n    \n    GetAvgPrice --> Fetch5Candles\n    Fetch5Candles --> CalcTypical\n    CalcTypical --> WeightByVolume\n    WeightByVolume --> ReturnVWAP\n```\n\n**Configuration:**\n- `CC_AVG_PRICE_CANDLES_COUNT` - Number of candles for VWAP (default: 5)\n- Always uses 1-minute interval for high precision\n- Falls back to simple average if volume data is unavailable\n\n**Usage in Signal Execution:**\n```typescript\n// Framework automatically uses VWAP for:\n// 1. Signal activation (scheduled → opened)\n// 2. Take profit detection\n// 3. Stop loss detection\n// 4. Partial profit/loss calculations\n```\n\n**Sources:** [types.d.ts:196-204](), [src/client/ClientExchange.ts](), [src/config/params.ts:6-11]()\n\n---\n\n## Data Validation & Anomaly Detection\n\n### Incomplete Candle Detection\n\nThe framework detects incomplete candles from API responses (e.g., Binance sometimes returns candles with near-zero prices).\n\n**Detection Logic:**\n\n```mermaid\ngraph TB\n    FetchCandles[\"Fetch Candles\"]\n    CalcMedian[\"Calculate Median Price<br/>(from all OHLC values)\"]\n    CheckMinCandles{\">= MIN_CANDLES_FOR_MEDIAN?\"}\n    UseMedian[\"Use Median\"]\n    UseAverage[\"Use Average\"]\n    CheckAnomaly[\"For each candle:<br/>check if any price < threshold\"]\n    Threshold[\"Threshold = medianPrice /<br/>ANOMALY_THRESHOLD_FACTOR\"]\n    ThrowError[\"Throw Error:<br/>'Incomplete candle detected'\"]\n    ReturnCandles[\"Return Valid Candles\"]\n    \n    FetchCandles --> CalcMedian\n    CalcMedian --> CheckMinCandles\n    CheckMinCandles -->|Yes| UseMedian\n    CheckMinCandles -->|No| UseAverage\n    UseMedian --> CheckAnomaly\n    UseAverage --> CheckAnomaly\n    CheckAnomaly --> Threshold\n    Threshold -->|Anomaly found| ThrowError\n    Threshold -->|All valid| ReturnCandles\n```\n\n**Configuration Parameters:**\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR` | 1000 | Max deviation factor for price detection |\n| `CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN` | 5 | Minimum candles for median calculation |\n\n**Anomaly Detection Algorithm:**\n1. Collect all OHLC prices from fetched candles\n2. Calculate reference price:\n   - If `candles.length >= CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN`: use **median**\n   - Otherwise: use **average**\n3. Calculate threshold: `referencePrice / CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR`\n4. Check each candle's OHLC values\n5. If any price < threshold: **throw error**\n\n**Example:**\n```typescript\n// BTC median price: $50,000\n// Threshold: $50,000 / 1000 = $50\n// Incomplete candle with close=$0.01 → DETECTED (0.01 < 50)\n// Normal candle with close=$49,500 → VALID (49500 > 50)\n```\n\n**Sources:** [src/config/params.ts:77-104](), [src/client/ClientExchange.ts]()\n\n---\n\n## Retry Logic\n\n### Failed Fetch Handling\n\nThe framework implements automatic retry logic with exponential backoff for transient network failures.\n\n```mermaid\ngraph TB\n    Start[\"getCandles called\"]\n    Attempt[\"Attempt fetch<br/>(call schema.getCandles)\"]\n    Success{Success?}\n    ValidateData[\"Validate data<br/>(anomaly detection)\"]\n    Return[\"Return candles\"]\n    \n    CheckRetries{Retries remaining?}\n    Sleep[\"Sleep<br/>CC_GET_CANDLES_RETRY_DELAY_MS\"]\n    IncrementRetry[\"Increment retry count\"]\n    ThrowError[\"Throw final error\"]\n    \n    Start --> Attempt\n    Attempt --> Success\n    Success -->|Yes| ValidateData\n    ValidateData -->|Valid| Return\n    ValidateData -->|Invalid| CheckRetries\n    Success -->|No| CheckRetries\n    \n    CheckRetries -->|Yes| Sleep\n    Sleep --> IncrementRetry\n    IncrementRetry --> Attempt\n    \n    CheckRetries -->|No| ThrowError\n```\n\n**Configuration:**\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `CC_GET_CANDLES_RETRY_COUNT` | 3 | Maximum retry attempts |\n| `CC_GET_CANDLES_RETRY_DELAY_MS` | 5000 | Delay between retries (ms) |\n\n**Retry Triggers:**\n- Network errors (connection timeout, DNS failure)\n- HTTP 429 (rate limit)\n- HTTP 500/502/503 (server errors)\n- Anomaly detection failures\n\n**Sources:** [src/config/params.ts:66-74](), [src/client/ClientExchange.ts]()\n\n---\n\n## Price and Quantity Formatting\n\n### Exchange-Specific Precision\n\nExchanges have different precision rules for prices and quantities. The `formatPrice` and `formatQuantity` methods ensure values match exchange requirements.\n\n**formatPrice Method:**\n```typescript\nformatPrice: async (symbol: string, price: number) => Promise<string>\n```\n\n**formatQuantity Method:**\n```typescript\nformatQuantity: async (symbol: string, quantity: number) => Promise<string>\n```\n\n**Common Patterns:**\n\n| Exchange | Price Precision | Quantity Precision | Example |\n|----------|----------------|-------------------|---------|\n| Binance | 2-8 decimals | 8 decimals | `price.toFixed(2)` |\n| Kraken | 1-5 decimals | 8 decimals | `price.toFixed(1)` |\n| Custom | Variable | Variable | Lookup table |\n\n**Usage in Framework:**\n- Report generation (markdown tables)\n- Order placement (live trading)\n- Position size calculations\n\n**Sources:** [types.d.ts:138-152](), [types.d.ts:180-194]()\n\n---\n\n## CCXT Integration\n\n### Common Integration Pattern\n\nCCXT is a popular cryptocurrency exchange library. Below is the standard pattern for integrating CCXT as a data source.\n\n**Basic CCXT Exchange:**\n```typescript\nimport ccxt from 'ccxt';\nimport { addExchange } from 'backtest-kit';\n\nconst exchange = new ccxt.binance({\n  // Optional: API credentials for live trading\n  apiKey: process.env.BINANCE_API_KEY,\n  secret: process.env.BINANCE_API_SECRET,\n});\n\naddExchange({\n  exchangeName: 'binance',\n  \n  getCandles: async (symbol, interval, since, limit) => {\n    // CCXT uses different interval format\n    const ohlcv = await exchange.fetchOHLCV(\n      symbol,\n      interval,\n      since.getTime(),\n      limit\n    );\n    \n    // Convert CCXT format [timestamp, o, h, l, c, v] to ICandleData\n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n      timestamp,\n      open,\n      high,\n      low,\n      close,\n      volume,\n    }));\n  },\n  \n  formatPrice: async (symbol, price) => {\n    const market = exchange.market(symbol);\n    return exchange.priceToPrecision(symbol, price);\n  },\n  \n  formatQuantity: async (symbol, quantity) => {\n    const market = exchange.market(symbol);\n    return exchange.amountToPrecision(symbol, quantity);\n  },\n});\n```\n\n**CCXT-Specific Considerations:**\n\n| Aspect | Solution |\n|--------|----------|\n| Rate limiting | CCXT handles automatically |\n| Symbol format | Use CCXT unified symbols (e.g., \"BTC/USDT\") |\n| Precision | Use `priceToPrecision` and `amountToPrecision` |\n| Error handling | Wrap in try-catch, let retry logic handle |\n\n**Advanced: Multiple Exchanges:**\n```typescript\nconst exchanges = {\n  binance: new ccxt.binance(),\n  kraken: new ccxt.kraken(),\n  coinbase: new ccxt.coinbase(),\n};\n\nObject.entries(exchanges).forEach(([name, instance]) => {\n  addExchange({\n    exchangeName: name,\n    getCandles: async (symbol, interval, since, limit) => {\n      const ohlcv = await instance.fetchOHLCV(symbol, interval, since.getTime(), limit);\n      return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n        timestamp, open, high, low, close, volume\n      }));\n    },\n    formatPrice: (symbol, price) => instance.priceToPrecision(symbol, price),\n    formatQuantity: (symbol, qty) => instance.amountToPrecision(symbol, qty),\n  });\n});\n```\n\n**Sources:** [README.md:70-80](), [demo/backtest/src/setup/exchange.mjs](), [types.d.ts:119-155]()\n\n---\n\n## ClientExchange Architecture\n\n### Internal Implementation\n\n`ClientExchange` is the internal client that wraps exchange schemas and provides additional functionality like VWAP calculation and retry logic.\n\n```mermaid\ngraph TB\n    subgraph \"Service Layer\"\n        ExchangeConnectionService[\"ExchangeConnectionService\"]\n        Memoization[\"Memoization Cache<br/>Map<exchangeName, ClientExchange>\"]\n    end\n    \n    subgraph \"ClientExchange Instance\"\n        Constructor[\"Constructor<br/>(IExchangeParams)\"]\n        GetCandlesMethod[\"getCandles()<br/>backward lookup\"]\n        GetNextCandlesMethod[\"getNextCandles()<br/>forward lookup\"]\n        FormatPriceMethod[\"formatPrice()\"]\n        FormatQuantityMethod[\"formatQuantity()\"]\n        GetAvgPriceMethod[\"getAveragePrice()<br/>VWAP calculation\"]\n    end\n    \n    subgraph \"Schema Access\"\n        SchemaRef[\"schema: IExchangeSchema\"]\n        Logger[\"logger: ILogger\"]\n        Execution[\"execution: ExecutionContextService\"]\n    end\n    \n    subgraph \"Validation\"\n        RetryWrapper[\"Retry Wrapper\"]\n        AnomalyCheck[\"Anomaly Detection\"]\n        Callback[\"onCandleData callback\"]\n    end\n    \n    ExchangeConnectionService --> Memoization\n    Memoization --> Constructor\n    \n    Constructor --> GetCandlesMethod\n    Constructor --> GetNextCandlesMethod\n    Constructor --> FormatPriceMethod\n    Constructor --> FormatQuantityMethod\n    Constructor --> GetAvgPriceMethod\n    \n    Constructor --> SchemaRef\n    Constructor --> Logger\n    Constructor --> Execution\n    \n    GetCandlesMethod --> RetryWrapper\n    GetNextCandlesMethod --> RetryWrapper\n    RetryWrapper --> AnomalyCheck\n    AnomalyCheck --> Callback\n```\n\n**Key Architectural Decisions:**\n\n1. **Memoization:** `ExchangeConnectionService` caches `ClientExchange` instances by `exchangeName` to prevent redundant instantiation.\n\n2. **Prototype Methods:** All methods are defined on the prototype for memory efficiency (shared across instances).\n\n3. **Context Injection:** `ExecutionContextService` provides temporal context (symbol, when, backtest flag) automatically.\n\n4. **Separation of Concerns:**\n   - **Schema (IExchangeSchema):** User-defined data fetching logic\n   - **Client (ClientExchange):** Framework-provided validation, retry, VWAP\n   - **Service (ExchangeConnectionService):** Lifecycle management, routing\n\n**Sources:** [src/client/ClientExchange.ts](), [src/lib/services/connection/ExchangeConnectionService.ts](), [types.d.ts:102-110]()\n\n---\n\n## Configuration Reference\n\n### Data Fetching Parameters\n\n| Parameter | Default | Type | Description |\n|-----------|---------|------|-------------|\n| `CC_AVG_PRICE_CANDLES_COUNT` | 5 | number | Number of 1m candles for VWAP calculation |\n| `CC_GET_CANDLES_RETRY_COUNT` | 3 | number | Maximum retry attempts for failed fetches |\n| `CC_GET_CANDLES_RETRY_DELAY_MS` | 5000 | number | Delay between retry attempts (milliseconds) |\n| `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR` | 1000 | number | Max price deviation factor for anomaly detection |\n| `CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN` | 5 | number | Minimum candles required for median price calculation |\n\n**Configuration Example:**\n```typescript\nimport { setConfig } from 'backtest-kit';\n\nsetConfig({\n  CC_AVG_PRICE_CANDLES_COUNT: 10,  // Use 10 candles for VWAP\n  CC_GET_CANDLES_RETRY_COUNT: 5,   // Retry 5 times on failure\n  CC_GET_CANDLES_RETRY_DELAY_MS: 3000,  // 3 second delay\n  CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR: 500,  // Stricter anomaly detection\n});\n```\n\n**Sources:** [src/config/params.ts:6-104](), [src/function/setup.ts]()\n\n---\n\n## Exchange Callbacks\n\n### Lifecycle Event Monitoring\n\nThe optional `callbacks` property in `IExchangeSchema` allows monitoring data fetching events.\n\n**IExchangeCallbacks Interface:**\n```typescript\ninterface IExchangeCallbacks {\n  onCandleData: (\n    symbol: string,\n    interval: CandleInterval,\n    since: Date,\n    limit: number,\n    data: ICandleData[]\n  ) => void;\n}\n```\n\n**Usage Example:**\n```typescript\naddExchange({\n  exchangeName: \"binance\",\n  \n  getCandles: async (symbol, interval, since, limit) => {\n    // Fetch logic\n    return candles;\n  },\n  \n  formatPrice: async (symbol, price) => price.toFixed(2),\n  formatQuantity: async (symbol, quantity) => quantity.toFixed(8),\n  \n  callbacks: {\n    onCandleData: (symbol, interval, since, limit, data) => {\n      console.log(`[${symbol}] Fetched ${data.length} ${interval} candles from ${since.toISOString()}`);\n      \n      // Example: Log to monitoring service\n      monitoring.track('candle_fetch', {\n        symbol,\n        interval,\n        count: data.length,\n        requested: limit,\n        fulfilled: data.length === limit,\n      });\n    },\n  },\n});\n```\n\n**Use Cases:**\n- Logging data fetch operations\n- Monitoring API usage and quotas\n- Debugging data quality issues\n- Performance profiling\n\n**Sources:** [types.d.ts:112-117](), [types.d.ts:153-154]()\n\n---\n\n## Complete Example: Custom Database Exchange\n\n### CSV File Data Source\n\n```typescript\nimport { addExchange, ICandleData } from 'backtest-kit';\nimport fs from 'fs/promises';\nimport path from 'path';\n\n// Custom exchange reading from CSV files\naddExchange({\n  exchangeName: 'csv-historical',\n  note: 'Historical data from CSV files',\n  \n  getCandles: async (symbol, interval, since, limit) => {\n    // CSV file path: ./data/BTCUSDT_1m.csv\n    const filename = `./data/${symbol}_${interval}.csv`;\n    const content = await fs.readFile(filename, 'utf-8');\n    const lines = content.split('\\n').slice(1); // Skip header\n    \n    const allCandles: ICandleData[] = lines\n      .filter(line => line.trim())\n      .map(line => {\n        const [timestamp, open, high, low, close, volume] = line.split(',');\n        return {\n          timestamp: parseInt(timestamp),\n          open: parseFloat(open),\n          high: parseFloat(high),\n          low: parseFloat(low),\n          close: parseFloat(close),\n          volume: parseFloat(volume),\n        };\n      });\n    \n    // Filter by date range\n    const sinceMs = since.getTime();\n    const filtered = allCandles.filter(c => c.timestamp >= sinceMs);\n    \n    // Return requested limit\n    return filtered.slice(0, limit);\n  },\n  \n  formatPrice: async (symbol, price) => {\n    // Fixed precision for all symbols\n    return price.toFixed(2);\n  },\n  \n  formatQuantity: async (symbol, quantity) => {\n    return quantity.toFixed(8);\n  },\n  \n  callbacks: {\n    onCandleData: (symbol, interval, since, limit, data) => {\n      console.log(`CSV: Loaded ${data.length}/${limit} ${interval} candles for ${symbol}`);\n    },\n  },\n});\n```\n\n**Sources:** [types.d.ts:119-155](), [README.md:70-80]()"
                    },
                    {
                        "page_plan": {
                            "id": "8.1",
                            "title": "Exchange Configuration"
                        },
                        "content": "# Exchange Configuration\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose\n\nThis document describes how to configure exchange data sources in Backtest Kit using the `IExchangeSchema` interface. An exchange configuration defines how the framework fetches historical candle data, formats prices and quantities, and calculates VWAP for realistic trade execution.\n\nFor information about candle data structure and validation, see [Candle Data & Validation](#8.2). For CCXT-specific integration patterns, see [CCXT Integration](#8.3).\n\n---\n\n## Overview\n\nThe exchange system provides market data abstraction through three key components:\n\n| Component | Purpose | Location |\n|-----------|---------|----------|\n| `IExchangeSchema` | User-defined configuration schema | [types.d.ts:122-155]() |\n| `addExchange()` | Registration function | [src/function/add.ts]() |\n| `ClientExchange` | Internal client implementation | [src/client/ClientExchange.ts]() |\n\nAn exchange schema must implement methods for fetching candles (`getCandles`), formatting prices and quantities according to exchange precision rules, and optionally handling lifecycle callbacks.\n\n**Sources:** [types.d.ts:82-209](), [README.md:70-80]()\n\n---\n\n## Configuration Flow\n\n```mermaid\ngraph TB\n    User[\"User Code\"] -->|\"addExchange(schema)\"| AddFn[\"addExchange()<br/>function\"]\n    AddFn -->|\"validate\"| ValSvc[\"ExchangeValidationService<br/>Check for duplicates\"]\n    ValSvc -->|\"store\"| SchemaSvc[\"ExchangeSchemaService<br/>ToolRegistry storage\"]\n    \n    SchemaSvc -.->|\"retrieve during execution\"| ConnSvc[\"ExchangeConnectionService<br/>Memoized factory\"]\n    ConnSvc -->|\"instantiate once\"| Client[\"ClientExchange instance<br/>Per exchangeName\"]\n    \n    Client -->|\"calls\"| GetCandles[\"schema.getCandles()<br/>Fetch OHLCV data\"]\n    Client -->|\"calls\"| FmtPrice[\"schema.formatPrice()<br/>Apply precision rules\"]\n    Client -->|\"calls\"| FmtQty[\"schema.formatQuantity()<br/>Apply precision rules\"]\n    Client -->|\"triggers\"| Callbacks[\"schema.callbacks.onCandleData<br/>Optional lifecycle hook\"]\n    \n    Client -->|\"provides\"| Strategy[\"ClientStrategy<br/>getSignal() execution\"]\n    Strategy -->|\"getCandles()\"| Client\n    Strategy -->|\"getAveragePrice()\"| Client\n    \n    Client -->|\"calculates VWAP\"| VWAP[\"getAveragePrice()<br/>Last 5 1-min candles<br/>VWAP = Σ(TP × Vol) / ΣVol\"]\n```\n\n**Diagram: Exchange Configuration and Usage Flow**\n\nThe user defines an `IExchangeSchema` and registers it via `addExchange()`. The system validates uniqueness, stores the schema in `ToolRegistry`, and creates a memoized `ClientExchange` instance during execution. Strategies access exchange methods through `getCandles()` and `getAveragePrice()` helper functions.\n\n**Sources:** [types.d.ts:122-155](), [src/function/add.ts](), [src/client/ClientExchange.ts]()\n\n---\n\n## IExchangeSchema Interface\n\n```mermaid\nclassDiagram\n    class IExchangeSchema {\n        +ExchangeName exchangeName\n        +string? note\n        +getCandles(symbol, interval, since, limit) Promise~ICandleData[]~\n        +formatQuantity(symbol, quantity) Promise~string~\n        +formatPrice(symbol, price) Promise~string~\n        +Partial~IExchangeCallbacks~? callbacks\n    }\n    \n    class IExchangeCallbacks {\n        +onCandleData(symbol, interval, since, limit, data) void\n    }\n    \n    class ICandleData {\n        +number timestamp\n        +number open\n        +number high\n        +number low\n        +number close\n        +number volume\n    }\n    \n    class CandleInterval {\n        <<enumeration>>\n        1m\n        3m\n        5m\n        15m\n        30m\n        1h\n        2h\n        4h\n        6h\n        8h\n    }\n    \n    IExchangeSchema --> IExchangeCallbacks : \"optional callbacks\"\n    IExchangeSchema --> ICandleData : \"returns from getCandles()\"\n    IExchangeSchema --> CandleInterval : \"uses as interval parameter\"\n```\n\n**Diagram: IExchangeSchema Structure**\n\nThe schema consists of four required methods and one optional callbacks object. All methods are async to support API calls or database queries.\n\n**Sources:** [types.d.ts:122-155](), [types.d.ts:82-100](), [types.d.ts:114-117]()\n\n---\n\n## Required Methods\n\n### getCandles()\n\nFetches historical OHLCV candle data from the exchange API or database.\n\n**Signature:**\n```typescript\ngetCandles: (\n  symbol: string,      // Trading pair (e.g., \"BTCUSDT\")\n  interval: CandleInterval,  // Time interval (e.g., \"1m\", \"1h\")\n  since: Date,         // Start date for data fetching\n  limit: number        // Maximum number of candles to return\n) => Promise<ICandleData[]>\n```\n\n**Requirements:**\n- Return candles sorted by timestamp ascending\n- Each candle must have all OHLCV fields populated\n- Timestamps should be in milliseconds (Unix epoch)\n- Handle API rate limits and retry logic internally\n- Return empty array if no data available\n\n**Example Implementation:**\n```typescript\n// From README.md example\ngetCandles: async (symbol, interval, since, limit) => {\n  const exchange = new ccxt.binance();\n  const ohlcv = await exchange.fetchOHLCV(\n    symbol, \n    interval, \n    since.getTime(), \n    limit\n  );\n  return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n    timestamp,\n    open,\n    high,\n    low,\n    close,\n    volume\n  }));\n}\n```\n\n**Sources:** [types.d.ts:128-137](), [README.md:73-77]()\n\n---\n\n### formatPrice()\n\nFormats price values according to exchange precision rules (e.g., 2 decimals for BTC pairs, 8 for altcoins).\n\n**Signature:**\n```typescript\nformatPrice: (\n  symbol: string,  // Trading pair\n  price: number    // Raw price value\n) => Promise<string>  // Formatted price string\n```\n\n**Purpose:**\n- Ensure prices meet exchange precision requirements\n- Prevent order rejection due to invalid price formatting\n- Used when logging signals and calculating PNL\n\n**Example Implementation:**\n```typescript\nformatPrice: async (symbol, price) => {\n  // Simple fixed decimal approach\n  return price.toFixed(2);\n  \n  // Or use exchange-specific precision\n  const market = await exchange.loadMarkets();\n  const precision = market[symbol].precision.price;\n  return price.toFixed(precision);\n}\n```\n\n**Sources:** [types.d.ts:146-152](), [README.md:78]()\n\n---\n\n### formatQuantity()\n\nFormats quantity/size values according to exchange lot size rules.\n\n**Signature:**\n```typescript\nformatQuantity: (\n  symbol: string,    // Trading pair\n  quantity: number   // Raw quantity value\n) => Promise<string>  // Formatted quantity string\n```\n\n**Purpose:**\n- Ensure quantities meet exchange minimum/maximum size requirements\n- Apply lot size increments correctly\n- Prevent order rejection due to invalid quantity formatting\n\n**Example Implementation:**\n```typescript\nformatQuantity: async (symbol, quantity) => {\n  // Fixed decimal approach\n  return quantity.toFixed(8);\n  \n  // Or use exchange-specific precision\n  const market = await exchange.loadMarkets();\n  const precision = market[symbol].precision.amount;\n  return quantity.toFixed(precision);\n}\n```\n\n**Sources:** [types.d.ts:139-145](), [README.md:79]()\n\n---\n\n## Optional Callbacks\n\nThe `callbacks` field enables lifecycle event hooks for monitoring and debugging.\n\n### IExchangeCallbacks\n\n| Callback | Trigger | Parameters | Use Case |\n|----------|---------|------------|----------|\n| `onCandleData` | After `getCandles()` completes | `symbol`, `interval`, `since`, `limit`, `data` | Logging, debugging, cache invalidation |\n\n**Example:**\n```typescript\naddExchange({\n  exchangeName: 'binance',\n  getCandles: async (symbol, interval, since, limit) => {\n    // ... fetch implementation\n  },\n  callbacks: {\n    onCandleData: (symbol, interval, since, limit, data) => {\n      console.log(`Fetched ${data.length} candles for ${symbol} (${interval})`);\n      console.log(`Date range: ${since} to ${data[data.length - 1]?.timestamp}`);\n    }\n  },\n  // ... other methods\n});\n```\n\n**Sources:** [types.d.ts:114-117](), [types.d.ts:154]()\n\n---\n\n## Registration with addExchange()\n\n```mermaid\nsequenceDiagram\n    participant User as \"User Code\"\n    participant AddFn as \"addExchange()\"\n    participant Logger as \"LoggerService\"\n    participant ValSvc as \"ExchangeValidationService\"\n    participant SchemaSvc as \"ExchangeSchemaService\"\n    \n    User->>AddFn: addExchange(schema)\n    AddFn->>Logger: log(\"add.addExchange\")\n    \n    AddFn->>ValSvc: validateUniqueExchange(exchangeName)\n    alt Exchange already exists\n        ValSvc-->>AddFn: throw Error(\"Exchange exists\")\n        AddFn-->>User: Error thrown\n    else Exchange is unique\n        ValSvc-->>AddFn: validation passed\n        AddFn->>SchemaSvc: addExchange(schema)\n        SchemaSvc->>SchemaSvc: ToolRegistry.set(exchangeName, schema)\n        SchemaSvc-->>AddFn: void\n        AddFn-->>User: void (success)\n    end\n```\n\n**Diagram: addExchange() Registration Flow**\n\nThe registration process validates uniqueness to prevent accidental overwrites, then stores the schema in `ToolRegistry` for retrieval during execution.\n\n**Validation Rules:**\n- `exchangeName` must be unique across all registered exchanges\n- All required methods (`getCandles`, `formatPrice`, `formatQuantity`) must be provided\n- Callbacks are optional\n\n**Sources:** [src/function/add.ts](), [src/lib/services/validation/ExchangeValidationService.ts](), [src/lib/services/schema/ExchangeSchemaService.ts]()\n\n---\n\n## ClientExchange Implementation\n\nThe framework instantiates `ClientExchange` using the provided schema. This client implements additional logic around the user-defined methods.\n\n```mermaid\ngraph TB\n    Schema[\"IExchangeSchema<br/>User configuration\"] -->|\"passed to\"| Params[\"IExchangeParams<br/>+ logger<br/>+ execution context\"]\n    \n    Params -->|\"constructor\"| Client[\"ClientExchange instance<br/>Prototype methods\"]\n    \n    Client --> GetCandlesMethod[\"getCandles(symbol, interval, limit)<br/>- Reads execution context (when)<br/>- Calls schema.getCandles()<br/>- Returns data UP TO context time\"]\n    \n    Client --> GetNextCandlesMethod[\"getNextCandles(symbol, interval, limit)<br/>- Backtest only<br/>- Returns future candles<br/>- For fast backtest optimization\"]\n    \n    Client --> GetAvgPriceMethod[\"getAveragePrice(symbol)<br/>- Fetches last 5 1m candles<br/>- Calculates VWAP<br/>- TP = (H + L + C) / 3<br/>- VWAP = Σ(TP × Vol) / ΣVol\"]\n    \n    Client --> FormatPriceMethod[\"formatPrice(symbol, price)<br/>- Delegates to schema.formatPrice()\"]\n    \n    Client --> FormatQtyMethod[\"formatQuantity(symbol, quantity)<br/>- Delegates to schema.formatQuantity()\"]\n    \n    GetAvgPriceMethod -->|\"uses\"| GetCandlesMethod\n```\n\n**Diagram: ClientExchange Method Structure**\n\n`ClientExchange` wraps the user-defined schema and adds execution context awareness. The `getCandles()` method automatically respects the temporal context to prevent look-ahead bias.\n\n**Key Implementation Details:**\n- **Temporal Context:** `getCandles()` uses `ExecutionContextService.context.when` to limit data to current backtest time\n- **Memoization:** One `ClientExchange` instance per `exchangeName` (via `ExchangeConnectionService`)\n- **VWAP Calculation:** Default uses 5 one-minute candles (configurable via `CC_AVG_PRICE_CANDLES_COUNT`)\n- **Callback Invocation:** `onCandleData` triggered after successful `getCandles()` execution\n\n**Sources:** [src/client/ClientExchange.ts](), [types.d.ts:102-110](), [types.d.ts:157-205]()\n\n---\n\n## VWAP Pricing for Realistic Execution\n\nThe `getAveragePrice()` method calculates Volume Weighted Average Price to simulate realistic entry/exit prices.\n\n### VWAP Formula\n\n```\nTypical Price (TP) = (High + Low + Close) / 3\n\nVWAP = Σ(TP × Volume) / Σ(Volume)\n```\n\n### Configuration\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `CC_AVG_PRICE_CANDLES_COUNT` | 5 | Number of 1-minute candles to use for VWAP |\n\n**Example:**\n```typescript\nimport { setConfig } from 'backtest-kit';\n\nsetConfig({\n  CC_AVG_PRICE_CANDLES_COUNT: 10  // Use 10 candles instead of 5\n});\n```\n\n### When VWAP is Used\n\n- **Signal Opening:** When `priceOpen` is not specified (immediate market entry)\n- **Signal Monitoring:** Checking take profit and stop loss conditions\n- **Scheduled Signal Activation:** Determining when `priceOpen` is reached\n\n**Sources:** [types.d.ts:196-204](), [src/config/params.ts](), [src/client/ClientExchange.ts]()\n\n---\n\n## Integration with Strategy Execution\n\nStrategies access exchange functionality through helper functions that automatically resolve the correct exchange instance.\n\n```mermaid\nsequenceDiagram\n    participant Strategy as \"getSignal()<br/>User Strategy\"\n    participant Helper as \"getCandles()<br/>Helper Function\"\n    participant ExecCtx as \"ExecutionContextService<br/>{ symbol, when, backtest }\"\n    participant MethodCtx as \"MethodContextService<br/>{ exchangeName, ... }\"\n    participant ConnSvc as \"ExchangeConnectionService\"\n    participant Client as \"ClientExchange\"\n    participant Schema as \"schema.getCandles()\"\n    \n    Strategy->>Helper: getCandles(\"BTCUSDT\", \"1h\", 24)\n    Helper->>ExecCtx: Read context.symbol, context.when\n    Helper->>MethodCtx: Read context.exchangeName\n    Helper->>ConnSvc: getExchange(exchangeName)\n    \n    ConnSvc->>ConnSvc: Check memoization cache\n    alt Not cached\n        ConnSvc->>Client: new ClientExchange(schema, logger, execution)\n        ConnSvc->>ConnSvc: Cache instance\n    end\n    ConnSvc-->>Helper: ClientExchange instance\n    \n    Helper->>Client: getCandles(\"BTCUSDT\", \"1h\", 24)\n    Client->>Schema: schema.getCandles(symbol, \"1h\", since, 24)\n    Note over Client,Schema: since = context.when - (24 * 1h)\n    Schema-->>Client: ICandleData[]\n    Client-->>Helper: ICandleData[] (filtered to context.when)\n    Helper-->>Strategy: ICandleData[]\n```\n\n**Diagram: Strategy to Exchange Data Flow**\n\nThe framework uses dependency injection to automatically route strategy calls to the correct exchange instance based on execution context.\n\n**Helper Functions:**\n- `getCandles(symbol, interval, limit)` - Fetch historical candles\n- `getAveragePrice(symbol)` - Calculate current VWAP\n- `formatPrice(symbol, price)` - Format price for logging\n- `formatQuantity(symbol, quantity)` - Format quantity for logging\n\n**Sources:** [src/function/exchange.ts](), [src/lib/services/connection/ExchangeConnectionService.ts](), [src/lib/services/context/ExecutionContextService.ts]()\n\n---\n\n## Complete Configuration Example\n\n### Basic CCXT Integration\n\n```typescript\nimport ccxt from 'ccxt';\nimport { addExchange } from 'backtest-kit';\n\naddExchange({\n  exchangeName: 'binance',\n  note: 'Binance exchange for BTC/USDT pairs',\n  \n  getCandles: async (symbol, interval, since, limit) => {\n    const exchange = new ccxt.binance();\n    const ohlcv = await exchange.fetchOHLCV(\n      symbol,\n      interval,\n      since.getTime(),\n      limit\n    );\n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n      timestamp,\n      open,\n      high,\n      low,\n      close,\n      volume\n    }));\n  },\n  \n  formatPrice: async (symbol, price) => {\n    return price.toFixed(2);\n  },\n  \n  formatQuantity: async (symbol, quantity) => {\n    return quantity.toFixed(8);\n  },\n  \n  callbacks: {\n    onCandleData: (symbol, interval, since, limit, data) => {\n      console.log(`[EXCHANGE] Fetched ${data.length}/${limit} candles for ${symbol}`);\n    }\n  }\n});\n```\n\n### Custom Database Integration\n\n```typescript\nimport { addExchange } from 'backtest-kit';\nimport { db } from './database';\n\naddExchange({\n  exchangeName: 'historical-db',\n  note: 'Local database with historical OHLCV data',\n  \n  getCandles: async (symbol, interval, since, limit) => {\n    // Query local database\n    const candles = await db.query(\n      `SELECT timestamp, open, high, low, close, volume\n       FROM candles\n       WHERE symbol = ? AND interval = ? AND timestamp >= ?\n       ORDER BY timestamp ASC\n       LIMIT ?`,\n      [symbol, interval, since.getTime(), limit]\n    );\n    return candles;\n  },\n  \n  formatPrice: async (symbol, price) => {\n    // Lookup precision from database\n    const precision = await db.getPricePrecision(symbol);\n    return price.toFixed(precision);\n  },\n  \n  formatQuantity: async (symbol, quantity) => {\n    const precision = await db.getQuantityPrecision(symbol);\n    return quantity.toFixed(precision);\n  }\n});\n```\n\n**Sources:** [README.md:70-80](), [demo/backtest/src/exchange.mjs](), [demo/live/src/exchange.mjs]()\n\n---\n\n## Common Configuration Patterns\n\n### Retry Logic for API Failures\n\n```typescript\nasync function fetchWithRetry(fn, retries = 3) {\n  for (let i = 0; i < retries; i++) {\n    try {\n      return await fn();\n    } catch (error) {\n      if (i === retries - 1) throw error;\n      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n    }\n  }\n}\n\naddExchange({\n  exchangeName: 'robust-exchange',\n  getCandles: async (symbol, interval, since, limit) => {\n    return fetchWithRetry(async () => {\n      const exchange = new ccxt.binance();\n      const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n      // ... map to ICandleData\n    });\n  },\n  // ... other methods\n});\n```\n\n### Caching Candle Data\n\n```typescript\nconst candleCache = new Map();\n\naddExchange({\n  exchangeName: 'cached-exchange',\n  getCandles: async (symbol, interval, since, limit) => {\n    const cacheKey = `${symbol}-${interval}-${since.getTime()}-${limit}`;\n    \n    if (candleCache.has(cacheKey)) {\n      return candleCache.get(cacheKey);\n    }\n    \n    const exchange = new ccxt.binance();\n    const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n    const candles = ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n      timestamp, open, high, low, close, volume\n    }));\n    \n    candleCache.set(cacheKey, candles);\n    return candles;\n  },\n  callbacks: {\n    onCandleData: (symbol, interval, since, limit, data) => {\n      // Clear cache on new data\n      candleCache.clear();\n    }\n  },\n  // ... other methods\n});\n```\n\n### Multiple Exchange Support\n\n```typescript\n// Configure multiple exchanges for arbitrage or comparison\naddExchange({ exchangeName: 'binance', /* ... */ });\naddExchange({ exchangeName: 'coinbase', /* ... */ });\naddExchange({ exchangeName: 'kraken', /* ... */ });\n\n// Use different exchanges in strategies\naddStrategy({\n  strategyName: 'binance-strategy',\n  interval: '5m',\n  getSignal: async (symbol, when) => {\n    const candles = await getCandles(symbol, '1h', 24);\n    // Uses 'binance' exchange (from execution context)\n  }\n});\n```\n\n**Sources:** [src/client/ClientExchange.ts](), [src/lib/services/connection/ExchangeConnectionService.ts]()\n\n---\n\n## Summary\n\nThe exchange configuration system provides flexible market data abstraction through:\n\n1. **Schema-Based Configuration:** Define data sources via `IExchangeSchema` interface\n2. **Required Methods:** Implement `getCandles()`, `formatPrice()`, `formatQuantity()`\n3. **Optional Callbacks:** Monitor data fetching via `onCandleData` lifecycle hook\n4. **Temporal Context:** Automatic look-ahead bias prevention through `ExecutionContextService`\n5. **VWAP Pricing:** Realistic entry/exit simulation using volume-weighted prices\n6. **Memoization:** Efficient instance caching per exchange name\n\nFor specific integration patterns with CCXT, see [CCXT Integration](#8.3). For details on candle data structure and validation, see [Candle Data & Validation](#8.2).\n\n**Sources:** [types.d.ts:82-209](), [README.md:70-80](), [src/client/ClientExchange.ts](), [src/function/add.ts]()"
                    },
                    {
                        "page_plan": {
                            "id": "8.2",
                            "title": "Candle Data & Validation"
                        },
                        "content": "# Candle Data & Validation\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/config/params.ts](src/config/params.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [test/README.md](test/README.md)\n- [test/config/setup.mjs](test/config/setup.mjs)\n- [test/e2e/close.test.mjs](test/e2e/close.test.mjs)\n- [test/e2e/edge.test.mjs](test/e2e/edge.test.mjs)\n- [test/e2e/other.test.mjs](test/e2e/other.test.mjs)\n- [test/e2e/persist.test.mjs](test/e2e/persist.test.mjs)\n- [test/e2e/sanitize.test.mjs](test/e2e/sanitize.test.mjs)\n- [test/e2e/sequence.test.mjs](test/e2e/sequence.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page documents the candle data structure, retrieval mechanisms, and validation system used throughout Backtest Kit. It covers the `ICandleData` interface, retry logic for network failures, anomaly detection for incomplete candles, and median-based price validation. \n\nFor information about implementing exchange data sources that provide candle data, see [Exchange Configuration](#8.1). For VWAP pricing calculation that uses validated candles, see [VWAP Pricing & Data Handling](#3.5).\n\n---\n\n## ICandleData Structure\n\nThe `ICandleData` interface defines the OHLCV (Open-High-Low-Close-Volume) candle format used throughout the framework. All exchange implementations must return data in this format.\n\n```typescript\ninterface ICandleData {\n    timestamp: number;  // Unix timestamp in milliseconds\n    open: number;       // Opening price at candle start\n    high: number;       // Highest price during candle period\n    low: number;        // Lowest price during candle period\n    close: number;      // Closing price at candle end\n    volume: number;     // Trading volume during candle period\n}\n```\n\n### Field Semantics\n\n| Field | Type | Purpose | Usage |\n|-------|------|---------|-------|\n| `timestamp` | `number` | Unix epoch (ms) when candle opened | Temporal context for ExecutionContextService |\n| `open` | `number` | First trade price in period | VWAP calculation, signal validation |\n| `high` | `number` | Maximum price in period | TP/SL activation checks, volatility analysis |\n| `low` | `number` | Minimum price in period | TP/SL activation checks, support/resistance |\n| `close` | `number` | Last trade price in period | VWAP calculation, trend analysis |\n| `volume` | `number` | Total volume traded | VWAP weighting, liquidity assessment |\n\n**Sources:** [types.d.ts:87-100]()\n\n---\n\n## Candle Retrieval Flow\n\n### User-Facing API\n\nThe `getCandles` function provides the primary interface for retrieving historical candle data. It automatically injects temporal context and applies validation.\n\n**Candle Retrieval with Temporal Context**\n\n```mermaid\ngraph TD\n    User[\"Strategy getSignal()\"]\n    GetCandles[\"getCandles(symbol, interval, limit)\"]\n    ExecCtx[\"ExecutionContextService.context\"]\n    Exchange[\"ClientExchange.getCandles()\"]\n    Schema[\"IExchangeSchema.getCandles()\"]\n    Retry[\"Retry Logic<br/>(CC_GET_CANDLES_RETRY_COUNT)\"]\n    Validate[\"Anomaly Detection\"]\n    Result[\"ICandleData[]\"]\n    \n    User -->|\"calls\"| GetCandles\n    GetCandles -->|\"reads temporal context\"| ExecCtx\n    GetCandles -->|\"delegates to\"| Exchange\n    Exchange -->|\"calls user implementation\"| Schema\n    Schema -->|\"fetch with retry\"| Retry\n    Retry -->|\"returns raw data\"| Validate\n    Validate -->|\"filtered candles\"| Result\n    Result -->|\"return\"| User\n    \n    ExecCtx -.->|\"provides when (Date)\"| Exchange\n```\n\n**Sources:** [types.d.ts:11-18](), [types.d.ts:159-205]()\n\n---\n\n### Retry Logic\n\nNetwork failures and API rate limits are handled through automatic retry with exponential backoff.\n\n**Retry Configuration Parameters**\n\n```typescript\n// From GLOBAL_CONFIG (params.ts)\nCC_GET_CANDLES_RETRY_COUNT: 3         // Max retry attempts\nCC_GET_CANDLES_RETRY_DELAY_MS: 5000   // Delay between retries (5s)\n```\n\n**Retry Behavior**\n\n1. **Initial Attempt**: Call `IExchangeSchema.getCandles()` \n2. **On Failure**: Wait `CC_GET_CANDLES_RETRY_DELAY_MS` milliseconds\n3. **Retry**: Attempt again up to `CC_GET_CANDLES_RETRY_COUNT` times\n4. **Success**: Return validated candles\n5. **Exhausted**: Throw error, emit to `errorEmitter`\n\n**Example Retry Scenario**\n\n```\nAttempt 1: Failed (network timeout)\nWait: 5000ms\nAttempt 2: Failed (503 Service Unavailable)\nWait: 5000ms\nAttempt 3: Success → return candles\n```\n\n**Sources:** [src/config/params.ts:66-74]()\n\n---\n\n## Price Anomaly Detection\n\n### The Problem\n\nExchange APIs occasionally return incomplete or corrupted candles with anomalous prices (e.g., $0.01 for BTC when median is $50,000). These corrupt price calculations for VWAP, TP/SL validation, and PNL.\n\n**Common Anomaly Patterns**\n\n| Anomaly Type | Example | Cause |\n|--------------|---------|-------|\n| Near-zero prices | BTC: $0.01 | Incomplete candle from API |\n| Extreme outliers | BTC: $1,000,000 | Data corruption |\n| Missing data | `null`/`undefined` | API error |\n\n### Detection Algorithm\n\nThe framework uses a **factor-based threshold** approach comparing each candle against the median price of the batch.\n\n**Anomaly Detection Algorithm**\n\n```mermaid\ngraph TD\n    Input[\"Raw ICandleData[]\"]\n    CalcMedian[\"Calculate Median Price<br/>from all OHLC values\"]\n    CheckCount{\"Candle count >=<br/>CC_MIN_CANDLES_FOR_MEDIAN?\"}\n    UseMedian[\"Use Median as<br/>Reference Price\"]\n    UseAvg[\"Use Average as<br/>Reference Price\"]\n    Threshold[\"Threshold =<br/>Reference / CC_THRESHOLD_FACTOR\"]\n    \n    FilterLoop[\"For each candle\"]\n    CheckOHLC{\"All OHLC values<br/>> Threshold?\"}\n    Keep[\"Keep Candle\"]\n    Discard[\"Discard Candle<br/>(log warning)\"]\n    \n    Output[\"Filtered ICandleData[]\"]\n    \n    Input --> CalcMedian\n    CalcMedian --> CheckCount\n    CheckCount -->|\">= 5\"| UseMedian\n    CheckCount -->|\"< 5\"| UseAvg\n    UseMedian --> Threshold\n    UseAvg --> Threshold\n    Threshold --> FilterLoop\n    FilterLoop --> CheckOHLC\n    CheckOHLC -->|\"yes\"| Keep\n    CheckOHLC -->|\"no\"| Discard\n    Keep --> Output\n    Discard --> FilterLoop\n```\n\n**Sources:** [src/config/params.ts:76-104]()\n\n### Threshold Calculation\n\n**Configuration**\n\n```typescript\nCC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR: 1000  // Default\nCC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN: 5             // Median vs average switch\n```\n\n**Formula**\n\n```\nthreshold = referencePrice / CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR\n\nwhere:\n  referencePrice = median(all OHLC values)  if candles.length >= 5\n                   average(all OHLC values) otherwise\n```\n\n**Example: BTC at $50,000**\n\n```\nCandles: 10 candles with prices $49,500 - $50,500\nMedian: $50,000\nThreshold: $50,000 / 1000 = $50\n\nAnomalous candle: { open: 0.01, high: 0.02, low: 0.01, close: 0.01 }\n→ All values < $50 → DISCARDED\n\nNormal candle: { open: 49800, high: 50100, low: 49700, close: 50000 }\n→ All values > $50 → KEPT\n```\n\n### Why Factor 1000?\n\n| Factor | Threshold at $50k | Catches | Misses |\n|--------|-------------------|---------|--------|\n| 100 | $500 | Incomplete candles | Some bad data |\n| **1000** | **$50** | **All anomalies** | **None** |\n| 10000 | $5 | Everything | Normal volatility |\n\nThe factor of 1000 provides optimal balance:\n- **Catches incomplete candles**: $0.01-1 prices are well below $50\n- **Preserves flash crashes**: Even -90% crash ($5,000) passes threshold\n- **Works across assets**: Scales with price (BTC $50k vs ETH $3k)\n\n**Sources:** [src/config/params.ts:76-89]()\n\n---\n\n## Median vs Average Reference Price\n\nThe choice between median and average affects anomaly detection robustness.\n\n### Decision Logic\n\n```mermaid\ngraph LR\n    Input[\"Candle Batch\"]\n    Count{\"Candle Count\"}\n    Median[\"Calculate Median<br/>Robust to outliers\"]\n    Average[\"Calculate Average<br/>Faster computation\"]\n    \n    Input --> Count\n    Count -->|\">= CC_MIN_CANDLES_FOR_MEDIAN (5)\"| Median\n    Count -->|\"< 5\"| Average\n```\n\n### Statistical Rationale\n\n**Small Datasets (< 5 candles)**\n- Each candle provides 4 price points (OHLC)\n- < 5 candles = < 20 data points\n- Single outlier heavily skews median\n- Average is more stable\n\n**Large Datasets (≥ 5 candles)**\n- ≥ 5 candles = ≥ 20 data points\n- Median is robust to outliers\n- Protects against corrupt data affecting reference price\n\n**Example: 3 Candles with Anomaly**\n\n```\nCandles:\n  #1: { open: 50000, high: 50100, low: 49900, close: 50000 }\n  #2: { open: 50000, high: 50050, low: 49950, close: 50000 }\n  #3: { open: 0.01, high: 0.02, low: 0.01, close: 0.01 }  ← anomaly\n\nAll prices: [50000, 50100, 49900, 50000, 50000, 50050, 49950, 50000, 0.01, 0.02, 0.01, 0.01]\n\nAverage: ~33,333  (dragged down by anomaly!)\nMedian:  50000    (resistant to anomaly)\n\nWith < 5 candles → Use Average (faster, no statistical advantage)\nWith ≥ 5 candles → Use Median (outlier protection)\n```\n\n**Sources:** [src/config/params.ts:91-104]()\n\n---\n\n## Complete Validation Pipeline\n\n### End-to-End Flow\n\n**Candle Data Validation Pipeline**\n\n```mermaid\ngraph TB\n    subgraph \"1. User Request\"\n        UserCall[\"getCandles(symbol, '1h', 100)\"]\n    end\n    \n    subgraph \"2. Context Injection\"\n        ExecCtx[\"ExecutionContextService<br/>provides: symbol, when, backtest\"]\n        MethodCtx[\"MethodContextService<br/>provides: exchangeName\"]\n    end\n    \n    subgraph \"3. Exchange Layer\"\n        ConnService[\"ExchangeConnectionService<br/>getMemoizedExchange()\"]\n        ClientExch[\"ClientExchange<br/>getCandles()\"]\n        UserImpl[\"User IExchangeSchema.getCandles()<br/>(CCXT, API, Database)\"]\n    end\n    \n    subgraph \"4. Retry Logic\"\n        TryCount[\"Attempt Counter<br/>0 / CC_GET_CANDLES_RETRY_COUNT\"]\n        NetworkCall[\"Network Request\"]\n        RetryDelay[\"sleep(CC_GET_CANDLES_RETRY_DELAY_MS)\"]\n        Success{\"Success?\"}\n        Exhausted{\"Retries<br/>Exhausted?\"}\n    end\n    \n    subgraph \"5. Validation\"\n        RawData[\"Raw ICandleData[]\"]\n        CalcRef[\"Calculate Reference Price<br/>(median or average)\"]\n        FilterAnom[\"Filter Anomalies<br/>(price < threshold)\"]\n        CheckEmpty{\"Empty<br/>result?\"}\n        LogWarn[\"Log Warning<br/>(anomalies detected)\"]\n    end\n    \n    subgraph \"6. Return\"\n        ValidData[\"Validated ICandleData[]\"]\n        ErrorEmit[\"Emit errorEmitter<br/>(if all retries fail)\"]\n    end\n    \n    UserCall --> ExecCtx\n    ExecCtx --> MethodCtx\n    MethodCtx --> ConnService\n    ConnService --> ClientExch\n    ClientExch --> UserImpl\n    \n    UserImpl --> TryCount\n    TryCount --> NetworkCall\n    NetworkCall --> Success\n    Success -->|\"fail\"| Exhausted\n    Exhausted -->|\"yes\"| ErrorEmit\n    Exhausted -->|\"no\"| RetryDelay\n    RetryDelay --> TryCount\n    Success -->|\"ok\"| RawData\n    \n    RawData --> CalcRef\n    CalcRef --> FilterAnom\n    FilterAnom --> CheckEmpty\n    CheckEmpty -->|\"anomalies found\"| LogWarn\n    CheckEmpty -->|\"all valid\"| ValidData\n    LogWarn --> ValidData\n```\n\n**Sources:** [types.d.ts:159-205](), [src/config/params.ts:66-104]()\n\n---\n\n## Configuration Reference\n\n### Validation Parameters\n\nAll validation behavior is controlled through `GLOBAL_CONFIG` parameters. Use `setConfig()` to customize.\n\n| Parameter | Default | Purpose | Impact |\n|-----------|---------|---------|--------|\n| `CC_GET_CANDLES_RETRY_COUNT` | `3` | Maximum retry attempts | Higher = more resilient to transient failures |\n| `CC_GET_CANDLES_RETRY_DELAY_MS` | `5000` | Delay between retries (ms) | Higher = more respectful of rate limits |\n| `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR` | `1000` | Anomaly detection sensitivity | Higher = more strict, Lower = more permissive |\n| `CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN` | `5` | Switch from average to median | Affects reference price calculation method |\n\n**Example: Relaxed Validation for Testing**\n\n```typescript\nimport { setConfig } from 'backtest-kit';\n\nsetConfig({\n  CC_GET_CANDLES_RETRY_COUNT: 1,              // Fast failure\n  CC_GET_CANDLES_RETRY_DELAY_MS: 100,         // Short delay\n  CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR: 100,  // Permissive\n});\n```\n\n**Example: Strict Production Settings**\n\n```typescript\nsetConfig({\n  CC_GET_CANDLES_RETRY_COUNT: 5,              // Extra resilient\n  CC_GET_CANDLES_RETRY_DELAY_MS: 10000,       // Respectful rate limits\n  CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR: 10000,  // Very strict\n});\n```\n\n**Sources:** [src/config/params.ts:1-114]()\n\n---\n\n## Integration with Exchange Implementation\n\n### Exchange Schema Contract\n\nExchange implementations must provide the `getCandles` method that returns `ICandleData[]`. The framework handles validation automatically.\n\n**Minimal Exchange Implementation**\n\n```typescript\nimport { addExchange, ICandleData } from 'backtest-kit';\n\naddExchange({\n  exchangeName: 'my-exchange',\n  \n  // User implements data fetching - framework handles validation\n  getCandles: async (\n    symbol: string,\n    interval: CandleInterval,\n    since: Date,\n    limit: number\n  ): Promise<ICandleData[]> => {\n    // Fetch from API, database, or CCXT\n    const rawData = await fetchFromSource(symbol, interval, since, limit);\n    \n    // Transform to ICandleData format\n    return rawData.map(candle => ({\n      timestamp: candle.time,\n      open: candle.o,\n      high: candle.h,\n      low: candle.l,\n      close: candle.c,\n      volume: candle.v,\n    }));\n    \n    // Framework automatically:\n    // - Retries on failure (CC_GET_CANDLES_RETRY_COUNT)\n    // - Detects anomalies (CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR)\n    // - Filters corrupt data\n    // - Logs warnings\n  },\n  \n  formatPrice: async (symbol, price) => price.toFixed(8),\n  formatQuantity: async (symbol, qty) => qty.toFixed(8),\n});\n```\n\n**Sources:** [types.d.ts:119-155]()\n\n---\n\n## Error Handling\n\n### Validation Failures\n\n**Empty Candle Set After Filtering**\n\nWhen all candles are filtered out due to anomalies:\n1. Warning logged via `LoggerService`\n2. Empty array returned to caller\n3. Strategy receives no data for that interval\n4. No signal generated (protection mechanism)\n\n**Retry Exhaustion**\n\nWhen all retry attempts fail:\n1. Error logged via `LoggerService`\n2. Error emitted to `errorEmitter`\n3. Exception propagated to caller\n4. Execution continues (recoverable error)\n\n### Monitoring\n\nListen to error events to track data quality issues:\n\n```typescript\nimport { listenError } from 'backtest-kit';\n\nlistenError((error) => {\n  console.error('[Candle Fetch Error]', error.message);\n  // Send to monitoring service (Sentry, Datadog, etc.)\n});\n```\n\n**Sources:** [src/config/emitters.ts:34-44](), [src/function/event.ts:223-250]()\n\n---\n\n## Summary\n\nThe candle data validation system provides automatic protection against corrupt market data through:\n\n1. **Structured Format**: `ICandleData` interface ensures consistent OHLCV data\n2. **Retry Logic**: Automatic recovery from network failures (configurable attempts and delays)\n3. **Anomaly Detection**: Factor-based threshold filtering (catches incomplete candles)\n4. **Robust Statistics**: Median-based reference prices (resistant to outliers)\n5. **Configuration**: Tunable parameters via `GLOBAL_CONFIG`\n\nThis validation runs transparently for all exchange implementations, ensuring strategies receive clean, reliable market data regardless of the underlying data source."
                    },
                    {
                        "page_plan": {
                            "id": "8.3",
                            "title": "CCXT Integration"
                        },
                        "content": "# CCXT Integration\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/classes/Optimizer.ts](src/classes/Optimizer.ts)\n- [src/client/ClientOptimizer.ts](src/client/ClientOptimizer.ts)\n- [src/interfaces/Optimizer.interface.ts](src/interfaces/Optimizer.interface.ts)\n- [src/lib/services/connection/OptimizerConnectionService.ts](src/lib/services/connection/OptimizerConnectionService.ts)\n- [src/lib/services/global/OptimizerGlobalService.ts](src/lib/services/global/OptimizerGlobalService.ts)\n- [src/lib/services/schema/OptimizerSchemaService.ts](src/lib/services/schema/OptimizerSchemaService.ts)\n- [src/lib/services/template/OptimizerTemplateService.ts](src/lib/services/template/OptimizerTemplateService.ts)\n- [src/lib/services/validation/OptimizerValidationService.ts](src/lib/services/validation/OptimizerValidationService.ts)\n- [src/model/Message.model.ts](src/model/Message.model.ts)\n\n</details>\n\n\n\nThis document explains how Backtest Kit integrates with the CCXT library to fetch market data from cryptocurrency exchanges. CCXT (CryptoCurrency eXchange Trading) serves as the primary data source implementation for the framework, providing historical OHLCV (Open, High, Low, Close, Volume) candle data.\n\nFor information about defining custom exchange configurations, see [Exchange Configuration](#8.1). For details on candle data structures and validation, see [Candle Data & Validation](#8.2).\n\n---\n\n## Overview\n\nCCXT is a JavaScript/TypeScript library that provides a unified API for interacting with over 100+ cryptocurrency exchanges. Backtest Kit uses CCXT exclusively for **data fetching**, not for actual trading operations. The framework wraps CCXT's data fetching capabilities within the `IExchangeSchema` interface, providing a consistent interface regardless of the underlying exchange.\n\n**Key Integration Points:**\n- **Data Source**: CCXT provides historical OHLCV candles via `fetchOHLCV`\n- **Price Formatting**: CCXT exchanges handle symbol-specific price precision\n- **Quantity Formatting**: CCXT exchanges handle symbol-specific quantity precision\n- **No Trading**: Backtest Kit does not use CCXT for order placement or account management\n\n**Sources:** [README.md:67-80](), [package.json:1-81]()\n\n---\n\n## Architecture Integration\n\n### CCXT in the Exchange Layer\n\n```mermaid\ngraph TB\n    subgraph \"User Code Layer\"\n        addExchange[\"addExchange()<br/>IExchangeSchema\"]\n    end\n    \n    subgraph \"Service Layer\"\n        ExchangeSchemaService[\"ExchangeSchemaService<br/>Register & Store\"]\n        ExchangeConnectionService[\"ExchangeConnectionService<br/>Memoized ClientExchange\"]\n    end\n    \n    subgraph \"Client Layer\"\n        ClientExchange[\"ClientExchange<br/>getCandles, formatPrice,<br/>formatQuantity\"]\n    end\n    \n    subgraph \"CCXT Integration\"\n        CCXT[\"ccxt.binance()<br/>ccxt.kraken()<br/>etc.\"]\n        fetchOHLCV[\"exchange.fetchOHLCV()<br/>Returns: [timestamp, O, H, L, C, V][]\"]\n    end\n    \n    subgraph \"Framework Data Model\"\n        ICandleData[\"ICandleData<br/>{timestamp, open, high,<br/>low, close, volume}\"]\n    end\n    \n    addExchange --> ExchangeSchemaService\n    ExchangeSchemaService --> ExchangeConnectionService\n    ExchangeConnectionService --> ClientExchange\n    \n    ClientExchange -->|calls getCandles| CCXT\n    CCXT --> fetchOHLCV\n    fetchOHLCV -->|maps array to objects| ICandleData\n    \n    style CCXT fill:#e1f5ff,stroke:#0066cc,stroke-width:2px\n    style ICandleData fill:#ffe1e1,stroke:#cc0000,stroke-width:2px\n```\n\n**Data Flow:**\n1. User calls `addExchange()` with CCXT-based implementation\n2. Schema stored in `ExchangeSchemaService`\n3. `ClientExchange` instance created by `ExchangeConnectionService`\n4. Strategy calls `getCandles()` → triggers CCXT `fetchOHLCV()`\n5. CCXT returns nested arrays → mapped to `ICandleData` objects\n\n**Sources:** [README.md:67-80](), [src/lib/services/template/OptimizerTemplateService.ts:307-342]()\n\n---\n\n## IExchangeSchema Implementation\n\n### Required Methods\n\nThe `IExchangeSchema` interface requires three methods when implementing CCXT integration:\n\n| Method | Purpose | CCXT Equivalent |\n|--------|---------|-----------------|\n| `getCandles` | Fetch historical OHLCV data | `exchange.fetchOHLCV()` |\n| `formatPrice` | Format price to exchange precision | `exchange.priceToPrecision()` or custom |\n| `formatQuantity` | Format quantity to exchange precision | `exchange.amountToPrecision()` or custom |\n\n### Basic CCXT Implementation\n\n```typescript\nimport ccxt from 'ccxt';\nimport { addExchange } from 'backtest-kit';\n\naddExchange({\n  exchangeName: 'binance',\n  \n  // Fetch candles using CCXT\n  getCandles: async (symbol, interval, since, limit) => {\n    const exchange = new ccxt.binance();\n    const ohlcv = await exchange.fetchOHLCV(\n      symbol,           // e.g., \"BTCUSDT\"\n      interval,         // e.g., \"1m\", \"5m\", \"1h\"\n      since.getTime(),  // Unix timestamp in milliseconds\n      limit             // Number of candles to fetch\n    );\n    \n    // Map CCXT array format to ICandleData object format\n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n      timestamp,  // Unix timestamp (ms)\n      open,       // Opening price\n      high,       // Highest price\n      low,        // Lowest price\n      close,      // Closing price\n      volume      // Trading volume\n    }));\n  },\n  \n  // Format price (simple approach)\n  formatPrice: (symbol, price) => price.toFixed(2),\n  \n  // Format quantity (simple approach)\n  formatQuantity: (symbol, quantity) => quantity.toFixed(8),\n});\n```\n\n**Sources:** [README.md:67-80]()\n\n---\n\n## Data Format Mapping\n\n### CCXT OHLCV Array to ICandleData\n\nCCXT returns OHLCV data as nested arrays with a specific structure. Backtest Kit requires object-based `ICandleData` format for easier manipulation and type safety.\n\n```mermaid\ngraph LR\n    subgraph \"CCXT Output Format\"\n        CCXT_Array[\"[[timestamp, O, H, L, C, V],<br/>[timestamp, O, H, L, C, V],<br/>...]\"]\n    end\n    \n    subgraph \"Mapping Process\"\n        Map[\"ohlcv.map([t, o, h, l, c, v])<br/>=> ({timestamp: t, open: o, ...})\"]\n    end\n    \n    subgraph \"Framework Format\"\n        ICandleData_Array[\"[{timestamp, open, high, low, close, volume},<br/>{timestamp, open, high, low, close, volume},<br/>...]\"]\n    end\n    \n    CCXT_Array -->|destructure array| Map\n    Map -->|construct objects| ICandleData_Array\n```\n\n**CCXT Array Structure:**\n```\n[\n  timestamp (number),  // Index 0: Unix timestamp in milliseconds\n  open (number),       // Index 1: Opening price\n  high (number),       // Index 2: Highest price\n  low (number),        // Index 3: Lowest price\n  close (number),      // Index 4: Closing price\n  volume (number)      // Index 5: Trading volume\n]\n```\n\n**ICandleData Object Structure:**\n```typescript\ninterface ICandleData {\n  timestamp: number;  // Unix timestamp in milliseconds\n  open: number;       // Opening price\n  high: number;       // Highest price\n  low: number;        // Lowest price\n  close: number;      // Closing price\n  volume: number;     // Trading volume\n}\n```\n\n**Sources:** [README.md:73-76](), [src/lib/services/template/OptimizerTemplateService.ts:331-336]()\n\n---\n\n## Exchange Method Parameters\n\n### getCandles Parameters\n\nThe `getCandles` method receives four parameters that must be passed to CCXT's `fetchOHLCV`:\n\n| Parameter | Type | Description | CCXT Mapping |\n|-----------|------|-------------|--------------|\n| `symbol` | `string` | Trading pair (e.g., \"BTCUSDT\") | Direct pass-through |\n| `interval` | `CandleInterval` | Timeframe string (\"1m\", \"5m\", etc.) | Direct pass-through |\n| `since` | `Date` | Start date for data range | Convert to `since.getTime()` |\n| `limit` | `number` | Maximum candles to fetch | Direct pass-through |\n\n**Important Notes:**\n- **Timestamp Conversion**: CCXT expects Unix timestamp in **milliseconds**, so use `since.getTime()` rather than `since`\n- **Interval Format**: CCXT uses strings like `\"1m\"`, `\"5m\"`, `\"1h\"`, `\"1d\"` - same as Backtest Kit's `CandleInterval` type\n- **Limit Behavior**: Some exchanges have maximum limits (e.g., 1000 candles per request). CCXT handles pagination internally for some methods, but `fetchOHLCV` typically requires manual pagination\n\n### Example with Error Handling\n\n```typescript\ngetCandles: async (symbol, interval, since, limit) => {\n  const exchange = new ccxt.binance();\n  \n  try {\n    const ohlcv = await exchange.fetchOHLCV(\n      symbol,\n      interval,\n      since.getTime(),  // Convert Date to Unix timestamp (ms)\n      limit\n    );\n    \n    // Validate data exists\n    if (!ohlcv || ohlcv.length === 0) {\n      throw new Error(`No candle data returned for ${symbol}`);\n    }\n    \n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n      timestamp,\n      open,\n      high,\n      low,\n      close,\n      volume\n    }));\n  } catch (error) {\n    console.error(`CCXT error fetching ${symbol}:`, error);\n    throw error;\n  }\n}\n```\n\n**Sources:** [README.md:73-76](), [src/lib/services/template/OptimizerTemplateService.ts:331-336]()\n\n---\n\n## Formatter Methods\n\n### formatPrice Implementation\n\nThe `formatPrice` method converts numeric prices to exchange-specific precision strings. While a simple `toFixed()` approach works for testing, production implementations should use CCXT's precision helpers.\n\n**Simple Approach (Testing):**\n```typescript\nformatPrice: (symbol, price) => price.toFixed(2)\n```\n\n**Production Approach (Using CCXT Precision):**\n```typescript\nformatPrice: async (symbol, price) => {\n  const exchange = new ccxt.binance();\n  await exchange.loadMarkets();  // Load market metadata\n  return exchange.priceToPrecision(symbol, price);\n}\n```\n\n### formatQuantity Implementation\n\nThe `formatQuantity` method converts numeric quantities to exchange-specific precision strings.\n\n**Simple Approach (Testing):**\n```typescript\nformatQuantity: (symbol, quantity) => quantity.toFixed(8)\n```\n\n**Production Approach (Using CCXT Precision):**\n```typescript\nformatQuantity: async (symbol, quantity) => {\n  const exchange = new ccxt.binance();\n  await exchange.loadMarkets();\n  return exchange.amountToPrecision(symbol, quantity);\n}\n```\n\n**Caching Consideration:**\nSince `loadMarkets()` makes a network request, consider caching the exchange instance:\n\n```typescript\nconst exchangeCache = new Map<string, ccxt.Exchange>();\n\nfunction getExchange(exchangeName: string): ccxt.Exchange {\n  if (!exchangeCache.has(exchangeName)) {\n    const exchange = new ccxt.binance();\n    exchangeCache.set(exchangeName, exchange);\n  }\n  return exchangeCache.get(exchangeName)!;\n}\n\naddExchange({\n  exchangeName: 'binance',\n  getCandles: async (symbol, interval, since, limit) => {\n    const exchange = getExchange('binance');\n    // ... rest of implementation\n  },\n  formatPrice: async (symbol, price) => {\n    const exchange = getExchange('binance');\n    await exchange.loadMarkets();\n    return exchange.priceToPrecision(symbol, price);\n  },\n  formatQuantity: async (symbol, quantity) => {\n    const exchange = getExchange('binance');\n    await exchange.loadMarkets();\n    return exchange.amountToPrecision(symbol, quantity);\n  },\n});\n```\n\n**Sources:** [README.md:78-79](), [src/lib/services/template/OptimizerTemplateService.ts:338-339]()\n\n---\n\n## Optimizer Template Generation\n\n### Auto-Generated CCXT Code\n\nThe `OptimizerTemplateService` automatically generates CCXT integration code when creating strategy files. This ensures consistency across optimizer-generated strategies.\n\n```mermaid\ngraph TB\n    subgraph \"Optimizer Code Generation\"\n        Template[\"OptimizerTemplateService<br/>getExchangeTemplate()\"]\n        Code[\"Generated .mjs File\"]\n    end\n    \n    subgraph \"Generated Code Structure\"\n        Import[\"import ccxt from 'ccxt'\"]\n        AddExchange[\"addExchange({<br/>  exchangeName: 'prefix_exchange',<br/>  getCandles: async (...) => {...}<br/>})\"]\n        CCXT_Call[\"new ccxt.binance()<br/>fetchOHLCV()\"]\n        Map[\"ohlcv.map(([t, o, h, l, c, v]) => {...})\"]\n    end\n    \n    Template --> Code\n    Code --> Import\n    Code --> AddExchange\n    AddExchange --> CCXT_Call\n    CCXT_Call --> Map\n    \n    style Template fill:#e1f5ff,stroke:#0066cc,stroke-width:2px\n```\n\n**Template Implementation:**\n\nThe `getExchangeTemplate` method in [src/lib/services/template/OptimizerTemplateService.ts:314-342]() generates:\n\n```typescript\naddExchange({\n    exchangeName: \"${escapedExchangeName}\",\n    getCandles: async (symbol, interval, since, limit) => {\n        const exchange = new ccxt.binance();\n        const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n        return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n            timestamp, open, high, low, close, volume\n        }));\n    },\n    formatPrice: async (symbol, price) => price.toFixed(2),\n    formatQuantity: async (symbol, quantity) => quantity.toFixed(8),\n});\n```\n\n**Key Features:**\n- **Code Injection Protection**: Uses `escapedExchangeName` to prevent malicious input [src/lib/services/template/OptimizerTemplateService.ts:324-326]()\n- **Hardcoded Binance**: Currently generates Binance-specific code (could be parameterized in future)\n- **Simple Formatters**: Uses basic `toFixed()` for price/quantity formatting\n\n**Sources:** [src/lib/services/template/OptimizerTemplateService.ts:307-342]()\n\n---\n\n## Multi-Exchange Support\n\n### Using Different CCXT Exchanges\n\nCCXT supports 100+ exchanges. To use a different exchange, simply change the constructor:\n\n```typescript\n// Binance\nconst exchange = new ccxt.binance();\n\n// Kraken\nconst exchange = new ccxt.kraken();\n\n// Coinbase Pro\nconst exchange = new ccxt.coinbasepro();\n\n// FTX (if available)\nconst exchange = new ccxt.ftx();\n```\n\n### Exchange-Specific Configuration\n\nSome exchanges require API credentials even for public data:\n\n```typescript\naddExchange({\n  exchangeName: 'kraken',\n  getCandles: async (symbol, interval, since, limit) => {\n    const exchange = new ccxt.kraken({\n      apiKey: process.env.KRAKEN_API_KEY,       // Optional for public data\n      secret: process.env.KRAKEN_SECRET,        // Optional for public data\n      enableRateLimit: true,                     // Recommended\n      timeout: 30000                             // 30 second timeout\n    });\n    \n    const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n      timestamp, open, high, low, close, volume\n    }));\n  },\n  // ... formatters\n});\n```\n\n### Handling Exchange Rate Limits\n\nCCXT provides built-in rate limiting:\n\n```typescript\nconst exchange = new ccxt.binance({\n  enableRateLimit: true,  // Automatically throttle requests\n  rateLimit: 1200         // Milliseconds between requests (optional)\n});\n```\n\n**Backtest Considerations:**\n- During backtests, `getCandles` may be called thousands of times\n- Enable `enableRateLimit` to avoid hitting exchange API limits\n- Consider implementing a caching layer for frequently accessed data\n- Use the framework's built-in candle buffering (handled by `ClientExchange`)\n\n**Sources:** [README.md:67-80]()\n\n---\n\n## Common Patterns and Best Practices\n\n### Pattern 1: Singleton Exchange Instance\n\nCreate exchange instances once and reuse them:\n\n```typescript\nlet exchangeInstance: ccxt.Exchange | null = null;\n\naddExchange({\n  exchangeName: 'binance',\n  getCandles: async (symbol, interval, since, limit) => {\n    if (!exchangeInstance) {\n      exchangeInstance = new ccxt.binance({\n        enableRateLimit: true\n      });\n    }\n    \n    const ohlcv = await exchangeInstance.fetchOHLCV(\n      symbol, interval, since.getTime(), limit\n    );\n    \n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n      timestamp, open, high, low, close, volume\n    }));\n  },\n  // ... formatters\n});\n```\n\n### Pattern 2: Symbol Normalization\n\nDifferent exchanges use different symbol formats:\n\n```typescript\nfunction normalizeSymbol(symbol: string, exchangeName: string): string {\n  // Binance uses \"BTCUSDT\", Kraken uses \"BTC/USDT\"\n  if (exchangeName === 'binance') {\n    return symbol.replace('/', '');  // BTC/USDT -> BTCUSDT\n  }\n  if (exchangeName === 'kraken') {\n    return symbol.includes('/') ? symbol : `${symbol.slice(0, -4)}/${symbol.slice(-4)}`;\n  }\n  return symbol;\n}\n\naddExchange({\n  exchangeName: 'binance',\n  getCandles: async (symbol, interval, since, limit) => {\n    const exchange = new ccxt.binance();\n    const normalizedSymbol = normalizeSymbol(symbol, 'binance');\n    // ... rest of implementation\n  },\n  // ... formatters\n});\n```\n\n### Pattern 3: Error Recovery with Retries\n\nImplement retry logic for network failures:\n\n```typescript\nasync function fetchWithRetry<T>(\n  fn: () => Promise<T>,\n  retries: number = 3,\n  delay: number = 1000\n): Promise<T> {\n  try {\n    return await fn();\n  } catch (error) {\n    if (retries > 0) {\n      await new Promise(resolve => setTimeout(resolve, delay));\n      return fetchWithRetry(fn, retries - 1, delay * 2);\n    }\n    throw error;\n  }\n}\n\naddExchange({\n  exchangeName: 'binance',\n  getCandles: async (symbol, interval, since, limit) => {\n    const exchange = new ccxt.binance({ enableRateLimit: true });\n    \n    const ohlcv = await fetchWithRetry(() =>\n      exchange.fetchOHLCV(symbol, interval, since.getTime(), limit)\n    );\n    \n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n      timestamp, open, high, low, close, volume\n    }));\n  },\n  // ... formatters\n});\n```\n\n**Sources:** [README.md:67-80]()\n\n---\n\n## Interval Mapping\n\n### Supported Timeframes\n\nCCXT and Backtest Kit both use string-based interval notation. Common intervals:\n\n| Interval | Description | Typical Use Case |\n|----------|-------------|------------------|\n| `\"1m\"` | 1 minute | High-frequency strategies |\n| `\"5m\"` | 5 minutes | Intraday trading |\n| `\"15m\"` | 15 minutes | Short-term analysis |\n| `\"1h\"` | 1 hour | Medium-term trends |\n| `\"4h\"` | 4 hours | Swing trading |\n| `\"1d\"` | 1 day | Long-term analysis |\n\n**Note:** Not all exchanges support all intervals. Check CCXT documentation for exchange-specific limitations.\n\n### Validating Interval Support\n\n```typescript\naddExchange({\n  exchangeName: 'binance',\n  getCandles: async (symbol, interval, since, limit) => {\n    const exchange = new ccxt.binance();\n    \n    // Load markets to check supported timeframes\n    await exchange.loadMarkets();\n    \n    const market = exchange.market(symbol);\n    if (market && market.timeframes && !market.timeframes.includes(interval)) {\n      throw new Error(\n        `Interval ${interval} not supported for ${symbol} on ${exchange.name}`\n      );\n    }\n    \n    const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n      timestamp, open, high, low, close, volume\n    }));\n  },\n  // ... formatters\n});\n```\n\n**Sources:** [README.md:73-76]()\n\n---\n\n## Testing and Debugging\n\n### Logging CCXT Requests\n\nEnable verbose logging to debug data fetching issues:\n\n```typescript\naddExchange({\n  exchangeName: 'binance',\n  getCandles: async (symbol, interval, since, limit) => {\n    const exchange = new ccxt.binance({\n      enableRateLimit: true,\n      verbose: process.env.DEBUG === 'true'  // Enable in .env\n    });\n    \n    console.log(`Fetching ${symbol} ${interval} from ${since.toISOString()}, limit=${limit}`);\n    \n    const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n    \n    console.log(`Received ${ohlcv.length} candles`);\n    \n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n      timestamp, open, high, low, close, volume\n    }));\n  },\n  // ... formatters\n});\n```\n\n### Validating Data Quality\n\nCheck for common data issues:\n\n```typescript\ngetCandles: async (symbol, interval, since, limit) => {\n  const exchange = new ccxt.binance();\n  const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n  \n  // Validate data\n  const candles = ohlcv.map(([timestamp, open, high, low, close, volume]) => {\n    // Check for invalid prices\n    if (open <= 0 || high <= 0 || low <= 0 || close <= 0) {\n      console.warn(`Invalid prices for ${symbol} at ${timestamp}`);\n    }\n    \n    // Check OHLC relationship\n    if (high < Math.max(open, close) || low > Math.min(open, close)) {\n      console.warn(`OHLC inconsistency for ${symbol} at ${timestamp}`);\n    }\n    \n    return { timestamp, open, high, low, close, volume };\n  });\n  \n  return candles;\n}\n```\n\n**Sources:** [README.md:67-80]()\n\n---\n\n## Common Issues and Solutions\n\n### Issue 1: Rate Limit Exceeded\n\n**Problem:** CCXT throws `RateLimitExceeded` error during backtests.\n\n**Solution:**\n```typescript\nconst exchange = new ccxt.binance({\n  enableRateLimit: true,  // Enable automatic throttling\n  rateLimit: 2000         // Increase delay between requests\n});\n```\n\n### Issue 2: Missing Candles\n\n**Problem:** CCXT returns fewer candles than requested `limit`.\n\n**Explanation:** Exchanges may not have data for the entire requested range, especially for recent listings or delisted pairs.\n\n**Solution:** Handle partial data gracefully:\n```typescript\nconst ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n\nif (ohlcv.length < limit) {\n  console.warn(`Only ${ohlcv.length} of ${limit} candles available`);\n}\n\n// Framework handles incomplete data via anomaly detection (see page 8.2)\nreturn ohlcv.map(/* ... */);\n```\n\n### Issue 3: Symbol Not Found\n\n**Problem:** Exchange throws \"symbol not found\" error.\n\n**Solution:** Load markets first and validate symbol exists:\n```typescript\nconst exchange = new ccxt.binance();\nawait exchange.loadMarkets();\n\nif (!exchange.has[symbol]) {\n  throw new Error(`Symbol ${symbol} not found on ${exchange.name}`);\n}\n```\n\n### Issue 4: Timestamp Mismatch\n\n**Problem:** Candle timestamps don't align with requested `since` date.\n\n**Explanation:** Exchanges return candles aligned to interval boundaries. Requesting data from `2024-01-01 14:23:00` with `1h` interval will return candles starting at `2024-01-01 14:00:00`.\n\n**Solution:** This is expected behavior. The framework's time execution engine handles alignment automatically.\n\n**Sources:** [README.md:67-80]()\n\n---\n\n## Integration with Optimizer\n\nThe Optimizer system automatically generates CCXT integration code for strategy backtests. When you define an optimizer schema with `addOptimizer()`, the generated `.mjs` file includes a complete CCXT exchange configuration.\n\n### Generated Code Structure\n\n```mermaid\ngraph TB\n    subgraph \"Optimizer Schema\"\n        addOptimizer[\"addOptimizer({<br/>optimizerName,<br/>source,<br/>rangeTrain,<br/>rangeTest<br/>})\"]\n    end\n    \n    subgraph \"Code Generation Pipeline\"\n        Template[\"OptimizerTemplateService\"]\n        getTopBanner[\"getTopBanner()<br/>import ccxt\"]\n        getExchangeTemplate[\"getExchangeTemplate()<br/>addExchange(...)\"]\n        getStrategyTemplate[\"getStrategyTemplate()<br/>addStrategy(...)\"]\n        getLauncherTemplate[\"getLauncherTemplate()<br/>Walker.background()\"]\n    end\n    \n    subgraph \"Generated .mjs File\"\n        Import[\"import ccxt from 'ccxt'\"]\n        Exchange[\"addExchange({<br/>  exchangeName: 'prefix_exchange',<br/>  getCandles: async (...) => {<br/>    const exchange = new ccxt.binance();<br/>    ...<br/>  }<br/>})\"]\n        Strategy[\"addStrategy({...})\"]\n        Walker[\"Walker.background(...)\"]\n    end\n    \n    addOptimizer --> Template\n    Template --> getTopBanner\n    Template --> getExchangeTemplate\n    Template --> getStrategyTemplate\n    Template --> getLauncherTemplate\n    \n    getTopBanner --> Import\n    getExchangeTemplate --> Exchange\n    getStrategyTemplate --> Strategy\n    getLauncherTemplate --> Walker\n    \n    style Template fill:#e1f5ff,stroke:#0066cc,stroke-width:2px\n    style Exchange fill:#ffe1e1,stroke:#cc0000,stroke-width:2px\n```\n\n**Generated Exchange Code:**\n\nFrom [src/lib/services/template/OptimizerTemplateService.ts:314-342](), the optimizer generates:\n\n```typescript\nimport ccxt from 'ccxt';\n\naddExchange({\n    exchangeName: \"abc123_exchange\",\n    getCandles: async (symbol, interval, since, limit) => {\n        const exchange = new ccxt.binance();\n        const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n        return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n            timestamp, open, high, low, close, volume\n        }));\n    },\n    formatPrice: async (symbol, price) => price.toFixed(2),\n    formatQuantity: async (symbol, quantity) => quantity.toFixed(8),\n});\n```\n\n**Customizing Generated Exchange:**\n\nTo use a different exchange in generated code, override the `getExchangeTemplate` method:\n\n```typescript\naddOptimizer({\n  optimizerName: 'my-optimizer',\n  // ... other config\n  template: {\n    getExchangeTemplate: async (symbol, exchangeName) => {\n      return `\n        addExchange({\n          exchangeName: \"${exchangeName}\",\n          getCandles: async (symbol, interval, since, limit) => {\n            const exchange = new ccxt.kraken();  // Use Kraken instead\n            const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n            return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n              timestamp, open, high, low, close, volume\n            }));\n          },\n          formatPrice: async (symbol, price) => price.toFixed(2),\n          formatQuantity: async (symbol, quantity) => quantity.toFixed(8),\n        });\n      `;\n    }\n  }\n});\n```\n\n**Sources:** [src/lib/services/template/OptimizerTemplateService.ts:314-342](), [src/interfaces/Optimizer.interface.ts:242-305]()\n\n---\n\n## Summary\n\nCCXT integration in Backtest Kit provides:\n\n1. **Unified Data Access**: Single interface (`IExchangeSchema`) wraps CCXT's exchange-specific implementations\n2. **Automatic Mapping**: CCXT's array-based OHLCV data automatically mapped to framework's object-based `ICandleData`\n3. **Multi-Exchange Support**: Easy switching between 100+ exchanges by changing constructor\n4. **Optimizer Integration**: Auto-generated CCXT code in optimizer-produced strategies\n5. **Production Ready**: Built-in rate limiting, error handling, and retry logic support\n\n**Key Takeaways:**\n- CCXT is used **only for data fetching**, not trading\n- Always enable rate limiting with `enableRateLimit: true`\n- Use `since.getTime()` to convert Date to milliseconds\n- Implement exchange instance caching for better performance\n- Override optimizer templates to customize generated exchange code\n\nFor advanced exchange configuration patterns, see [Exchange Configuration](#8.1). For data validation and anomaly detection, see [Candle Data & Validation](#8.2).\n\n**Sources:** [README.md:67-80](), [src/lib/services/template/OptimizerTemplateService.ts:307-342](), [package.json:1-81]()"
                    },
                    {
                        "page_plan": {
                            "id": "9",
                            "title": "Reporting & Monitoring"
                        },
                        "content": "# Reporting & Monitoring\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Heat.ts](src/classes/Heat.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Partial.ts](src/classes/Partial.ts)\n- [src/classes/Performance.ts](src/classes/Performance.ts)\n- [src/classes/Risk.ts](src/classes/Risk.ts)\n- [src/classes/Schedule.ts](src/classes/Schedule.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/lib/services/markdown/BacktestMarkdownService.ts](src/lib/services/markdown/BacktestMarkdownService.ts)\n- [src/lib/services/markdown/HeatMarkdownService.ts](src/lib/services/markdown/HeatMarkdownService.ts)\n- [src/lib/services/markdown/LiveMarkdownService.ts](src/lib/services/markdown/LiveMarkdownService.ts)\n- [src/lib/services/markdown/PartialMarkdownService.ts](src/lib/services/markdown/PartialMarkdownService.ts)\n- [src/lib/services/markdown/PerformanceMarkdownService.ts](src/lib/services/markdown/PerformanceMarkdownService.ts)\n- [src/lib/services/markdown/RiskMarkdownService.ts](src/lib/services/markdown/RiskMarkdownService.ts)\n- [src/lib/services/markdown/ScheduleMarkdownService.ts](src/lib/services/markdown/ScheduleMarkdownService.ts)\n- [src/lib/services/markdown/WalkerMarkdownService.ts](src/lib/services/markdown/WalkerMarkdownService.ts)\n- [src/model/Column.model.ts](src/model/Column.model.ts)\n- [test/spec/columns.test.mjs](test/spec/columns.test.mjs)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page documents the reporting and monitoring capabilities of Backtest Kit. The system provides real-time event streaming, statistical analysis, and markdown report generation for all execution modes (Backtest, Live, Walker). \n\n**Core capabilities covered:**\n- Event-driven architecture with 13+ specialized emitters\n- 8 markdown report services with automatic data aggregation\n- Statistics calculation (Sharpe ratio, win rate, PNL, performance metrics)\n- Public API for programmatic access to reports and data\n- Column configuration for customizable report formatting\n- File system persistence with organized directory structure\n\n**Related pages:**\n- For strategy lifecycle callbacks, see [Strategy Development](#6)\n- For execution modes that generate events, see [Execution Modes](#5)\n- For risk validation that triggers risk events, see [Risk Management](#7)\n\n---\n\n## Event-Driven Architecture\n\nThe framework implements a comprehensive event system using `functools-kit` `Subject` pattern. All execution activities emit events that can be subscribed to via listener functions or consumed internally by markdown services.\n\n### Event Emitters\n\n```mermaid\ngraph TB\n    subgraph \"Signal Events\"\n        signalEmitter[\"signalEmitter<br/>(all modes)\"]\n        signalBacktestEmitter[\"signalBacktestEmitter<br/>(backtest only)\"]\n        signalLiveEmitter[\"signalLiveEmitter<br/>(live only)\"]\n    end\n    \n    subgraph \"Progress Events\"\n        progressBacktestEmitter[\"progressBacktestEmitter<br/>(frame completion %)\"]\n        progressWalkerEmitter[\"progressWalkerEmitter<br/>(strategy progress)\"]\n        progressOptimizerEmitter[\"progressOptimizerEmitter<br/>(optimization progress)\"]\n    end\n    \n    subgraph \"Completion Events\"\n        doneBacktestSubject[\"doneBacktestSubject<br/>(backtest complete)\"]\n        doneLiveSubject[\"doneLiveSubject<br/>(live shutdown)\"]\n        doneWalkerSubject[\"doneWalkerSubject<br/>(walker complete)\"]\n    end\n    \n    subgraph \"Monitoring Events\"\n        performanceEmitter[\"performanceEmitter<br/>(timing metrics)\"]\n        partialProfitSubject[\"partialProfitSubject<br/>(profit milestones)\"]\n        partialLossSubject[\"partialLossSubject<br/>(loss milestones)\"]\n        riskSubject[\"riskSubject<br/>(validation failures)\"]\n    end\n    \n    subgraph \"Walker Events\"\n        walkerEmitter[\"walkerEmitter<br/>(strategy tested)\"]\n        walkerCompleteSubject[\"walkerCompleteSubject<br/>(final results)\"]\n        walkerStopSubject[\"walkerStopSubject<br/>(cancellation)\"]\n    end\n    \n    subgraph \"Error Events\"\n        errorEmitter[\"errorEmitter<br/>(recoverable)\"]\n        exitEmitter[\"exitEmitter<br/>(fatal)\"]\n        validationSubject[\"validationSubject<br/>(validation errors)\"]\n    end\n    \n    style signalEmitter fill:#e1f5ff\n    style performanceEmitter fill:#fff3e0\n    style doneBacktestSubject fill:#e8f5e9\n    style errorEmitter fill:#ffebee\n```\n\n**Event Emitter Catalog**\n\n| Emitter | Type | Payload | Emission Trigger |\n|---------|------|---------|------------------|\n| `signalEmitter` | `Subject<IStrategyTickResult>` | All tick results | Every strategy tick (all modes) |\n| `signalBacktestEmitter` | `Subject<IStrategyTickResult>` | Backtest-only results | Strategy tick in backtest mode |\n| `signalLiveEmitter` | `Subject<IStrategyTickResult>` | Live-only results | Strategy tick in live mode |\n| `progressBacktestEmitter` | `Subject<ProgressBacktestContract>` | Frame progress | Each timeframe processed |\n| `progressWalkerEmitter` | `Subject<ProgressWalkerContract>` | Strategy progress | Walker iteration progress |\n| `progressOptimizerEmitter` | `Subject<ProgressOptimizerContract>` | Optimization progress | Optimizer generation steps |\n| `doneBacktestSubject` | `Subject<DoneContract>` | Completion context | Backtest completes |\n| `doneLiveSubject` | `Subject<DoneContract>` | Completion context | Live trading stops |\n| `doneWalkerSubject` | `Subject<DoneContract>` | Completion context | Walker completes |\n| `performanceEmitter` | `Subject<PerformanceContract>` | Timing metrics | Operation completes |\n| `partialProfitSubject` | `Subject<PartialProfitContract>` | Profit milestone | 10%/20%/30%... profit reached |\n| `partialLossSubject` | `Subject<PartialLossContract>` | Loss milestone | -10%/-20%/-30%... loss reached |\n| `riskSubject` | `Subject<RiskContract>` | Rejection details | Risk validation fails |\n| `walkerEmitter` | `Subject<WalkerContract>` | Strategy result | Strategy backtest completes |\n| `walkerCompleteSubject` | `Subject<WalkerCompleteContract>` | Final results | All strategies tested |\n| `walkerStopSubject` | `Subject<WalkerStopContract>` | Stop event | Walker cancelled |\n| `errorEmitter` | `Subject<Error>` | Error object | Recoverable error occurs |\n| `exitEmitter` | `Subject<Error>` | Error object | Fatal error occurs |\n| `validationSubject` | `Subject<Error>` | Error object | Validation throws |\n\n**Sources:** [src/config/emitters.ts:1-119]()\n\n### Event Listeners\n\nPublic API provides typed listener functions with `queued` wrapper from `functools-kit`. The wrapper ensures sequential async processing even during high-frequency emissions.\n\n```mermaid\ngraph LR\n    subgraph \"Listener Functions\"\n        listenSignal[\"listenSignal(fn)<br/>listenSignalOnce(fn)\"]\n        listenSignalBacktest[\"listenSignalBacktest(fn)<br/>listenSignalBacktestOnce(fn)\"]\n        listenSignalLive[\"listenSignalLive(fn)<br/>listenSignalLiveOnce(fn)\"]\n        listenPerformance[\"listenPerformance(fn)\"]\n        listenPartial[\"listenPartialProfit(fn)<br/>listenPartialLoss(fn)\"]\n        listenRisk[\"listenRisk(fn)<br/>listenRiskOnce(fn)\"]\n        listenDone[\"listenDoneBacktest(fn)<br/>listenDoneLive(fn)<br/>listenDoneWalker(fn)\"]\n        listenProgress[\"listenBacktestProgress(fn)<br/>listenWalkerProgress(fn)<br/>listenOptimizerProgress(fn)\"]\n        listenWalker[\"listenWalker(fn)<br/>listenWalkerComplete(fn)\"]\n        listenError[\"listenError(fn)<br/>listenExit(fn)<br/>listenValidation(fn)\"]\n    end\n    \n    subgraph \"Queued Wrapper\"\n        queuedFn[\"queued(fn)<br/>Sequential execution<br/>Prevents concurrency\"]\n    end\n    \n    subgraph \"Subscription\"\n        emitterSubscribe[\"emitter.subscribe(queuedFn)<br/>Returns unsubscribe function\"]\n    end\n    \n    listenSignal --> queuedFn\n    listenSignalBacktest --> queuedFn\n    listenSignalLive --> queuedFn\n    listenPerformance --> queuedFn\n    listenPartial --> queuedFn\n    listenRisk --> queuedFn\n    listenDone --> queuedFn\n    listenProgress --> queuedFn\n    listenWalker --> queuedFn\n    listenError --> queuedFn\n    \n    queuedFn --> emitterSubscribe\n```\n\n**Listener Pattern Example:**\n\n```typescript\nimport { listenSignal, listenPerformance } from \"backtest-kit\";\n\n// Subscribe to all signal events\nconst unsubSignal = listenSignal(async (result) => {\n  if (result.action === \"closed\") {\n    console.log(`PNL: ${result.pnl.pnlPercentage}%`);\n    await saveToDatabase(result); // Async operations are queued\n  }\n});\n\n// Subscribe to performance metrics\nconst unsubPerf = listenPerformance((event) => {\n  if (event.duration > 1000) {\n    console.warn(`Slow operation: ${event.metricType} took ${event.duration}ms`);\n  }\n});\n\n// Cleanup\nunsubSignal();\nunsubPerf();\n```\n\n**Sources:** [src/function/event.ts:1-641](), [src/config/emitters.ts:1-119]()\n\n---\n\n## Markdown Report Services\n\nEight specialized markdown services subscribe to event emitters and accumulate data in memory. Each service provides `getData()`, `getReport()`, and `dump()` methods following a consistent Controller-View pattern.\n\n### Service Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Event Sources\"\n        signalEmitters[\"Signal Emitters<br/>(signalEmitter, signalBacktestEmitter,<br/>signalLiveEmitter)\"]\n        otherEmitters[\"Specialized Emitters<br/>(performanceEmitter, partialProfitSubject,<br/>riskSubject, walkerEmitter)\"]\n    end\n    \n    subgraph \"Markdown Services\"\n        BacktestMarkdownService[\"BacktestMarkdownService<br/>Closed signals only<br/>Max 250 per symbol:strategy\"]\n        LiveMarkdownService[\"LiveMarkdownService<br/>All tick events<br/>Max 250 per symbol:strategy\"]\n        WalkerMarkdownService[\"WalkerMarkdownService<br/>Strategy comparison results<br/>Unlimited per walker\"]\n        ScheduleMarkdownService[\"ScheduleMarkdownService<br/>Scheduled/opened/cancelled<br/>Max 250 per symbol:strategy\"]\n        HeatMarkdownService[\"HeatMarkdownService<br/>Portfolio-wide aggregation<br/>Max 250 per symbol\"]\n        PerformanceMarkdownService[\"PerformanceMarkdownService<br/>Timing metrics<br/>Max 10000 per symbol:strategy\"]\n        PartialMarkdownService[\"PartialMarkdownService<br/>Profit/loss milestones<br/>Max 250 per symbol:strategy\"]\n        RiskMarkdownService[\"RiskMarkdownService<br/>Rejection events<br/>Max 250 per symbol:strategy\"]\n    end\n    \n    subgraph \"Storage Layer\"\n        ReportStorage[\"ReportStorage<br/>In-memory accumulation<br/>Memoized per key\"]\n    end\n    \n    subgraph \"Statistics Layer\"\n        BacktestStatisticsModel[\"BacktestStatisticsModel\"]\n        LiveStatisticsModel[\"LiveStatisticsModel\"]\n        WalkerStatisticsModel[\"WalkerStatisticsModel\"]\n        ScheduleStatisticsModel[\"ScheduleStatisticsModel\"]\n        HeatmapStatisticsModel[\"HeatmapStatisticsModel\"]\n        PerformanceStatisticsModel[\"PerformanceStatisticsModel\"]\n        PartialStatisticsModel[\"PartialStatisticsModel\"]\n        RiskStatisticsModel[\"RiskStatisticsModel\"]\n    end\n    \n    subgraph \"Public Methods\"\n        getData[\"getData()<br/>Returns statistics model\"]\n        getReport[\"getReport()<br/>Returns markdown string\"]\n        dump[\"dump()<br/>Writes to file system\"]\n    end\n    \n    signalEmitters --> BacktestMarkdownService\n    signalEmitters --> LiveMarkdownService\n    signalEmitters --> ScheduleMarkdownService\n    signalEmitters --> HeatMarkdownService\n    \n    otherEmitters --> PerformanceMarkdownService\n    otherEmitters --> PartialMarkdownService\n    otherEmitters --> RiskMarkdownService\n    otherEmitters --> WalkerMarkdownService\n    \n    BacktestMarkdownService --> ReportStorage\n    LiveMarkdownService --> ReportStorage\n    WalkerMarkdownService --> ReportStorage\n    ScheduleMarkdownService --> ReportStorage\n    HeatMarkdownService --> ReportStorage\n    PerformanceMarkdownService --> ReportStorage\n    PartialMarkdownService --> ReportStorage\n    RiskMarkdownService --> ReportStorage\n    \n    ReportStorage --> BacktestStatisticsModel\n    ReportStorage --> LiveStatisticsModel\n    ReportStorage --> WalkerStatisticsModel\n    ReportStorage --> ScheduleStatisticsModel\n    ReportStorage --> HeatmapStatisticsModel\n    ReportStorage --> PerformanceStatisticsModel\n    ReportStorage --> PartialStatisticsModel\n    ReportStorage --> RiskStatisticsModel\n    \n    BacktestStatisticsModel --> getData\n    LiveStatisticsModel --> getData\n    WalkerStatisticsModel --> getData\n    ScheduleStatisticsModel --> getData\n    HeatmapStatisticsModel --> getData\n    PerformanceStatisticsModel --> getData\n    PartialStatisticsModel --> getData\n    RiskStatisticsModel --> getData\n    \n    getData --> getReport\n    getReport --> dump\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:1-464](), [src/lib/services/markdown/LiveMarkdownService.ts:1-612]()\n\n### Service Responsibilities\n\n#### BacktestMarkdownService\n\n**Purpose:** Accumulates closed signals from backtest execution and generates performance reports.\n\n**Event Source:** `signalBacktestEmitter`\n\n**Storage Key:** `${symbol}:${strategyName}`\n\n**Data Model:** `BacktestStatisticsModel`\n\n**Key Features:**\n- Only processes signals with `action === \"closed\"` or `action === \"cancelled\"`\n- Calculates Sharpe Ratio, win rate, total PNL, certainty ratio\n- Safe math: all metrics return `null` if unsafe (NaN, Infinity)\n- Expected yearly returns based on average trade duration\n- Max 250 signals per symbol-strategy pair\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:72-253]()\n\n#### LiveMarkdownService\n\n**Purpose:** Tracks all tick events (idle, opened, active, closed) during live trading.\n\n**Event Source:** `signalLiveEmitter`\n\n**Storage Key:** `${symbol}:${strategyName}`\n\n**Data Model:** `LiveStatisticsModel`\n\n**Key Features:**\n- Processes all tick actions: `idle`, `opened`, `active`, `closed`\n- Replaces last idle event if no opened/active events follow (deduplication)\n- Replaces last active event with same `signalId` (update pattern)\n- Calculates live trading statistics including real-time PNL tracking\n- Max 250 events per symbol-strategy pair\n\n**Sources:** [src/lib/services/markdown/LiveMarkdownService.ts:78-391]()\n\n#### WalkerMarkdownService\n\n**Purpose:** Aggregates strategy comparison results and ranks strategies by optimization metric.\n\n**Event Source:** `walkerEmitter`\n\n**Storage Key:** `${walkerName}`\n\n**Data Model:** `WalkerStatisticsModel`\n\n**Key Features:**\n- Accumulates results from each strategy backtest\n- Tracks best strategy and best metric value\n- Generates comparison table sorted by metric\n- Generates consolidated PNL table across all strategies\n- No event limit (unlimited strategies)\n\n**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:124-388]()\n\n#### ScheduleMarkdownService\n\n**Purpose:** Monitors scheduled signals and tracks activation vs cancellation rates.\n\n**Event Source:** `signalEmitter`\n\n**Storage Key:** `${symbol}:${strategyName}`\n\n**Data Model:** `ScheduleStatisticsModel`\n\n**Key Features:**\n- Processes `scheduled`, `opened`, `cancelled` actions\n- Only tracks opened signals if `scheduledAt !== pendingAt` (was actually scheduled)\n- Calculates cancellation rate and activation rate\n- Measures average wait time before activation or cancellation\n- Max 250 events per symbol-strategy pair\n\n**Sources:** [src/lib/services/markdown/ScheduleMarkdownService.ts:59-301]()\n\n#### HeatMarkdownService\n\n**Purpose:** Generates portfolio-wide heatmap showing per-symbol performance aggregated across all strategies.\n\n**Event Source:** `signalEmitter`\n\n**Storage Key:** `${strategyName}` (single storage per strategy)\n\n**Data Model:** `HeatmapStatisticsModel`\n\n**Key Features:**\n- Aggregates closed signals by symbol\n- Calculates per-symbol: Total PNL, Sharpe Ratio, Max Drawdown, Profit Factor\n- Calculates portfolio-wide: Total PNL, weighted Sharpe Ratio\n- Advanced metrics: Win/Loss streaks, Expectancy, Average Win/Loss\n- Max 250 signals per symbol (within strategy)\n\n**Sources:** [src/lib/services/markdown/HeatMarkdownService.ts:82-387]()\n\n#### PerformanceMarkdownService\n\n**Purpose:** Profiles execution performance by collecting timing metrics for bottleneck analysis.\n\n**Event Source:** `performanceEmitter`\n\n**Storage Key:** `${symbol}:${strategyName}`\n\n**Data Model:** `PerformanceStatisticsModel`\n\n**Key Features:**\n- Groups events by `metricType` (operation category)\n- Calculates avg/min/max duration per metric\n- Calculates percentiles (P50, P95, P99) for outlier detection\n- Tracks wait times between consecutive events of same type\n- Max 10000 events per symbol-strategy pair (higher limit for profiling)\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:81-283]()\n\n#### PartialMarkdownService\n\n**Purpose:** Tracks partial profit/loss milestones (10%, 20%, 30%...) for unrealized PNL monitoring.\n\n**Event Source:** `partialProfitSubject`, `partialLossSubject`\n\n**Storage Key:** `${symbol}:${strategyName}`\n\n**Data Model:** `PartialStatisticsModel`\n\n**Key Features:**\n- Processes profit and loss milestone events\n- Tracks which levels (10-100%) have been reached per signal\n- Enables real-time unrealized PNL alerts\n- Max 250 events per symbol-strategy pair\n\n**Sources:** [src/lib/services/markdown/PartialMarkdownService.ts:60-236]()\n\n#### RiskMarkdownService\n\n**Purpose:** Records risk validation failures to analyze rejection patterns.\n\n**Event Source:** `riskSubject`\n\n**Storage Key:** `${symbol}:${strategyName}`\n\n**Data Model:** `RiskStatisticsModel`\n\n**Key Features:**\n- Captures all signal rejections due to risk limits\n- Aggregates rejections by symbol and by strategy\n- Includes rejection reason from validation comment\n- Max 250 events per symbol-strategy pair\n\n**Sources:** [src/lib/services/markdown/RiskMarkdownService.ts:52-185]()\n\n---\n\n## Statistics Models\n\nEach markdown service produces a statistics model containing aggregated metrics and raw event data. All numeric fields use safe math: `null` is returned for NaN, Infinity, or unsafe values.\n\n### Common Metrics Across Models\n\n```mermaid\ngraph TB\n    subgraph \"Trading Metrics\"\n        totalSignals[\"totalSignals<br/>(count)\"]\n        winCount[\"winCount<br/>(PNL > 0)\"]\n        lossCount[\"lossCount<br/>(PNL < 0)\"]\n        winRate[\"winRate<br/>percentage, null if unsafe\"]\n        avgPnl[\"avgPnl<br/>percentage, null if unsafe\"]\n        totalPnl[\"totalPnl<br/>cumulative percentage, null if unsafe\"]\n    end\n    \n    subgraph \"Risk Metrics\"\n        stdDev[\"stdDev<br/>volatility, null if unsafe\"]\n        sharpeRatio[\"sharpeRatio<br/>avgPnl / stdDev, null if unsafe\"]\n        annualizedSharpeRatio[\"annualizedSharpeRatio<br/>sharpeRatio * sqrt(365), null if unsafe\"]\n        certaintyRatio[\"certaintyRatio<br/>avgWin / abs(avgLoss), null if unsafe\"]\n    end\n    \n    subgraph \"Projection Metrics\"\n        expectedYearlyReturns[\"expectedYearlyReturns<br/>avgPnl * tradesPerYear, null if unsafe\"]\n    end\n    \n    subgraph \"Raw Data\"\n        signalList[\"signalList / eventList<br/>Array of closed signals or events\"]\n    end\n    \n    totalSignals --> winRate\n    winCount --> winRate\n    lossCount --> winRate\n    \n    totalSignals --> avgPnl\n    totalPnl --> avgPnl\n    \n    avgPnl --> sharpeRatio\n    stdDev --> sharpeRatio\n    \n    sharpeRatio --> annualizedSharpeRatio\n    \n    avgPnl --> expectedYearlyReturns\n```\n\n### BacktestStatisticsModel\n\n```typescript\ninterface BacktestStatisticsModel {\n  signalList: IStrategyTickResultClosed[];      // All closed signals\n  totalSignals: number;                         // Count of closed signals\n  winCount: number;                             // Signals with PNL > 0\n  lossCount: number;                            // Signals with PNL < 0\n  winRate: number | null;                       // (winCount / totalSignals) * 100\n  avgPnl: number | null;                        // Average PNL percentage\n  totalPnl: number | null;                      // Sum of all PNL percentages\n  stdDev: number | null;                        // Standard deviation of returns\n  sharpeRatio: number | null;                   // avgPnl / stdDev\n  annualizedSharpeRatio: number | null;         // sharpeRatio * sqrt(365)\n  certaintyRatio: number | null;                // avgWin / abs(avgLoss)\n  expectedYearlyReturns: number | null;         // avgPnl * (365 / avgDurationDays)\n}\n```\n\n**Calculation Details:**\n\n**Sharpe Ratio:** Risk-adjusted return assuming zero risk-free rate. Formula: `avgPnl / stdDev`. Higher is better.\n\n**Annualized Sharpe Ratio:** Scales Sharpe Ratio to yearly timeframe. Formula: `sharpeRatio * Math.sqrt(365)`. Industry-standard metric.\n\n**Certainty Ratio:** Measures average win size relative to average loss size. Formula: `avgWin / Math.abs(avgLoss)`. Values > 1.0 indicate wins larger than losses.\n\n**Expected Yearly Returns:** Projects annual returns based on average trade duration. Formula: `avgPnl * (365 / avgDurationDays)`. Assumes consistent trading frequency.\n\n**Sources:** [types.d.ts:918-943](), [src/lib/services/markdown/BacktestMarkdownService.ts:100-168]()\n\n### LiveStatisticsModel\n\n```typescript\ninterface LiveStatisticsModel {\n  eventList: TickEvent[];                       // All tick events (idle, opened, active, closed)\n  totalEvents: number;                          // Total event count\n  totalClosed: number;                          // Count of closed signals\n  winCount: number;                             // Closed with PNL > 0\n  lossCount: number;                            // Closed with PNL < 0\n  winRate: number | null;                       // (winCount / totalClosed) * 100\n  avgPnl: number | null;                        // Average PNL of closed signals\n  totalPnl: number | null;                      // Sum of PNL from closed signals\n  stdDev: number | null;                        // Standard deviation\n  sharpeRatio: number | null;                   // avgPnl / stdDev\n  annualizedSharpeRatio: number | null;         // sharpeRatio * sqrt(365)\n  certaintyRatio: number | null;                // avgWin / abs(avgLoss)\n  expectedYearlyReturns: number | null;         // Projected annual returns\n}\n```\n\n**Differences from Backtest:**\n- Includes `totalEvents` (all tick types) vs `totalSignals` (closed only)\n- `eventList` contains all actions: `idle`, `opened`, `active`, `closed`\n- Statistics calculated only from closed events for consistency\n\n**Sources:** [src/model/LiveStatistics.model.ts:1-100](), [src/lib/services/markdown/LiveMarkdownService.ts:223-306]()\n\n### WalkerStatisticsModel\n\n```typescript\ninterface WalkerStatisticsModel {\n  walkerName: WalkerName;                       // Walker identifier\n  symbol: string;                               // Trading pair\n  exchangeName: string;                         // Exchange used\n  frameName: string;                            // Timeframe used\n  metric: WalkerMetric;                         // Optimization metric\n  totalStrategies: number;                      // Number of strategies tested\n  bestStrategy: StrategyName | null;            // Strategy with highest metric\n  bestMetric: number | null;                    // Highest metric value\n  bestStats: BacktestStatisticsModel | null;    // Full stats for best strategy\n  strategyResults: IStrategyResult[];           // Results for all strategies\n}\n```\n\n**IStrategyResult:**\n```typescript\ninterface IStrategyResult {\n  strategyName: StrategyName;                   // Strategy identifier\n  stats: BacktestStatisticsModel;               // Full backtest statistics\n  metricValue: number | null;                   // Value of optimization metric\n}\n```\n\n**Sources:** [src/model/WalkerStatistics.model.ts:1-50](), [src/lib/services/markdown/WalkerMarkdownService.ts:169-192]()\n\n### HeatmapStatisticsModel\n\n```typescript\ninterface HeatmapStatisticsModel {\n  symbols: IHeatmapRow[];                       // Per-symbol statistics\n  totalSymbols: number;                         // Count of symbols\n  portfolioTotalPnl: number | null;             // Sum of all symbol PNL\n  portfolioSharpeRatio: number | null;          // Weighted Sharpe Ratio\n  portfolioTotalTrades: number;                 // Total trades across all symbols\n}\n\ninterface IHeatmapRow {\n  symbol: string;                               // Trading pair\n  totalPnl: number | null;                      // Total PNL for this symbol\n  sharpeRatio: number | null;                   // Sharpe Ratio for this symbol\n  maxDrawdown: number | null;                   // Maximum drawdown\n  totalTrades: number;                          // Trade count\n  winCount: number;                             // Winning trades\n  lossCount: number;                            // Losing trades\n  winRate: number | null;                       // Win percentage\n  avgPnl: number | null;                        // Average PNL\n  stdDev: number | null;                        // Standard deviation\n  profitFactor: number | null;                  // sumWins / sumLosses\n  avgWin: number | null;                        // Average winning trade\n  avgLoss: number | null;                       // Average losing trade\n  maxWinStreak: number;                         // Longest winning streak\n  maxLossStreak: number;                        // Longest losing streak\n  expectancy: number | null;                    // Expected value per trade\n}\n```\n\n**Advanced Metrics:**\n\n**Max Drawdown:** Largest peak-to-trough decline. Calculated by tracking cumulative PNL and measuring largest drop from peak.\n\n**Profit Factor:** Ratio of gross profit to gross loss. Formula: `sumWins / sumLosses`. Values > 1.0 indicate profitability.\n\n**Expectancy:** Expected value per trade. Formula: `(winRate * avgWin) + (lossRate * avgLoss)`. Positive values indicate edge.\n\n**Sources:** [src/model/HeatmapStatistics.model.ts:1-40](), [src/lib/services/markdown/HeatMarkdownService.ts:115-271]()\n\n### PerformanceStatisticsModel\n\n```typescript\ninterface PerformanceStatisticsModel {\n  strategyName: string;                         // Strategy identifier\n  totalEvents: number;                          // Total performance events\n  totalDuration: number;                        // Sum of all durations (ms)\n  metricStats: Record<string, MetricStats>;     // Stats grouped by metricType\n  events: PerformanceContract[];                // Raw performance events\n}\n\ninterface MetricStats {\n  metricType: PerformanceMetricType;            // Operation category\n  count: number;                                // Event count\n  totalDuration: number;                        // Sum of durations (ms)\n  avgDuration: number;                          // Average duration (ms)\n  minDuration: number;                          // Fastest execution (ms)\n  maxDuration: number;                          // Slowest execution (ms)\n  stdDev: number;                               // Duration volatility\n  median: number;                               // 50th percentile (ms)\n  p95: number;                                  // 95th percentile (ms)\n  p99: number;                                  // 99th percentile (ms)\n  avgWaitTime: number;                          // Time between events (ms)\n  minWaitTime: number;                          // Shortest gap (ms)\n  maxWaitTime: number;                          // Longest gap (ms)\n}\n```\n\n**Percentile Metrics:**\n- **Median (P50):** Half of operations complete faster, half slower\n- **P95:** 95% of operations complete within this time\n- **P99:** 99% of operations complete within this time\n\nUsed for identifying outliers and tail latency problems.\n\n**Sources:** [src/model/PerformanceStatistics.model.ts:1-40](), [src/lib/services/markdown/PerformanceMarkdownService.ts:104-185]()\n\n---\n\n## Public API for Reports\n\nThe framework provides two access patterns: instance methods on execution classes (Backtest, Live, Walker) and static utility classes (Performance, Heat, Schedule, Partial, Risk).\n\n### Execution Class Methods\n\n```mermaid\ngraph LR\n    subgraph \"Backtest Class\"\n        Backtest.getData[\"Backtest.getData(symbol, strategyName)\"]\n        Backtest.getReport[\"Backtest.getReport(symbol, strategyName, columns?)\"]\n        Backtest.dump[\"Backtest.dump(symbol, strategyName, path?, columns?)\"]\n    end\n    \n    subgraph \"Live Class\"\n        Live.getData[\"Live.getData(symbol, strategyName)\"]\n        Live.getReport[\"Live.getReport(symbol, strategyName, columns?)\"]\n        Live.dump[\"Live.dump(symbol, strategyName, path?, columns?)\"]\n    end\n    \n    subgraph \"Walker Class\"\n        Walker.getData[\"Walker.getData(walkerName, symbol, metric, context)\"]\n        Walker.getReport[\"Walker.getReport(walkerName, symbol, metric, context, strategyColumns?, pnlColumns?)\"]\n        Walker.dump[\"Walker.dump(walkerName, symbol, metric, context, path?, strategyColumns?, pnlColumns?)\"]\n    end\n    \n    subgraph \"BacktestMarkdownService\"\n        BMS.getData[\"backtestMarkdownService.getData(symbol, strategyName)\"]\n        BMS.getReport[\"backtestMarkdownService.getReport(symbol, strategyName, columns)\"]\n        BMS.dump[\"backtestMarkdownService.dump(symbol, strategyName, path, columns)\"]\n    end\n    \n    subgraph \"LiveMarkdownService\"\n        LMS.getData[\"liveMarkdownService.getData(symbol, strategyName)\"]\n        LMS.getReport[\"liveMarkdownService.getReport(symbol, strategyName, columns)\"]\n        LMS.dump[\"liveMarkdownService.dump(symbol, strategyName, path, columns)\"]\n    end\n    \n    subgraph \"WalkerMarkdownService\"\n        WMS.getData[\"walkerMarkdownService.getData(walkerName, symbol, metric, context)\"]\n        WMS.getReport[\"walkerMarkdownService.getReport(walkerName, symbol, metric, context, strategyColumns, pnlColumns)\"]\n        WMS.dump[\"walkerMarkdownService.dump(walkerName, symbol, metric, context, path, strategyColumns, pnlColumns)\"]\n    end\n    \n    Backtest.getData --> BMS.getData\n    Backtest.getReport --> BMS.getReport\n    Backtest.dump --> BMS.dump\n    \n    Live.getData --> LMS.getData\n    Live.getReport --> LMS.getReport\n    Live.dump --> LMS.dump\n    \n    Walker.getData --> WMS.getData\n    Walker.getReport --> WMS.getReport\n    Walker.dump --> WMS.dump\n```\n\n**Example Usage:**\n\n```typescript\nimport { Backtest } from \"backtest-kit\";\n\n// Run backtest (execution generates events)\nfor await (const result of Backtest.run(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\",\n  frameName: \"1d-backtest\"\n})) {\n  // Events are accumulated by BacktestMarkdownService\n}\n\n// Access statistics programmatically\nconst stats = await Backtest.getData(\"BTCUSDT\", \"my-strategy\");\nconsole.log(`Sharpe Ratio: ${stats.sharpeRatio}`);\nconsole.log(`Win Rate: ${stats.winRate}%`);\n\n// Generate markdown report\nconst markdown = await Backtest.getReport(\"BTCUSDT\", \"my-strategy\");\nconsole.log(markdown);\n\n// Save to file system\nawait Backtest.dump(\"BTCUSDT\", \"my-strategy\"); // ./dump/backtest/my-strategy.md\nawait Backtest.dump(\"BTCUSDT\", \"my-strategy\", \"./custom/path\"); // Custom directory\n```\n\n**Sources:** [src/classes/Backtest.ts:276-337](), [src/classes/Live.ts:283-344](), [src/classes/Walker.ts:201-298]()\n\n### Utility Classes\n\n```mermaid\ngraph TB\n    subgraph \"Performance Utility\"\n        Performance.getData[\"Performance.getData(symbol, strategyName)\"]\n        Performance.getReport[\"Performance.getReport(symbol, strategyName, columns?)\"]\n        Performance.dump[\"Performance.dump(symbol, strategyName, path?, columns?)\"]\n    end\n    \n    subgraph \"Heat Utility\"\n        Heat.getData[\"Heat.getData(strategyName)\"]\n        Heat.getReport[\"Heat.getReport(strategyName, columns?)\"]\n        Heat.dump[\"Heat.dump(strategyName, path?, columns?)\"]\n    end\n    \n    subgraph \"Schedule Utility\"\n        Schedule.getData[\"Schedule.getData(symbol, strategyName)\"]\n        Schedule.getReport[\"Schedule.getReport(symbol, strategyName, columns?)\"]\n        Schedule.dump[\"Schedule.dump(symbol, strategyName, path?, columns?)\"]\n    end\n    \n    subgraph \"Partial Utility\"\n        Partial.getData[\"Partial.getData(symbol, strategyName)\"]\n        Partial.getReport[\"Partial.getReport(symbol, strategyName, columns?)\"]\n        Partial.dump[\"Partial.dump(symbol, strategyName, path?, columns?)\"]\n    end\n    \n    subgraph \"Risk Utility\"\n        Risk.getData[\"Risk.getData(symbol, strategyName)\"]\n        Risk.getReport[\"Risk.getReport(symbol, strategyName, columns?)\"]\n        Risk.dump[\"Risk.dump(symbol, strategyName, path?, columns?)\"]\n    end\n    \n    subgraph \"Markdown Services\"\n        PerformanceMarkdownService[\"performanceMarkdownService\"]\n        HeatMarkdownService[\"heatMarkdownService\"]\n        ScheduleMarkdownService[\"scheduleMarkdownService\"]\n        PartialMarkdownService[\"partialMarkdownService\"]\n        RiskMarkdownService[\"riskMarkdownService\"]\n    end\n    \n    Performance.getData --> PerformanceMarkdownService\n    Performance.getReport --> PerformanceMarkdownService\n    Performance.dump --> PerformanceMarkdownService\n    \n    Heat.getData --> HeatMarkdownService\n    Heat.getReport --> HeatMarkdownService\n    Heat.dump --> HeatMarkdownService\n    \n    Schedule.getData --> ScheduleMarkdownService\n    Schedule.getReport --> ScheduleMarkdownService\n    Schedule.dump --> ScheduleMarkdownService\n    \n    Partial.getData --> PartialMarkdownService\n    Partial.getReport --> PartialMarkdownService\n    Partial.dump --> PartialMarkdownService\n    \n    Risk.getData --> RiskMarkdownService\n    Risk.getReport --> RiskMarkdownService\n    Risk.dump --> RiskMarkdownService\n```\n\n**Example Usage:**\n\n```typescript\nimport { Performance, Heat, Schedule } from \"backtest-kit\";\n\n// Performance profiling\nconst perfStats = await Performance.getData(\"BTCUSDT\", \"my-strategy\");\nconsole.log(`Total execution time: ${perfStats.totalDuration}ms`);\nfor (const [metricType, metric] of Object.entries(perfStats.metricStats)) {\n  if (metric.p99 > 1000) {\n    console.warn(`Slow operation: ${metricType} P99=${metric.p99}ms`);\n  }\n}\n\n// Portfolio heatmap (aggregated across all symbols)\nconst heatStats = await Heat.getData(\"my-strategy\");\nconsole.log(`Portfolio PNL: ${heatStats.portfolioTotalPnl}%`);\nheatStats.symbols.forEach(row => {\n  console.log(`${row.symbol}: Sharpe=${row.sharpeRatio}, Trades=${row.totalTrades}`);\n});\n\n// Scheduled signals report\nconst schedStats = await Schedule.getData(\"BTCUSDT\", \"my-strategy\");\nconsole.log(`Activation rate: ${schedStats.activationRate}%`);\nconsole.log(`Average wait time: ${schedStats.avgActivationTime} minutes`);\n\n// Dump all reports\nawait Performance.dump(\"BTCUSDT\", \"my-strategy\", \"./reports/performance\");\nawait Heat.dump(\"my-strategy\", \"./reports/heatmap\");\nawait Schedule.dump(\"BTCUSDT\", \"my-strategy\", \"./reports/schedule\");\n```\n\n**Sources:** [src/classes/Performance.ts:70-128](), [src/classes/Heat.ts:57-115](), [src/classes/Schedule.ts:48-106](), [src/classes/Partial.ts:57-115](), [src/classes/Risk.ts:85-143]()\n\n---\n\n## Column Configuration\n\nMarkdown reports use the `ColumnModel<T>` interface for customizable table formatting. Each markdown service has default columns defined in `COLUMN_CONFIG`, which can be overridden via method parameters.\n\n### ColumnModel Interface\n\n```typescript\ninterface ColumnModel<T extends object = any> {\n  key: string;                                  // Unique column identifier\n  label: string;                                // Display header text\n  format: (data: T, index: number) => string | Promise<string>;\n  isVisible: () => boolean | Promise<boolean>;  // Dynamic visibility control\n}\n```\n\n**Sources:** [src/model/Column.model.ts:26-38]()\n\n### Column Configuration System\n\n```mermaid\ngraph TB\n    subgraph \"Column Definitions\"\n        COLUMN_CONFIG[\"COLUMN_CONFIG<br/>src/config/columns.ts\"]\n        backtest_columns[\"backtest_columns: ColumnModel<IStrategyTickResultClosed>[]\"]\n        live_columns[\"live_columns: ColumnModel<TickEvent>[]\"]\n        walker_strategy_columns[\"walker_strategy_columns: ColumnModel<IStrategyResult>[]\"]\n        walker_pnl_columns[\"walker_pnl_columns: ColumnModel<SignalData>[]\"]\n        schedule_columns[\"schedule_columns: ColumnModel<ScheduledEvent>[]\"]\n        heat_columns[\"heat_columns: ColumnModel<IHeatmapRow>[]\"]\n        performance_columns[\"performance_columns: ColumnModel<MetricStats>[]\"]\n        partial_columns[\"partial_columns: ColumnModel<PartialEvent>[]\"]\n        risk_columns[\"risk_columns: ColumnModel<RiskEvent>[]\"]\n    end\n    \n    subgraph \"Usage in Services\"\n        getReport[\"service.getReport(..., columns?)\"]\n        dump[\"service.dump(..., columns?)\"]\n    end\n    \n    subgraph \"Report Generation\"\n        filterVisible[\"Filter: col.isVisible()\"]\n        buildHeader[\"Build header from col.label\"]\n        formatRows[\"Format rows with col.format(data, index)\"]\n        generateTable[\"Generate markdown table\"]\n    end\n    \n    COLUMN_CONFIG --> backtest_columns\n    COLUMN_CONFIG --> live_columns\n    COLUMN_CONFIG --> walker_strategy_columns\n    COLUMN_CONFIG --> walker_pnl_columns\n    COLUMN_CONFIG --> schedule_columns\n    COLUMN_CONFIG --> heat_columns\n    COLUMN_CONFIG --> performance_columns\n    COLUMN_CONFIG --> partial_columns\n    COLUMN_CONFIG --> risk_columns\n    \n    backtest_columns --> getReport\n    live_columns --> getReport\n    walker_strategy_columns --> getReport\n    heat_columns --> getReport\n    \n    getReport --> filterVisible\n    dump --> filterVisible\n    \n    filterVisible --> buildHeader\n    buildHeader --> formatRows\n    formatRows --> generateTable\n```\n\n### Custom Column Example\n\n```typescript\nimport { Backtest } from \"backtest-kit\";\nimport { ColumnModel } from \"backtest-kit\";\nimport { IStrategyTickResultClosed } from \"backtest-kit\";\n\n// Define custom columns for backtest report\nconst customColumns: ColumnModel<IStrategyTickResultClosed>[] = [\n  {\n    key: \"timestamp\",\n    label: \"Close Time\",\n    format: (signal) => new Date(signal.closeTimestamp).toISOString(),\n    isVisible: () => true\n  },\n  {\n    key: \"pnl\",\n    label: \"PNL %\",\n    format: (signal) => {\n      const pnl = signal.pnl.pnlPercentage;\n      const sign = pnl > 0 ? \"+\" : \"\";\n      return `${sign}${pnl.toFixed(2)}%`;\n    },\n    isVisible: () => true\n  },\n  {\n    key: \"reason\",\n    label: \"Close Reason\",\n    format: (signal) => signal.closeReason,\n    isVisible: () => true\n  },\n  {\n    key: \"duration\",\n    label: \"Duration (min)\",\n    format: (signal) => {\n      const durationMs = signal.closeTimestamp - signal.signal.pendingAt;\n      return Math.round(durationMs / 60000).toString();\n    },\n    isVisible: () => true\n  },\n  {\n    key: \"note\",\n    label: \"Signal Note\",\n    format: (signal) => signal.signal.note || \"N/A\",\n    isVisible: async () => {\n      // Dynamic visibility: show only if any signal has a note\n      return true; // Could check database, environment variable, etc.\n    }\n  }\n];\n\n// Generate report with custom columns\nconst markdown = await Backtest.getReport(\"BTCUSDT\", \"my-strategy\", customColumns);\n\n// Save report with custom columns\nawait Backtest.dump(\"BTCUSDT\", \"my-strategy\", \"./reports\", customColumns);\n```\n\n### Global Column Configuration\n\nDefault columns can be customized globally via `setColumns()`:\n\n```typescript\nimport { setColumns, getColumns, getDefaultColumns } from \"backtest-kit\";\nimport { ColumnConfig } from \"backtest-kit\";\n\n// Get current configuration\nconst currentConfig = getColumns();\n\n// Get framework defaults\nconst defaultConfig = getDefaultColumns();\n\n// Set custom configuration\nconst customConfig: Partial<ColumnConfig> = {\n  backtest_columns: [\n    // Custom backtest columns\n  ],\n  live_columns: [\n    // Custom live columns\n  ]\n};\n\nsetColumns(customConfig);\n\n// Reset to defaults\nsetColumns(getDefaultColumns());\n```\n\n**Sources:** [src/index.ts:5-8](), [src/config/columns.ts:1-500]() (inferred)\n\n---\n\n## Report Storage and Persistence\n\n### In-Memory Storage\n\nEach markdown service uses a memoized `ReportStorage` instance per unique key. Storage is bounded by `MAX_EVENTS` constant (typically 250, except `PerformanceMarkdownService` which uses 10000).\n\n```mermaid\ngraph TB\n    subgraph \"Service Layer\"\n        BacktestMarkdownService[\"BacktestMarkdownService\"]\n        LiveMarkdownService[\"LiveMarkdownService\"]\n        PerformanceMarkdownService[\"PerformanceMarkdownService\"]\n    end\n    \n    subgraph \"Memoization\"\n        getStorage[\"getStorage = memoize(<br/>  (symbol, strategyName) => key,<br/>  () => new ReportStorage()<br/>)\"]\n    end\n    \n    subgraph \"Storage Instances\"\n        Storage1[\"ReportStorage<br/>BTCUSDT:strategy-a<br/>Max 250 events\"]\n        Storage2[\"ReportStorage<br/>ETHUSDT:strategy-a<br/>Max 250 events\"]\n        Storage3[\"ReportStorage<br/>BTCUSDT:strategy-b<br/>Max 250 events\"]\n    end\n    \n    subgraph \"Queue Behavior\"\n        addEvent[\"addEvent(data)<br/>Unshift to front\"]\n        trimQueue[\"if length > MAX_EVENTS:<br/>  pop from back\"]\n    end\n    \n    BacktestMarkdownService --> getStorage\n    LiveMarkdownService --> getStorage\n    PerformanceMarkdownService --> getStorage\n    \n    getStorage --> Storage1\n    getStorage --> Storage2\n    getStorage --> Storage3\n    \n    Storage1 --> addEvent\n    addEvent --> trimQueue\n```\n\n**Storage Key Patterns:**\n\n| Service | Key Pattern | Max Events |\n|---------|-------------|------------|\n| BacktestMarkdownService | `${symbol}:${strategyName}` | 250 |\n| LiveMarkdownService | `${symbol}:${strategyName}` | 250 |\n| WalkerMarkdownService | `${walkerName}` | Unlimited |\n| ScheduleMarkdownService | `${symbol}:${strategyName}` | 250 |\n| HeatMarkdownService | `${strategyName}` (single storage) | 250 per symbol |\n| PerformanceMarkdownService | `${symbol}:${strategyName}` | 10000 |\n| PartialMarkdownService | `${symbol}:${strategyName}` | 250 |\n| RiskMarkdownService | `${symbol}:${strategyName}` | 250 |\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:290-293](), [src/lib/services/markdown/LiveMarkdownService.ts:431-434](), [src/lib/services/markdown/PerformanceMarkdownService.ts:75]()\n\n### File System Persistence\n\nThe `dump()` method on each service writes markdown reports to organized directories:\n\n**Default Paths:**\n\n| Report Type | Default Path | Filename Pattern |\n|-------------|--------------|------------------|\n| Backtest | `./dump/backtest/` | `${strategyName}.md` |\n| Live | `./dump/live/` | `${strategyName}.md` |\n| Walker | `./dump/walker/` | `${walkerName}.md` |\n| Schedule | `./dump/schedule/` | `${strategyName}.md` |\n| Heat | `./dump/heat/` | `${strategyName}.md` |\n| Performance | `./dump/performance/` | `${strategyName}.md` |\n| Partial | `./dump/partial/` | `${symbol}_${strategyName}.md` |\n| Risk | `./dump/risk/` | `${symbol}_${strategyName}.md` |\n\n**Dump Implementation Pattern:**\n\n```typescript\npublic async dump(\n  symbol: string,\n  strategyName: StrategyName,\n  path = \"./dump/backtest\",\n  columns: Columns[] = COLUMN_CONFIG.backtest_columns\n): Promise<void> {\n  const markdown = await this.getReport(strategyName, columns);\n  \n  try {\n    const dir = join(process.cwd(), path);\n    await mkdir(dir, { recursive: true });  // Create directory if not exists\n    \n    const filename = `${strategyName}.md`;\n    const filepath = join(dir, filename);\n    \n    await writeFile(filepath, markdown, \"utf-8\");\n    console.log(`Backtest report saved: ${filepath}`);\n  } catch (error) {\n    console.error(`Failed to save markdown report:`, error);\n  }\n}\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:233-252](), [src/lib/services/markdown/LiveMarkdownService.ts:549-562]()\n\n### Clearing Accumulated Data\n\nServices provide `clear()` methods to remove accumulated data from memory:\n\n```typescript\n// Clear specific symbol-strategy pair\nawait backtest.backtestMarkdownService.clear({\n  symbol: \"BTCUSDT\",\n  strategyName: \"my-strategy\"\n});\n\n// Clear all data for a service\nawait backtest.backtestMarkdownService.clear();\n\n// Clear walker data\nawait backtest.walkerMarkdownService.clear(\"my-walker\");\n\n// Clear all walkers\nawait backtest.walkerMarkdownService.clear();\n```\n\nClearing is automatically invoked at the start of `Backtest.run()`, `Live.run()`, and `Walker.run()` to ensure fresh data accumulation.\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:434-444](), [src/classes/Backtest.ts:163-164]()\n\n---\n\n## Report Format Examples\n\n### Backtest Report Structure\n\n```markdown\n# Backtest Report: my-strategy\n\n| # | Signal ID | Symbol | Position | Open | TP | SL | Close | PNL % | Reason | Duration |\n|---|-----------|--------|----------|------|----|----|-------|-------|--------|----------|\n| 1 | abc-123   | BTCUSDT | LONG    | 50000 | 51000 | 49500 | 51000 | +1.80% | take_profit | 45 min |\n| 2 | abc-124   | BTCUSDT | SHORT   | 51000 | 50500 | 51500 | 50500 | +0.78% | take_profit | 30 min |\n\n**Total signals:** 2\n**Closed signals:** 2\n**Win rate:** 100.00% (2W / 0L) (higher is better)\n**Average PNL:** +1.29% (higher is better)\n**Total PNL:** +2.58% (higher is better)\n**Standard Deviation:** 0.510% (lower is better)\n**Sharpe Ratio:** 2.529 (higher is better)\n**Annualized Sharpe Ratio:** 48.320 (higher is better)\n**Certainty Ratio:** N/A (higher is better)\n**Expected Yearly Returns:** +12501.60% (higher is better)\n```\n\n### Live Report Structure\n\n```markdown\n# Live Trading Report: my-strategy\n\n| Timestamp | Action | Signal ID | Position | Price | TP | SL | PNL % | TP Progress | SL Risk |\n|-----------|--------|-----------|----------|-------|----|----|-------|-------------|---------|\n| 2024-01-15T10:30:00Z | opened | xyz-789 | LONG | 50000 | 51000 | 49500 | - | - | - |\n| 2024-01-15T10:45:00Z | active | xyz-789 | LONG | 50500 | 51000 | 49500 | - | 50% | 0% |\n| 2024-01-15T11:00:00Z | active | xyz-789 | LONG | 50800 | 51000 | 49500 | - | 80% | 0% |\n| 2024-01-15T11:15:00Z | closed | xyz-789 | LONG | 51000 | 51000 | 49500 | +1.80% | 100% | 0% |\n| 2024-01-15T11:30:00Z | idle | - | - | 51000 | - | - | - | - | - |\n\n**Total events:** 5\n**Closed signals:** 1\n**Win rate:** 100.00% (1W / 0L) (higher is better)\n**Average PNL:** +1.80% (higher is better)\n**Total PNL:** +1.80% (higher is better)\n...\n```\n\n### Walker Report Structure\n\n```markdown\n# Walker Comparison Report: my-walker\n\n**Symbol:** BTCUSDT\n**Exchange:** binance\n**Frame:** 1d-backtest\n**Optimization Metric:** sharpeRatio\n**Strategies Tested:** 5\n\n## Best Strategy: strategy-a\n\n**Best sharpeRatio:** 2.53\n**Total Signals:** 100\n\n## Top Strategies Comparison\n\n| Rank | Strategy | Sharpe Ratio | Win Rate | Total PNL | Trades |\n|------|----------|--------------|----------|-----------|--------|\n| 1 | strategy-a | 2.53 | 65.0% | +125.5% | 100 |\n| 2 | strategy-b | 2.01 | 60.0% | +98.2% | 120 |\n| 3 | strategy-c | 1.85 | 58.5% | +87.3% | 95 |\n\n## All Signals (PNL Table)\n\n| Strategy | Signal ID | Symbol | Position | PNL % | Reason | Open Time | Close Time |\n|----------|-----------|--------|----------|-------|--------|-----------|------------|\n| strategy-a | abc-123 | BTCUSDT | LONG | +1.80% | take_profit | ... | ... |\n...\n```\n\n### Performance Report Structure\n\n```markdown\n# Performance Report: my-strategy\n\n**Total events:** 1000\n**Total execution time:** 5432.12ms\n**Number of metric types:** 5\n\n## Time Distribution\n\n- **getCandles**: 45.2% (2455.32ms total)\n- **tick**: 30.1% (1635.05ms total)\n- **getSignal**: 15.6% (847.41ms total)\n- **checkRisk**: 5.8% (315.12ms total)\n- **getAveragePrice**: 3.3% (179.22ms total)\n\n## Detailed Metrics\n\n| Metric Type | Count | Avg (ms) | Min (ms) | Max (ms) | P95 (ms) | P99 (ms) | Std Dev |\n|-------------|-------|----------|----------|----------|----------|----------|---------|\n| getCandles | 100 | 24.55 | 10.23 | 150.45 | 45.32 | 98.12 | 18.45 |\n| tick | 1000 | 1.64 | 0.12 | 25.34 | 3.21 | 8.45 | 2.12 |\n...\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:177-224](), [src/lib/services/markdown/LiveMarkdownService.ts:315-362](), [src/lib/services/markdown/WalkerMarkdownService.ts:311-350](), [src/lib/services/markdown/PerformanceMarkdownService.ts:194-254]()"
                    },
                    {
                        "page_plan": {
                            "id": "9.1",
                            "title": "Event Listeners"
                        },
                        "content": "# Event Listeners\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [assets/uml.svg](assets/uml.svg)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document provides a complete reference for the event listener system in Backtest Kit. Event listeners enable real-time monitoring of strategy execution, signal lifecycle events, risk violations, and performance metrics. This page covers all available listener functions, event emitters, event contracts, and usage patterns.\n\nFor information about generating markdown reports from accumulated events, see [Markdown Reports](#9.2). For statistics calculation models, see [Statistics Models](#9.3).\n\n---\n\n## Event System Architecture\n\nThe framework implements a comprehensive event-driven architecture using the Subject pattern from `functools-kit`. Events flow from producers (strategy execution, risk validation, etc.) through emitters to consumers (listener functions). All listener callbacks are wrapped with `queued` to ensure sequential async execution, preventing race conditions.\n\n**Architecture Diagram**\n\n```mermaid\ngraph TB\n    subgraph \"Event Producers\"\n        ClientStrategy[\"ClientStrategy<br/>(tick/backtest methods)\"]\n        ClientRisk[\"ClientRisk<br/>(checkSignal)\"]\n        ClientPartial[\"ClientPartial<br/>(profit/loss)\"]\n        BacktestLogic[\"BacktestLogicPrivateService\"]\n        LiveLogic[\"LiveLogicPrivateService\"]\n        WalkerLogic[\"WalkerLogicPrivateService\"]\n    end\n    \n    subgraph \"Event Emitters (Subject instances)\"\n        signalEmitter[\"signalEmitter<br/>(all signals)\"]\n        signalLiveEmitter[\"signalLiveEmitter<br/>(live only)\"]\n        signalBacktestEmitter[\"signalBacktestEmitter<br/>(backtest only)\"]\n        errorEmitter[\"errorEmitter<br/>(recoverable errors)\"]\n        exitEmitter[\"exitEmitter<br/>(fatal errors)\"]\n        doneBacktestSubject[\"doneBacktestSubject\"]\n        doneLiveSubject[\"doneLiveSubject\"]\n        doneWalkerSubject[\"doneWalkerSubject\"]\n        progressBacktestEmitter[\"progressBacktestEmitter\"]\n        progressWalkerEmitter[\"progressWalkerEmitter\"]\n        performanceEmitter[\"performanceEmitter\"]\n        walkerEmitter[\"walkerEmitter\"]\n        walkerCompleteSubject[\"walkerCompleteSubject\"]\n        riskSubject[\"riskSubject\"]\n        partialProfitSubject[\"partialProfitSubject\"]\n        partialLossSubject[\"partialLossSubject\"]\n    end\n    \n    subgraph \"Listener Functions (Public API)\"\n        listenSignal[\"listenSignal()\"]\n        listenSignalOnce[\"listenSignalOnce()\"]\n        listenSignalLive[\"listenSignalLive()\"]\n        listenSignalBacktest[\"listenSignalBacktest()\"]\n        listenError[\"listenError()\"]\n        listenExit[\"listenExit()\"]\n        listenDoneBacktest[\"listenDoneBacktest()\"]\n        listenDoneLive[\"listenDoneLive()\"]\n        listenDoneWalker[\"listenDoneWalker()\"]\n        listenBacktestProgress[\"listenBacktestProgress()\"]\n        listenPerformance[\"listenPerformance()\"]\n        listenWalker[\"listenWalker()\"]\n        listenRisk[\"listenRisk()\"]\n        listenPartialProfit[\"listenPartialProfit()\"]\n        listenPartialLoss[\"listenPartialLoss()\"]\n    end\n    \n    subgraph \"Queued Processing\"\n        queued[\"functools-kit queued()<br/>Sequential async execution\"]\n    end\n    \n    ClientStrategy --> signalEmitter\n    ClientStrategy --> signalLiveEmitter\n    ClientStrategy --> signalBacktestEmitter\n    \n    ClientRisk --> riskSubject\n    ClientPartial --> partialProfitSubject\n    ClientPartial --> partialLossSubject\n    \n    BacktestLogic --> progressBacktestEmitter\n    BacktestLogic --> doneBacktestSubject\n    BacktestLogic --> performanceEmitter\n    \n    LiveLogic --> doneLiveSubject\n    LiveLogic --> performanceEmitter\n    \n    WalkerLogic --> progressWalkerEmitter\n    WalkerLogic --> walkerEmitter\n    WalkerLogic --> walkerCompleteSubject\n    WalkerLogic --> doneWalkerSubject\n    \n    BacktestLogic --> errorEmitter\n    LiveLogic --> errorEmitter\n    WalkerLogic --> exitEmitter\n    \n    signalEmitter --> listenSignal\n    signalEmitter --> listenSignalOnce\n    signalLiveEmitter --> listenSignalLive\n    signalBacktestEmitter --> listenSignalBacktest\n    errorEmitter --> listenError\n    exitEmitter --> listenExit\n    doneBacktestSubject --> listenDoneBacktest\n    doneLiveSubject --> listenDoneLive\n    doneWalkerSubject --> listenDoneWalker\n    progressBacktestEmitter --> listenBacktestProgress\n    performanceEmitter --> listenPerformance\n    walkerEmitter --> listenWalker\n    riskSubject --> listenRisk\n    partialProfitSubject --> listenPartialProfit\n    partialLossSubject --> listenPartialLoss\n    \n    listenSignal --> queued\n    listenSignalLive --> queued\n    listenSignalBacktest --> queued\n    listenError --> queued\n    listenDoneBacktest --> queued\n    listenDoneLive --> queued\n    listenBacktestProgress --> queued\n    listenPerformance --> queued\n    listenWalker --> queued\n    listenRisk --> queued\n    listenPartialProfit --> queued\n    listenPartialLoss --> queued\n```\n\n**Sources:** [src/config/emitters.ts:1-133](), [src/function/event.ts:1-400](), [types.d.ts:1-50]()\n\n---\n\n## Event Emitters Reference\n\nAll emitters are instances of `Subject` from `functools-kit` and are exported from `src/config/emitters.ts`. Markdown services subscribe to these emitters to accumulate data for report generation.\n\n| Emitter | Type | Purpose | Emitted By |\n|---------|------|---------|------------|\n| `signalEmitter` | `Subject<IStrategyTickResult>` | All signal events (live + backtest) | ClientStrategy |\n| `signalLiveEmitter` | `Subject<IStrategyTickResult>` | Live trading signals only | ClientStrategy |\n| `signalBacktestEmitter` | `Subject<IStrategyTickResult>` | Backtest signals only | ClientStrategy |\n| `errorEmitter` | `Subject<Error>` | Recoverable errors from background tasks | BacktestLogicPrivateService, LiveLogicPrivateService |\n| `exitEmitter` | `Subject<Error>` | Fatal errors requiring termination | WalkerLogicPrivateService |\n| `doneLiveSubject` | `Subject<DoneContract>` | Live execution completion | LiveLogicPrivateService |\n| `doneBacktestSubject` | `Subject<DoneContract>` | Backtest execution completion | BacktestLogicPrivateService |\n| `doneWalkerSubject` | `Subject<DoneContract>` | Walker execution completion | WalkerLogicPrivateService |\n| `progressBacktestEmitter` | `Subject<ProgressBacktestContract>` | Backtest progress percentage | BacktestLogicPrivateService |\n| `progressWalkerEmitter` | `Subject<ProgressWalkerContract>` | Walker strategy iteration progress | WalkerLogicPrivateService |\n| `progressOptimizerEmitter` | `Subject<ProgressOptimizerContract>` | Optimizer execution progress | OptimizerLogicPrivateService |\n| `performanceEmitter` | `Subject<PerformanceContract>` | Execution timing metrics | BacktestLogicPrivateService, LiveLogicPrivateService |\n| `walkerEmitter` | `Subject<WalkerContract>` | Per-strategy walker results | WalkerLogicPrivateService |\n| `walkerCompleteSubject` | `Subject<WalkerCompleteContract>` | Final walker comparison results | WalkerLogicPrivateService |\n| `validationSubject` | `Subject<Error>` | Risk validation errors | ClientRisk |\n| `partialProfitSubject` | `Subject<PartialProfitContract>` | Profit milestone events (10%, 20%, etc) | ClientPartial |\n| `partialLossSubject` | `Subject<PartialLossContract>` | Loss milestone events (10%, 20%, etc) | ClientPartial |\n| `riskSubject` | `Subject<RiskContract>` | Signal rejection due to risk limits | ClientRisk |\n\n**Sources:** [src/config/emitters.ts:15-132](), [types.d.ts:1-50]()\n\n---\n\n## Listener Functions Reference\n\nAll listener functions are exported from `src/function/event.ts` and accept callbacks wrapped with `queued` for sequential async processing.\n\n**Signal Listeners**\n\n```mermaid\ngraph LR\n    subgraph \"Global Signal Listeners\"\n        listenSignal[\"listenSignal(fn)<br/>Returns: unsubscribe()\"]\n        listenSignalOnce[\"listenSignalOnce(filterFn, fn)<br/>Returns: cancel()\"]\n    end\n    \n    subgraph \"Mode-Specific Signal Listeners\"\n        listenSignalLive[\"listenSignalLive(fn)\"]\n        listenSignalLiveOnce[\"listenSignalLiveOnce(filterFn, fn)\"]\n        listenSignalBacktest[\"listenSignalBacktest(fn)\"]\n        listenSignalBacktestOnce[\"listenSignalBacktestOnce(filterFn, fn)\"]\n    end\n    \n    subgraph \"Event Flow\"\n        signalEmitter[\"signalEmitter<br/>(Subject)\"]\n        signalLiveEmitter[\"signalLiveEmitter\"]\n        signalBacktestEmitter[\"signalBacktestEmitter\"]\n    end\n    \n    signalEmitter --> listenSignal\n    signalEmitter --> listenSignalOnce\n    signalLiveEmitter --> listenSignalLive\n    signalLiveEmitter --> listenSignalLiveOnce\n    signalBacktestEmitter --> listenSignalBacktest\n    signalBacktestEmitter --> listenSignalBacktestOnce\n```\n\n**Completion Listeners**\n\n```mermaid\ngraph LR\n    subgraph \"Done Event Listeners\"\n        listenDoneLive[\"listenDoneLive(fn)\"]\n        listenDoneLiveOnce[\"listenDoneLiveOnce(filterFn, fn)\"]\n        listenDoneBacktest[\"listenDoneBacktest(fn)\"]\n        listenDoneBacktestOnce[\"listenDoneBacktestOnce(filterFn, fn)\"]\n        listenDoneWalker[\"listenDoneWalker(fn)\"]\n        listenDoneWalkerOnce[\"listenDoneWalkerOnce(filterFn, fn)\"]\n    end\n    \n    subgraph \"Emitters\"\n        doneLiveSubject[\"doneLiveSubject\"]\n        doneBacktestSubject[\"doneBacktestSubject\"]\n        doneWalkerSubject[\"doneWalkerSubject\"]\n    end\n    \n    doneLiveSubject --> listenDoneLive\n    doneLiveSubject --> listenDoneLiveOnce\n    doneBacktestSubject --> listenDoneBacktest\n    doneBacktestSubject --> listenDoneBacktestOnce\n    doneWalkerSubject --> listenDoneWalker\n    doneWalkerSubject --> listenDoneWalkerOnce\n```\n\n**Progress and Monitoring Listeners**\n\n| Function | Parameters | Returns | Purpose |\n|----------|------------|---------|---------|\n| `listenBacktestProgress` | `fn: (event: ProgressBacktestContract) => void` | `unsubscribe: () => void` | Monitor backtest frame completion percentage |\n| `listenWalkerProgress` | `fn: (event: ProgressWalkerContract) => void` | `unsubscribe: () => void` | Monitor walker strategy iteration |\n| `listenOptimizerProgress` | `fn: (event: ProgressOptimizerContract) => void` | `unsubscribe: () => void` | Monitor optimizer execution |\n| `listenPerformance` | `fn: (event: PerformanceContract) => void` | `unsubscribe: () => void` | Track execution timing metrics |\n| `listenWalker` | `fn: (event: WalkerContract) => void` | `unsubscribe: () => void` | Receive per-strategy walker results |\n| `listenWalkerOnce` | `filterFn, fn` | `cancel: () => void` | One-time walker event with filter |\n| `listenWalkerComplete` | `fn: (event: WalkerCompleteContract) => void` | `unsubscribe: () => void` | Final walker comparison results |\n\n**Risk and Partial Listeners**\n\n| Function | Parameters | Returns | Purpose |\n|----------|------------|---------|---------|\n| `listenRisk` | `fn: (event: RiskContract) => void` | `unsubscribe: () => void` | Signal rejections due to risk limits |\n| `listenRiskOnce` | `filterFn, fn` | `cancel: () => void` | One-time risk event with filter |\n| `listenPartialProfit` | `fn: (event: PartialProfitContract) => void` | `unsubscribe: () => void` | Profit milestone events |\n| `listenPartialProfitOnce` | `filterFn, fn` | `cancel: () => void` | One-time profit event with filter |\n| `listenPartialLoss` | `fn: (event: PartialLossContract) => void` | `unsubscribe: () => void` | Loss milestone events |\n| `listenPartialLossOnce` | `filterFn, fn` | `cancel: () => void` | One-time loss event with filter |\n\n**Error Listeners**\n\n| Function | Parameters | Returns | Purpose |\n|----------|------------|---------|---------|\n| `listenError` | `fn: (error: Error) => void` | `unsubscribe: () => void` | Recoverable errors from background tasks |\n| `listenExit` | `fn: (error: Error) => void` | `unsubscribe: () => void` | Fatal errors requiring termination |\n| `listenValidation` | `fn: (error: Error) => void` | `unsubscribe: () => void` | Risk validation errors |\n\n**Sources:** [src/function/event.ts:45-400](), [types.d.ts:1-50]()\n\n---\n\n## Event Contracts\n\nEvent contracts define the structure of data passed to listener callbacks. All contracts are TypeScript interfaces exported from the framework.\n\n**Signal Event Contract**\n\nThe `IStrategyTickResult` is a discriminated union representing all signal states:\n\n```mermaid\ngraph TD\n    IStrategyTickResult[\"IStrategyTickResult<br/>(Discriminated Union)\"]\n    \n    IStrategyTickResult --> IStrategyTickResultIdle[\"IStrategyTickResultIdle<br/>action: 'idle'<br/>signal: null<br/>currentPrice\"]\n    IStrategyTickResult --> IStrategyTickResultScheduled[\"IStrategyTickResultScheduled<br/>action: 'scheduled'<br/>signal: IScheduledSignalRow<br/>currentPrice\"]\n    IStrategyTickResult --> IStrategyTickResultOpened[\"IStrategyTickResultOpened<br/>action: 'opened'<br/>signal: ISignalRow<br/>currentPrice\"]\n    IStrategyTickResult --> IStrategyTickResultActive[\"IStrategyTickResultActive<br/>action: 'active'<br/>signal: ISignalRow<br/>currentPrice, percentTp, percentSl\"]\n    IStrategyTickResult --> IStrategyTickResultClosed[\"IStrategyTickResultClosed<br/>action: 'closed'<br/>signal: ISignalRow<br/>currentPrice, closeReason, pnl\"]\n    IStrategyTickResult --> IStrategyTickResultCancelled[\"IStrategyTickResultCancelled<br/>action: 'cancelled'<br/>signal: IScheduledSignalRow<br/>currentPrice, closeTimestamp\"]\n```\n\n**DoneContract**\n\nEmitted when background execution completes:\n\n```typescript\ninterface DoneContract {\n  /** Trading pair symbol (e.g., \"BTCUSDT\") */\n  symbol: string;\n  /** Strategy name that completed */\n  strategyName: string;\n  /** Exchange name used */\n  exchangeName: string;\n  /** Frame name used (empty for live) */\n  frameName?: string;\n  /** Walker name (if applicable) */\n  walkerName?: string;\n  /** True if backtest, false if live */\n  backtest: boolean;\n  /** Unix timestamp in milliseconds when execution completed */\n  timestamp: number;\n}\n```\n\n**ProgressBacktestContract**\n\nEmitted during backtest frame iteration:\n\n```typescript\ninterface ProgressBacktestContract {\n  /** Trading pair symbol */\n  symbol: string;\n  /** Strategy name */\n  strategyName: string;\n  /** Completion percentage (0-100) */\n  progress: number;\n  /** Unix timestamp in milliseconds */\n  timestamp: number;\n}\n```\n\n**WalkerContract**\n\nEmitted after each strategy completes in walker:\n\n```typescript\ninterface WalkerContract {\n  /** Trading pair symbol */\n  symbol: string;\n  /** Walker name */\n  walkerName: string;\n  /** Strategy name that just completed */\n  strategyName: string;\n  /** Backtest statistics for this strategy */\n  statistics: BacktestStatisticsModel;\n  /** Metric value used for comparison */\n  metricValue: number | null;\n  /** Current strategy index (0-based) */\n  currentIndex: number;\n  /** Total number of strategies */\n  totalStrategies: number;\n  /** Unix timestamp in milliseconds */\n  timestamp: number;\n}\n```\n\n**RiskContract**\n\nEmitted when signal is rejected by risk validation:\n\n```typescript\ninterface RiskContract {\n  /** Trading pair symbol */\n  symbol: string;\n  /** Strategy name that attempted to open signal */\n  strategyName: string;\n  /** Exchange name */\n  exchangeName: string;\n  /** Pending signal that was rejected */\n  pendingSignal: ISignalDto;\n  /** Number of active positions at rejection time */\n  activePositionCount: number;\n  /** Rejection reason (from validation note or \"N/A\") */\n  comment: string;\n  /** Current VWAP price */\n  currentPrice: number;\n  /** Unix timestamp in milliseconds */\n  timestamp: number;\n}\n```\n\n**PartialProfitContract and PartialLossContract**\n\nEmitted when signal reaches profit/loss milestones:\n\n```typescript\ninterface PartialProfitContract {\n  /** Trading pair symbol */\n  symbol: string;\n  /** Signal data */\n  signal: ISignalRow;\n  /** Current VWAP price */\n  currentPrice: number;\n  /** Profit percentage reached (10, 20, 30, etc) */\n  level: PartialLevel;\n  /** True if backtest mode */\n  backtest: boolean;\n  /** Unix timestamp in milliseconds */\n  timestamp: number;\n}\n\ninterface PartialLossContract {\n  /** Trading pair symbol */\n  symbol: string;\n  /** Signal data */\n  signal: ISignalRow;\n  /** Current VWAP price */\n  currentPrice: number;\n  /** Loss percentage reached (10, 20, 30, etc) */\n  level: PartialLevel;\n  /** True if backtest mode */\n  backtest: boolean;\n  /** Unix timestamp in milliseconds */\n  timestamp: number;\n}\n```\n\n**PerformanceContract**\n\nEmitted for execution timing metrics:\n\n```typescript\ninterface PerformanceContract {\n  /** Metric type identifier */\n  type: PerformanceMetricType;\n  /** Trading pair symbol */\n  symbol: string;\n  /** Strategy name (if applicable) */\n  strategyName?: string;\n  /** Execution duration in milliseconds */\n  duration: number;\n  /** Unix timestamp in milliseconds */\n  timestamp: number;\n}\n```\n\n**Sources:** [types.d.ts:765-893](), [src/contract/*.contract.ts:1-100]()\n\n---\n\n## Usage Patterns\n\n**Basic Signal Listening**\n\n```typescript\nimport { listenSignal, Backtest } from 'backtest-kit';\n\n// Subscribe to all signal events\nconst unsubscribe = listenSignal((event) => {\n  if (event.action === 'opened') {\n    console.log('New signal:', event.signal.id);\n  } else if (event.action === 'closed') {\n    console.log('PNL:', event.pnl.pnlPercentage);\n  }\n});\n\n// Run backtest\nBacktest.background('BTCUSDT', {\n  strategyName: 'my-strategy',\n  exchangeName: 'binance',\n  frameName: '1d-test'\n});\n\n// Later: stop listening\nunsubscribe();\n```\n\n**Filtering with Once Listeners**\n\n```typescript\nimport { listenSignalOnce } from 'backtest-kit';\n\n// Wait for first take profit hit\nlistenSignalOnce(\n  (event) => event.action === 'closed' && event.closeReason === 'take_profit',\n  (event) => {\n    console.log('Take profit reached:', event.pnl.pnlPercentage);\n    // Automatically unsubscribes after this executes\n  }\n);\n```\n\n**Mode-Specific Listening**\n\n```typescript\nimport { listenSignalLive, listenSignalBacktest } from 'backtest-kit';\n\n// Only listen to live trading\nlistenSignalLive((event) => {\n  console.log('[LIVE]', event.action);\n});\n\n// Only listen to backtesting\nlistenSignalBacktest((event) => {\n  console.log('[BACKTEST]', event.action);\n});\n```\n\n**Completion Coordination**\n\n```typescript\nimport { listenDoneBacktest, Backtest } from 'backtest-kit';\n\nlistenDoneBacktest(async (event) => {\n  console.log('Backtest completed:', event.symbol, event.strategyName);\n  \n  // Generate report\n  await Backtest.dump(event.symbol, event.strategyName);\n  \n  // Perform cleanup\n});\n\nBacktest.background('BTCUSDT', {\n  strategyName: 'my-strategy',\n  exchangeName: 'binance',\n  frameName: '1d-test'\n});\n```\n\n**Progress Monitoring**\n\n```typescript\nimport { listenBacktestProgress } from 'backtest-kit';\n\nlistenBacktestProgress((event) => {\n  console.log(`${event.symbol}: ${event.progress.toFixed(2)}% complete`);\n});\n```\n\n**Risk Monitoring**\n\n```typescript\nimport { listenRisk } from 'backtest-kit';\n\nlistenRisk((event) => {\n  console.error(`Signal rejected for ${event.symbol}:`, event.comment);\n  console.log('Active positions:', event.activePositionCount);\n});\n```\n\n**Partial Profit/Loss Tracking**\n\n```typescript\nimport { listenPartialProfit, listenPartialLoss } from 'backtest-kit';\n\nlistenPartialProfit((event) => {\n  console.log(`Profit milestone: ${event.level}% on ${event.symbol}`);\n});\n\nlistenPartialLoss((event) => {\n  console.log(`Loss milestone: -${event.level}% on ${event.symbol}`);\n});\n```\n\n**Walker Progress**\n\n```typescript\nimport { listenWalker, listenWalkerComplete } from 'backtest-kit';\n\nlistenWalker((event) => {\n  console.log(`Tested ${event.strategyName}: Sharpe ${event.statistics.sharpeRatio}`);\n});\n\nlistenWalkerComplete((event) => {\n  console.log('Best strategy:', event.results.bestStrategy);\n  console.log('All results:', event.results.strategies);\n});\n```\n\n**Error Handling**\n\n```typescript\nimport { listenError, listenExit } from 'backtest-kit';\n\n// Recoverable errors\nlistenError((error) => {\n  console.error('Recoverable error:', error.message);\n  // Continue execution\n});\n\n// Fatal errors\nlistenExit((error) => {\n  console.error('Fatal error:', error.message);\n  process.exit(1);\n});\n```\n\n**Sources:** [src/function/event.ts:45-400](), [README.md:145-178]()\n\n---\n\n## Queued Processing\n\nAll listener callbacks are wrapped with `queued` from `functools-kit` to ensure sequential async execution. This prevents race conditions when multiple events arrive rapidly or when callbacks contain async operations.\n\n```mermaid\nsequenceDiagram\n    participant Emitter as signalEmitter\n    participant Queue as queued() Wrapper\n    participant Callback1 as Callback Execution 1\n    participant Callback2 as Callback Execution 2\n    \n    Emitter->>Queue: emit(event1)\n    Queue->>Callback1: Start async callback(event1)\n    Emitter->>Queue: emit(event2)\n    Note over Queue: Event2 waits in queue\n    Callback1-->>Queue: Complete\n    Queue->>Callback2: Start async callback(event2)\n    Callback2-->>Queue: Complete\n```\n\n**How It Works:**\n\n1. Each listener function wraps the user callback with `queued(async (event) => fn(event))`\n2. When an event is emitted, `queued` checks if a callback is currently executing\n3. If yes, the event is queued\n4. If no, the callback starts immediately\n5. Once complete, the next queued event is processed\n6. This ensures callbacks execute in order, one at a time\n\n**Example from source:**\n\n[src/function/event.ts:70-73]()\n```typescript\nexport function listenSignal(fn: (event: IStrategyTickResult) => void) {\n  backtest.loggerService.log(LISTEN_SIGNAL_METHOD_NAME);\n  return signalEmitter.subscribe(queued(async (event) => fn(event)));\n}\n```\n\n**Sources:** [src/function/event.ts:1-400]()\n\n---\n\n## Subscriber Management\n\n**Unsubscribing**\n\nAll listener functions (except \"once\" variants) return an unsubscribe function:\n\n```typescript\nconst unsubscribe = listenSignal((event) => {\n  console.log(event);\n});\n\n// Later: stop listening\nunsubscribe();\n```\n\n**Once Listeners**\n\nOnce listeners execute the callback exactly one time and automatically unsubscribe. They return a cancel function:\n\n```typescript\nconst cancel = listenSignalOnce(\n  (event) => event.action === 'closed',\n  (event) => console.log('First closed signal')\n);\n\n// Cancel before event fires\ncancel();\n```\n\n**Filter Predicates**\n\nOnce listeners accept a filter predicate to match specific events:\n\n```typescript\nlistenSignalOnce(\n  // Filter: only BTCUSDT stop losses\n  (event) => event.action === 'closed' \n    && event.closeReason === 'stop_loss'\n    && event.symbol === 'BTCUSDT',\n  // Callback: executed once when matched\n  (event) => {\n    console.log('BTCUSDT hit stop loss');\n  }\n);\n```\n\n**Sources:** [src/function/event.ts:107-113]()\n\n---\n\n## Integration with Markdown Services\n\nMarkdown services subscribe to emitters to accumulate event data for report generation. For example, `BacktestMarkdownService` subscribes to `signalBacktestEmitter`:\n\n```mermaid\ngraph LR\n    ClientStrategy[\"ClientStrategy.tick()\"]\n    signalBacktestEmitter[\"signalBacktestEmitter.emit()\"]\n    BacktestMarkdownService[\"BacktestMarkdownService<br/>(ReportStorage)\"]\n    \n    ClientStrategy --> signalBacktestEmitter\n    signalBacktestEmitter --> BacktestMarkdownService\n    \n    BacktestMarkdownService --> getData[\"getData()<br/>Returns statistics\"]\n    BacktestMarkdownService --> getReport[\"getReport()<br/>Returns markdown\"]\n    BacktestMarkdownService --> dump[\"dump()<br/>Writes file\"]\n```\n\nEach markdown service maintains a `ReportStorage` instance that stores up to 250 events per `symbol:strategyName` key to prevent memory bloat during long-running executions.\n\n**Sources:** [types.d.ts:1-50]()\n\n---\n\n## Best Practices\n\n**1. Always Unsubscribe**\n\nPrevent memory leaks by unsubscribing when listeners are no longer needed:\n\n```typescript\nconst unsubscribe = listenSignal(callback);\n\n// When done\nunsubscribe();\n```\n\n**2. Use Mode-Specific Listeners**\n\nReduce noise by subscribing only to relevant execution modes:\n\n```typescript\n// Production: only live events\nlistenSignalLive(callback);\n\n// Testing: only backtest events\nlistenSignalBacktest(callback);\n```\n\n**3. Use Once Listeners for Coordination**\n\nWait for specific conditions without manual unsubscription:\n\n```typescript\nlistenDoneBacktestOnce(\n  (event) => event.symbol === 'BTCUSDT',\n  async (event) => {\n    await generateReport(event.symbol);\n  }\n);\n```\n\n**4. Handle Async Operations Safely**\n\nThe `queued` wrapper ensures sequential execution, but still use try-catch:\n\n```typescript\nlistenSignal(async (event) => {\n  try {\n    await sendNotification(event);\n  } catch (error) {\n    console.error('Notification failed:', error);\n  }\n});\n```\n\n**5. Log Errors Appropriately**\n\nUse `listenError` for recoverable errors and `listenExit` for fatal errors:\n\n```typescript\nlistenError((error) => {\n  // Log and continue\n  logger.error('Background error:', error);\n});\n\nlistenExit((error) => {\n  // Log and terminate\n  logger.fatal('Fatal error:', error);\n  process.exit(1);\n});\n```\n\n**6. Monitor Progress for Long Operations**\n\nProvide user feedback during lengthy backtests or walker comparisons:\n\n```typescript\nlistenBacktestProgress((event) => {\n  console.log(`Progress: ${event.progress.toFixed(0)}%`);\n});\n```\n\n**7. Use Risk Listeners for Debugging**\n\nUnderstand why signals are rejected:\n\n```typescript\nlistenRisk((event) => {\n  console.log('Rejection:', event.comment);\n  console.log('Signal:', event.pendingSignal);\n  console.log('Active positions:', event.activePositionCount);\n});\n```\n\n**Sources:** [src/function/event.ts:1-400](), [README.md:173-177]()"
                    },
                    {
                        "page_plan": {
                            "id": "9.2",
                            "title": "Markdown Reports"
                        },
                        "content": "# Markdown Reports\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Heat.ts](src/classes/Heat.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Partial.ts](src/classes/Partial.ts)\n- [src/classes/Performance.ts](src/classes/Performance.ts)\n- [src/classes/Risk.ts](src/classes/Risk.ts)\n- [src/classes/Schedule.ts](src/classes/Schedule.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [src/lib/services/markdown/BacktestMarkdownService.ts](src/lib/services/markdown/BacktestMarkdownService.ts)\n- [src/lib/services/markdown/HeatMarkdownService.ts](src/lib/services/markdown/HeatMarkdownService.ts)\n- [src/lib/services/markdown/LiveMarkdownService.ts](src/lib/services/markdown/LiveMarkdownService.ts)\n- [src/lib/services/markdown/PartialMarkdownService.ts](src/lib/services/markdown/PartialMarkdownService.ts)\n- [src/lib/services/markdown/PerformanceMarkdownService.ts](src/lib/services/markdown/PerformanceMarkdownService.ts)\n- [src/lib/services/markdown/RiskMarkdownService.ts](src/lib/services/markdown/RiskMarkdownService.ts)\n- [src/lib/services/markdown/ScheduleMarkdownService.ts](src/lib/services/markdown/ScheduleMarkdownService.ts)\n- [src/lib/services/markdown/WalkerMarkdownService.ts](src/lib/services/markdown/WalkerMarkdownService.ts)\n- [src/model/Column.model.ts](src/model/Column.model.ts)\n- [test/spec/columns.test.mjs](test/spec/columns.test.mjs)\n\n</details>\n\n\n\nThis page covers the markdown report generation system in Backtest Kit. The framework provides eight specialized markdown services that accumulate event data, calculate statistics, and generate formatted reports. Each service exposes three methods: `getData()` for raw statistics, `getReport()` for markdown-formatted strings, and `dump()` for saving reports to disk.\n\nFor information about subscribing to the real-time events that feed these reports, see [Event Listeners](#9.1). For details about the statistical models and their calculated metrics, see [Statistics Models](#9.3).\n\n## Overview of Markdown Services\n\nThe framework provides eight markdown service classes that follow a consistent architecture:\n\n| Service | Purpose | Event Source | Storage Key |\n|---------|---------|--------------|-------------|\n| `BacktestMarkdownService` | Closed backtest signals with PNL | `signalBacktestEmitter` | `${symbol}:${strategyName}` |\n| `LiveMarkdownService` | All live events (idle, opened, active, closed) | `signalLiveEmitter` | `${symbol}:${strategyName}` |\n| `WalkerMarkdownService` | Strategy comparison results | `walkerEmitter` | `${walkerName}` |\n| `PerformanceMarkdownService` | Execution timing metrics | `performanceEmitter` | `${symbol}:${strategyName}` |\n| `HeatMarkdownService` | Portfolio-wide symbol aggregation | `signalEmitter` | `${strategyName}` |\n| `ScheduleMarkdownService` | Scheduled signal lifecycle | `signalEmitter` | `${symbol}:${strategyName}` |\n| `PartialMarkdownService` | Partial profit/loss milestones | `partialProfitSubject`, `partialLossSubject` | `${symbol}:${strategyName}` |\n| `RiskMarkdownService` | Risk rejection events | `riskSubject` | `${symbol}:${strategyName}` |\n\nAll services automatically subscribe to their respective emitters during initialization using the `singleshot` pattern to ensure one-time subscription.\n\nSources: [src/lib/services/markdown/BacktestMarkdownService.ts:1-464](), [src/lib/services/markdown/LiveMarkdownService.ts:1-612](), [src/lib/services/markdown/WalkerMarkdownService.ts:1-606]()\n\n## Service Architecture and Data Flow\n\n```mermaid\ngraph TB\n    subgraph \"Event Layer\"\n        SigBT[\"signalBacktestEmitter\"]\n        SigLive[\"signalLiveEmitter\"]\n        WalkEm[\"walkerEmitter\"]\n        PerfEm[\"performanceEmitter\"]\n        SigGlobal[\"signalEmitter\"]\n        RiskEm[\"riskSubject\"]\n        PartProfit[\"partialProfitSubject\"]\n        PartLoss[\"partialLossSubject\"]\n    end\n    \n    subgraph \"Markdown Service Layer\"\n        BTMD[\"BacktestMarkdownService\"]\n        LiveMD[\"LiveMarkdownService\"]\n        WalkMD[\"WalkerMarkdownService\"]\n        PerfMD[\"PerformanceMarkdownService\"]\n        HeatMD[\"HeatMarkdownService\"]\n        SchedMD[\"ScheduleMarkdownService\"]\n        PartMD[\"PartialMarkdownService\"]\n        RiskMD[\"RiskMarkdownService\"]\n    end\n    \n    subgraph \"Storage Layer\"\n        BTStore[\"ReportStorage<br/>memoize by symbol:strategy\"]\n        LiveStore[\"ReportStorage<br/>memoize by symbol:strategy\"]\n        WalkStore[\"ReportStorage<br/>memoize by walkerName\"]\n        PerfStore[\"PerformanceStorage<br/>memoize by symbol:strategy\"]\n        HeatStore[\"HeatmapStorage<br/>memoize by strategyName\"]\n        SchedStore[\"ReportStorage<br/>memoize by symbol:strategy\"]\n        PartStore[\"ReportStorage<br/>memoize by symbol:strategy\"]\n        RiskStore[\"ReportStorage<br/>memoize by symbol:strategy\"]\n    end\n    \n    subgraph \"Public API\"\n        BacktestAPI[\"Backtest.getData/getReport/dump\"]\n        LiveAPI[\"Live.getData/getReport/dump\"]\n        WalkerAPI[\"Walker.getData/getReport/dump\"]\n        PerfAPI[\"Performance.getData/getReport/dump\"]\n        HeatAPI[\"Heat.getData/getReport/dump\"]\n        SchedAPI[\"Schedule.getData/getReport/dump\"]\n        PartAPI[\"Partial.getData/getReport/dump\"]\n        RiskAPI[\"Risk.getData/getReport/dump\"]\n    end\n    \n    SigBT --> BTMD\n    SigLive --> LiveMD\n    WalkEm --> WalkMD\n    PerfEm --> PerfMD\n    SigGlobal --> HeatMD\n    SigGlobal --> SchedMD\n    RiskEm --> RiskMD\n    PartProfit --> PartMD\n    PartLoss --> PartMD\n    \n    BTMD --> BTStore\n    LiveMD --> LiveStore\n    WalkMD --> WalkStore\n    PerfMD --> PerfStore\n    HeatMD --> HeatStore\n    SchedMD --> SchedStore\n    PartMD --> PartStore\n    RiskMD --> RiskStore\n    \n    BTStore --> BacktestAPI\n    LiveStore --> LiveAPI\n    WalkStore --> WalkerAPI\n    PerfStore --> PerfAPI\n    HeatStore --> HeatAPI\n    SchedStore --> SchedAPI\n    PartStore --> PartAPI\n    RiskStore --> RiskAPI\n```\n\nSources: [src/lib/services/markdown/BacktestMarkdownService.ts:282-461](), [src/classes/Backtest.ts:1-601](), [src/classes/Live.ts:1-614]()\n\n## Common API Pattern\n\nEvery markdown service exposes three methods via public API classes (Backtest, Live, Walker, Performance, Heat, Schedule, Partial, Risk):\n\n### getData()\n\nReturns raw statistical data as a typed model object without formatting:\n\n```typescript\n// Returns BacktestStatisticsModel\nconst stats = await Backtest.getData(\"BTCUSDT\", \"my-strategy\");\nconsole.log(stats.sharpeRatio, stats.winRate, stats.totalPnl);\n\n// Returns LiveStatisticsModel\nconst liveStats = await Live.getData(\"BTCUSDT\", \"my-strategy\");\nconsole.log(liveStats.totalEvents, liveStats.eventList);\n\n// Returns WalkerStatisticsModel\nconst walkerData = await Walker.getData(\"BTCUSDT\", \"my-walker\");\nconsole.log(walkerData.bestStrategy, walkerData.strategyResults);\n```\n\n### getReport()\n\nGenerates markdown-formatted report string with tables and statistics. Accepts optional custom column configuration:\n\n```typescript\n// Default columns\nconst markdown = await Backtest.getReport(\"BTCUSDT\", \"my-strategy\");\n\n// Custom columns\nconst customColumns = [\n  { key: \"pnl\", label: \"PNL\", format: (s) => `${s.pnl.pnlPercentage.toFixed(2)}%`, isVisible: () => true }\n];\nconst customMarkdown = await Backtest.getReport(\"BTCUSDT\", \"my-strategy\", customColumns);\n```\n\n### dump()\n\nSaves report to disk as markdown file. Creates directory recursively if needed:\n\n```typescript\n// Save to default path: ./dump/backtest/my-strategy.md\nawait Backtest.dump(\"BTCUSDT\", \"my-strategy\");\n\n// Custom path: ./reports/my-strategy.md\nawait Backtest.dump(\"BTCUSDT\", \"my-strategy\", \"./reports\");\n\n// Custom path and columns\nawait Backtest.dump(\"BTCUSDT\", \"my-strategy\", \"./reports\", customColumns);\n```\n\nSources: [src/classes/Backtest.ts:276-337](), [src/classes/Live.ts:283-344](), [src/classes/Walker.ts:249-313]()\n\n## Backtest Reports\n\n`BacktestMarkdownService` accumulates closed backtest signals and calculates performance statistics.\n\n### Characteristics\n\n- **Event Source**: `signalBacktestEmitter` (only `action === \"closed\"`)\n- **Storage**: Memoized by `${symbol}:${strategyName}`\n- **Max Events**: 250 per symbol-strategy pair\n- **Default Path**: `./dump/backtest/`\n- **Model**: `BacktestStatisticsModel`\n\n### Statistics Calculated\n\n- Total signals, win/loss counts, win rate percentage\n- Average PNL, total PNL\n- Standard deviation\n- Sharpe ratio (daily and annualized via `sqrt(365)`)\n- Certainty ratio (average win / absolute average loss)\n- Expected yearly returns (based on average trade duration)\n\n### Usage Example\n\n```typescript\n// Run backtest\nfor await (const result of Backtest.run(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\",\n  frameName: \"1d-backtest\"\n})) {\n  if (result.action === \"closed\") {\n    console.log(\"Signal closed:\", result.pnl.pnlPercentage);\n  }\n}\n\n// Get raw statistics\nconst stats = await Backtest.getData(\"BTCUSDT\", \"my-strategy\");\nconsole.log(\"Sharpe Ratio:\", stats.sharpeRatio);\nconsole.log(\"Win Rate:\", stats.winRate);\n\n// Generate markdown report\nconst markdown = await Backtest.getReport(\"BTCUSDT\", \"my-strategy\");\nconsole.log(markdown);\n\n// Save to disk\nawait Backtest.dump(\"BTCUSDT\", \"my-strategy\");\n```\n\n### Report Structure\n\nGenerated markdown includes:\n1. Title: `# Backtest Report: {strategyName}`\n2. Markdown table with closed signals (default or custom columns)\n3. Summary section:\n   - `**Total signals:** {totalSignals}`\n   - `**Win rate:** {winRate}% ({winCount}W / {lossCount}L) (higher is better)`\n   - `**Average PNL:** {avgPnl}% (higher is better)`\n   - `**Total PNL:** {totalPnl}% (higher is better)`\n   - `**Standard Deviation:** {stdDev}% (lower is better)`\n   - `**Sharpe Ratio:** {sharpeRatio} (higher is better)`\n   - `**Annualized Sharpe Ratio:** {annualizedSharpeRatio} (higher is better)`\n   - `**Certainty Ratio:** {certaintyRatio} (higher is better)`\n   - `**Expected Yearly Returns:** {expectedYearlyReturns}% (higher is better)`\n\nSources: [src/lib/services/markdown/BacktestMarkdownService.ts:76-253](), [src/classes/Backtest.ts:276-337]()\n\n## Live Trading Reports\n\n`LiveMarkdownService` tracks all live trading events including idle states, signal openings, active monitoring, and closures.\n\n### Characteristics\n\n- **Event Source**: `signalLiveEmitter` (all action types)\n- **Storage**: Memoized by `${symbol}:${strategyName}`\n- **Max Events**: 250 per symbol-strategy pair\n- **Default Path**: `./dump/live/`\n- **Model**: `LiveStatisticsModel`\n\n### Event Types Tracked\n\n| Action | Description | Storage Behavior |\n|--------|-------------|------------------|\n| `idle` | No active signal | Replaces last idle if no opened/active events follow |\n| `opened` | Signal activated | Added to front |\n| `active` | Position monitoring | Replaces last active with same signalId |\n| `closed` | Position closed | Added to front, used for statistics |\n\n### Special Deduplication Logic\n\n```typescript\n// Idle event deduplication - prevents spam\nconst canReplaceLastIdle = lastIdleIndex !== -1 &&\n  !this._eventList.slice(lastIdleIndex + 1)\n    .some((event) => event.action === \"opened\" || event.action === \"active\");\n\n// Active event deduplication - keeps latest state\nconst lastActiveIndex = this._eventList.findLastIndex(\n  (event) => event.action === \"active\" && event.signalId === data.signal.id\n);\n```\n\n### Usage Example\n\n```typescript\n// Start live trading\nLive.background(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\"\n});\n\n// Query statistics (only closed events count toward metrics)\nconst stats = await Live.getData(\"BTCUSDT\", \"my-strategy\");\nconsole.log(\"Total events:\", stats.totalEvents);  // All event types\nconsole.log(\"Closed signals:\", stats.totalClosed); // Only closed\nconsole.log(\"Win rate:\", stats.winRate);           // From closed only\n\n// Generate report (shows ALL events in table)\nconst markdown = await Live.getReport(\"BTCUSDT\", \"my-strategy\");\n\n// Save to disk\nawait Live.dump(\"BTCUSDT\", \"my-strategy\");\n```\n\nSources: [src/lib/services/markdown/LiveMarkdownService.ts:78-391](), [src/classes/Live.ts:283-344]()\n\n## Walker Comparison Reports\n\n`WalkerMarkdownService` accumulates strategy comparison results and generates comparative analysis.\n\n### Characteristics\n\n- **Event Source**: `walkerEmitter` (progress per strategy)\n- **Storage**: Memoized by `${walkerName}`\n- **Max Events**: Unlimited (stores all strategy results)\n- **Default Path**: `./dump/walker/`\n- **Model**: `WalkerStatisticsModel`\n\n### Data Structure\n\nThe walker storage maintains:\n- **Metadata**: `totalStrategies`, `bestStrategy`, `bestMetric`\n- **Best Strategy Stats**: Full `BacktestStatisticsModel` for best performer\n- **Strategy Results Array**: `IStrategyResult[]` with strategyName, stats, metricValue\n- **Signal List**: All closed signals from all strategies combined\n\n### Report Tables\n\nWalker reports generate two distinct tables:\n\n**Strategy Comparison Table** (default top 10):\n- Sorted by metric value descending\n- Uses `walker_strategy_columns` from `COLUMN_CONFIG`\n- Typically shows: Strategy, Metric Value, Trades, Win Rate, etc.\n\n**PNL Table** (all signals):\n- All closed signals from all strategies\n- Uses `walker_pnl_columns` from `COLUMN_CONFIG`\n- Typically shows: Strategy, Signal ID, Symbol, Position, PNL, Close Reason, etc.\n\n### Usage Example\n\n```typescript\n// Run walker comparison\nfor await (const progress of Walker.run(\"BTCUSDT\", {\n  walkerName: \"my-walker\"\n})) {\n  console.log(`${progress.strategiesTested}/${progress.totalStrategies}`);\n  console.log(`Best: ${progress.bestStrategy} (${progress.bestMetric})`);\n}\n\n// Get results\nconst results = await Walker.getData(\"BTCUSDT\", \"my-walker\");\nconsole.log(\"Winner:\", results.bestStrategy);\nconsole.log(\"Metric:\", results.bestMetric);\n\n// Generate report with both tables\nconst markdown = await Walker.getReport(\"BTCUSDT\", \"my-walker\");\n\n// Custom columns for strategy table\nconst stratCols = [\n  { key: \"name\", label: \"Strategy\", format: (r) => r.strategyName, isVisible: () => true },\n  { key: \"sharpe\", label: \"Sharpe\", format: (r) => r.stats.sharpeRatio?.toFixed(3) ?? \"N/A\", isVisible: () => true }\n];\nconst customMarkdown = await Walker.getReport(\"BTCUSDT\", \"my-walker\", stratCols);\n\n// Save to disk\nawait Walker.dump(\"BTCUSDT\", \"my-walker\");\n```\n\n### Report Structure\n\n```\n# Walker Comparison Report: {walkerName}\n\n**Symbol:** {symbol}\n**Exchange:** {exchangeName}\n**Frame:** {frameName}\n**Optimization Metric:** {metric}\n**Strategies Tested:** {totalStrategies}\n\n## Best Strategy: {bestStrategy}\n\n**Best {metric}:** {bestMetric}\n**Total Signals:** {bestStrategySignals}\n\n## Top Strategies Comparison\n\n| Strategy | Metric | Trades | ... |\n| --- | --- | --- | --- |\n| ... | ... | ... | ... |\n\n## All Signals (PNL Table)\n\n| Strategy | Signal | PNL | ... |\n| --- | --- | --- | --- |\n| ... | ... | ... | ... |\n\n**Note:** Higher values are better for all metrics except Standard Deviation (lower is better).\n```\n\nSources: [src/lib/services/markdown/WalkerMarkdownService.ts:124-388](), [src/classes/Walker.ts:249-313]()\n\n## Specialized Report Services\n\n### Performance Reports\n\n`PerformanceMarkdownService` tracks execution timing for bottleneck identification.\n\n**Key Details:**\n- Event source: `performanceEmitter`\n- Storage key: `${symbol}:${strategyName}`\n- Max events: 10,000 (higher limit for granular profiling)\n- Default path: `./dump/performance/`\n- Model: `PerformanceStatisticsModel`\n\n**Metrics per operation type:**\n- Count, total duration, average duration\n- Min/max duration\n- Standard deviation\n- Percentiles: Median, P95, P99\n- Wait times between consecutive operations\n\n```typescript\nconst stats = await Performance.getData(\"BTCUSDT\", \"my-strategy\");\nconsole.log(\"Total time:\", stats.totalDuration);\nconsole.log(\"Metrics by type:\", stats.metricStats);\n\nawait Performance.dump(\"BTCUSDT\", \"my-strategy\");\n```\n\nSources: [src/lib/services/markdown/PerformanceMarkdownService.ts:81-283](), [src/classes/Performance.ts:1-159]()\n\n### Heatmap Reports\n\n`HeatMarkdownService` provides portfolio-wide aggregation across all symbols.\n\n**Key Details:**\n- Event source: `signalEmitter` (closed only)\n- Storage key: `${strategyName}` (single storage per strategy)\n- Max events: 250 per symbol within strategy\n- Default path: `./dump/heatmap/`\n- Model: `HeatmapStatisticsModel`\n\n**Per-Symbol Metrics:**\n- Total PNL, Sharpe Ratio, Max Drawdown\n- Total trades, win/loss counts, win rate\n- Average PNL, Standard Deviation\n- Profit Factor, Average Win/Loss\n- Max Win/Loss Streaks, Expectancy\n\n**Portfolio Aggregates:**\n- Total symbols count\n- Portfolio total PNL (sum across symbols)\n- Portfolio Sharpe Ratio (trade-weighted average)\n- Portfolio total trades\n\n```typescript\nconst stats = await Heat.getData(\"my-strategy\");\nconsole.log(\"Portfolio PNL:\", stats.portfolioTotalPnl);\nconsole.log(\"Symbols:\", stats.totalSymbols);\n\n// Iterate per-symbol\nstats.symbols.forEach(row => {\n  console.log(`${row.symbol}: ${row.totalPnl}% (${row.totalTrades} trades)`);\n});\n\nawait Heat.dump(\"my-strategy\");\n```\n\nSources: [src/lib/services/markdown/HeatMarkdownService.ts:82-406](), [src/classes/Heat.ts:1-148]()\n\n### Schedule Reports\n\n`ScheduleMarkdownService` tracks scheduled signal lifecycle.\n\n**Key Details:**\n- Event source: `signalEmitter` (scheduled, opened, cancelled)\n- Storage key: `${symbol}:${strategyName}`\n- Max events: 250\n- Default path: `./dump/schedule/`\n- Model: `ScheduleStatisticsModel`\n\n**Metrics:**\n- Total scheduled/opened/cancelled counts\n- Cancellation rate: `(cancelled / scheduled) * 100`\n- Activation rate: `(opened / scheduled) * 100`\n- Average wait time for cancelled signals\n- Average activation time for opened signals\n\n```typescript\nconst stats = await Schedule.getData(\"BTCUSDT\", \"my-strategy\");\nconsole.log(\"Cancellation rate:\", stats.cancellationRate);\nconsole.log(\"Avg activation:\", stats.avgActivationTime);\n\nawait Schedule.dump(\"BTCUSDT\", \"my-strategy\");\n```\n\nSources: [src/lib/services/markdown/ScheduleMarkdownService.ts:59-301](), [src/classes/Schedule.ts:1-149]()\n\n### Partial Reports\n\n`PartialMarkdownService` tracks partial profit/loss milestone events.\n\n**Key Details:**\n- Event sources: `partialProfitSubject`, `partialLossSubject`\n- Storage key: `${symbol}:${strategyName}`\n- Max events: 250\n- Default path: `./dump/partial/`\n- Model: `PartialStatisticsModel`\n\n**Event Types:**\n- Profit: +10%, +20%, +30%, etc.\n- Loss: −10%, −20%, −30%, etc.\n\n```typescript\nconst stats = await Partial.getData(\"BTCUSDT\", \"my-strategy\");\nconsole.log(\"Profit events:\", stats.totalProfit);\nconsole.log(\"Loss events:\", stats.totalLoss);\n\nawait Partial.dump(\"BTCUSDT\", \"my-strategy\");\n```\n\nSources: [src/lib/services/markdown/PartialMarkdownService.ts:60-236](), [src/classes/Partial.ts:1-193]()\n\n### Risk Reports\n\n`RiskMarkdownService` tracks risk validation rejection events.\n\n**Key Details:**\n- Event source: `riskSubject`\n- Storage key: `${symbol}:${strategyName}`\n- Max events: 250\n- Default path: `./dump/risk/`\n- Model: `RiskStatisticsModel`\n\n**Metrics:**\n- Total rejections\n- Rejections grouped by symbol\n- Rejections grouped by strategy\n\n```typescript\nconst stats = await Risk.getData(\"BTCUSDT\", \"my-strategy\");\nconsole.log(\"Total rejections:\", stats.totalRejections);\nconsole.log(\"By symbol:\", stats.bySymbol);\n\nawait Risk.dump(\"BTCUSDT\", \"my-strategy\");\n```\n\nSources: [src/lib/services/markdown/RiskMarkdownService.ts:52-185](), [src/classes/Risk.ts:153-246]()\n\n## Column Customization\n\nAll report generation methods accept optional `Columns` parameter for fine-grained table formatting control.\n\n### ColumnModel Interface\n\n```typescript\ninterface ColumnModel<T extends object = any> {\n  /** Unique column identifier */\n  key: string;\n  \n  /** Display label for column header */\n  label: string;\n  \n  /** Formatting function to convert data to string */\n  format: (data: T, index: number) => string | Promise<string>;\n  \n  /** Function to determine if column should be visible */\n  isVisible: () => boolean | Promise<boolean>;\n}\n```\n\nThe `T` type parameter corresponds to the data model for each service:\n- Backtest: `IStrategyTickResultClosed`\n- Live: `TickEvent`\n- Walker (strategy table): `IStrategyResult`\n- Walker (PNL table): `SignalData`\n- Performance: `MetricStats`\n- Heatmap: `IHeatmapRow`\n- Schedule: `ScheduledEvent`\n- Partial: `PartialEvent`\n- Risk: `RiskEvent`\n\nSources: [src/model/Column.model.ts:1-39]()\n\n### Column Type Definitions\n\n```mermaid\ngraph LR\n    subgraph \"Column Types\"\n        ColModel[\"ColumnModel<T>\"]\n    end\n    \n    subgraph \"Service-Specific Types\"\n        BTCol[\"BacktestMarkdownService.Columns<br/>ColumnModel<IStrategyTickResultClosed>\"]\n        LiveCol[\"LiveMarkdownService.Columns<br/>ColumnModel<TickEvent>\"]\n        WalkStratCol[\"WalkerMarkdownService.StrategyColumn<br/>ColumnModel<IStrategyResult>\"]\n        WalkPnlCol[\"WalkerMarkdownService.PnlColumn<br/>ColumnModel<SignalData>\"]\n        PerfCol[\"PerformanceMarkdownService.Columns<br/>ColumnModel<MetricStats>\"]\n        HeatCol[\"HeatMarkdownService.Columns<br/>ColumnModel<IHeatmapRow>\"]\n        SchedCol[\"ScheduleMarkdownService.Columns<br/>ColumnModel<ScheduledEvent>\"]\n        PartCol[\"PartialMarkdownService.Columns<br/>ColumnModel<PartialEvent>\"]\n        RiskCol[\"RiskMarkdownService.Columns<br/>ColumnModel<RiskEvent>\"]\n    end\n    \n    ColModel --> BTCol\n    ColModel --> LiveCol\n    ColModel --> WalkStratCol\n    ColModel --> WalkPnlCol\n    ColModel --> PerfCol\n    ColModel --> HeatCol\n    ColModel --> SchedCol\n    ColModel --> PartCol\n    ColModel --> RiskCol\n```\n\nSources: [src/lib/services/markdown/BacktestMarkdownService.ts:17-48](), [src/lib/services/markdown/LiveMarkdownService.ts:19-50](), [src/lib/services/markdown/WalkerMarkdownService.ts:24-88]()\n\n### Custom Column Examples\n\n**Basic Backtest Columns:**\n\n```typescript\nconst customColumns = [\n  {\n    key: \"id\",\n    label: \"ID\",\n    format: (signal) => signal.signal.id,\n    isVisible: () => true\n  },\n  {\n    key: \"position\",\n    label: \"Position\",\n    format: (signal) => signal.signal.position.toUpperCase(),\n    isVisible: () => true\n  },\n  {\n    key: \"pnl\",\n    label: \"PNL\",\n    format: (signal) => `${signal.pnl.pnlPercentage.toFixed(2)}%`,\n    isVisible: () => true\n  }\n];\n\nconst report = await Backtest.getReport(\"BTCUSDT\", \"my-strategy\", customColumns);\n```\n\n**Conditional Visibility:**\n\n```typescript\nconst winColumn = {\n  key: \"bigWin\",\n  label: \"Large Win\",\n  format: (signal) => signal.pnl.pnlPercentage > 5 ? \"YES\" : \"NO\",\n  isVisible: async () => {\n    // Could check environment, configuration, etc.\n    return process.env.SHOW_WINS === \"true\";\n  }\n};\n```\n\n**Async Formatting:**\n\n```typescript\nconst asyncColumn = {\n  key: \"formatted\",\n  label: \"Formatted Price\",\n  format: async (signal, index) => {\n    // Can perform async operations\n    const formatted = await externalFormatter(signal.signal.priceOpen);\n    return formatted;\n  },\n  isVisible: () => true\n};\n```\n\n**Walker Strategy Comparison:**\n\n```typescript\nconst strategyColumns = [\n  {\n    key: \"strategy\",\n    label: \"Strategy\",\n    format: (result) => result.strategyName,\n    isVisible: () => true\n  },\n  {\n    key: \"sharpe\",\n    label: \"Sharpe Ratio\",\n    format: (result) => result.stats.sharpeRatio?.toFixed(3) ?? \"N/A\",\n    isVisible: () => true\n  },\n  {\n    key: \"trades\",\n    label: \"Total Trades\",\n    format: (result) => result.stats.totalSignals.toString(),\n    isVisible: () => true\n  }\n];\n\nawait Walker.getReport(\"BTCUSDT\", \"my-walker\", strategyColumns);\n```\n\nSources: [test/spec/columns.test.mjs:69-112](), [test/spec/columns.test.mjs:169-182]()\n\n## Default Column Configuration\n\nThe framework provides default column configurations in `COLUMN_CONFIG`:\n\n```typescript\n// Default configurations used when no custom columns provided\nexport const COLUMN_CONFIG = {\n  backtest_columns: Columns[],\n  live_columns: Columns[],\n  walker_strategy_columns: StrategyColumn[],\n  walker_pnl_columns: PnlColumn[],\n  performance_columns: Columns[],\n  heat_columns: Columns[],\n  schedule_columns: Columns[],\n  partial_columns: Columns[],\n  risk_columns: Columns[]\n};\n```\n\nAll services reference these defaults:\n\n```typescript\n// Example from BacktestMarkdownService\npublic async getReport(\n  strategyName: StrategyName,\n  columns: Columns[] = COLUMN_CONFIG.backtest_columns\n): Promise<string> {\n  // ...\n}\n```\n\nSources: [src/lib/services/markdown/BacktestMarkdownService.ts:177-180]()\n\n## Report Storage and Memory Management\n\n### Storage Pattern\n\nEach service uses memoized storage instances to isolate data by unique keys:\n\n```typescript\n// Example from BacktestMarkdownService\nprivate getStorage = memoize<(symbol: string, strategyName: string) => ReportStorage>(\n  ([symbol, strategyName]) => `${symbol}:${strategyName}`,\n  () => new ReportStorage()\n);\n```\n\n### Memory Limits\n\n| Service | Max Events | Reason |\n|---------|------------|--------|\n| Backtest | 250 | Balance history vs memory |\n| Live | 250 | Balance history vs memory |\n| Walker | Unlimited | All strategies needed for comparison |\n| Performance | 10,000 | Granular profiling data |\n| Heatmap | 250 per symbol | Portfolio-wide aggregation |\n| Schedule | 250 | Balance history vs memory |\n| Partial | 250 | Balance history vs memory |\n| Risk | 250 | Balance history vs memory |\n\n### Circular Buffer Implementation\n\nStorage uses unshift/pop pattern to maintain FIFO ordering:\n\n```typescript\npublic addSignal(data: IStrategyTickResultClosed) {\n  this._signalList.unshift(data);  // Add to front\n  \n  // Trim from back if exceeded\n  if (this._signalList.length > MAX_EVENTS) {\n    this._signalList.pop();\n  }\n}\n```\n\n### Deduplication Strategies\n\n**Idle Events (Live):**\n```typescript\n// Replace last idle if no opened/active events follow\nconst canReplaceLastIdle = lastIdleIndex !== -1 &&\n  !this._eventList.slice(lastIdleIndex + 1)\n    .some((event) => event.action === \"opened\" || event.action === \"active\");\n\nif (canReplaceLastIdle) {\n  this._eventList[lastIdleIndex] = newEvent;\n  return;\n}\n```\n\n**Active Events (Live):**\n```typescript\n// Replace last active event with same signalId\nconst lastActiveIndex = this._eventList.findLastIndex(\n  (event) => event.action === \"active\" && event.signalId === data.signal.id\n);\n\nif (lastActiveIndex !== -1) {\n  this._eventList[lastActiveIndex] = newEvent;\n  return;\n}\n```\n\nSources: [src/lib/services/markdown/BacktestMarkdownService.ts:85-92](), [src/lib/services/markdown/LiveMarkdownService.ts:88-115](), [src/lib/services/markdown/LiveMarkdownService.ts:148-182]()\n\n### Clearing Storage\n\nAll services provide `clear()` methods:\n\n```typescript\n// Clear specific key\nawait service.clear({ symbol: \"BTCUSDT\", strategyName: \"my-strategy\" });\n\n// Clear all data\nawait service.clear();\n\n// Clear by strategy (heatmap)\nawait service.clear(\"my-strategy\");\n```\n\nStorage is automatically cleared at the start of each execution:\n\n```typescript\n// From Backtest.run()\n{\n  backtest.backtestMarkdownService.clear({ symbol, strategyName: context.strategyName });\n  backtest.scheduleMarkdownService.clear({ symbol, strategyName: context.strategyName });\n}\n```\n\nSources: [src/lib/services/markdown/BacktestMarkdownService.ts:434-444](), [src/classes/Backtest.ts:163-176]()\n\n## File System Output\n\n### Directory Structure\n\nDefault output paths organize reports by type:\n\n```\n./dump/\n├── backtest/{strategyName}.md\n├── live/{strategyName}.md\n├── walker/{walkerName}.md\n├── performance/{strategyName}.md\n├── heatmap/{strategyName}.md\n├── schedule/{strategyName}.md\n├── partial/{symbol}_{strategyName}.md\n└── risk/{symbol}_{strategyName}.md\n```\n\n### Dump Implementation Pattern\n\nAll `dump()` methods follow this pattern:\n\n```typescript\npublic async dump(\n  strategyName: StrategyName,\n  path = \"./dump/backtest\",\n  columns: Columns[] = COLUMN_CONFIG.backtest_columns\n): Promise<void> {\n  const markdown = await this.getReport(strategyName, columns);\n  \n  try {\n    const dir = join(process.cwd(), path);\n    await mkdir(dir, { recursive: true });\n    \n    const filename = `${strategyName}.md`;\n    const filepath = join(dir, filename);\n    \n    await writeFile(filepath, markdown, \"utf-8\");\n    console.log(`Backtest report saved: ${filepath}`);\n  } catch (error) {\n    console.error(`Failed to save markdown report:`, error);\n  }\n}\n```\n\nProcess:\n1. Generate markdown via `getReport()`\n2. Resolve absolute path from `process.cwd()`\n3. Create directory recursively (`mkdir` with `recursive: true`)\n4. Write UTF-8 encoded file\n5. Log success/failure to console\n\nSources: [src/lib/services/markdown/BacktestMarkdownService.ts:233-252]()\n\n## Event Subscription and Initialization\n\nServices automatically subscribe to emitters during initialization using `singleshot`:\n\n```typescript\nprotected init = singleshot(async () => {\n  this.loggerService.log(\"backtestMarkdownService init\");\n  signalBacktestEmitter.subscribe(this.tick);\n});\n```\n\nThe `tick()` method (private) processes incoming events:\n\n```typescript\nprivate tick = async (data: IStrategyTickResult) => {\n  this.loggerService.log(\"backtestMarkdownService tick\", { data });\n  \n  if (data.action !== \"closed\") {\n    return;  // Backtest only processes closed signals\n  }\n  \n  const storage = this.getStorage(data.symbol, data.strategyName);\n  storage.addSignal(data);\n};\n```\n\nThe `singleshot` wrapper ensures subscription happens only once, even if the service is accessed multiple times.\n\nSources: [src/lib/services/markdown/BacktestMarkdownService.ts:457-460](), [src/lib/services/markdown/BacktestMarkdownService.ts:314-325]()\n\n## Safe Math and Statistics\n\nAll services implement safe math checks to handle edge cases gracefully:\n\n### isUnsafe() Helper\n\n```typescript\nfunction isUnsafe(value: number | null): boolean {\n  if (typeof value !== \"number\") return true;\n  if (isNaN(value)) return true;\n  if (!isFinite(value)) return true;\n  return false;\n}\n```\n\n### Null Value Handling\n\nStatistics calculations check each metric:\n\n```typescript\nreturn {\n  signalList: this._signalList,\n  totalSignals,\n  winCount,\n  lossCount,\n  winRate: isUnsafe(winRate) ? null : winRate,\n  avgPnl: isUnsafe(avgPnl) ? null : avgPnl,\n  totalPnl: isUnsafe(totalPnl) ? null : totalPnl,\n  stdDev: isUnsafe(stdDev) ? null : stdDev,\n  sharpeRatio: isUnsafe(sharpeRatio) ? null : sharpeRatio,\n  annualizedSharpeRatio: isUnsafe(annualizedSharpeRatio) ? null : annualizedSharpeRatio,\n  certaintyRatio: isUnsafe(certaintyRatio) ? null : certaintyRatio,\n  expectedYearlyReturns: isUnsafe(expectedYearlyReturns) ? null : expectedYearlyReturns,\n};\n```\n\n### Report Display\n\nNull values display as \"N/A\":\n\n```typescript\n`**Average PNL:** ${stats.avgPnl === null ? \"N/A\" : `${stats.avgPnl > 0 ? \"+\" : \"\"}${stats.avgPnl.toFixed(2)}%`}`\n```\n\nThis ensures reports are always readable even with insufficient data or calculation edge cases.\n\nSources: [src/lib/services/markdown/BacktestMarkdownService.ts:56-67](), [src/lib/services/markdown/BacktestMarkdownService.ts:154-167](), [src/lib/services/markdown/BacktestMarkdownService.ts:216-217]()"
                    },
                    {
                        "page_plan": {
                            "id": "9.3",
                            "title": "Statistics Models"
                        },
                        "content": "# Statistics Models\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/lib/services/markdown/BacktestMarkdownService.ts](src/lib/services/markdown/BacktestMarkdownService.ts)\n- [src/lib/services/markdown/HeatMarkdownService.ts](src/lib/services/markdown/HeatMarkdownService.ts)\n- [src/lib/services/markdown/LiveMarkdownService.ts](src/lib/services/markdown/LiveMarkdownService.ts)\n- [src/lib/services/markdown/PartialMarkdownService.ts](src/lib/services/markdown/PartialMarkdownService.ts)\n- [src/lib/services/markdown/PerformanceMarkdownService.ts](src/lib/services/markdown/PerformanceMarkdownService.ts)\n- [src/lib/services/markdown/RiskMarkdownService.ts](src/lib/services/markdown/RiskMarkdownService.ts)\n- [src/lib/services/markdown/ScheduleMarkdownService.ts](src/lib/services/markdown/ScheduleMarkdownService.ts)\n- [src/lib/services/markdown/WalkerMarkdownService.ts](src/lib/services/markdown/WalkerMarkdownService.ts)\n- [src/model/Column.model.ts](src/model/Column.model.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis document describes the eight statistics model interfaces that aggregate and compute performance metrics from trading execution data. These models transform raw event data into actionable statistics including profit/loss calculations, risk-adjusted returns (Sharpe Ratio), win rates, and timing metrics.\n\nFor information about the markdown services that generate these statistics, see [Markdown Reports](#9.2). For details on the event system that feeds data into statistics calculation, see [Event Listeners](#9.1).\n\n**Sources:** [src/index.ts:139-146](), [types.d.ts:918-943]()\n\n---\n\n## Statistics Model Hierarchy\n\nThe framework provides eight distinct statistics models, each serving a specific reporting domain:\n\n```mermaid\ngraph TB\n    subgraph \"Core Trading Statistics\"\n        BT[BacktestStatisticsModel<br/>Closed signals only<br/>Win rate, Sharpe, PNL]\n        LIVE[LiveStatisticsModel<br/>All events: idle, opened, active, closed<br/>Real-time monitoring]\n        WALK[WalkerStatisticsModel<br/>Multi-strategy comparison<br/>Best strategy selection]\n    end\n    \n    subgraph \"Specialized Domain Statistics\"\n        SCHED[ScheduleStatisticsModel<br/>Scheduled/opened/cancelled signals<br/>Activation rates]\n        PART[PartialStatisticsModel<br/>Profit/loss milestone tracking<br/>10%, 20%, 30%... levels]\n        RISK[RiskStatisticsModel<br/>Rejection events<br/>By symbol, by strategy]\n    end\n    \n    subgraph \"Performance & Portfolio Statistics\"\n        PERF[PerformanceStatisticsModel<br/>Execution timing metrics<br/>Bottleneck analysis]\n        HEAT[HeatmapStatisticsModel<br/>Portfolio-wide aggregation<br/>Per-symbol breakdown]\n    end\n    \n    BT --> |\"getData()\"| BTService[BacktestMarkdownService]\n    LIVE --> |\"getData()\"| LiveService[LiveMarkdownService]\n    WALK --> |\"getData()\"| WalkService[WalkerMarkdownService]\n    SCHED --> |\"getData()\"| SchedService[ScheduleMarkdownService]\n    PART --> |\"getData()\"| PartService[PartialMarkdownService]\n    RISK --> |\"getData()\"| RiskService[RiskMarkdownService]\n    PERF --> |\"getData()\"| PerfService[PerformanceMarkdownService]\n    HEAT --> |\"getData()\"| HeatService[HeatMarkdownService]\n    \n    BTService --> Storage[ReportStorage]\n    LiveService --> Storage\n    WalkService --> Storage\n    SchedService --> Storage\n    PartService --> Storage\n    RiskService --> Storage\n    PerfService --> Storage\n    HeatService --> Storage\n```\n\n**Sources:** [src/index.ts:139-146](), [src/lib/services/markdown/BacktestMarkdownService.ts:76-93](), [src/lib/services/markdown/LiveMarkdownService.ts:78-215]()\n\n---\n\n## BacktestStatisticsModel\n\nThe `BacktestStatisticsModel` interface defines the canonical structure for backtest performance metrics, computed from closed signal data only.\n\n### Structure\n\n| Field | Type | Description | Interpretation |\n|-------|------|-------------|----------------|\n| `signalList` | `IStrategyTickResultClosed[]` | Array of all closed signals with full details | Raw data source |\n| `totalSignals` | `number` | Total count of closed signals | Volume metric |\n| `winCount` | `number` | Number of profitable signals (PNL > 0) | Win frequency |\n| `lossCount` | `number` | Number of losing signals (PNL < 0) | Loss frequency |\n| `winRate` | `number \\| null` | Percentage of winning signals (0-100) | **Higher is better** |\n| `avgPnl` | `number \\| null` | Average PNL per signal as percentage | **Higher is better** |\n| `totalPnl` | `number \\| null` | Cumulative PNL across all signals | **Higher is better** |\n| `stdDev` | `number \\| null` | Standard deviation of returns (volatility) | **Lower is better** |\n| `sharpeRatio` | `number \\| null` | Risk-adjusted return (avgPnl / stdDev) | **Higher is better** |\n| `annualizedSharpeRatio` | `number \\| null` | Sharpe × √365 | **Higher is better** |\n| `certaintyRatio` | `number \\| null` | avgWin / \\|avgLoss\\| | **Higher is better** |\n| `expectedYearlyReturns` | `number \\| null` | Projected annual returns based on trade frequency | **Higher is better** |\n\n**Sources:** [types.d.ts:918-943]()\n\n### Calculation Implementation\n\nThe calculation occurs in [BacktestMarkdownService.ts:100-168]() within the `ReportStorage.getData()` method:\n\n```mermaid\ngraph TD\n    A[\"signalList: IStrategyTickResultClosed[]\"] --> B[\"Filter and Count\"]\n    B --> C[\"winCount = filter(pnl > 0).length\"]\n    B --> D[\"lossCount = filter(pnl < 0).length\"]\n    \n    A --> E[\"Calculate Basic Stats\"]\n    E --> F[\"avgPnl = sum(pnl) / totalSignals\"]\n    E --> G[\"totalPnl = sum(pnl)\"]\n    E --> H[\"winRate = (winCount / totalSignals) × 100\"]\n    \n    F --> I[\"Calculate Variance\"]\n    I --> J[\"variance = sum((pnl - avgPnl)²) / totalSignals\"]\n    J --> K[\"stdDev = √variance\"]\n    \n    K --> L[\"Calculate Sharpe Ratio\"]\n    F --> L\n    L --> M[\"sharpeRatio = avgPnl / stdDev\"]\n    M --> N[\"annualizedSharpeRatio = sharpeRatio × √365\"]\n    \n    C --> O[\"Calculate Certainty Ratio\"]\n    D --> O\n    O --> P[\"avgWin = sum(wins) / winCount\"]\n    O --> Q[\"avgLoss = sum(losses) / lossCount\"]\n    P --> R[\"certaintyRatio = avgWin / |avgLoss|\"]\n    Q --> R\n    \n    A --> S[\"Calculate Duration\"]\n    S --> T[\"avgDurationMs = sum(closeTime - pendingAt) / totalSignals\"]\n    T --> U[\"avgDurationDays = avgDurationMs / (1000 × 60 × 60 × 24)\"]\n    U --> V[\"tradesPerYear = 365 / avgDurationDays\"]\n    V --> W[\"expectedYearlyReturns = avgPnl × tradesPerYear\"]\n    F --> W\n    \n    H --> X[\"isUnsafe() check\"]\n    F --> X\n    G --> X\n    K --> X\n    M --> X\n    N --> X\n    R --> X\n    W --> X\n    \n    X --> Y[\"Return BacktestStatisticsModel<br/>null for unsafe values\"]\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:100-168]()\n\n### Safe Math Enforcement\n\nAll numeric metrics return `null` if the calculated value is `NaN`, `Infinity`, or non-finite. The `isUnsafe()` helper function [BacktestMarkdownService.ts:56-67]() performs validation:\n\n```typescript\nfunction isUnsafe(value: number | null): boolean {\n  if (typeof value !== \"number\") return true;\n  if (isNaN(value)) return true;\n  if (!isFinite(value)) return true;\n  return false;\n}\n```\n\nThis ensures reports display \"N/A\" instead of invalid numeric values.\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:56-67](), [src/lib/services/markdown/BacktestMarkdownService.ts:159-166]()\n\n---\n\n## LiveStatisticsModel\n\nThe `LiveStatisticsModel` extends backtest statistics with real-time event tracking, including idle and active states.\n\n### Structure Differences\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `eventList` | `TickEvent[]` | All events: idle, opened, active, closed |\n| `totalEvents` | `number` | Count of all events (not just closed) |\n| `totalClosed` | `number` | Count of closed signals only |\n| *(inherits)* | | All `BacktestStatisticsModel` fields |\n\nThe `TickEvent` type (defined in [src/model/LiveStatistics.model.ts]()) supports discriminated union based on `action` field:\n\n- `\"idle\"`: No active signal\n- `\"opened\"`: Signal just created\n- `\"active\"`: Signal being monitored (with `percentTp`, `percentSl`)\n- `\"closed\"`: Signal completed (with `pnl`, `closeReason`, `duration`)\n\n**Sources:** [src/lib/services/markdown/LiveMarkdownService.ts:223-306](), [src/model/LiveStatistics.model.ts]()\n\n### Event Replacement Strategy\n\nThe `LiveMarkdownService.ReportStorage` implements intelligent event deduplication to prevent memory bloat:\n\n1. **Idle events**: Replace last idle event if no opened/active events follow it [LiveMarkdownService.ts:88-114]()\n2. **Active events**: Replace last active event with same `signalId` [LiveMarkdownService.ts:148-182]()\n3. **Opened/Closed events**: Always insert new [LiveMarkdownService.ts:122-140](), [LiveMarkdownService.ts:189-215]()\n\nThis maintains a 250-event maximum per symbol-strategy pair [LiveMarkdownService.ts:72]() while preserving event history.\n\n**Sources:** [src/lib/services/markdown/LiveMarkdownService.ts:78-215]()\n\n---\n\n## WalkerStatisticsModel\n\nThe `WalkerStatisticsModel` aggregates results from multiple strategy backtests for comparison.\n\n### Structure\n\n```mermaid\nclassDiagram\n    class WalkerStatisticsModel {\n        +string walkerName\n        +string symbol\n        +string exchangeName\n        +string frameName\n        +WalkerMetric metric\n        +number totalStrategies\n        +string|null bestStrategy\n        +number|null bestMetric\n        +BacktestStatisticsModel|null bestStats\n        +IStrategyResult[] strategyResults\n    }\n    \n    class IStrategyResult {\n        +string strategyName\n        +BacktestStatisticsModel stats\n        +number|null metricValue\n    }\n    \n    class SignalData {\n        +string strategyName\n        +string signalId\n        +string symbol\n        +string position\n        +number pnl\n        +StrategyCloseReason closeReason\n        +number openTime\n        +number closeTime\n    }\n    \n    WalkerStatisticsModel \"1\" --> \"*\" IStrategyResult : strategyResults\n    IStrategyResult --> \"1\" BacktestStatisticsModel : stats\n    BacktestStatisticsModel --> \"*\" SignalData : extracted from signalList\n```\n\n**Sources:** [src/model/WalkerStatistics.model.ts](), [src/lib/services/markdown/WalkerMarkdownService.ts:124-192]()\n\n### Calculation Flow\n\nThe `WalkerMarkdownService.ReportStorage` [WalkerMarkdownService.ts:124-192]() accumulates strategy results incrementally:\n\n1. Each `WalkerContract` event [WalkerMarkdownService.ts:144-158]() adds a strategy result\n2. Best strategy is tracked by comparing `metricValue` fields\n3. `getData()` returns final aggregated model with all strategy results sorted by metric\n\nThe `WalkerMetric` type defines comparison criteria:\n\n```typescript\ntype WalkerMetric = \n  | \"sharpeRatio\" \n  | \"annualizedSharpeRatio\" \n  | \"winRate\" \n  | \"totalPnl\" \n  | \"certaintyRatio\" \n  | \"avgPnl\" \n  | \"expectedYearlyReturns\";\n```\n\n**Higher values always indicate better performance** for all metrics.\n\n**Sources:** [types.d.ts:949](), [src/lib/services/markdown/WalkerMarkdownService.ts:124-192]()\n\n---\n\n## ScheduleStatisticsModel\n\nThe `ScheduleStatisticsModel` tracks scheduled signal lifecycle events: creation, activation, and cancellation.\n\n### Structure\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `eventList` | `ScheduledEvent[]` | All scheduled/opened/cancelled events |\n| `totalEvents` | `number` | Count of all events |\n| `totalScheduled` | `number` | Count of scheduled signals |\n| `totalOpened` | `number` | Count of activated signals |\n| `totalCancelled` | `number` | Count of cancelled signals |\n| `cancellationRate` | `number \\| null` | `(totalCancelled / totalScheduled) × 100` |\n| `activationRate` | `number \\| null` | `(totalOpened / totalScheduled) × 100` |\n| `avgWaitTime` | `number \\| null` | Average minutes until cancellation |\n| `avgActivationTime` | `number \\| null` | Average minutes until activation |\n\n**Sources:** [src/model/ScheduleStatistics.model.ts](), [src/lib/services/markdown/ScheduleMarkdownService.ts:156-218]()\n\n### Event Processing Logic\n\nThe service [ScheduleMarkdownService.ts:351-369]() filters events intelligently:\n\n- **Scheduled events**: Directly added [ScheduleMarkdownService.ts:358-359]()\n- **Opened events**: Only added if `scheduledAt ≠ pendingAt` [ScheduleMarkdownService.ts:360-366]() (indicates it was scheduled first)\n- **Cancelled events**: Always added [ScheduleMarkdownService.ts:367-368]()\n\nThis prevents double-counting immediate signals that were never scheduled.\n\n**Sources:** [src/lib/services/markdown/ScheduleMarkdownService.ts:59-301]()\n\n---\n\n## PartialStatisticsModel\n\nThe `PartialStatisticsModel` tracks profit and loss milestone events (10%, 20%, 30%, etc.) during active signal monitoring.\n\n### Structure\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `eventList` | `PartialEvent[]` | All profit/loss milestone events |\n| `totalEvents` | `number` | Count of all milestone events |\n| `totalProfit` | `number` | Count of profit milestone events |\n| `totalLoss` | `number` | Count of loss milestone events |\n\nEach `PartialEvent` contains:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `timestamp` | `number` | Event timestamp in milliseconds |\n| `action` | `\"profit\" \\| \"loss\"` | Event type |\n| `symbol` | `string` | Trading pair |\n| `strategyName` | `string` | Strategy name |\n| `signalId` | `string` | Signal identifier |\n| `position` | `\"long\" \\| \"short\"` | Trade direction |\n| `currentPrice` | `number` | Market price at milestone |\n| `level` | `PartialLevel` | Milestone level (10, 20, ..., 100) |\n| `backtest` | `boolean` | Execution mode |\n\n**Sources:** [src/model/PartialStatistics.model.ts](), [src/lib/services/markdown/PartialMarkdownService.ts:60-154]()\n\n### Deduplication via Set-Based Tracking\n\nPartial events are emitted by `ClientPartial` [types.d.ts:548-639]() which uses Set-based deduplication to ensure each level emits only once per signal. The markdown service simply accumulates these deduplicated events.\n\n**Sources:** [src/lib/services/markdown/PartialMarkdownService.ts:60-154](), [types.d.ts:548-639]()\n\n---\n\n## RiskStatisticsModel\n\nThe `RiskStatisticsModel` aggregates risk rejection events when signals fail validation checks.\n\n### Structure\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `eventList` | `RiskEvent[]` | All rejection events |\n| `totalRejections` | `number` | Count of rejected signals |\n| `bySymbol` | `Record<string, number>` | Rejection count per symbol |\n| `byStrategy` | `Record<string, number>` | Rejection count per strategy |\n\nEach `RiskEvent` contains:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `symbol` | `string` | Trading pair |\n| `strategyName` | `string` | Strategy name |\n| `timestamp` | `number` | Rejection timestamp |\n| `activePositionCount` | `number` | Active positions at rejection |\n| `comment` | `string` | Rejection reason |\n\n**Sources:** [src/model/RiskStatistics.model.ts](), [src/lib/services/markdown/RiskMarkdownService.ts:52-99]()\n\n### Aggregation Logic\n\nThe `getData()` method [RiskMarkdownService.ts:75-99]() iterates through all rejection events and builds aggregation maps:\n\n```typescript\nconst bySymbol: Record<string, number> = {};\nconst byStrategy: Record<string, number> = {};\n\nfor (const event of this._eventList) {\n  bySymbol[event.symbol] = (bySymbol[event.symbol] || 0) + 1;\n  byStrategy[event.strategyName] = (byStrategy[event.strategyName] || 0) + 1;\n}\n```\n\nThis enables identification of which symbols or strategies trigger rejections most frequently.\n\n**Sources:** [src/lib/services/markdown/RiskMarkdownService.ts:75-99]()\n\n---\n\n## PerformanceStatisticsModel\n\nThe `PerformanceStatisticsModel` aggregates execution timing metrics for profiling and bottleneck detection.\n\n### Structure\n\n```mermaid\nclassDiagram\n    class PerformanceStatisticsModel {\n        +string strategyName\n        +number totalEvents\n        +number totalDuration\n        +Record~string_MetricStats~ metricStats\n        +PerformanceContract[] events\n    }\n    \n    class MetricStats {\n        +string metricType\n        +number count\n        +number totalDuration\n        +number avgDuration\n        +number minDuration\n        +number maxDuration\n        +number stdDev\n        +number median\n        +number p95\n        +number p99\n        +number avgWaitTime\n        +number minWaitTime\n        +number maxWaitTime\n    }\n    \n    class PerformanceContract {\n        +string|null symbol\n        +string|null strategyName\n        +PerformanceMetricType metricType\n        +number timestamp\n        +number|null previousTimestamp\n        +number duration\n    }\n    \n    PerformanceStatisticsModel \"1\" --> \"*\" MetricStats : metricStats\n    PerformanceStatisticsModel \"1\" --> \"*\" PerformanceContract : events\n```\n\n**Sources:** [src/model/PerformanceStatistics.model.ts](), [src/contract/Performance.contract.ts]()\n\n### Percentile Calculation\n\nThe service [PerformanceMarkdownService.ts:68-72]() includes a percentile helper:\n\n```typescript\nfunction percentile(sortedArray: number[], p: number): number {\n  if (sortedArray.length === 0) return 0;\n  const index = Math.ceil((sortedArray.length * p) / 100) - 1;\n  return sortedArray[Math.max(0, index)];\n}\n```\n\nThis computes P95 and P99 response times for each `PerformanceMetricType`:\n\n- `\"backtest.getSignal\"`: Signal generation duration\n- `\"backtest.tick\"`: Tick processing duration\n- `\"backtest.backtest\"`: Fast backtest duration\n- `\"live.tick\"`: Live tick processing duration\n- And others defined by the system\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:68-72](), [src/lib/services/markdown/PerformanceMarkdownService.ts:104-184]()\n\n---\n\n## HeatmapStatisticsModel\n\nThe `HeatmapStatisticsModel` provides portfolio-wide aggregation across all symbols for a strategy.\n\n### Structure\n\n```mermaid\nclassDiagram\n    class HeatmapStatisticsModel {\n        +IHeatmapRow[] symbols\n        +number totalSymbols\n        +number|null portfolioTotalPnl\n        +number|null portfolioSharpeRatio\n        +number portfolioTotalTrades\n    }\n    \n    class IHeatmapRow {\n        +string symbol\n        +number|null totalPnl\n        +number|null sharpeRatio\n        +number|null maxDrawdown\n        +number totalTrades\n        +number winCount\n        +number lossCount\n        +number|null winRate\n        +number|null avgPnl\n        +number|null stdDev\n        +number|null profitFactor\n        +number|null avgWin\n        +number|null avgLoss\n        +number maxWinStreak\n        +number maxLossStreak\n        +number|null expectancy\n    }\n    \n    HeatmapStatisticsModel \"1\" --> \"*\" IHeatmapRow : symbols\n```\n\n**Sources:** [src/model/HeatmapStatistics.model.ts](), [src/interfaces/Heatmap.interface.ts]()\n\n### Per-Symbol Calculation\n\nEach `IHeatmapRow` [HeatMarkdownService.ts:115-271]() is calculated independently from the symbol's closed signals:\n\n1. **Basic metrics**: Win rate, total PNL, average PNL\n2. **Volatility**: Standard deviation\n3. **Risk-adjusted**: Sharpe Ratio\n4. **Drawdown**: Maximum consecutive loss from peak\n5. **Win/Loss analysis**: Profit factor, average win/loss\n6. **Streaks**: Maximum consecutive wins/losses\n7. **Expectancy**: `(winRate × avgWin) + (lossRate × avgLoss)`\n\nAll metrics undergo safe math validation [HeatMarkdownService.ts:242-251]().\n\n**Sources:** [src/lib/services/markdown/HeatMarkdownService.ts:115-271]()\n\n### Portfolio Aggregation\n\nPortfolio-wide metrics [HeatMarkdownService.ts:278-330]() are computed as:\n\n- **portfolioTotalPnl**: Sum of all symbol PNLs\n- **portfolioSharpeRatio**: Trade-weighted average of symbol Sharpe Ratios\n- **portfolioTotalTrades**: Sum of all symbol trade counts\n\nSymbols are sorted by Sharpe Ratio descending (best performers first, nulls last).\n\n**Sources:** [src/lib/services/markdown/HeatMarkdownService.ts:278-330]()\n\n---\n\n## Common Calculation Patterns\n\nAll statistics models follow consistent implementation patterns across the markdown services.\n\n### Pattern 1: ReportStorage Classes\n\nEach markdown service contains an internal `ReportStorage` class that:\n\n1. Accumulates raw event data in private arrays/maps\n2. Implements `getData()` returning the statistics model\n3. Implements `getReport()` generating markdown tables\n4. Implements `dump()` saving reports to disk\n\n```mermaid\ngraph LR\n    A[\"Event Emitter<br/>(signalEmitter, etc.)\"] --> B[\"MarkdownService.tick()\"]\n    B --> C[\"ReportStorage.addEvent()\"]\n    C --> D[\"_eventList / _signalList<br/>(internal storage)\"]\n    D --> E[\"ReportStorage.getData()\"]\n    E --> F[\"StatisticsModel\"]\n    F --> G[\"ReportStorage.getReport()\"]\n    G --> H[\"Markdown String\"]\n    H --> I[\"ReportStorage.dump()\"]\n    I --> J[\"File System<br/>(./dump/*)\"]\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:76-253](), [src/lib/services/markdown/LiveMarkdownService.ts:78-391]()\n\n### Pattern 2: Memoized Storage Factory\n\nEach markdown service uses `memoize()` from `functools-kit` to cache storage instances per key:\n\n```typescript\nprivate getStorage = memoize<(symbol: string, strategyName: string) => ReportStorage>(\n  ([symbol, strategyName]) => `${symbol}:${strategyName}`,\n  () => new ReportStorage()\n);\n```\n\nThis ensures each symbol-strategy pair has isolated storage with a maximum of 250 events [BacktestMarkdownService.ts:70](), [LiveMarkdownService.ts:72]().\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:290-293](), [src/lib/services/markdown/LiveMarkdownService.ts:431-434]()\n\n### Pattern 3: Safe Math Validation\n\nAll statistics models return `null` for unsafe numeric values. Each service defines an `isUnsafe()` helper:\n\n```typescript\nfunction isUnsafe(value: number | null): boolean {\n  if (typeof value !== \"number\") return true;\n  if (isNaN(value)) return true;\n  if (!isFinite(value)) return true;\n  return false;\n}\n```\n\nThis is applied to all calculated metrics before returning the model:\n\n```typescript\nreturn {\n  // ...\n  winRate: isUnsafe(winRate) ? null : winRate,\n  avgPnl: isUnsafe(avgPnl) ? null : avgPnl,\n  sharpeRatio: isUnsafe(sharpeRatio) ? null : sharpeRatio,\n  // ...\n};\n```\n\nMarkdown reports display \"N/A\" for null values [BacktestMarkdownService.ts:215-222]().\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:56-67](), [src/lib/services/markdown/LiveMarkdownService.ts:58-69](), [src/lib/services/markdown/HeatMarkdownService.ts:62-73]()\n\n### Pattern 4: Singleshot Initialization\n\nAll markdown services use `singleshot()` from `functools-kit` to ensure event subscription happens exactly once:\n\n```typescript\nprotected init = singleshot(async () => {\n  this.loggerService.log(\"backtestMarkdownService init\");\n  signalBacktestEmitter.subscribe(this.tick);\n});\n```\n\nThis prevents duplicate subscriptions even if multiple instances are created or methods called multiple times.\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:457-460](), [src/lib/services/markdown/LiveMarkdownService.ts:605-608]()\n\n---\n\n## Statistics Model Export and Usage\n\nAll statistics models are exported from the main package entry point [src/index.ts:139-146]():\n\n```typescript\nexport { BacktestStatisticsModel } from \"./model/BacktestStatistics.model\";\nexport { LiveStatisticsModel } from \"./model/LiveStatistics.model\";\nexport { HeatmapStatisticsModel } from \"./model/HeatmapStatistics.model\";\nexport { ScheduleStatisticsModel } from \"./model/ScheduleStatistics.model\";\nexport { PerformanceStatisticsModel } from \"./model/PerformanceStatistics.model\";\nexport { WalkerStatisticsModel } from \"./model/WalkerStatistics.model\";\nexport { PartialStatisticsModel } from \"./model/PartialStatistics.model\";\nexport { RiskStatisticsModel } from \"./model/RiskStatistics.model\";\n```\n\nThese TypeScript interfaces are used by:\n\n1. Markdown services for type-safe statistics calculation\n2. Public API classes (`Backtest`, `Live`, `Walker`, etc.) for `getData()` return types\n3. External consumers for type checking and autocomplete\n\nAll models are accessed via the public API classes documented in [Reporting Classes API](#12.3).\n\n**Sources:** [src/index.ts:139-146](), [types.d.ts:918-943]()"
                    },
                    {
                        "page_plan": {
                            "id": "9.4",
                            "title": "Performance Tracking"
                        },
                        "content": "# Performance Tracking\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/lib/services/markdown/BacktestMarkdownService.ts](src/lib/services/markdown/BacktestMarkdownService.ts)\n- [src/lib/services/markdown/HeatMarkdownService.ts](src/lib/services/markdown/HeatMarkdownService.ts)\n- [src/lib/services/markdown/LiveMarkdownService.ts](src/lib/services/markdown/LiveMarkdownService.ts)\n- [src/lib/services/markdown/PartialMarkdownService.ts](src/lib/services/markdown/PartialMarkdownService.ts)\n- [src/lib/services/markdown/PerformanceMarkdownService.ts](src/lib/services/markdown/PerformanceMarkdownService.ts)\n- [src/lib/services/markdown/RiskMarkdownService.ts](src/lib/services/markdown/RiskMarkdownService.ts)\n- [src/lib/services/markdown/ScheduleMarkdownService.ts](src/lib/services/markdown/ScheduleMarkdownService.ts)\n- [src/lib/services/markdown/WalkerMarkdownService.ts](src/lib/services/markdown/WalkerMarkdownService.ts)\n- [src/model/Column.model.ts](src/model/Column.model.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nPerformance tracking provides execution timing metrics for profiling strategy operations and identifying bottlenecks. The framework emits performance events during strategy execution, accumulates them per symbol-strategy pair, and calculates statistical metrics including average duration, percentiles, and wait times between operations.\n\nThis page covers performance event emission, event listening, statistics calculation, and report generation. For general event system architecture, see [9.1 Event Listeners](#9.1). For other monitoring capabilities, see [9.2 Markdown Reports](#9.2) and [9.3 Statistics Models](#9.3).\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:1-460](), [types.d.ts:156-160]()\n\n---\n\n## Performance Event Flow\n\nThe following diagram illustrates how performance events flow from emission through the event system to storage and report generation.\n\n```mermaid\ngraph TB\n    subgraph \"Event Emission\"\n        STRAT_EXEC[\"Strategy Execution<br/>(ClientStrategy, StrategyCoreService)\"]\n        BT_EXEC[\"Backtest Execution<br/>(BacktestLogicPrivateService)\"]\n        LIVE_EXEC[\"Live Execution<br/>(LiveLogicPrivateService)\"]\n    end\n    \n    subgraph \"Event System\"\n        PERF_EMIT[\"performanceEmitter<br/>Subject&lt;PerformanceContract&gt;<br/>src/config/emitters.ts:86\"]\n    end\n    \n    subgraph \"Public API\"\n        LISTEN[\"listenPerformance()<br/>src/function/event.ts\"]\n    end\n    \n    subgraph \"Performance Service\"\n        PERF_SVC[\"PerformanceMarkdownService<br/>src/lib/services/markdown/<br/>PerformanceMarkdownService.ts:312\"]\n        TRACK[\"track() method<br/>Subscribe to performanceEmitter\"]\n    end\n    \n    subgraph \"Storage Layer\"\n        STORAGE[\"PerformanceStorage<br/>Memoized per symbol:strategyName<br/>Max 10,000 events\"]\n        ADD[\"addEvent()<br/>FIFO queue with trimming\"]\n    end\n    \n    subgraph \"Statistics Calculation\"\n        GET_DATA[\"getData()<br/>Groups by metricType<br/>Calculates aggregates\"]\n        METRICS[\"MetricStats<br/>avg, min, max, stdDev<br/>median, p95, p99<br/>wait times\"]\n    end\n    \n    subgraph \"Report Generation\"\n        GET_REPORT[\"getReport()<br/>Markdown formatting\"]\n        DUMP[\"dump()<br/>File: ./dump/performance/<br/>{strategyName}.md\"]\n    end\n    \n    STRAT_EXEC --> PERF_EMIT\n    BT_EXEC --> PERF_EMIT\n    LIVE_EXEC --> PERF_EMIT\n    \n    PERF_EMIT --> LISTEN\n    PERF_EMIT --> TRACK\n    \n    TRACK --> STORAGE\n    STORAGE --> ADD\n    \n    STORAGE --> GET_DATA\n    GET_DATA --> METRICS\n    \n    METRICS --> GET_REPORT\n    GET_REPORT --> DUMP\n    \n    style PERF_EMIT fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style STORAGE fill:#f0f0f0,stroke:#333,stroke-width:2px\n    style METRICS fill:#e8e8e8,stroke:#333,stroke-width:2px\n```\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:312-460](), [src/config/emitters.ts:82-86](), [src/function/event.ts:531-556]()\n\n---\n\n## PerformanceContract Structure\n\nPerformance events use the `PerformanceContract` type to capture timing information and context.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `metricType` | `PerformanceMetricType` | Category of operation being measured (e.g., \"tick\", \"getSignal\", \"getCandles\") |\n| `duration` | `number` | Execution time in milliseconds |\n| `timestamp` | `number` | Unix timestamp when operation completed |\n| `previousTimestamp` | `number \\| null` | Timestamp of previous event of same metricType (for wait time calculation) |\n| `symbol` | `string \\| null` | Trading pair symbol if operation is symbol-specific |\n| `strategyName` | `string \\| null` | Strategy name if operation is strategy-specific |\n\n**PerformanceMetricType** is a string union representing operation categories:\n- Framework typically uses values like: `\"tick\"`, `\"backtest\"`, `\"getSignal\"`, `\"getCandles\"`, `\"getAveragePrice\"`\n- Custom strategies can emit custom metric types\n\n**Sources:** [types.d.ts:156-160](), [src/contract/Performance.contract.ts]()\n\n---\n\n## Emitting Performance Events\n\nPerformance events are emitted by calling `emit()` on the `performanceEmitter` Subject. The framework automatically emits events during strategy execution, but custom code can also emit events.\n\n```typescript\nimport { performanceEmitter } from \"backtest-kit\";\n\n// Emit a performance event\nconst startTime = Date.now();\n// ... perform operation ...\nconst duration = Date.now() - startTime;\n\nperformanceEmitter.emit({\n  metricType: \"custom_operation\",\n  duration,\n  timestamp: Date.now(),\n  previousTimestamp: null, // Set if tracking wait times\n  symbol: \"BTCUSDT\",\n  strategyName: \"my-strategy\"\n});\n```\n\nThe framework automatically emits events for:\n- **tick operations**: Each strategy tick execution\n- **backtest operations**: Fast backtest processing\n- **getSignal calls**: Signal generation timing\n- **getCandles calls**: Data fetching timing\n- **getAveragePrice calls**: VWAP calculation timing\n\n**Sources:** [src/config/emitters.ts:82-86](), [src/lib/services/markdown/PerformanceMarkdownService.ts:331-340]()\n\n---\n\n## Listening to Performance Events\n\nThe `listenPerformance()` function subscribes to performance events with queued async processing to ensure sequential execution.\n\n```typescript\nimport { listenPerformance } from \"backtest-kit\";\n\n// Subscribe to all performance events\nconst unsubscribe = listenPerformance((event) => {\n  console.log(`${event.metricType}: ${event.duration.toFixed(2)}ms`);\n  \n  if (event.duration > 1000) {\n    console.warn(`Slow operation detected: ${event.metricType}`);\n  }\n});\n\n// Later: stop listening\nunsubscribe();\n```\n\nThe callback receives a `PerformanceContract` object for each event. Events are processed sequentially even if the callback is async, preventing race conditions.\n\n**Sources:** [src/function/event.ts:531-556]()\n\n---\n\n## PerformanceMarkdownService Architecture\n\nThe following diagram shows the internal structure of `PerformanceMarkdownService` and how it manages storage.\n\n```mermaid\ngraph TB\n    subgraph \"PerformanceMarkdownService\"\n        SERVICE[\"PerformanceMarkdownService<br/>Singleton per DI container\"]\n        GET_STORAGE[\"getStorage()<br/>memoize&lt;symbol:strategyName&gt;\"]\n        TRACK_METHOD[\"track(event)<br/>Routes to storage\"]\n        GET_DATA_METHOD[\"getData(symbol, strategyName)<br/>Returns PerformanceStatisticsModel\"]\n        GET_REPORT_METHOD[\"getReport(symbol, strategyName)<br/>Returns markdown string\"]\n        DUMP_METHOD[\"dump(symbol, strategyName, path)<br/>Saves to filesystem\"]\n        CLEAR_METHOD[\"clear(ctx)<br/>Clears memoized storage\"]\n        INIT_METHOD[\"init()<br/>singleshot subscribe\"]\n    end\n    \n    subgraph \"PerformanceStorage (Memoized)\"\n        STORAGE_A[\"PerformanceStorage<br/>BTCUSDT:strategy-a\"]\n        STORAGE_B[\"PerformanceStorage<br/>ETHUSDT:strategy-b\"]\n        STORAGE_N[\"PerformanceStorage<br/>symbol:strategyName...\"]\n    end\n    \n    subgraph \"PerformanceStorage Internal\"\n        EVENTS_ARRAY[\"_events: PerformanceContract[]<br/>Max 10,000 events (FIFO)\"]\n        ADD_EVENT[\"addEvent(event)<br/>Unshift + trim if > MAX_EVENTS\"]\n        GET_DATA_STORAGE[\"getData(strategyName)<br/>Calculate statistics\"]\n        GET_REPORT_STORAGE[\"getReport(strategyName)<br/>Format markdown\"]\n        DUMP_STORAGE[\"dump(strategyName, path)<br/>Write to file\"]\n    end\n    \n    SERVICE --> GET_STORAGE\n    GET_STORAGE --> STORAGE_A\n    GET_STORAGE --> STORAGE_B\n    GET_STORAGE --> STORAGE_N\n    \n    TRACK_METHOD --> GET_STORAGE\n    GET_DATA_METHOD --> GET_STORAGE\n    GET_REPORT_METHOD --> GET_STORAGE\n    DUMP_METHOD --> GET_STORAGE\n    CLEAR_METHOD --> GET_STORAGE\n    \n    STORAGE_A --> EVENTS_ARRAY\n    STORAGE_A --> ADD_EVENT\n    STORAGE_A --> GET_DATA_STORAGE\n    STORAGE_A --> GET_REPORT_STORAGE\n    STORAGE_A --> DUMP_STORAGE\n    \n    INIT_METHOD -.->|subscribes to| TRACK_METHOD\n    \n    style SERVICE fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style GET_STORAGE fill:#e8e8e8,stroke:#333,stroke-width:2px\n    style EVENTS_ARRAY fill:#f0f0f0,stroke:#333,stroke-width:2px\n```\n\n**Key characteristics:**\n\n1. **Memoization**: Storage instances are cached per `symbol:strategyName` key using `functools-kit` `memoize`\n2. **FIFO Queue**: Events are stored in reverse chronological order (newest first) with a 10,000 event limit\n3. **Automatic Trimming**: When capacity is exceeded, oldest events are removed\n4. **Singleshot Init**: Service initializes once and subscribes to `performanceEmitter`\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:312-460](), [src/lib/services/markdown/PerformanceMarkdownService.ts:81-283]()\n\n---\n\n## Statistics Calculation\n\nThe `getData()` method calculates comprehensive statistics grouped by `metricType`. The following table describes each metric:\n\n| Metric | Calculation | Purpose |\n|--------|-------------|---------|\n| `count` | Number of events of this type | Volume of operations |\n| `totalDuration` | Sum of all durations | Total time spent |\n| `avgDuration` | Mean of durations | Average operation time |\n| `minDuration` | Minimum duration | Best case performance |\n| `maxDuration` | Maximum duration | Worst case performance |\n| `stdDev` | Standard deviation of durations | Consistency measure |\n| `median` | 50th percentile | Typical performance |\n| `p95` | 95th percentile | High-load threshold |\n| `p99` | 99th percentile | Outlier threshold |\n| `avgWaitTime` | Mean time between consecutive events | Operation frequency |\n| `minWaitTime` | Minimum inter-event time | Peak frequency |\n| `maxWaitTime` | Maximum inter-event time | Idle periods |\n\n**Percentile Calculation:**\n\n```typescript\nfunction percentile(sortedArray: number[], p: number): number {\n  if (sortedArray.length === 0) return 0;\n  const index = Math.ceil((sortedArray.length * p) / 100) - 1;\n  return sortedArray[Math.max(0, index)];\n}\n```\n\n**Wait Time Calculation:**\n\nWait times are computed using the `previousTimestamp` field:\n```typescript\nconst waitTime = event.timestamp - event.previousTimestamp;\n```\n\nThis measures the interval between consecutive events of the same `metricType`, helping identify:\n- Operation frequency patterns\n- Idle periods where no operations occur\n- Bottlenecks causing delays between operations\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:104-184](), [src/lib/services/markdown/PerformanceMarkdownService.ts:66-72]()\n\n---\n\n## PerformanceStatisticsModel Structure\n\nThe `getData()` method returns a `PerformanceStatisticsModel` object:\n\n```mermaid\ngraph LR\n    MODEL[\"PerformanceStatisticsModel\"]\n    \n    MODEL --> STRATEGY[\"strategyName: string\"]\n    MODEL --> TOTAL_EVENTS[\"totalEvents: number\"]\n    MODEL --> TOTAL_DURATION[\"totalDuration: number\"]\n    MODEL --> METRIC_STATS[\"metricStats: Record&lt;string, MetricStats&gt;\"]\n    MODEL --> EVENTS[\"events: PerformanceContract[]\"]\n    \n    METRIC_STATS --> MS1[\"metricStats['tick']\"]\n    METRIC_STATS --> MS2[\"metricStats['getSignal']\"]\n    METRIC_STATS --> MS3[\"metricStats['getCandles']\"]\n    METRIC_STATS --> MSN[\"metricStats[...]\"]\n    \n    MS1 --> FIELDS[\"metricType, count, totalDuration<br/>avgDuration, minDuration, maxDuration<br/>stdDev, median, p95, p99<br/>avgWaitTime, minWaitTime, maxWaitTime\"]\n    \n    style MODEL fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style METRIC_STATS fill:#e8e8e8,stroke:#333,stroke-width:2px\n    style FIELDS fill:#f0f0f0,stroke:#333,stroke-width:2px\n```\n\n**Sources:** [src/model/PerformanceStatistics.model.ts](), [types.d.ts:1-10000]()\n\n---\n\n## Using the Performance Class\n\nThe framework provides a `Performance` class as the public API for accessing performance data. This class internally uses `PerformanceMarkdownService`.\n\n```typescript\nimport { Performance } from \"backtest-kit\";\n\n// Get statistics for a symbol-strategy pair\nconst stats = await Performance.getData(\"BTCUSDT\", \"my-strategy\");\n\nconsole.log(`Total events: ${stats.totalEvents}`);\nconsole.log(`Total time: ${stats.totalDuration.toFixed(2)}ms`);\n\n// Analyze each metric type\nfor (const [metricType, metricStats] of Object.entries(stats.metricStats)) {\n  console.log(`\\n${metricType}:`);\n  console.log(`  Count: ${metricStats.count}`);\n  console.log(`  Avg: ${metricStats.avgDuration.toFixed(2)}ms`);\n  console.log(`  P95: ${metricStats.p95.toFixed(2)}ms`);\n  console.log(`  P99: ${metricStats.p99.toFixed(2)}ms`);\n}\n\n// Identify bottlenecks\nconst bottlenecks = Object.values(stats.metricStats)\n  .sort((a, b) => b.totalDuration - a.totalDuration)\n  .slice(0, 3);\n\nconsole.log(\"\\nTop 3 bottlenecks:\");\nbottlenecks.forEach((metric, i) => {\n  const pct = (metric.totalDuration / stats.totalDuration) * 100;\n  console.log(`${i+1}. ${metric.metricType}: ${pct.toFixed(1)}%`);\n});\n```\n\n**Sources:** [src/classes/Performance.ts](), [src/lib/services/markdown/PerformanceMarkdownService.ts:357-367]()\n\n---\n\n## Generating Performance Reports\n\nThe `getReport()` method generates a formatted markdown report with statistics tables.\n\n```typescript\nimport { Performance } from \"backtest-kit\";\n\n// Generate markdown report\nconst markdown = await Performance.getReport(\"BTCUSDT\", \"my-strategy\");\nconsole.log(markdown);\n\n// Save report to filesystem\nawait Performance.dump(\"BTCUSDT\", \"my-strategy\", \"./custom/path\");\n// Saves to: ./custom/path/my-strategy.md\n```\n\n**Report Structure:**\n\nThe generated markdown includes:\n\n1. **Header**: Strategy name and summary statistics\n2. **Time Distribution**: Percentage breakdown by metric type\n3. **Detailed Metrics Table**: Comprehensive statistics for each operation\n4. **Notes**: Explanation of metrics (P95/P99, wait times)\n\n**Example Report Output:**\n\n```markdown\n# Performance Report: my-strategy\n\n**Total events:** 1,234\n**Total execution time:** 45,678.92ms\n**Number of metric types:** 5\n\n## Time Distribution\n\n- **tick**: 45.2% (20,642.13ms total)\n- **getCandles**: 32.1% (14,652.84ms total)\n- **getSignal**: 18.3% (8,359.21ms total)\n\n## Detailed Metrics\n\n| Metric | Count | Avg (ms) | Min (ms) | Max (ms) | Median (ms) | P95 (ms) | P99 (ms) | Std Dev |\n|--------|-------|----------|----------|----------|-------------|----------|----------|---------|\n| tick | 500 | 41.28 | 12.34 | 156.78 | 38.45 | 87.21 | 124.56 | 18.92 |\n| getCandles | 150 | 97.69 | 45.12 | 234.56 | 89.23 | 178.34 | 212.45 | 42.18 |\n| getSignal | 500 | 16.72 | 5.67 | 89.34 | 14.23 | 34.56 | 56.78 | 12.45 |\n\n**Note:** All durations are in milliseconds. P95/P99 represent 95th and 99th percentile response times. Wait times show the interval between consecutive events of the same type.\n```\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:194-254](), [src/lib/services/markdown/PerformanceMarkdownService.ts:383-394]()\n\n---\n\n## Column Configuration\n\nPerformance report tables use the `ColumnModel` interface for customizable column formatting. Default columns are defined in `COLUMN_CONFIG.performance_columns`.\n\n```typescript\nimport { COLUMN_CONFIG } from \"backtest-kit\";\n\n// Use custom columns\nconst customColumns = [\n  {\n    key: \"metric\",\n    label: \"Operation\",\n    format: (stats: MetricStats) => stats.metricType,\n    isVisible: () => true\n  },\n  {\n    key: \"count\",\n    label: \"Count\",\n    format: (stats: MetricStats) => stats.count.toString(),\n    isVisible: () => true\n  },\n  {\n    key: \"avgDuration\",\n    label: \"Avg (ms)\",\n    format: (stats: MetricStats) => stats.avgDuration.toFixed(2),\n    isVisible: () => true\n  }\n];\n\nconst report = await Performance.getReport(\n  \"BTCUSDT\",\n  \"my-strategy\",\n  customColumns\n);\n```\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:14-47](), [src/config/columns.ts](), [src/model/Column.model.ts:1-39]()\n\n---\n\n## Clearing Performance Data\n\nThe `clear()` method removes accumulated performance data from memoized storage.\n\n```typescript\nimport { Performance } from \"backtest-kit\";\n\n// Clear specific symbol-strategy pair\nawait Performance.clear({\n  symbol: \"BTCUSDT\",\n  strategyName: \"my-strategy\"\n});\n\n// Clear all performance data\nawait Performance.clear();\n```\n\nClearing is useful when:\n- Starting a new backtest run with fresh metrics\n- Managing memory in long-running processes\n- Resetting data after configuration changes\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:434-452]()\n\n---\n\n## Integration with Strategy Execution\n\nPerformance tracking integrates seamlessly with the strategy execution pipeline. The framework automatically emits events at key execution points.\n\n```mermaid\ngraph TB\n    subgraph \"Strategy Execution Flow\"\n        TICK_START[\"Strategy tick begins<br/>(ClientStrategy.tick)\"]\n        GET_SIGNAL[\"Call getSignal()<br/>Emit: metricType='getSignal'\"]\n        GET_CANDLES[\"Fetch candles<br/>Emit: metricType='getCandles'\"]\n        VWAP[\"Calculate VWAP<br/>Emit: metricType='getAveragePrice'\"]\n        VALIDATE[\"Validate signal\"]\n        TICK_END[\"Tick completes<br/>Emit: metricType='tick'\"]\n    end\n    \n    subgraph \"Performance Tracking\"\n        START_TIMER[\"Start timestamp\"]\n        END_TIMER[\"End timestamp\"]\n        CALC_DURATION[\"duration = end - start\"]\n        EMIT[\"Emit PerformanceContract<br/>to performanceEmitter\"]\n    end\n    \n    TICK_START --> START_TIMER\n    \n    GET_SIGNAL --> START_TIMER\n    GET_SIGNAL --> END_TIMER\n    GET_SIGNAL --> CALC_DURATION\n    \n    GET_CANDLES --> START_TIMER\n    GET_CANDLES --> END_TIMER\n    GET_CANDLES --> CALC_DURATION\n    \n    VWAP --> START_TIMER\n    VWAP --> END_TIMER\n    VWAP --> CALC_DURATION\n    \n    CALC_DURATION --> EMIT\n    \n    TICK_END --> START_TIMER\n    TICK_END --> END_TIMER\n    TICK_END --> CALC_DURATION\n    \n    style START_TIMER fill:#f0f0f0,stroke:#333,stroke-width:2px\n    style EMIT fill:#e8e8e8,stroke:#333,stroke-width:2px\n```\n\n**Typical metricType values emitted during execution:**\n\n| metricType | Emitted By | Measures |\n|------------|-----------|----------|\n| `tick` | `ClientStrategy.tick()` | Complete tick cycle duration |\n| `backtest` | `ClientStrategy.backtest()` | Fast backtest processing time |\n| `getSignal` | Strategy execution | User's `getSignal()` function time |\n| `getCandles` | `ClientExchange.getCandles()` | Candle data fetching time |\n| `getAveragePrice` | `ClientExchange.getAveragePrice()` | VWAP calculation time |\n\nCustom strategies can emit additional metric types by calling `performanceEmitter.emit()` directly.\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:1-460](), [src/config/emitters.ts:82-86]()\n\n---\n\n## Safe Math and Error Handling\n\nPerformance statistics use safe math checks to handle edge cases:\n\n```typescript\nfunction isUnsafe(value: number): boolean {\n  if (typeof value !== \"number\") return true;\n  if (isNaN(value)) return true;\n  if (!isFinite(value)) return true;\n  return false;\n}\n```\n\nWhen calculations produce `NaN` or `Infinity` values:\n- The unsafe values are preserved (not converted to null)\n- Report formatting handles these gracefully\n- Percentile calculations return 0 for empty arrays\n\nThis ensures that performance reports remain stable even with:\n- Zero-duration operations\n- Empty event lists\n- Division by zero scenarios\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:49-63]()\n\n---\n\n## Storage Limits and Memory Management\n\n`PerformanceStorage` implements a fixed-size FIFO queue with a 10,000 event limit per symbol-strategy pair.\n\n```typescript\nconst MAX_EVENTS = 10000;\n\npublic addEvent(event: PerformanceContract) {\n  this._events.unshift(event);  // Add to front\n  \n  if (this._events.length > MAX_EVENTS) {\n    this._events.pop();  // Remove oldest\n  }\n}\n```\n\n**Memory characteristics:**\n\n- **Per-pair isolation**: Each `symbol:strategyName` combination has independent storage\n- **Automatic trimming**: Oldest events are discarded when capacity is reached\n- **Most recent first**: Events are stored newest-first for efficient access\n- **Memoization**: Storage instances are cached and reused\n\nFor long-running live trading or extensive backtests, the 10,000 event limit prevents unbounded memory growth while retaining sufficient recent history for analysis.\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:75-97]()\n\n---\n\n## Example: Bottleneck Detection Workflow\n\nThe following example demonstrates a complete workflow for detecting and analyzing performance bottlenecks:\n\n```typescript\nimport { \n  Backtest, \n  Performance, \n  listenPerformance \n} from \"backtest-kit\";\n\n// 1. Monitor real-time performance\nlistenPerformance((event) => {\n  if (event.duration > 100) {\n    console.warn(`Slow operation: ${event.metricType} took ${event.duration}ms`);\n  }\n});\n\n// 2. Run backtest\nconst results = await Backtest.run(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\",\n  frameName: \"1d-backtest\"\n});\n\n// 3. Analyze performance statistics\nconst stats = await Performance.getData(\"BTCUSDT\", \"my-strategy\");\n\n// 4. Identify bottlenecks\nconst sortedMetrics = Object.values(stats.metricStats)\n  .sort((a, b) => b.totalDuration - a.totalDuration);\n\nconsole.log(\"\\nPerformance Analysis:\");\nconsole.log(`Total execution time: ${stats.totalDuration.toFixed(2)}ms`);\nconsole.log(`Total operations: ${stats.totalEvents}`);\n\nconsole.log(\"\\nBottlenecks (by total time):\");\nsortedMetrics.forEach((metric, index) => {\n  const percentage = (metric.totalDuration / stats.totalDuration) * 100;\n  console.log(\n    `${index + 1}. ${metric.metricType}: ${percentage.toFixed(1)}% ` +\n    `(${metric.count} calls, ${metric.avgDuration.toFixed(2)}ms avg)`\n  );\n});\n\n// 5. Check outliers (P99)\nconsole.log(\"\\nP99 Response Times:\");\nsortedMetrics.forEach((metric) => {\n  if (metric.p99 > 200) {\n    console.warn(\n      `${metric.metricType}: P99=${metric.p99.toFixed(2)}ms (high outlier)`\n    );\n  }\n});\n\n// 6. Generate report\nawait Performance.dump(\"BTCUSDT\", \"my-strategy\");\nconsole.log(\"\\nReport saved to: ./dump/performance/my-strategy.md\");\n```\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:286-311](), [src/function/event.ts:531-556]()"
                    },
                    {
                        "page_plan": {
                            "id": "9.5",
                            "title": "Portfolio Heatmap"
                        },
                        "content": "# Portfolio Heatmap\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Heat.ts](src/classes/Heat.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Partial.ts](src/classes/Partial.ts)\n- [src/classes/Performance.ts](src/classes/Performance.ts)\n- [src/classes/Risk.ts](src/classes/Risk.ts)\n- [src/classes/Schedule.ts](src/classes/Schedule.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [src/lib/services/markdown/BacktestMarkdownService.ts](src/lib/services/markdown/BacktestMarkdownService.ts)\n- [src/lib/services/markdown/HeatMarkdownService.ts](src/lib/services/markdown/HeatMarkdownService.ts)\n- [src/lib/services/markdown/LiveMarkdownService.ts](src/lib/services/markdown/LiveMarkdownService.ts)\n- [src/lib/services/markdown/PartialMarkdownService.ts](src/lib/services/markdown/PartialMarkdownService.ts)\n- [src/lib/services/markdown/PerformanceMarkdownService.ts](src/lib/services/markdown/PerformanceMarkdownService.ts)\n- [src/lib/services/markdown/RiskMarkdownService.ts](src/lib/services/markdown/RiskMarkdownService.ts)\n- [src/lib/services/markdown/ScheduleMarkdownService.ts](src/lib/services/markdown/ScheduleMarkdownService.ts)\n- [src/lib/services/markdown/WalkerMarkdownService.ts](src/lib/services/markdown/WalkerMarkdownService.ts)\n- [src/model/Column.model.ts](src/model/Column.model.ts)\n- [test/spec/columns.test.mjs](test/spec/columns.test.mjs)\n\n</details>\n\n\n\nThe Portfolio Heatmap provides cross-symbol aggregation and visualization for a single strategy's performance across multiple trading pairs. It calculates per-symbol and portfolio-wide statistics including Total PNL, Sharpe Ratio, Maximum Drawdown, and trade counts. This enables traders to identify which symbols perform best with a given strategy and evaluate overall portfolio health.\n\nFor single symbol-strategy reporting, see [Markdown Reports](#9.2). For performance timing analysis, see [Performance Tracking](#9.4).\n\n---\n\n## Overview\n\nThe heatmap system aggregates closed signals from all symbols traded by a strategy and generates comprehensive portfolio-wide reports. Unlike per-symbol reports that show individual trade sequences, the heatmap presents a bird's-eye view of strategy performance distributed across multiple markets.\n\n**Key capabilities:**\n- Automatic accumulation of closed signals per strategy (up to 250 signals per symbol)\n- Real-time calculation of 15+ statistical metrics per symbol\n- Portfolio-wide aggregated metrics (weighted Sharpe Ratio, total PNL)\n- Markdown table generation sorted by performance\n- Safe math handling (NaN/Infinity protection)\n\nSources: [src/lib/services/markdown/HeatMarkdownService.ts:1-606](), [src/classes/Heat.ts:1-148]()\n\n---\n\n## System Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Event Source\"\n        SE[\"signalEmitter<br/>(global)\"]\n        CE[\"closed signals<br/>IStrategyTickResultClosed\"]\n    end\n    \n    subgraph \"HeatMarkdownService\"\n        INIT[\"init()<br/>singleshot subscription\"]\n        TICK[\"tick(IStrategyTickResult)<br/>filter action === 'closed'\"]\n        STORAGE[\"getStorage(strategyName)<br/>memoized per strategy\"]\n    end\n    \n    subgraph \"HeatmapStorage (per strategy)\"\n        MAP[\"symbolData: Map<string, IStrategyTickResultClosed[]>\"]\n        ADD[\"addSignal(data)<br/>unshift + trim to MAX_EVENTS\"]\n        CALC[\"calculateSymbolStats(symbol, signals)<br/>15+ metrics per symbol\"]\n        DATA[\"getData()<br/>aggregates + portfolio metrics\"]\n        REPORT[\"getReport(strategyName)<br/>markdown generation\"]\n        DUMP[\"dump(strategyName, path)<br/>file export\"]\n    end\n    \n    subgraph \"Heat Class (Public API)\"\n        GET_DATA[\"Heat.getData(strategyName)\"]\n        GET_REPORT[\"Heat.getReport(strategyName)\"]\n        DUMP_FILE[\"Heat.dump(strategyName, path)\"]\n    end\n    \n    subgraph \"Data Models\"\n        HEATMAP_MODEL[\"HeatmapStatisticsModel<br/>symbols: IHeatmapRow[]<br/>portfolioTotalPnl<br/>portfolioSharpeRatio\"]\n        ROW[\"IHeatmapRow<br/>per-symbol metrics\"]\n    end\n    \n    SE --> CE\n    CE --> INIT\n    INIT --> TICK\n    TICK --> STORAGE\n    STORAGE --> MAP\n    TICK --> ADD\n    ADD --> MAP\n    \n    MAP --> CALC\n    CALC --> DATA\n    DATA --> HEATMAP_MODEL\n    DATA --> REPORT\n    REPORT --> DUMP\n    \n    GET_DATA --> STORAGE\n    STORAGE --> DATA\n    GET_REPORT --> STORAGE\n    STORAGE --> REPORT\n    DUMP_FILE --> STORAGE\n    STORAGE --> DUMP\n    \n    HEATMAP_MODEL --> ROW\n    \n    style STORAGE fill:#f9f9f9\n    style MAP fill:#e1f5ff\n    style HEATMAP_MODEL fill:#fff3cd\n```\n\n**Flow:**\n1. `signalEmitter` broadcasts all closed signals from any strategy/symbol\n2. `HeatMarkdownService.tick()` filters for `action === \"closed\"`\n3. Signals are routed to memoized `HeatmapStorage` instances (one per strategy)\n4. `HeatmapStorage.addSignal()` accumulates signals in a `Map<symbol, signals[]>`\n5. `getData()` calculates per-symbol statistics and aggregates portfolio metrics\n6. `Heat` class provides convenient public API wrapping the service\n\nSources: [src/lib/services/markdown/HeatMarkdownService.ts:434-606](), [src/classes/Heat.ts:33-148]()\n\n---\n\n## Data Model\n\nThe heatmap uses a two-level statistical model: per-symbol rows and portfolio-wide aggregates.\n\n### IHeatmapRow (Per-Symbol Statistics)\n\nEach symbol gets a row containing 15 calculated metrics:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `symbol` | `string` | Trading pair identifier |\n| `totalPnl` | `number \\| null` | Sum of all PNL percentages |\n| `sharpeRatio` | `number \\| null` | Risk-adjusted returns (avgPnl / stdDev) |\n| `maxDrawdown` | `number \\| null` | Largest peak-to-trough decline |\n| `totalTrades` | `number` | Count of closed signals |\n| `winCount` | `number` | Trades with PNL > 0 |\n| `lossCount` | `number` | Trades with PNL < 0 |\n| `winRate` | `number \\| null` | (winCount / totalTrades) × 100 |\n| `avgPnl` | `number \\| null` | Mean PNL percentage |\n| `stdDev` | `number \\| null` | Standard deviation of returns |\n| `profitFactor` | `number \\| null` | Sum of wins / Sum of losses |\n| `avgWin` | `number \\| null` | Mean winning trade PNL |\n| `avgLoss` | `number \\| null` | Mean losing trade PNL |\n| `maxWinStreak` | `number` | Longest consecutive win sequence |\n| `maxLossStreak` | `number` | Longest consecutive loss sequence |\n| `expectancy` | `number \\| null` | Expected return per trade |\n\n### HeatmapStatisticsModel (Portfolio Aggregate)\n\n```typescript\ninterface HeatmapStatisticsModel {\n  symbols: IHeatmapRow[];           // All per-symbol rows\n  totalSymbols: number;             // Count of symbols traded\n  portfolioTotalPnl: number | null; // Sum of all symbol PNLs\n  portfolioSharpeRatio: number | null; // Trade-weighted Sharpe\n  portfolioTotalTrades: number;     // Sum of all trades\n}\n```\n\n**Safe Math:** All numeric fields are nullable. The `isUnsafe()` function [src/lib/services/markdown/HeatMarkdownService.ts:62-73]() checks for `NaN`, `Infinity`, or non-numeric values and converts them to `null` to prevent rendering issues.\n\nSources: [src/interfaces/Heatmap.interface.ts](), [src/model/HeatmapStatistics.model.ts](), [src/lib/services/markdown/HeatMarkdownService.ts:108-271]()\n\n---\n\n## Per-Symbol Statistics Calculation\n\nThe `calculateSymbolStats()` method [src/lib/services/markdown/HeatMarkdownService.ts:115-271]() processes each symbol's signal array independently.\n\n```mermaid\ngraph LR\n    SIGNALS[\"signals: IStrategyTickResultClosed[]\"]\n    \n    subgraph \"Basic Metrics\"\n        COUNT[\"totalTrades = signals.length\"]\n        WIN[\"winCount = filter(pnl > 0)\"]\n        LOSS[\"lossCount = filter(pnl < 0)\"]\n        RATE[\"winRate = (winCount / totalTrades) × 100\"]\n    end\n    \n    subgraph \"PNL Analysis\"\n        TOTAL[\"totalPnl = sum(all pnl)\"]\n        AVG[\"avgPnl = totalPnl / totalTrades\"]\n        VARIANCE[\"variance = sum((pnl - avgPnl)²) / count\"]\n        STD[\"stdDev = sqrt(variance)\"]\n    end\n    \n    subgraph \"Risk Metrics\"\n        SHARPE[\"sharpeRatio = avgPnl / stdDev\"]\n        DRAWDOWN[\"maxDrawdown = max cumulative decline\"]\n        PROFIT[\"profitFactor = sumWins / sumLosses\"]\n    end\n    \n    subgraph \"Win/Loss Analysis\"\n        AVGWIN[\"avgWin = sum(wins) / winCount\"]\n        AVGLOSS[\"avgLoss = sum(losses) / lossCount\"]\n        EXPECT[\"expectancy = (winRate × avgWin) + ((100-winRate) × avgLoss)\"]\n    end\n    \n    subgraph \"Streak Detection\"\n        WINSTREAK[\"maxWinStreak = longest consecutive wins\"]\n        LOSSSTREAK[\"maxLossStreak = longest consecutive losses\"]\n    end\n    \n    SIGNALS --> COUNT\n    SIGNALS --> WIN\n    SIGNALS --> LOSS\n    COUNT --> RATE\n    WIN --> RATE\n    \n    SIGNALS --> TOTAL\n    TOTAL --> AVG\n    AVG --> VARIANCE\n    VARIANCE --> STD\n    \n    AVG --> SHARPE\n    STD --> SHARPE\n    SIGNALS --> DRAWDOWN\n    WIN --> PROFIT\n    LOSS --> PROFIT\n    \n    WIN --> AVGWIN\n    LOSS --> AVGLOSS\n    RATE --> EXPECT\n    AVGWIN --> EXPECT\n    AVGLOSS --> EXPECT\n    \n    SIGNALS --> WINSTREAK\n    SIGNALS --> LOSSSTREAK\n```\n\n### Maximum Drawdown Algorithm\n\nThe drawdown calculation [src/lib/services/markdown/HeatMarkdownService.ts:158-178]() tracks cumulative PNL and measures the largest decline from peak:\n\n```typescript\nlet peak = 0;\nlet maxDD = 0;\n\nfor (const signal of signals) {\n  peak += signal.pnl.pnlPercentage;\n  if (peak > 0) {\n    // New peak, reset drawdown tracking\n  } else {\n    const currentDD = Math.abs(peak);\n    if (currentDD > maxDD) {\n      maxDD = currentDD;\n    }\n  }\n}\n```\n\nSources: [src/lib/services/markdown/HeatMarkdownService.ts:115-271]()\n\n---\n\n## Portfolio-Wide Aggregation\n\nThe `getData()` method [src/lib/services/markdown/HeatMarkdownService.ts:278-330]() aggregates per-symbol statistics into portfolio metrics.\n\n### Portfolio Total PNL\n\nSimple summation across all symbols:\n```typescript\nportfolioTotalPnl = symbols.reduce((acc, s) => acc + (s.totalPnl || 0), 0);\n```\n\n### Portfolio Sharpe Ratio (Trade-Weighted)\n\nWeighted by number of trades per symbol:\n```typescript\nconst validSharpes = symbols.filter(s => s.sharpeRatio !== null);\nconst weightedSum = validSharpes.reduce(\n  (acc, s) => acc + s.sharpeRatio! * s.totalTrades,\n  0\n);\nportfolioSharpeRatio = weightedSum / portfolioTotalTrades;\n```\n\nThis weighting ensures symbols with more trades have proportionally greater influence on the portfolio Sharpe Ratio.\n\n### Symbol Sorting\n\nSymbols are sorted by Sharpe Ratio descending before returning:\n```typescript\nsymbols.sort((a, b) => {\n  if (a.sharpeRatio === null && b.sharpeRatio === null) return 0;\n  if (a.sharpeRatio === null) return 1;  // Nulls last\n  if (b.sharpeRatio === null) return -1;\n  return b.sharpeRatio - a.sharpeRatio;  // Descending\n});\n```\n\nSources: [src/lib/services/markdown/HeatMarkdownService.ts:278-330]()\n\n---\n\n## Markdown Report Generation\n\nThe `getReport()` method [src/lib/services/markdown/HeatMarkdownService.ts:339-377]() produces formatted markdown with customizable columns.\n\n### Report Structure\n\n```\n# Portfolio Heatmap: {strategyName}\n\n**Total Symbols:** 5 | **Portfolio PNL:** +45.30% | **Portfolio Sharpe:** 1.85 | **Total Trades:** 120\n\n| Symbol | Total PNL | Sharpe | Max DD | Trades | Win Rate | Avg PNL | Profit Factor |\n|--------|-----------|--------|--------|--------|----------|---------|---------------|\n| BTCUSDT | +15.50% | 2.10 | -2.50% | 45 | 65.00% | +0.34% | 2.45 |\n| ETHUSDT | +12.30% | 1.85 | -3.10% | 38 | 60.00% | +0.32% | 2.10 |\n| ... | ... | ... | ... | ... | ... | ... | ... |\n```\n\n### Column Configuration\n\nDefault columns are defined in `COLUMN_CONFIG.heat_columns` [src/config/columns.ts](). Custom columns can be provided via the `columns` parameter:\n\n```typescript\ninterface ColumnModel<IHeatmapRow> {\n  key: string;\n  label: string;\n  format: (row: IHeatmapRow, index: number) => string | Promise<string>;\n  isVisible: () => boolean | Promise<boolean>;\n}\n```\n\nExample custom column:\n```typescript\nconst customColumn = {\n  key: \"symbol\",\n  label: \"Market\",\n  format: (row) => row.symbol.replace(\"USDT\", \" (Tether)\"),\n  isVisible: () => true\n};\n```\n\n### Column Visibility\n\nOnly columns with `isVisible() === true` are rendered. This allows dynamic column filtering based on runtime conditions.\n\nSources: [src/lib/services/markdown/HeatMarkdownService.ts:339-377](), [src/config/columns.ts](), [src/model/Column.model.ts:1-39]()\n\n---\n\n## Usage Examples\n\n### Basic Data Retrieval\n\n```typescript\nimport { Heat } from \"backtest-kit\";\n\n// Get raw statistics\nconst stats = await Heat.getData(\"my-strategy\");\n\nconsole.log(`Portfolio PNL: ${stats.portfolioTotalPnl}%`);\nconsole.log(`Portfolio Sharpe: ${stats.portfolioSharpeRatio}`);\nconsole.log(`Total Symbols: ${stats.totalSymbols}`);\n\n// Iterate per-symbol data\nstats.symbols.forEach(row => {\n  console.log(`${row.symbol}: ${row.totalPnl}% (${row.totalTrades} trades)`);\n});\n```\n\n### Generating Reports\n\n```typescript\n// Get markdown report with default columns\nconst markdown = await Heat.getReport(\"my-strategy\");\nconsole.log(markdown);\n\n// Save to disk (default: ./dump/heatmap/my-strategy.md)\nawait Heat.dump(\"my-strategy\");\n\n// Custom directory\nawait Heat.dump(\"my-strategy\", \"./reports\");\n```\n\n### Custom Column Configuration\n\n```typescript\nimport { Heat } from \"backtest-kit\";\n\nconst customColumns = [\n  {\n    key: \"symbol\",\n    label: \"Symbol\",\n    format: (row) => row.symbol,\n    isVisible: () => true\n  },\n  {\n    key: \"totalPnl\",\n    label: \"P&L\",\n    format: (row) => row.totalPnl !== null \n      ? `${row.totalPnl > 0 ? '+' : ''}${row.totalPnl.toFixed(2)}%`\n      : \"N/A\",\n    isVisible: () => true\n  },\n  {\n    key: \"sharpe\",\n    label: \"Sharpe\",\n    format: (row) => row.sharpeRatio !== null\n      ? row.sharpeRatio.toFixed(2)\n      : \"N/A\",\n    isVisible: () => true\n  }\n];\n\nconst report = await Heat.getReport(\"my-strategy\", customColumns);\nawait Heat.dump(\"my-strategy\", \"./reports\", customColumns);\n```\n\n### Filtering Top Performers\n\n```typescript\nconst stats = await Heat.getData(\"my-strategy\");\n\n// Top 5 by Sharpe Ratio\nconst topSymbols = stats.symbols\n  .filter(s => s.sharpeRatio !== null)\n  .slice(0, 5);\n\ntopSymbols.forEach((row, i) => {\n  console.log(`${i+1}. ${row.symbol}: Sharpe ${row.sharpeRatio}`);\n});\n\n// Symbols with negative PNL\nconst losers = stats.symbols.filter(s => s.totalPnl !== null && s.totalPnl < 0);\nconsole.log(`Underperforming symbols: ${losers.length}`);\n```\n\nSources: [src/classes/Heat.ts:33-148](), [test/spec/columns.test.mjs:1-218]()\n\n---\n\n## Storage and Memory Management\n\n### Memoization Strategy\n\n`HeatMarkdownService` uses a memoized storage factory [src/lib/services/markdown/HeatMarkdownService.ts:442-445]():\n\n```typescript\nprivate getStorage = memoize<(strategyName: string) => HeatmapStorage>(\n  ([strategyName]) => `${strategyName}`,\n  () => new HeatmapStorage()\n);\n```\n\nEach strategy gets exactly one `HeatmapStorage` instance. Multiple calls with the same strategy name return the same instance.\n\n### Per-Symbol Signal Limits\n\nEach symbol within a strategy is limited to `MAX_EVENTS = 250` signals [src/lib/services/markdown/HeatMarkdownService.ts:76]():\n\n```typescript\npublic addSignal(data: IStrategyTickResultClosed) {\n  const { symbol } = data;\n  \n  if (!this.symbolData.has(symbol)) {\n    this.symbolData.set(symbol, []);\n  }\n  \n  const signals = this.symbolData.get(symbol)!;\n  signals.unshift(data);  // Add to front (most recent)\n  \n  if (signals.length > MAX_EVENTS) {\n    signals.pop();  // Remove oldest\n  }\n}\n```\n\nFor a strategy trading 10 symbols, maximum memory usage is 2,500 signals total.\n\n### Clearing Data\n\nThe service provides a `clear()` method [src/lib/services/markdown/HeatMarkdownService.ts:579-591]():\n\n```typescript\n// Clear specific strategy\nawait heatMarkdownService.clear(\"my-strategy\");\n\n// Clear all strategies\nawait heatMarkdownService.clear();\n```\n\nThis is useful for:\n- Freeing memory between test runs\n- Resetting statistics mid-session\n- Isolating multiple backtest executions\n\nSources: [src/lib/services/markdown/HeatMarkdownService.ts:82-105](), [src/lib/services/markdown/HeatMarkdownService.ts:442-445](), [src/lib/services/markdown/HeatMarkdownService.ts:579-591]()\n\n---\n\n## Event System Integration\n\n```mermaid\nsequenceDiagram\n    participant ST as ClientStrategy\n    participant SE as signalEmitter\n    participant HMS as HeatMarkdownService\n    participant HS as HeatmapStorage\n    participant BMS as BacktestMarkdownService\n    participant LMS as LiveMarkdownService\n    \n    Note over HMS: init() subscribes once\n    HMS->>SE: signalEmitter.subscribe(tick)\n    \n    Note over ST: Signal closes\n    ST->>SE: emit(closed signal)\n    \n    SE->>HMS: tick(IStrategyTickResultClosed)\n    HMS->>HMS: filter: action === \"closed\"\n    HMS->>HMS: getStorage(strategyName)\n    HMS->>HS: addSignal(data)\n    HS->>HS: symbolData.get(symbol).push()\n    \n    Note over SE: Parallel subscriptions\n    SE->>BMS: tick(closed signal)\n    SE->>LMS: tick(closed signal)\n    \n    Note over HMS: Later: user requests report\n    ST->>HMS: Heat.getData(\"strategy\")\n    HMS->>HS: getData()\n    HS->>HS: calculateSymbolStats() for each\n    HS->>HS: aggregate portfolio metrics\n    HS-->>HMS: HeatmapStatisticsModel\n    HMS-->>ST: return stats\n```\n\n### Subscription Lifecycle\n\nThe service uses `singleshot` initialization [src/lib/services/markdown/HeatMarkdownService.ts:593-606]():\n\n```typescript\nprotected init = singleshot(async () => {\n  this.loggerService.log(\"heatMarkdownService init\");\n  signalEmitter.subscribe(this.tick);\n});\n```\n\nThis ensures subscription happens exactly once, even if multiple methods are called concurrently. The `init()` is automatically triggered on first use via the `singleshot` wrapper.\n\n### Event Filtering\n\nThe `tick()` method [src/lib/services/markdown/HeatMarkdownService.ts:455-466]() filters incoming events:\n\n```typescript\nprivate tick = async (data: IStrategyTickResult) => {\n  if (data.action !== \"closed\") {\n    return;  // Ignore idle, scheduled, opened, active, cancelled\n  }\n  \n  const storage = this.getStorage(data.strategyName);\n  storage.addSignal(data);\n};\n```\n\nOnly closed signals contribute to heatmap statistics. This ensures:\n- No double-counting of active positions\n- Accurate PNL calculations (only realized gains/losses)\n- Consistent statistics across live and backtest modes\n\n### Parallel Processing\n\nMultiple markdown services subscribe to `signalEmitter` simultaneously:\n- `BacktestMarkdownService` - per symbol-strategy reports\n- `LiveMarkdownService` - real-time event logs\n- `HeatMarkdownService` - cross-symbol aggregation\n- `ScheduleMarkdownService` - scheduled signal tracking\n\nEach service filters events independently and maintains separate storage.\n\nSources: [src/lib/services/markdown/HeatMarkdownService.ts:455-466](), [src/lib/services/markdown/HeatMarkdownService.ts:593-606](), [src/config/emitters.ts]()\n\n---\n\n## File Export\n\nThe `dump()` method [src/lib/services/markdown/HeatMarkdownService.ts:386-405]() writes reports to disk:\n\n```typescript\npublic async dump(\n  strategyName: StrategyName,\n  path = \"./dump/heatmap\",\n  columns: Columns[] = COLUMN_CONFIG.heat_columns\n): Promise<void> {\n  const markdown = await this.getReport(strategyName, columns);\n  \n  try {\n    const dir = join(process.cwd(), path);\n    await mkdir(dir, { recursive: true });  // Create if missing\n    \n    const filename = `${strategyName}.md`;\n    const filepath = join(dir, filename);\n    \n    await writeFile(filepath, markdown, \"utf-8\");\n    console.log(`Heatmap report saved: ${filepath}`);\n  } catch (error) {\n    console.error(`Failed to save heatmap report:`, error);\n  }\n}\n```\n\n**Filename convention:** `{strategyName}.md`\n\n**Directory structure:**\n```\n./dump/\n  heatmap/\n    my-strategy.md\n    another-strategy.md\n  backtest/\n    BTCUSDT_my-strategy.md\n  live/\n    BTCUSDT_my-strategy.md\n```\n\nThe heatmap uses strategy name only (not symbol) because it aggregates across all symbols.\n\nSources: [src/lib/services/markdown/HeatMarkdownService.ts:386-405]()\n\n---\n\n## Integration with Public API\n\nThe `Heat` class [src/classes/Heat.ts:1-148]() provides the public-facing API:\n\n```mermaid\ngraph TD\n    subgraph \"Public API (src/classes/Heat.ts)\"\n        HEAT[\"Heat (singleton instance)\"]\n        GET_DATA[\"getData(strategyName)\"]\n        GET_REPORT[\"getReport(strategyName, columns?)\"]\n        DUMP[\"dump(strategyName, path?, columns?)\"]\n    end\n    \n    subgraph \"Validation Layer\"\n        VAL_STRAT[\"strategyValidationService.validate()\"]\n        VAL_RISK[\"riskValidationService.validate()\"]\n    end\n    \n    subgraph \"Service Layer (src/lib/services/markdown)\"\n        HMS[\"HeatMarkdownService\"]\n        HMS_DATA[\"getData(strategyName)\"]\n        HMS_REPORT[\"getReport(strategyName, columns)\"]\n        HMS_DUMP[\"dump(strategyName, path, columns)\"]\n    end\n    \n    subgraph \"Storage Layer\"\n        HS[\"HeatmapStorage (memoized)\"]\n        MAP[\"symbolData: Map<symbol, signals[]>\"]\n    end\n    \n    HEAT --> GET_DATA\n    HEAT --> GET_REPORT\n    HEAT --> DUMP\n    \n    GET_DATA --> VAL_STRAT\n    GET_DATA --> VAL_RISK\n    VAL_STRAT --> HMS_DATA\n    VAL_RISK --> HMS_DATA\n    \n    GET_REPORT --> VAL_STRAT\n    GET_REPORT --> VAL_RISK\n    VAL_STRAT --> HMS_REPORT\n    VAL_RISK --> HMS_REPORT\n    \n    DUMP --> VAL_STRAT\n    DUMP --> VAL_RISK\n    VAL_STRAT --> HMS_DUMP\n    VAL_RISK --> HMS_DUMP\n    \n    HMS_DATA --> HS\n    HMS_REPORT --> HS\n    HMS_DUMP --> HS\n    \n    HS --> MAP\n    \n    style HEAT fill:#e1f5ff\n    style HS fill:#fff3cd\n```\n\n**Validation flow:**\n1. `Heat` methods validate strategy name exists\n2. Extract `riskName` and `riskList` from strategy schema\n3. Validate each risk profile exists\n4. Delegate to `HeatMarkdownService`\n\nThis ensures all referenced entities exist before attempting data access, preventing runtime errors.\n\nSources: [src/classes/Heat.ts:33-148](), [src/lib/services/markdown/HeatMarkdownService.ts:487-567]()\n\n---\n\n## Comparison with Other Markdown Services\n\n| Feature | HeatMarkdownService | BacktestMarkdownService | WalkerMarkdownService |\n|---------|---------------------|------------------------|----------------------|\n| **Aggregation Level** | Cross-symbol, per-strategy | Per symbol-strategy pair | Cross-strategy comparison |\n| **Storage Key** | `strategyName` | `symbol:strategyName` | `walkerName` |\n| **Primary Use Case** | Portfolio overview | Individual backtest results | Strategy optimization |\n| **Report Focus** | Symbol performance matrix | Chronological signal list | Best strategy identification |\n| **Sorting** | By Sharpe Ratio | By timestamp (newest first) | By metric value |\n| **Event Filter** | `action === \"closed\"` | `action === \"closed\"` | All walker progress events |\n| **Statistics** | 15 per symbol + portfolio | Win rate, Sharpe, total PNL | Per-strategy comparison table |\n\nThe heatmap complements other reporting services by answering the question: \"How does this strategy perform across my entire portfolio?\"\n\nSources: [src/lib/services/markdown/HeatMarkdownService.ts:1-606](), [src/lib/services/markdown/BacktestMarkdownService.ts:1-464](), [src/lib/services/markdown/WalkerMarkdownService.ts:1-606]()"
                    },
                    {
                        "page_plan": {
                            "id": "10",
                            "title": "Advanced Features"
                        },
                        "content": "# Advanced Features\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/classes/Optimizer.ts](src/classes/Optimizer.ts)\n- [src/client/ClientOptimizer.ts](src/client/ClientOptimizer.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Optimizer.interface.ts](src/interfaces/Optimizer.interface.ts)\n- [src/lib/services/connection/OptimizerConnectionService.ts](src/lib/services/connection/OptimizerConnectionService.ts)\n- [src/lib/services/global/OptimizerGlobalService.ts](src/lib/services/global/OptimizerGlobalService.ts)\n- [src/lib/services/schema/OptimizerSchemaService.ts](src/lib/services/schema/OptimizerSchemaService.ts)\n- [src/lib/services/template/OptimizerTemplateService.ts](src/lib/services/template/OptimizerTemplateService.ts)\n- [src/lib/services/validation/OptimizerValidationService.ts](src/lib/services/validation/OptimizerValidationService.ts)\n- [src/model/Message.model.ts](src/model/Message.model.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis page documents advanced capabilities in Backtest Kit that extend beyond basic strategy backtesting. These features enable AI-driven strategy development, automated code generation, crash-safe persistence, and custom storage backends.\n\n**Scope**: This page covers:\n- LLM-powered strategy generation using Ollama\n- Optimizer system for data-driven strategy synthesis\n- Template-based code generation\n- Crash recovery mechanisms and persistence\n- Custom persistence backend implementation\n\nFor basic strategy development, see [Strategy Development](#6). For risk management, see [Risk Management](#7). For execution modes, see [Execution Modes](#5).\n\n---\n\n## LLM-Powered Strategy Generation\n\nBacktest Kit integrates with Large Language Models (specifically Ollama) to generate trading strategies from historical data. The framework provides utilities to build LLM conversation histories, format market data, and synthesize executable strategy code.\n\n### Integration Architecture\n\n```mermaid\ngraph TB\n    subgraph \"User Space\"\n        USER[\"User defines<br/>IOptimizerSchema\"]\n        DATA_SOURCES[\"Data Sources<br/>IOptimizerSourceFn[]\"]\n        RANGES[\"Time Ranges<br/>rangeTrain, rangeTest\"]\n        PROMPT_FN[\"getPrompt function<br/>MessageModel[] → string\"]\n    end\n    \n    subgraph \"Optimizer System\"\n        CLIENT[\"ClientOptimizer\"]\n        CONN[\"OptimizerConnectionService\"]\n        GLOBAL[\"OptimizerGlobalService\"]\n    end\n    \n    subgraph \"Data Collection\"\n        PAGINATE[\"RESOLVE_PAGINATION_FN<br/>iterateDocuments\"]\n        DEDUPE[\"distinctDocuments<br/>by data.id\"]\n        MESSAGES[\"Build MessageModel[]<br/>user/assistant pairs\"]\n    end\n    \n    subgraph \"LLM Integration\"\n        USER_MSG[\"getUserMessage<br/>OptimizerTemplateService\"]\n        ASSIST_MSG[\"getAssistantMessage<br/>OptimizerTemplateService\"]\n        LLM[\"External LLM<br/>Ollama API\"]\n    end\n    \n    subgraph \"Code Generation\"\n        STRATEGY_DATA[\"IOptimizerStrategy[]<br/>messages + prompt\"]\n        TEMPLATE[\"OptimizerTemplateService<br/>getStrategyTemplate, etc\"]\n        CODE_GEN[\"Generated .mjs file<br/>Executable strategy\"]\n    end\n    \n    USER --> CLIENT\n    DATA_SOURCES --> CLIENT\n    RANGES --> CLIENT\n    PROMPT_FN --> CLIENT\n    \n    CLIENT --> CONN\n    CONN --> GLOBAL\n    \n    CLIENT --> PAGINATE\n    PAGINATE --> DEDUPE\n    DEDUPE --> MESSAGES\n    \n    MESSAGES --> USER_MSG\n    MESSAGES --> ASSIST_MSG\n    USER_MSG --> LLM\n    ASSIST_MSG --> LLM\n    \n    LLM --> PROMPT_FN\n    PROMPT_FN --> STRATEGY_DATA\n    \n    STRATEGY_DATA --> TEMPLATE\n    TEMPLATE --> CODE_GEN\n    \n    style CLIENT fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style LLM fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style CODE_GEN fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**Sources**: [src/interfaces/Optimizer.interface.ts:1-314](), [src/client/ClientOptimizer.ts:1-256](), [src/lib/services/connection/OptimizerConnectionService.ts:1-116]()\n\n### Message Model Structure\n\nThe framework uses a conversation-based approach with three message roles:\n\n| Role | Purpose | Example Usage |\n|------|---------|---------------|\n| `system` | System instructions, context | \"You are a trading strategy expert\" |\n| `user` | User prompts, market data | \"Analyze these 1h candles: ...\" |\n| `assistant` | LLM responses | \"Trend 1h analyzed\" |\n\nMessages are accumulated as `MessageModel[]` arrays, where each message contains:\n- `role`: `\"assistant\" | \"system\" | \"user\"`\n- `content`: String content of the message\n\n**Sources**: [src/model/Message.model.ts:1-26](), [src/interfaces/Optimizer.interface.ts:95-122]()\n\n### Data Source Configuration\n\nData sources define how to fetch training data for the LLM. Each source must implement `IOptimizerSourceFn` with pagination support:\n\n```typescript\ninterface IOptimizerFetchArgs {\n  symbol: string;\n  startDate: Date;\n  endDate: Date;\n  limit: number;   // Records per page (default: 25)\n  offset: number;  // Skip count for pagination\n}\n\ntype IOptimizerSourceFn<Data extends IOptimizerData> = \n  (args: IOptimizerFetchArgs) => Data[] | Promise<Data[]>;\n```\n\nData must include unique `id` field for deduplication. The system automatically handles pagination using `iterateDocuments` and deduplicates using `distinctDocuments`.\n\n**Sources**: [src/interfaces/Optimizer.interface.ts:46-94](), [src/client/ClientOptimizer.ts:70-88]()\n\n### Custom Message Formatters\n\nSources can provide custom formatters for LLM messages:\n\n```typescript\ninterface IOptimizerSource<Data> {\n  name: string;\n  fetch: IOptimizerSourceFn<Data>;\n  user?: (symbol: string, data: Data[], name: string) => string | Promise<string>;\n  assistant?: (symbol: string, data: Data[], name: string) => string | Promise<string>;\n}\n```\n\nIf not provided, defaults to `OptimizerTemplateService.getUserMessage` and `getAssistantMessage`.\n\n**Sources**: [src/interfaces/Optimizer.interface.ts:128-178](), [src/client/ClientOptimizer.ts:34-60]()\n\n---\n\n## Optimizer System Architecture\n\nThe Optimizer system coordinates data collection, LLM interaction, and code generation through a multi-layer service architecture.\n\n### Service Layer Hierarchy\n\n```mermaid\ngraph TB\n    subgraph \"Public API\"\n        OPTIMIZER_CLASS[\"Optimizer class<br/>getData, getCode, dump\"]\n    end\n    \n    subgraph \"Global Service Layer\"\n        OPTIMIZER_GLOBAL[\"OptimizerGlobalService<br/>Validation + delegation\"]\n    end\n    \n    subgraph \"Connection Service Layer\"\n        OPTIMIZER_CONN[\"OptimizerConnectionService<br/>Instance caching (memoized)\"]\n    end\n    \n    subgraph \"Client Layer\"\n        CLIENT_OPT[\"ClientOptimizer<br/>Business logic implementation\"]\n        GET_DATA[\"getData: IOptimizerStrategy[]\"]\n        GET_CODE[\"getCode: string\"]\n        DUMP[\"dump: void (writes file)\"]\n    end\n    \n    subgraph \"Schema & Validation\"\n        SCHEMA_SVC[\"OptimizerSchemaService<br/>ToolRegistry storage\"]\n        VALIDATION_SVC[\"OptimizerValidationService<br/>Existence checks (memoized)\"]\n    end\n    \n    subgraph \"Template Service\"\n        TEMPLATE_SVC[\"OptimizerTemplateService<br/>Code snippet generators\"]\n        GET_TOP[\"getTopBanner\"]\n        GET_STRATEGY[\"getStrategyTemplate\"]\n        GET_EXCHANGE[\"getExchangeTemplate\"]\n        GET_FRAME[\"getFrameTemplate\"]\n        GET_WALKER[\"getWalkerTemplate\"]\n        GET_LAUNCHER[\"getLauncherTemplate\"]\n        GET_JSON_DUMP[\"getJsonDumpTemplate\"]\n        GET_TEXT[\"getTextTemplate\"]\n        GET_JSON[\"getJsonTemplate\"]\n    end\n    \n    OPTIMIZER_CLASS --> OPTIMIZER_GLOBAL\n    OPTIMIZER_GLOBAL --> VALIDATION_SVC\n    OPTIMIZER_GLOBAL --> OPTIMIZER_CONN\n    \n    OPTIMIZER_CONN --> SCHEMA_SVC\n    OPTIMIZER_CONN --> TEMPLATE_SVC\n    OPTIMIZER_CONN --> CLIENT_OPT\n    \n    CLIENT_OPT --> GET_DATA\n    CLIENT_OPT --> GET_CODE\n    CLIENT_OPT --> DUMP\n    \n    GET_CODE --> TEMPLATE_SVC\n    \n    TEMPLATE_SVC --> GET_TOP\n    TEMPLATE_SVC --> GET_STRATEGY\n    TEMPLATE_SVC --> GET_EXCHANGE\n    TEMPLATE_SVC --> GET_FRAME\n    TEMPLATE_SVC --> GET_WALKER\n    TEMPLATE_SVC --> GET_LAUNCHER\n    TEMPLATE_SVC --> GET_JSON_DUMP\n    TEMPLATE_SVC --> GET_TEXT\n    TEMPLATE_SVC --> GET_JSON\n    \n    style CLIENT_OPT fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style TEMPLATE_SVC fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**Sources**: [src/classes/Optimizer.ts:1-135](), [src/lib/services/global/OptimizerGlobalService.ts:1-105](), [src/lib/services/connection/OptimizerConnectionService.ts:1-116]()\n\n### Optimizer Schema Definition\n\nAn optimizer is configured via `IOptimizerSchema`:\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `optimizerName` | `string` | Unique identifier |\n| `rangeTrain` | `IOptimizerRange[]` | Training time periods |\n| `rangeTest` | `IOptimizerRange[]` | Testing time periods |\n| `source` | `Source[]` | Data source configurations |\n| `getPrompt` | `(symbol, messages) => string` | Synthesizes strategy from conversation |\n| `template?` | `Partial<IOptimizerTemplate>` | Custom code generators |\n| `callbacks?` | `IOptimizerCallbacks` | Lifecycle hooks |\n\nEach `IOptimizerRange` defines:\n- `startDate`: Start of time range (inclusive)\n- `endDate`: End of time range (inclusive)\n- `note?`: Optional description\n\n**Sources**: [src/interfaces/Optimizer.interface.ts:312-377](), [src/lib/services/schema/OptimizerSchemaService.ts:1-97]()\n\n### Data Collection Flow\n\n```mermaid\nsequenceDiagram\n    participant USER as User Code\n    participant CLIENT as ClientOptimizer\n    participant PAGINATE as RESOLVE_PAGINATION_FN\n    participant SOURCE as IOptimizerSourceFn\n    participant DEDUPE as distinctDocuments\n    participant TEMPLATE as OptimizerTemplateService\n    \n    USER->>CLIENT: getData(symbol, optimizerName)\n    \n    loop For each rangeTrain\n        loop For each source\n            CLIENT->>PAGINATE: Fetch with pagination\n            loop While has more pages\n                PAGINATE->>SOURCE: fetch({limit, offset, symbol, dates})\n                SOURCE-->>PAGINATE: Data page\n            end\n            PAGINATE->>DEDUPE: Deduplicate by data.id\n            DEDUPE-->>CLIENT: Unique data array\n            \n            CLIENT->>TEMPLATE: getUserMessage(symbol, data, name)\n            TEMPLATE-->>CLIENT: User message content\n            \n            CLIENT->>TEMPLATE: getAssistantMessage(symbol, data, name)\n            TEMPLATE-->>CLIENT: Assistant message content\n            \n            CLIENT->>CLIENT: Build MessageModel pair\n        end\n        \n        CLIENT->>USER: Call getPrompt(symbol, messages)\n        USER-->>CLIENT: Strategy prompt string\n        \n        CLIENT->>CLIENT: Create IOptimizerStrategy\n    end\n    \n    CLIENT-->>USER: IOptimizerStrategy[]\n```\n\n**Sources**: [src/client/ClientOptimizer.ts:70-215](), [src/interfaces/Optimizer.interface.ts:92-94]()\n\n### Progress Tracking\n\nThe optimizer emits progress events via `progressOptimizerEmitter`:\n\n```typescript\ninterface ProgressOptimizerContract {\n  optimizerName: string;\n  symbol: string;\n  totalSources: number;      // rangeTrain.length × source.length\n  processedSources: number;  // Current count\n  progress: number;          // 0.0 to 1.0\n}\n```\n\nEvents are emitted:\n1. At start of each source processing (processedSources = current)\n2. After all sources complete (progress = 1.0)\n\nSubscribe via `listenOptimizerProgress((event) => { ... })`.\n\n**Sources**: [src/client/ClientOptimizer.ts:99-114](), [src/client/ClientOptimizer.ts:201-208](), [src/function/event.ts:275-286]()\n\n---\n\n## Code Generation & Templates\n\nThe template system generates executable strategy code by assembling TypeScript/JavaScript components.\n\n### Template Interface Structure\n\n`IOptimizerTemplate` defines 11 code generator methods:\n\n| Method | Returns | Purpose |\n|--------|---------|---------|\n| `getTopBanner` | Import statements, setup | File header with dependencies |\n| `getUserMessage` | String | Default user message formatter |\n| `getAssistantMessage` | String | Default assistant message formatter |\n| `getWalkerTemplate` | `addWalker()` call | Strategy comparison config |\n| `getStrategyTemplate` | `addStrategy()` call | Strategy with LLM integration |\n| `getExchangeTemplate` | `addExchange()` call | CCXT exchange config |\n| `getFrameTemplate` | `addFrame()` call | Timeframe config |\n| `getLauncherTemplate` | `Walker.background()` call | Execution launcher with listeners |\n| `getJsonDumpTemplate` | `dumpJson()` function | Debug output helper |\n| `getTextTemplate` | `text()` function | LLM text wrapper |\n| `getJsonTemplate` | `json()` function | LLM JSON wrapper |\n\nAll methods are `async` and return `string | Promise<string>`.\n\n**Sources**: [src/interfaces/Optimizer.interface.ts:238-339](), [src/lib/services/template/OptimizerTemplateService.ts:1-591]()\n\n### Generated Code Structure\n\n```mermaid\ngraph TB\n    subgraph \"Generated .mjs File\"\n        BANNER[\"#!/usr/bin/env node<br/>Imports: Ollama, ccxt,<br/>backtest-kit, uuid\"]\n        HELPERS[\"Helper Functions<br/>dumpJson, text, json\"]\n        EXCHANGE[\"addExchange<br/>CCXT Binance integration\"]\n        FRAMES[\"addFrame calls<br/>Train + Test frames\"]\n        STRATEGIES[\"addStrategy calls<br/>Multi-timeframe analysis<br/>LLM signal generation\"]\n        WALKER[\"addWalker<br/>Strategy comparison config\"]\n        LAUNCHER[\"Walker.background<br/>Event listeners\"]\n    end\n    \n    subgraph \"Template Methods\"\n        T1[\"getTopBanner\"]\n        T2[\"getJsonDumpTemplate<br/>getTextTemplate<br/>getJsonTemplate\"]\n        T3[\"getExchangeTemplate\"]\n        T4[\"getFrameTemplate\"]\n        T5[\"getStrategyTemplate\"]\n        T6[\"getWalkerTemplate\"]\n        T7[\"getLauncherTemplate\"]\n    end\n    \n    T1 --> BANNER\n    T2 --> HELPERS\n    T3 --> EXCHANGE\n    T4 --> FRAMES\n    T5 --> STRATEGIES\n    T6 --> WALKER\n    T7 --> LAUNCHER\n    \n    BANNER --> HELPERS\n    HELPERS --> EXCHANGE\n    EXCHANGE --> FRAMES\n    FRAMES --> STRATEGIES\n    STRATEGIES --> WALKER\n    WALKER --> LAUNCHER\n    \n    style STRATEGIES fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**Sources**: [src/client/ClientOptimizer.ts:217-302](), [src/lib/services/template/OptimizerTemplateService.ts:36-591]()\n\n### Strategy Template Composition\n\nThe `getStrategyTemplate` method generates a complete strategy with:\n\n1. **Multi-timeframe data loading**: Fetches 1m, 5m, 15m, 1h candles via `getCandles`\n2. **Message building**: Constructs user/assistant pairs for each timeframe\n3. **LLM invocation**: Calls `json(messages)` with embedded strategy prompt\n4. **Debug output**: Saves conversation to `./dump/strategy/{resultId}/`\n5. **Signal return**: Returns validated `ISignalDto` or `null`\n\nThe generated strategy includes automatic candle formatting, progressive timeframe analysis, and unique signal ID assignment.\n\n**Sources**: [src/lib/services/template/OptimizerTemplateService.ts:167-303](), [demo/optimization/package.json:1-19]()\n\n### Template Customization\n\nUsers can override any template method in `IOptimizerSchema.template`:\n\n```typescript\naddOptimizer({\n  optimizerName: \"custom\",\n  // ... other fields\n  template: {\n    // Override strategy generation\n    getStrategyTemplate: async (strategyName, interval, prompt) => {\n      return `addStrategy({ /* custom */ });`;\n    },\n    // Use defaults for other methods\n  }\n});\n```\n\nThe system merges custom templates with defaults from `OptimizerTemplateService`.\n\n**Sources**: [src/lib/services/connection/OptimizerConnectionService.ts:59-98](), [src/interfaces/Optimizer.interface.ts:238-339]()\n\n### Security: Code Injection Prevention\n\nAll template methods escape user-provided strings to prevent code injection:\n\n```typescript\n// Example from getStrategyTemplate\nconst escapedPrompt = String(plainPrompt)\n  .replace(/\\\\/g, '\\\\\\\\')\n  .replace(/`/g, '\\\\`')\n  .replace(/\\$/g, '\\\\$');\n```\n\nApplied to: `strategyName`, `exchangeName`, `frameName`, `interval`, `prompt`, etc.\n\n**Sources**: [src/lib/services/template/OptimizerTemplateService.ts:180-192](), [src/lib/services/template/OptimizerTemplateService.ts:324-326]()\n\n---\n\n## Crash Recovery & Persistence\n\nBacktest Kit implements crash-safe persistence to recover state after system failures. This is critical for live trading where signals must not be lost or duplicated.\n\n### Persistence Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Client Layer\"\n        CLIENT_STRAT[\"ClientStrategy<br/>Signal lifecycle\"]\n        CLIENT_PART[\"ClientPartial<br/>Profit/loss tracking\"]\n        CLIENT_RISK[\"ClientRisk<br/>Active positions\"]\n    end\n    \n    subgraph \"Persist Adapters\"\n        PERSIST_SIGNAL[\"PersistSignalAdapter<br/>SignalData by symbol\"]\n        PERSIST_PARTIAL[\"PersistPartialAdapter<br/>PartialData by signalId\"]\n        PERSIST_RISK[\"PersistRiskAdapter<br/>RiskData by symbol\"]\n        PERSIST_SCHEDULE[\"PersistScheduleAdapter<br/>ScheduleData by symbol\"]\n    end\n    \n    subgraph \"Base Persistence\"\n        PERSIST_BASE[\"PersistBase<br/>Abstract base class\"]\n        WRITE[\"write(entityId, value)<br/>Atomic JSON writes\"]\n        READ[\"read(entityId)<br/>Async read\"]\n        DELETE[\"delete(entityId)<br/>Async delete\"]\n        CLEAR[\"clear()<br/>Delete all\"]\n        INIT[\"waitForInit()<br/>Async initialization\"]\n    end\n    \n    subgraph \"File System\"\n        FILES[\"./persist/{entityId}.json<br/>Atomic writes with rename\"]\n    end\n    \n    CLIENT_STRAT --> PERSIST_SIGNAL\n    CLIENT_PART --> PERSIST_PARTIAL\n    CLIENT_RISK --> PERSIST_RISK\n    CLIENT_STRAT --> PERSIST_SCHEDULE\n    \n    PERSIST_SIGNAL --> PERSIST_BASE\n    PERSIST_PARTIAL --> PERSIST_BASE\n    PERSIST_RISK --> PERSIST_BASE\n    PERSIST_SCHEDULE --> PERSIST_BASE\n    \n    PERSIST_BASE --> WRITE\n    PERSIST_BASE --> READ\n    PERSIST_BASE --> DELETE\n    PERSIST_BASE --> CLEAR\n    PERSIST_BASE --> INIT\n    \n    WRITE --> FILES\n    READ --> FILES\n    DELETE --> FILES\n    CLEAR --> FILES\n    \n    style PERSIST_BASE fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style FILES fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**Sources**: [types.d.ts:1655-1843](), [src/classes/Persist.ts referenced in types]()\n\n### PersistBase Interface\n\nThe abstract base class defines the persistence contract:\n\n```typescript\ninterface IPersistBase<Value extends object = any> {\n  readonly directory: string;        // Storage directory path\n  readonly extension: string;        // File extension (default: \".json\")\n  \n  write(entityId: EntityId, value: Value): Promise<void>;\n  read(entityId: EntityId): Promise<Value | null>;\n  delete(entityId: EntityId): Promise<void>;\n  clear(): Promise<void>;\n  waitForInit(entityId: EntityId): Promise<void>;\n}\n```\n\nAll operations are async. `waitForInit` ensures storage is ready before operations.\n\n**Sources**: [types.d.ts:1655-1726]()\n\n### Signal Persistence\n\nSignals are persisted when opened and deleted when closed:\n\n| Event | Action | Data Structure |\n|-------|--------|----------------|\n| `onOpen` | Write `SignalData` | `{ symbol, data: ISignalRow }` |\n| `onClose` | Delete `SignalData` | Delete file |\n| `onSchedule` | No write | Scheduled signals NOT persisted |\n| `onCancel` | No action | Never written |\n\n**Key Design Decision**: Only **opened** signals are persisted. Scheduled signals remain in memory. This prevents bloat and ensures only active positions are recovered.\n\n**Sources**: [types.d.ts:1728-1775](), [types.d.ts:686-697]()\n\n### Partial Profit/Loss Persistence\n\nPartial tracking persists milestone levels reached:\n\n```typescript\ninterface IPartialData {\n  profitLevels: PartialLevel[];  // [10, 20, 30, ...]\n  lossLevels: PartialLevel[];    // [10, 20, 30, ...]\n}\n```\n\nStored by `signalId` to track which profit/loss milestones have been emitted. Prevents duplicate partial events after crashes.\n\n**Sources**: [types.d.ts:499-516](), [types.d.ts:1821-1843]()\n\n### Risk Position Tracking\n\nActive positions are tracked for portfolio-wide risk management:\n\n```typescript\ninterface RiskData {\n  [strategyName: string]: {\n    signal: ISignalRow;\n    strategyName: string;\n    exchangeName: string;\n    openTimestamp: number;\n  }\n}\n```\n\nStored by `symbol` to maintain cross-strategy position limits. Enables recovery of risk state after crashes.\n\n**Sources**: [types.d.ts:1793-1819](), [types.d.ts:359-369]()\n\n### Atomic Write Implementation\n\nFile writes use a two-phase commit pattern:\n\n1. **Write to temporary file**: `{entityId}.tmp.json`\n2. **Atomic rename**: `rename()` to `{entityId}.json`\n\nThis ensures:\n- No partial writes visible to readers\n- Crash during write leaves old file intact\n- POSIX filesystem guarantees atomic rename\n\n**Sources**: [types.d.ts:1688-1709](), [types.d.ts:1718-1726]()\n\n### Initialization Flow\n\n```mermaid\nsequenceDiagram\n    participant CLIENT as ClientStrategy/Partial/Risk\n    participant ADAPTER as PersistAdapter\n    participant BASE as PersistBase\n    participant FS as File System\n    \n    CLIENT->>ADAPTER: waitForInit(entityId)\n    ADAPTER->>BASE: waitForInit(entityId)\n    \n    alt First call for entityId\n        BASE->>FS: mkdir(directory, recursive: true)\n        BASE->>FS: Check if file exists\n        \n        alt File exists\n            BASE->>FS: readFile(entityId.json)\n            FS-->>BASE: Stored value\n            BASE->>BASE: Store in _cache Map\n        else File not exists\n            BASE->>BASE: Store null in _cache\n        end\n        \n        BASE-->>ADAPTER: Ready\n    else Subsequent calls\n        BASE->>BASE: Check _cache Map\n        BASE-->>ADAPTER: Already initialized\n    end\n    \n    ADAPTER-->>CLIENT: Ready\n```\n\n**Sources**: [types.d.ts:1718-1726]()\n\n---\n\n## Custom Persistence Backends\n\nThe framework supports custom persistence implementations for Redis, MongoDB, or other storage systems.\n\n### Implementation Steps\n\nTo create a custom backend:\n\n1. **Extend PersistBase abstract class**\n2. **Implement required methods**: `write`, `read`, `delete`, `clear`, `waitForInit`\n3. **Inject into adapters**: Create custom adapters extending the base adapters\n\n### Example: Redis Backend\n\n```typescript\nclass PersistRedis extends PersistBase<any> {\n  private client: RedisClient;\n  \n  constructor(directory: string, extension: string = \".json\") {\n    super(directory, extension);\n    this.client = createRedisClient();\n  }\n  \n  async write(entityId: EntityId, value: any): Promise<void> {\n    const key = `${this.directory}:${entityId}`;\n    await this.client.set(key, JSON.stringify(value));\n  }\n  \n  async read(entityId: EntityId): Promise<any | null> {\n    const key = `${this.directory}:${entityId}`;\n    const data = await this.client.get(key);\n    return data ? JSON.parse(data) : null;\n  }\n  \n  async delete(entityId: EntityId): Promise<void> {\n    const key = `${this.directory}:${entityId}`;\n    await this.client.del(key);\n  }\n  \n  async clear(): Promise<void> {\n    const pattern = `${this.directory}:*`;\n    const keys = await this.client.keys(pattern);\n    if (keys.length > 0) {\n      await this.client.del(...keys);\n    }\n  }\n  \n  async waitForInit(entityId: EntityId): Promise<void> {\n    if (!this.client.isReady) {\n      await this.client.connect();\n    }\n  }\n}\n```\n\n**Sources**: [types.d.ts:1655-1726]()\n\n### Custom Adapter Example\n\n```typescript\nclass PersistSignalAdapterRedis extends PersistSignalAdapter {\n  constructor() {\n    const backend = new PersistRedis(\"./persist/signal\");\n    super(backend);\n  }\n}\n\n// Inject into system\nconst customAdapter = new PersistSignalAdapterRedis();\n// Use in ClientStrategy initialization\n```\n\n**Sources**: [types.d.ts:1728-1775]()\n\n### Storage Backend Requirements\n\nAny custom backend must guarantee:\n\n| Requirement | Rationale |\n|-------------|-----------|\n| **Atomic writes** | Prevent partial state visibility |\n| **Read-after-write consistency** | Ensure state recovery accuracy |\n| **Durability** | Survive process crashes |\n| **Per-entity isolation** | No cross-contamination between symbols/strategies |\n| **Async initialization** | Support connection pools, authentication |\n\n**Sources**: [types.d.ts:1655-1726]()\n\n### Performance Considerations\n\nThe default file-based implementation provides:\n- **Fast local reads**: Direct filesystem access\n- **Atomic guarantees**: POSIX rename semantics\n- **No external dependencies**: Self-contained\n- **Debuggable**: JSON files human-readable\n\nFor distributed systems, consider:\n- **Redis**: Fast in-memory cache with persistence\n- **MongoDB**: Document storage with transactions\n- **PostgreSQL**: JSONB columns with ACID guarantees\n\nTrade-offs:\n- Network latency vs local filesystem speed\n- External dependency vs self-contained\n- Scalability vs simplicity\n\n**Sources**: [types.d.ts:1655-1843]()\n\n---\n\n## Summary\n\nBacktest Kit's advanced features enable:\n\n1. **AI-Driven Development**: LLM integration for strategy synthesis from historical data\n2. **Automated Code Generation**: Template system produces executable strategy files\n3. **Production Safety**: Crash-safe persistence ensures no signal loss or duplication\n4. **Extensibility**: Custom persistence backends for Redis, MongoDB, or other storage\n\nThe optimizer system coordinates data collection, LLM interaction, and code generation through a layered service architecture. The template system assembles code components into executable strategies. The persistence layer provides crash recovery with atomic writes and async initialization.\n\nFor optimizer usage examples, see [demo/optimization/]() directory. For persistence patterns, see type definitions in [types.d.ts:1655-1843](). For template customization, see [IOptimizerTemplate interface](src/interfaces/Optimizer.interface.ts:238-339)."
                    },
                    {
                        "page_plan": {
                            "id": "10.1",
                            "title": "LLM-Powered Strategy Generation"
                        },
                        "content": "# LLM-Powered Strategy Generation\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/classes/Optimizer.ts](src/classes/Optimizer.ts)\n- [src/client/ClientOptimizer.ts](src/client/ClientOptimizer.ts)\n- [src/interfaces/Optimizer.interface.ts](src/interfaces/Optimizer.interface.ts)\n- [src/lib/services/connection/OptimizerConnectionService.ts](src/lib/services/connection/OptimizerConnectionService.ts)\n- [src/lib/services/global/OptimizerGlobalService.ts](src/lib/services/global/OptimizerGlobalService.ts)\n- [src/lib/services/schema/OptimizerSchemaService.ts](src/lib/services/schema/OptimizerSchemaService.ts)\n- [src/lib/services/template/OptimizerTemplateService.ts](src/lib/services/template/OptimizerTemplateService.ts)\n- [src/lib/services/validation/OptimizerValidationService.ts](src/lib/services/validation/OptimizerValidationService.ts)\n- [src/model/Message.model.ts](src/model/Message.model.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page documents the LLM-powered strategy generation system in Backtest Kit, which uses AI language models to automatically generate trading strategies from historical data and market analysis. The system collects data from configurable sources, builds conversation context for an LLM, generates strategy prompts, and outputs executable TypeScript code complete with strategies, walkers, and backtests.\n\nFor information about the Optimizer system architecture, see [Optimizer System](#10.2). For details on code generation templates, see [Code Generation & Templates](#10.3).\n\n**Key Capabilities:**\n- Automated strategy creation from historical backtest data\n- Multi-timeframe market analysis (1m, 5m, 15m, 1h candles)\n- LLM conversation history building with pagination support\n- Complete executable code generation with Walker comparison\n- Debug logging of LLM conversations to `./dump/strategy/`\n\n**Sources:** [README.md:111-143](), [src/interfaces/Optimizer.interface.ts:1-483]()\n\n---\n\n## System Architecture\n\nThe LLM strategy generation system consists of four main layers: schema registration, data collection, LLM interaction, and code generation. The `ClientOptimizer` orchestrates the entire workflow while `OptimizerTemplateService` provides the code generation templates.\n\n```mermaid\ngraph TB\n    subgraph \"Public API\"\n        AddOptimizer[\"addOptimizer()<br/>IOptimizerSchema\"]\n        OptimizerClass[\"Optimizer.getData()<br/>Optimizer.getCode()<br/>Optimizer.dump()\"]\n    end\n    \n    subgraph \"Service Layer\"\n        OptimizerGlobal[\"OptimizerGlobalService<br/>Validation + delegation\"]\n        OptimizerConnection[\"OptimizerConnectionService<br/>Memoized instances\"]\n        OptimizerValidation[\"OptimizerValidationService<br/>Existence checks\"]\n        OptimizerSchema[\"OptimizerSchemaService<br/>ToolRegistry storage\"]\n    end\n    \n    subgraph \"Client Layer\"\n        ClientOptimizer[\"ClientOptimizer<br/>getData()<br/>getCode()<br/>dump()\"]\n        TemplateService[\"OptimizerTemplateService<br/>11 template methods\"]\n    end\n    \n    subgraph \"Data Sources\"\n        UserSources[\"IOptimizerSource[]<br/>fetch(), user(), assistant()\"]\n        Pagination[\"iterateDocuments()<br/>distinctDocuments()<br/>ITERATION_LIMIT=25\"]\n    end\n    \n    subgraph \"LLM Integration\"\n        Messages[\"MessageModel[]<br/>role: user|assistant|system<br/>content: string\"]\n        GetPrompt[\"getPrompt()<br/>User-defined logic\"]\n        Ollama[\"Ollama API<br/>deepseek-v3.1:671b<br/>JSON schema mode\"]\n    end\n    \n    subgraph \"Code Generation\"\n        Templates[\"IOptimizerTemplate<br/>getTopBanner()<br/>getStrategyTemplate()<br/>getExchangeTemplate()<br/>etc.\"]\n        GeneratedCode[\"Generated .mjs file<br/>Strategies + Walker + Launcher\"]\n    end\n    \n    AddOptimizer --> OptimizerSchema\n    AddOptimizer --> OptimizerValidation\n    OptimizerClass --> OptimizerGlobal\n    OptimizerGlobal --> OptimizerValidation\n    OptimizerGlobal --> OptimizerConnection\n    OptimizerConnection --> OptimizerSchema\n    OptimizerConnection --> TemplateService\n    OptimizerConnection --> ClientOptimizer\n    \n    ClientOptimizer --> UserSources\n    UserSources --> Pagination\n    Pagination --> Messages\n    Messages --> GetPrompt\n    GetPrompt --> Ollama\n    \n    ClientOptimizer --> Templates\n    Templates --> GeneratedCode\n    \n    style ClientOptimizer fill:#ffe1e1,stroke:#cc0000,stroke-width:2px\n    style TemplateService fill:#e1f5ff,stroke:#0066cc,stroke-width:2px\n    style Ollama fill:#f0f0f0,stroke:#666,stroke-width:2px\n```\n\n**Architecture Flow:**\n\n1. **Registration**: User calls `addOptimizer()` with `IOptimizerSchema` configuration\n2. **Validation**: `OptimizerValidationService` checks for duplicate names\n3. **Storage**: `OptimizerSchemaService` stores schema in `ToolRegistry`\n4. **Instantiation**: `OptimizerConnectionService` creates memoized `ClientOptimizer` instances\n5. **Execution**: `ClientOptimizer.getData()` fetches from sources, builds messages, calls LLM\n6. **Generation**: `ClientOptimizer.getCode()` uses templates to generate executable code\n7. **Export**: `ClientOptimizer.dump()` writes `.mjs` file to disk\n\n**Sources:** [src/client/ClientOptimizer.ts:1-459](), [src/lib/services/template/OptimizerTemplateService.ts:1-732](), [src/lib/services/connection/OptimizerConnectionService.ts:1-175]()\n\n---\n\n## Core Interfaces\n\n### IOptimizerSchema Configuration\n\nThe `IOptimizerSchema` interface defines the complete optimizer configuration, including data sources, time ranges, and custom generation logic.\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `optimizerName` | `OptimizerName` | Yes | Unique identifier for registry lookup |\n| `rangeTrain` | `IOptimizerRange[]` | Yes | Training periods for strategy generation |\n| `rangeTest` | `IOptimizerRange` | Yes | Testing period for Walker validation |\n| `source` | `Source[]` | Yes | Data sources (functions or objects) |\n| `getPrompt` | `(symbol, messages) => string` | Yes | Generates strategy prompt from messages |\n| `template` | `Partial<IOptimizerTemplate>` | No | Custom template method overrides |\n| `callbacks` | `Partial<IOptimizerCallbacks>` | No | Lifecycle event hooks |\n\n**Sources:** [src/interfaces/Optimizer.interface.ts:376-433]()\n\n### IOptimizerRange Time Periods\n\n```typescript\ninterface IOptimizerRange {\n  note?: string;        // Optional description\n  startDate: Date;      // Inclusive start\n  endDate: Date;        // Inclusive end\n}\n```\n\n**Multiple Training Ranges**: Each range in `rangeTrain` generates a separate strategy variant. For example, configuring three ranges produces three strategies that are compared in the generated Walker.\n\n**Sources:** [src/interfaces/Optimizer.interface.ts:12-32]()\n\n### IOptimizerSource Data Fetching\n\nData sources can be simple functions or full configuration objects with custom message formatters:\n\n```mermaid\ngraph LR\n    SourceConfig[\"IOptimizerSource\"]\n    SimpleFn[\"IOptimizerSourceFn\"]\n    FetchFn[\"fetch(args)<br/>Returns data array\"]\n    UserFn[\"user(symbol, data, name)<br/>Formats user message\"]\n    AssistantFn[\"assistant(symbol, data, name)<br/>Formats assistant message\"]\n    \n    SourceConfig --> FetchFn\n    SourceConfig --> UserFn\n    SourceConfig --> AssistantFn\n    SimpleFn --> FetchFn\n    \n    style SourceConfig fill:#e1f5ff,stroke:#0066cc,stroke-width:2px\n    style SimpleFn fill:#fff3cd,stroke:#856404,stroke-width:2px\n```\n\n**Simple Function Source**:\n```typescript\nconst source: IOptimizerSourceFn = async ({ symbol, startDate, endDate, limit, offset }) => {\n  // Fetch and return data array\n  return data;\n};\n```\n\n**Full Configuration Source**:\n```typescript\nconst source: IOptimizerSource = {\n  name: \"backtest-results\",\n  note: \"Historical performance data\",\n  fetch: async (args) => { /* ... */ },\n  user: async (symbol, data, name) => `Analyze these ${data.length} backtests...`,\n  assistant: async (symbol, data, name) => \"Analysis complete\"\n};\n```\n\n**Sources:** [src/interfaces/Optimizer.interface.ts:86-186]()\n\n---\n\n## Data Collection Pipeline\n\nThe data collection pipeline fetches data from all sources across all training ranges, building a comprehensive conversation history for the LLM. Pagination is handled automatically via `functools-kit`.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant ClientOptimizer\n    participant Source\n    participant Pagination\n    participant Messages\n    participant GetPrompt\n    \n    User->>ClientOptimizer: getData(symbol)\n    \n    loop For each rangeTrain\n        loop For each source\n            ClientOptimizer->>Source: fetch({ symbol, dates, limit, offset })\n            Source->>Pagination: iterateDocuments()\n            Pagination->>Pagination: distinctDocuments(id)\n            Pagination-->>ClientOptimizer: deduplicated data[]\n            \n            ClientOptimizer->>Source: user(symbol, data, name)\n            Source-->>ClientOptimizer: userContent string\n            \n            ClientOptimizer->>Source: assistant(symbol, data, name)\n            Source-->>ClientOptimizer: assistantContent string\n            \n            ClientOptimizer->>Messages: push({ role: \"user\", content })\n            ClientOptimizer->>Messages: push({ role: \"assistant\", content })\n        end\n        \n        ClientOptimizer->>GetPrompt: getPrompt(symbol, messages)\n        GetPrompt-->>ClientOptimizer: strategy prompt\n        ClientOptimizer->>ClientOptimizer: Store IOptimizerStrategy\n    end\n    \n    ClientOptimizer-->>User: IOptimizerStrategy[]\n```\n\n### Pagination Implementation\n\nThe system uses `functools-kit` utilities for automatic pagination with deduplication:\n\n**Pagination Constants**:\n- `ITERATION_LIMIT = 25` - Records per page [src/client/ClientOptimizer.ts:19]()\n\n**Pagination Flow**:\n1. `iterateDocuments()` - Creates async iterator with `limit` and `offset`\n2. `distinctDocuments()` - Deduplicates by `data.id` field\n3. `resolveDocuments()` - Materializes all pages into array\n\n**Sources:** [src/client/ClientOptimizer.ts:70-88](), [src/client/ClientOptimizer.ts:99-215]()\n\n### Message Building\n\nFor each source in each training range, the system creates a user-assistant message pair:\n\n| Step | Action | Output |\n|------|--------|--------|\n| 1 | Fetch all data from source | `Data[]` with pagination |\n| 2 | Call `callbacks.onSourceData()` | Monitoring hook (optional) |\n| 3 | Format user message | `user(symbol, data, name)` → string |\n| 4 | Format assistant message | `assistant(symbol, data, name)` → string |\n| 5 | Append to message list | `MessageModel[]` |\n| 6 | Call `getPrompt()` after all sources | Strategy description string |\n\n**Default Message Formatters**: If source doesn't provide custom `user()` or `assistant()` functions, defaults delegate to template methods:\n- [src/client/ClientOptimizer.ts:34-41]() - `DEFAULT_USER_FN`\n- [src/client/ClientOptimizer.ts:43-60]() - `DEFAULT_ASSISTANT_FN`\n\n**Sources:** [src/client/ClientOptimizer.ts:99-215](), [src/interfaces/Optimizer.interface.ts:126-177]()\n\n---\n\n## LLM Integration\n\nThe generated code integrates with Ollama LLM for real-time strategy decisions. The template system creates two LLM helper functions: `text()` for narrative analysis and `json()` for structured signal generation.\n\n### LLM Helper Functions\n\n```mermaid\ngraph TB\n    subgraph \"Generated Code\"\n        Text[\"text(messages)<br/>Narrative analysis\"]\n        Json[\"json(messages)<br/>Structured signals\"]\n        DumpJson[\"dumpJson(resultId, history, result)<br/>Debug logging\"]\n    end\n    \n    subgraph \"Ollama Configuration\"\n        Host[\"host: https://ollama.com\"]\n        Auth[\"Authorization: Bearer API_KEY\"]\n        Model[\"model: deepseek-v3.1:671b\"]\n    end\n    \n    subgraph \"Strategy Execution\"\n        GetSignal[\"getSignal(symbol)<br/>Multi-timeframe analysis\"]\n        Messages[\"messages: MessageModel[]\"]\n        Result[\"ISignalDto<br/>position, prices, timing\"]\n    end\n    \n    Text --> Host\n    Json --> Host\n    Host --> Auth\n    Host --> Model\n    \n    GetSignal --> Messages\n    Messages --> Text\n    Messages --> Json\n    Json --> Result\n    Result --> DumpJson\n    \n    style Json fill:#ffe1e1,stroke:#cc0000,stroke-width:2px\n    style Model fill:#f0f0f0,stroke:#666,stroke-width:2px\n```\n\n### text() Template\n\nThe `text()` function generates narrative market analysis with fundamental recommendations:\n\n**Template Location**: [src/lib/services/template/OptimizerTemplateService.ts:555-612]()\n\n**Key Features**:\n- Uses `deepseek-v3.1:671b` model\n- System prompt: \"Write strategy with no extra text, ready for copy-paste\"\n- User prompt asks for support/resistance analysis, entry points, R/R ratios\n- Escapes special characters to prevent code injection\n- Returns plain text analysis\n\n**Generated Function Structure**:\n```typescript\nasync function text(messages) {\n  const ollama = new Ollama({\n    host: \"https://ollama.com\",\n    headers: { Authorization: `Bearer ${process.env.OLLAMA_API_KEY}` }\n  });\n  \n  const response = await ollama.chat({\n    model: \"deepseek-v3.1:671b\",\n    messages: [\n      { role: \"system\", content: \"Strategic recommendation, no greetings\" },\n      ...messages,\n      { role: \"user\", content: \"Market analysis for ${symbol}\" }\n    ]\n  });\n  \n  return escapedContent;\n}\n```\n\n**Sources:** [src/lib/services/template/OptimizerTemplateService.ts:555-612]()\n\n### json() Template with Signal Schema\n\nThe `json()` function generates structured trading signals using JSON schema validation:\n\n**Template Location**: [src/lib/services/template/OptimizerTemplateService.ts:614-732]()\n\n**Signal Schema Definition**:\n\n| Field | Type | Required | Enum/Range | Description |\n|-------|------|----------|------------|-------------|\n| `position` | string | Yes | `wait`, `long`, `short` | Trade direction |\n| `note` | string | Yes | - | Strategy explanation |\n| `priceOpen` | number | Conditional | > 0 | Entry price (if not `wait`) |\n| `priceTakeProfit` | number | Conditional | > 0 | Target price (if not `wait`) |\n| `priceStopLoss` | number | Conditional | > 0 | Stop price (if not `wait`) |\n| `minuteEstimatedTime` | integer | Conditional | 1-360 | Duration (if not `wait`) |\n\n**JSON Schema Enforcement**:\n```json\n{\n  \"type\": \"object\",\n  \"required\": [\"position\", \"note\"],\n  \"properties\": {\n    \"position\": { \"type\": \"string\", \"enum\": [\"wait\", \"long\", \"short\"] },\n    \"note\": { \"type\": \"string\" },\n    \"priceOpen\": { \"type\": \"number\", \"minimum\": 0 },\n    \"priceTakeProfit\": { \"type\": \"number\", \"minimum\": 0 },\n    \"priceStopLoss\": { \"type\": \"number\", \"minimum\": 0 },\n    \"minuteEstimatedTime\": { \"type\": \"integer\", \"minimum\": 1, \"maximum\": 360 }\n  },\n  \"if\": { \"properties\": { \"position\": { \"not\": { \"const\": \"wait\" } } } },\n  \"then\": {\n    \"required\": [\"priceOpen\", \"priceTakeProfit\", \"priceStopLoss\", \"minuteEstimatedTime\"]\n  }\n}\n```\n\n**Generated Function Structure**:\n```typescript\nasync function json(messages) {\n  const ollama = new Ollama({\n    host: \"https://ollama.com\",\n    headers: { Authorization: `Bearer ${process.env.OLLAMA_API_KEY}` }\n  });\n  \n  const response = await ollama.chat({\n    model: \"deepseek-v3.1:671b\",\n    messages: [\n      { role: \"system\", content: \"Analyze strategy and return signal\" },\n      ...messages\n    ],\n    format: { type: \"json\", schema: signalSchema }\n  });\n  \n  return JSON.parse(response.message.content);\n}\n```\n\n**Sources:** [src/lib/services/template/OptimizerTemplateService.ts:614-732]()\n\n### Debug Logging - dumpJson()\n\nThe `dumpJson()` function saves LLM conversations and results to `./dump/strategy/{resultId}/`:\n\n**Generated Files**:\n1. `00_system_prompt.md` - System messages and output summary\n2. `01_user_message.md`, `02_user_message.md`, etc. - User inputs\n3. `0X_llm_output.md` - Final LLM response\n\n**Warning System**: Logs warning if user message exceeds `WARN_KB = 100` kilobytes\n\n**Sources:** [src/lib/services/template/OptimizerTemplateService.ts:452-546]()\n\n---\n\n## Strategy Generation Workflow\n\nThe complete workflow from configuration to executable code involves multiple stages: data fetching, message building, prompt generation, and code assembly.\n\n```mermaid\ngraph TD\n    Start[\"addOptimizer(schema)\"]\n    Validate[\"OptimizerValidationService<br/>Check duplicate names\"]\n    Register[\"OptimizerSchemaService<br/>Store in ToolRegistry\"]\n    \n    GetData[\"Optimizer.getData(symbol)\"]\n    Connection[\"OptimizerConnectionService<br/>Get memoized instance\"]\n    \n    LoopRanges[\"Loop: rangeTrain\"]\n    LoopSources[\"Loop: source\"]\n    Fetch[\"Fetch data with pagination<br/>iterateDocuments()\"]\n    Dedupe[\"distinctDocuments(id)<br/>Remove duplicates\"]\n    UserMsg[\"Call user() formatter<br/>or DEFAULT_USER_FN\"]\n    AssistantMsg[\"Call assistant() formatter<br/>or DEFAULT_ASSISTANT_FN\"]\n    AppendMsg[\"Append MessageModel pair\"]\n    \n    CallPrompt[\"Call getPrompt(symbol, messages)<br/>User-defined logic\"]\n    StoreStrategy[\"Store IOptimizerStrategy\"]\n    \n    GetCode[\"Optimizer.getCode(symbol)\"]\n    Templates[\"OptimizerTemplateService<br/>11 template methods\"]\n    Assemble[\"Assemble code sections:<br/>1. Top banner<br/>2. Helpers<br/>3. Exchange<br/>4. Frames<br/>5. Strategies<br/>6. Walker<br/>7. Launcher\"]\n    \n    Dump[\"Optimizer.dump(symbol, path)\"]\n    WriteFile[\"writeFile(.mjs)<br/>Executable strategy\"]\n    \n    Start --> Validate\n    Validate --> Register\n    Register --> GetData\n    GetData --> Connection\n    Connection --> LoopRanges\n    LoopRanges --> LoopSources\n    LoopSources --> Fetch\n    Fetch --> Dedupe\n    Dedupe --> UserMsg\n    UserMsg --> AssistantMsg\n    AssistantMsg --> AppendMsg\n    AppendMsg --> LoopSources\n    LoopSources --> CallPrompt\n    CallPrompt --> StoreStrategy\n    StoreStrategy --> LoopRanges\n    LoopRanges --> GetData\n    \n    GetData --> GetCode\n    GetCode --> Templates\n    Templates --> Assemble\n    Assemble --> Dump\n    Dump --> WriteFile\n    \n    style Connection fill:#e1f5ff,stroke:#0066cc,stroke-width:2px\n    style Templates fill:#ffe1e1,stroke:#cc0000,stroke-width:2px\n    style WriteFile fill:#c8e6c9,stroke:#388e3c,stroke-width:2px\n```\n\n### Phase 1: Registration\n\n**Entry Point**: `addOptimizer(schema: IOptimizerSchema)` [src/index.ts]()\n\n**Validation Steps**:\n1. Check for duplicate `optimizerName` [src/lib/services/validation/OptimizerValidationService.ts:25-34]()\n2. Validate schema structure [src/lib/services/schema/OptimizerSchemaService.ts:41-67]()\n3. Store in `ToolRegistry` [src/lib/services/schema/OptimizerSchemaService.ts:28-32]()\n\n**Sources:** [src/lib/services/validation/OptimizerValidationService.ts:1-72](), [src/lib/services/schema/OptimizerSchemaService.ts:1-97]()\n\n### Phase 2: Data Collection\n\n**Entry Point**: `Optimizer.getData(symbol, { optimizerName })` [src/classes/Optimizer.ts:42-59]()\n\n**Execution Flow**:\n1. `OptimizerGlobalService.getData()` validates and delegates [src/lib/services/global/OptimizerGlobalService.ts:37-50]()\n2. `OptimizerConnectionService.getData()` retrieves memoized instance [src/lib/services/connection/OptimizerConnectionService.ts:122-132]()\n3. `ClientOptimizer.getData()` executes collection logic [src/client/ClientOptimizer.ts:99-215]()\n\n**Inner Loops**:\n- **Outer Loop**: Iterate through `rangeTrain` array\n- **Inner Loop**: Iterate through `source` array\n- For each (range, source) pair:\n  - Fetch data with pagination\n  - Format user and assistant messages\n  - Append to message list\n- After each range:\n  - Call `getPrompt(symbol, messages)`\n  - Store `IOptimizerStrategy` object\n\n**Progress Events**: Emits `ProgressOptimizerContract` via `progressOptimizerEmitter` [src/client/ClientOptimizer.ts:108-114]()\n\n**Sources:** [src/client/ClientOptimizer.ts:99-215](), [src/classes/Optimizer.ts:42-59]()\n\n### Phase 3: Code Generation\n\n**Entry Point**: `Optimizer.getCode(symbol, { optimizerName })` [src/classes/Optimizer.ts:70-87]()\n\n**Template Merging**: `OptimizerConnectionService` merges custom templates with defaults [src/lib/services/connection/OptimizerConnectionService.ts:59-112]()\n\n**Code Assembly Order**:\n\n| Section | Template Method | Description |\n|---------|----------------|-------------|\n| 1 | `getTopBanner()` | Shebang, imports, constants |\n| 2 | `getJsonDumpTemplate()` | Debug logging helper |\n| 3 | `getTextTemplate()` | LLM text generation |\n| 4 | `getJsonTemplate()` | LLM JSON signal generation |\n| 5 | `getExchangeTemplate()` | CCXT Binance configuration |\n| 6 | `getFrameTemplate()` (loop) | Train and test timeframes |\n| 7 | `getStrategyTemplate()` (loop) | Strategies from prompt |\n| 8 | `getWalkerTemplate()` | Strategy comparison |\n| 9 | `getLauncherTemplate()` | Event listeners and execution |\n\n**Prefix Generation**: Uses random prefix to prevent naming conflicts [src/client/ClientOptimizer.ts:22](), [src/client/ClientOptimizer.ts:228]()\n\n**Sources:** [src/client/ClientOptimizer.ts:217-350](), [src/lib/services/template/OptimizerTemplateService.ts:1-732]()\n\n### Phase 4: File Export\n\n**Entry Point**: `Optimizer.dump(symbol, { optimizerName }, path)` [src/classes/Optimizer.ts:100-120]()\n\n**File Operations**:\n1. Generate complete code via `getCode()`\n2. Create output directory with `mkdir(path, { recursive: true })`\n3. Write file: `{optimizerName}_{symbol}.mjs`\n4. Call `callbacks.onDump()` if provided\n\n**Default Path**: Current working directory (`./`)\n\n**Sources:** [src/client/ClientOptimizer.ts:360-384](), [src/classes/Optimizer.ts:100-120]()\n\n---\n\n## Generated Code Structure\n\nThe generated `.mjs` file is a complete, executable Node.js script that includes all necessary components for strategy comparison. The structure follows a consistent 9-section format.\n\n### Complete File Anatomy\n\n```mermaid\ngraph TB\n    subgraph \"Section 1: Banner\"\n        Shebang[\"#!/usr/bin/env node\"]\n        Imports[\"import Ollama, ccxt, backtest-kit\"]\n        Constants[\"WARN_KB = 100\"]\n    end\n    \n    subgraph \"Section 2-4: Helpers\"\n        DumpJson[\"async function dumpJson()<br/>Saves to ./dump/strategy/\"]\n        Text[\"async function text()<br/>Narrative analysis\"]\n        Json[\"async function json()<br/>Signal schema validation\"]\n    end\n    \n    subgraph \"Section 5: Exchange\"\n        AddExchange[\"addExchange()<br/>exchangeName: prefix_exchange<br/>CCXT Binance integration\"]\n    end\n    \n    subgraph \"Section 6: Frames\"\n        TrainFrames[\"addFrame() × rangeTrain.length<br/>frameName: prefix_train_frame-N<br/>interval: 1m\"]\n        TestFrame[\"addFrame()<br/>frameName: prefix_test_frame<br/>rangeTest dates\"]\n    end\n    \n    subgraph \"Section 7: Strategies\"\n        Strategies[\"addStrategy() × strategyData.length<br/>strategyName: prefix_strategy-N<br/>interval: 5m<br/>getSignal: multi-timeframe + LLM\"]\n    end\n    \n    subgraph \"Section 8: Walker\"\n        AddWalker[\"addWalker()<br/>walkerName: prefix_walker<br/>All strategies for comparison\"]\n    end\n    \n    subgraph \"Section 9: Launcher\"\n        Background[\"Walker.background(symbol)\"]\n        Listeners[\"listenSignalBacktest()<br/>listenBacktestProgress()<br/>listenWalkerProgress()<br/>listenWalkerComplete()<br/>listenDoneBacktest()<br/>listenError()\"]\n    end\n    \n    Shebang --> Imports\n    Imports --> Constants\n    Constants --> DumpJson\n    DumpJson --> Text\n    Text --> Json\n    Json --> AddExchange\n    AddExchange --> TrainFrames\n    TrainFrames --> TestFrame\n    TestFrame --> Strategies\n    Strategies --> AddWalker\n    AddWalker --> Background\n    Background --> Listeners\n    \n    style Strategies fill:#ffe1e1,stroke:#cc0000,stroke-width:2px\n    style AddWalker fill:#e1f5ff,stroke:#0066cc,stroke-width:2px\n```\n\n**Sources:** [src/client/ClientOptimizer.ts:217-350]()\n\n### Multi-Timeframe Strategy Template\n\nEach generated strategy performs four-level timeframe analysis before calling the LLM:\n\n**Timeframe Cascade**:\n1. **Medium-term (1h)**: 24 candles for trend context\n2. **Short-term (15m)**: 24 candles for momentum\n3. **Main-term (5m)**: 24 candles for signal generation\n4. **Micro-term (1m)**: 30 candles for precise entry\n\n**Message Building**:\n```typescript\naddStrategy({\n  strategyName: \"${prefix}_strategy-1\",\n  interval: \"5m\",\n  getSignal: async (symbol) => {\n    const messages = [];\n    \n    // Load all timeframes\n    const microTermCandles = await getCandles(symbol, \"1m\", 30);\n    const mainTermCandles = await getCandles(symbol, \"5m\", 24);\n    const shortTermCandles = await getCandles(symbol, \"15m\", 24);\n    const mediumTermCandles = await getCandles(symbol, \"1h\", 24);\n    \n    // Helper to format candles\n    function formatCandles(candles, timeframe) {\n      return candles.map((c) =>\n        `${new Date(c.timestamp).toISOString()}[${timeframe}]: O:${c.open} H:${c.high} L:${c.low} C:${c.close} V:${c.volume}`\n      ).join(\"\\n\");\n    }\n    \n    // Message 1: Medium-term trend\n    messages.push(\n      { role: \"user\", content: `${symbol}\\nAnalyze 1h candles:\\n\\n${formatCandles(mediumTermCandles, \"1h\")}` },\n      { role: \"assistant\", content: \"1h trend analyzed\" }\n    );\n    \n    // Message 2: Short-term trend\n    messages.push(\n      { role: \"user\", content: `Analyze 15m candles:\\n\\n${formatCandles(shortTermCandles, \"15m\")}` },\n      { role: \"assistant\", content: \"15m trend analyzed\" }\n    );\n    \n    // Message 3: Main timeframe\n    messages.push(\n      { role: \"user\", content: `Analyze 5m candles:\\n\\n${formatCandles(mainTermCandles, \"5m\")}` },\n      { role: \"assistant\", content: \"5m timeframe analyzed\" }\n    );\n    \n    // Message 4: Micro-structure\n    messages.push(\n      { role: \"user\", content: `Analyze 1m candles:\\n\\n${formatCandles(microTermCandles, \"1m\")}` },\n      { role: \"assistant\", content: \"1m microstructure analyzed\" }\n    );\n    \n    // Message 5: Request signal\n    messages.push({\n      role: \"user\",\n      content: [\n        \"Analyze all timeframes and generate signal per strategy.\",\n        \"\",\n        `${escapedPrompt}`,  // User's strategy logic\n        \"\",\n        \"If signals contradict or trend weak then position: wait\"\n      ].join(\"\\n\")\n    });\n    \n    const resultId = uuid();\n    const result = await json(messages);\n    await dumpJson(resultId, messages, result);\n    \n    result.id = resultId;\n    return result;\n  }\n});\n```\n\n**Sources:** [src/lib/services/template/OptimizerTemplateService.ts:168-304]()\n\n### Walker Comparison Setup\n\nThe generated Walker compares all strategies on the test frame:\n\n**Configuration**:\n```typescript\naddWalker({\n  walkerName: \"${prefix}_walker\",\n  exchangeName: \"${prefix}_exchange\",\n  frameName: \"${prefix}_test_frame\",\n  strategies: [\n    \"${prefix}_strategy-1\",\n    \"${prefix}_strategy-2\",\n    \"${prefix}_strategy-3\"\n  ]\n});\n```\n\n**Launcher with Event Listeners**:\n```typescript\nWalker.background(\"BTCUSDT\", {\n  walkerName: \"${prefix}_walker\"\n});\n\nlistenSignalBacktest((event) => {\n  console.log(event);\n});\n\nlistenBacktestProgress((event) => {\n  console.log(`Progress: ${(event.progress * 100).toFixed(2)}%`);\n  console.log(`Processed: ${event.processedFrames} / ${event.totalFrames}`);\n});\n\nlistenWalkerProgress((event) => {\n  console.log(`Progress: ${(event.progress * 100).toFixed(2)}%`);\n  console.log(`${event.processedStrategies} / ${event.totalStrategies} strategies`);\n  console.log(`Walker: ${event.walkerName}, Symbol: ${event.symbol}`);\n});\n\nlistenWalkerComplete((results) => {\n  console.log(\"Walker completed:\", results.bestStrategy);\n  Walker.dump(\"BTCUSDT\", results.walkerName);\n});\n\nlistenDoneBacktest((event) => {\n  console.log(\"Backtest completed:\", event.symbol);\n  Backtest.dump(event.symbol, event.strategyName);\n});\n\nlistenError((error) => {\n  console.error(\"Error occurred:\", error);\n});\n```\n\n**Sources:** [src/lib/services/template/OptimizerTemplateService.ts:395-443]()\n\n---\n\n## Configuration Examples\n\n### Basic Optimizer Configuration\n\nMinimal configuration with single source and training range:\n\n```typescript\nimport { addOptimizer } from \"backtest-kit\";\n\naddOptimizer({\n  optimizerName: \"simple-optimizer\",\n  \n  // Training period\n  rangeTrain: [\n    {\n      note: \"Bull market 2024\",\n      startDate: new Date(\"2024-01-01\"),\n      endDate: new Date(\"2024-03-31\")\n    }\n  ],\n  \n  // Testing period\n  rangeTest: {\n    note: \"Validation period\",\n    startDate: new Date(\"2024-04-01\"),\n    endDate: new Date(\"2024-06-30\")\n  },\n  \n  // Single data source\n  source: [\n    async ({ symbol, startDate, endDate, limit, offset }) => {\n      // Fetch historical backtest results\n      const results = await fetchBacktests({\n        symbol,\n        startDate,\n        endDate,\n        limit,\n        offset\n      });\n      return results.map(r => ({\n        id: r.id,\n        pnl: r.pnl,\n        winRate: r.winRate,\n        sharpe: r.sharpe\n      }));\n    }\n  ],\n  \n  // Generate strategy prompt\n  getPrompt: async (symbol, messages) => {\n    return `Based on the analysis above, trade ${symbol} with conservative risk management`;\n  }\n});\n```\n\n**Sources:** [README.md:111-143](), [src/interfaces/Optimizer.interface.ts:376-433]()\n\n### Advanced Configuration with Custom Templates\n\nFull-featured configuration with multiple sources, custom messages, and template overrides:\n\n```typescript\nimport { addOptimizer } from \"backtest-kit\";\n\naddOptimizer({\n  optimizerName: \"advanced-optimizer\",\n  \n  // Multiple training ranges for strategy variants\n  rangeTrain: [\n    {\n      note: \"Bull market\",\n      startDate: new Date(\"2024-01-01\"),\n      endDate: new Date(\"2024-03-31\")\n    },\n    {\n      note: \"Sideways market\",\n      startDate: new Date(\"2023-06-01\"),\n      endDate: new Date(\"2023-09-30\")\n    },\n    {\n      note: \"Bear market\",\n      startDate: new Date(\"2022-05-01\"),\n      endDate: new Date(\"2022-08-31\")\n    }\n  ],\n  \n  rangeTest: {\n    startDate: new Date(\"2024-04-01\"),\n    endDate: new Date(\"2024-06-30\")\n  },\n  \n  // Multiple data sources\n  source: [\n    // Source 1: Backtest results\n    {\n      name: \"backtest-results\",\n      note: \"Historical performance data\",\n      fetch: async (args) => {\n        const results = await fetchBacktests(args);\n        return results.map(r => ({\n          id: r.id,\n          strategy: r.strategyName,\n          pnl: r.totalPnl,\n          trades: r.closedSignals.length,\n          winRate: r.statistics.winRate\n        }));\n      },\n      user: async (symbol, data, name) => {\n        return [\n          `Historical backtest results for ${symbol}:`,\n          \"\",\n          JSON.stringify(data, null, 2),\n          \"\",\n          `Total strategies tested: ${data.length}`\n        ].join(\"\\n\");\n      },\n      assistant: async (symbol, data, name) => {\n        const avgPnl = data.reduce((sum, d) => sum + d.pnl, 0) / data.length;\n        return `Analyzed ${data.length} strategies. Average PNL: ${avgPnl.toFixed(2)}%`;\n      }\n    },\n    \n    // Source 2: Market news\n    {\n      name: \"market-sentiment\",\n      fetch: async ({ symbol, startDate, endDate, limit, offset }) => {\n        const news = await fetchNews(symbol, startDate, endDate, limit, offset);\n        return news.map(n => ({\n          id: n.id,\n          date: n.publishedAt,\n          headline: n.title,\n          sentiment: n.sentimentScore\n        }));\n      },\n      user: async (symbol, data, name) => {\n        return `Recent news for ${symbol}:\\n${data.map(n => `${n.date}: ${n.headline} (sentiment: ${n.sentiment})`).join(\"\\n\")}`;\n      },\n      assistant: async () => \"News sentiment analyzed\"\n    },\n    \n    // Source 3: Technical indicators\n    async ({ symbol, startDate, endDate, limit, offset }) => {\n      const indicators = await calculateIndicators(symbol, startDate, endDate, limit, offset);\n      return indicators.map(i => ({\n        id: `${symbol}_${i.timestamp}`,\n        timestamp: i.timestamp,\n        rsi: i.rsi,\n        macd: i.macd,\n        bbands: i.bbands\n      }));\n    }\n  ],\n  \n  // LLM prompt generation\n  getPrompt: async (symbol, messages) => {\n    // Could call text() here for LLM-generated prompt\n    return [\n      `Trade ${symbol} using the following strategy:`,\n      \"\",\n      \"1. Confirm trend direction across all timeframes\",\n      \"2. Wait for RSI divergence on 15m timeframe\",\n      \"3. Enter on 5m momentum confirmation\",\n      \"4. Set stop-loss at recent structure level\",\n      \"5. Target 2:1 risk-reward minimum\",\n      \"\",\n      \"Risk Management:\",\n      \"- Maximum 2% risk per trade\",\n      \"- No more than 3 concurrent positions\",\n      \"- Close all positions if daily loss exceeds 5%\"\n    ].join(\"\\n\");\n  },\n  \n  // Custom template overrides\n  template: {\n    // Override strategy template to use different intervals\n    getStrategyTemplate: async (strategyName, interval, prompt) => {\n      return [\n        `addStrategy({`,\n        `  strategyName: \"${strategyName}\",`,\n        `  interval: \"15m\",  // Custom: 15m instead of 5m`,\n        `  getSignal: async (symbol) => {`,\n        `    // Custom multi-timeframe logic`,\n        `    const candles4h = await getCandles(symbol, \"4h\", 24);`,\n        `    const candles1h = await getCandles(symbol, \"1h\", 48);`,\n        `    const candles15m = await getCandles(symbol, \"15m\", 96);`,\n        `    // ... custom implementation`,\n        `  }`,\n        `});`\n      ].join(\"\\n\");\n    }\n  },\n  \n  // Lifecycle callbacks\n  callbacks: {\n    onSourceData: async (symbol, sourceName, data, startDate, endDate) => {\n      console.log(`Fetched ${data.length} rows from ${sourceName} for ${symbol}`);\n      console.log(`Period: ${startDate.toISOString()} to ${endDate.toISOString()}`);\n    },\n    \n    onData: async (symbol, strategyData) => {\n      console.log(`Generated ${strategyData.length} strategy variants for ${symbol}`);\n      strategyData.forEach((s, i) => {\n        console.log(`Strategy ${i + 1}: ${s.messages.length} messages, prompt length: ${s.strategy.length} chars`);\n      });\n    },\n    \n    onCode: async (symbol, code) => {\n      console.log(`Generated code for ${symbol}: ${code.length} characters`);\n      console.log(`Lines: ${code.split(\"\\n\").length}`);\n    },\n    \n    onDump: async (symbol, filepath) => {\n      console.log(`Saved strategy to: ${filepath}`);\n      console.log(`Run with: node ${filepath}`);\n    }\n  }\n});\n```\n\n**Sources:** [src/interfaces/Optimizer.interface.ts:126-237](), [src/interfaces/Optimizer.interface.ts:376-433]()\n\n---\n\n## API Reference\n\n### Optimizer Class Methods\n\n| Method | Signature | Description |\n|--------|-----------|-------------|\n| `getData()` | `async (symbol: string, context: { optimizerName: string }) => IOptimizerStrategy[]` | Fetches data and generates strategies |\n| `getCode()` | `async (symbol: string, context: { optimizerName: string }) => string` | Generates executable code |\n| `dump()` | `async (symbol: string, context: { optimizerName: string }, path?: string) => void` | Saves code to file |\n\n**Sources:** [src/classes/Optimizer.ts:1-135]()\n\n### Event Emitters\n\n**Progress Tracking**:\n```typescript\nimport { listenProgressOptimizer } from \"backtest-kit\";\n\nlistenProgressOptimizer((progress) => {\n  console.log(`Optimizer: ${progress.optimizerName}`);\n  console.log(`Symbol: ${progress.symbol}`);\n  console.log(`Progress: ${(progress.progress * 100).toFixed(2)}%`);\n  console.log(`Processed: ${progress.processedSources} / ${progress.totalSources}`);\n});\n```\n\n**Contract Definition**:\n```typescript\ninterface ProgressOptimizerContract {\n  optimizerName: string;\n  symbol: string;\n  totalSources: number;        // Total data sources to process\n  processedSources: number;    // Sources completed\n  progress: number;            // 0.0 to 1.0\n}\n```\n\n**Sources:** [src/contract/ProgressOptimizer.contract.ts](), [src/client/ClientOptimizer.ts:108-114]()\n\n### Template Method Reference\n\nAll template methods return `string | Promise<string>` and can be overridden in `IOptimizerSchema.template`:\n\n| Method | Parameters | Purpose |\n|--------|------------|---------|\n| `getTopBanner()` | `symbol: string` | Imports and constants |\n| `getUserMessage()` | `symbol: string, data: any[], name: string` | Default user message |\n| `getAssistantMessage()` | `symbol: string, data: any[], name: string` | Default assistant message |\n| `getWalkerTemplate()` | `walkerName, exchangeName, frameName, strategies[]` | Walker config |\n| `getExchangeTemplate()` | `symbol, exchangeName` | Exchange config |\n| `getFrameTemplate()` | `symbol, frameName, interval, startDate, endDate` | Frame config |\n| `getStrategyTemplate()` | `strategyName, interval, prompt` | Strategy with getSignal |\n| `getLauncherTemplate()` | `symbol, walkerName` | Walker execution |\n| `getTextTemplate()` | `symbol` | LLM text helper |\n| `getJsonTemplate()` | `symbol` | LLM JSON helper |\n| `getJsonDumpTemplate()` | `symbol` | Debug logging helper |\n\n**Sources:** [src/interfaces/Optimizer.interface.ts:238-374]()\n\n---\n\n## Integration Patterns\n\n### Using with Walker for Comparison\n\nThe generated code automatically creates a Walker that compares all strategy variants:\n\n```typescript\n// Register optimizer with 3 training ranges\naddOptimizer({\n  optimizerName: \"market-conditions\",\n  rangeTrain: [\n    { startDate: new Date(\"2024-01-01\"), endDate: new Date(\"2024-02-01\") },  // Bull\n    { startDate: new Date(\"2023-06-01\"), endDate: new Date(\"2023-07-01\") },  // Sideways\n    { startDate: new Date(\"2022-11-01\"), endDate: new Date(\"2022-12-01\") }   // Bear\n  ],\n  rangeTest: { startDate: new Date(\"2024-04-01\"), endDate: new Date(\"2024-05-01\") },\n  source: [/* ... */],\n  getPrompt: async (symbol, messages) => \"Strategy for specific market condition\"\n});\n\n// Generate code\nawait Optimizer.dump(\"BTCUSDT\", { optimizerName: \"market-conditions\" }, \"./output\");\n\n// Run generated file\n// $ node ./output/market-conditions_BTCUSDT.mjs\n// \n// Output:\n// Progress: 33.33%\n// 1 / 3 strategies\n// Walker: abc123_walker, Symbol: BTCUSDT\n// \n// Progress: 66.67%\n// 2 / 3 strategies\n// \n// Progress: 100.00%\n// 3 / 3 strategies\n// \n// Walker completed: abc123_strategy-2\n// Best strategy: abc123_strategy-2 (Sideways market variant)\n```\n\n**Sources:** [src/lib/services/template/OptimizerTemplateService.ts:122-157](), [src/lib/services/template/OptimizerTemplateService.ts:395-443]()\n\n### Custom Data Source with Pagination\n\nImplement a paginated data source with proper ID handling:\n\n```typescript\ninterface BacktestResult extends IOptimizerData {\n  id: string;\n  strategyName: string;\n  symbol: string;\n  pnl: number;\n  winRate: number;\n  sharpeRatio: number;\n  totalTrades: number;\n}\n\nconst backtestSource: IOptimizerSourceFn<BacktestResult> = async ({\n  symbol,\n  startDate,\n  endDate,\n  limit,\n  offset\n}) => {\n  // Fetch from database with pagination\n  const results = await db.backtests.findMany({\n    where: {\n      symbol,\n      completedAt: {\n        gte: startDate,\n        lte: endDate\n      }\n    },\n    skip: offset,\n    take: limit,\n    orderBy: { completedAt: \"asc\" }\n  });\n  \n  // Map to IOptimizerData with required id field\n  return results.map(r => ({\n    id: r.id,  // Required for deduplication\n    strategyName: r.strategyName,\n    symbol: r.symbol,\n    pnl: r.totalPnl,\n    winRate: (r.profitableTrades / r.totalTrades) * 100,\n    sharpeRatio: r.sharpeRatio,\n    totalTrades: r.totalTrades\n  }));\n};\n\naddOptimizer({\n  optimizerName: \"historical-learner\",\n  rangeTrain: [/* ... */],\n  rangeTest: { /* ... */ },\n  source: [backtestSource],\n  getPrompt: async (symbol, messages) => {\n    // Analyze conversation history to generate prompt\n    return \"Strategy based on historical performance patterns\";\n  }\n});\n```\n\n**Deduplication**: The `id` field is used by `distinctDocuments()` to remove duplicates when pages overlap.\n\n**Sources:** [src/client/ClientOptimizer.ts:70-88](), [src/interfaces/Optimizer.interface.ts:36-44]()\n\n### Custom Message Formatting\n\nOverride default message formatters for specialized data presentation:\n\n```typescript\naddOptimizer({\n  optimizerName: \"custom-messages\",\n  rangeTrain: [/* ... */],\n  rangeTest: { /* ... */ },\n  source: [\n    {\n      name: \"performance-metrics\",\n      fetch: async (args) => {\n        const metrics = await fetchMetrics(args);\n        return metrics.map(m => ({\n          id: m.id,\n          sharpe: m.sharpeRatio,\n          sortino: m.sortinoRatio,\n          calmar: m.calmarRatio,\n          maxDrawdown: m.maxDrawdown\n        }));\n      },\n      \n      // Custom user message with formatted table\n      user: async (symbol, data, name) => {\n        const table = data.map(d => \n          `| ${d.sharpe.toFixed(2)} | ${d.sortino.toFixed(2)} | ${d.calmar.toFixed(2)} | ${(d.maxDrawdown * 100).toFixed(2)}% |`\n        ).join(\"\\n\");\n        \n        return [\n          `Performance metrics for ${symbol}:`,\n          \"\",\n          \"| Sharpe | Sortino | Calmar | Max DD |\",\n          \"|--------|---------|--------|--------|\",\n          table,\n          \"\",\n          `Total records: ${data.length}`\n        ].join(\"\\n\");\n      },\n      \n      // Custom assistant message with analysis\n      assistant: async (symbol, data, name) => {\n        const avgSharpe = data.reduce((sum, d) => sum + d.sharpe, 0) / data.length;\n        const avgMaxDD = data.reduce((sum, d) => sum + d.maxDrawdown, 0) / data.length;\n        \n        return [\n          `Analyzed ${data.length} performance records.`,\n          `Average Sharpe Ratio: ${avgSharpe.toFixed(2)}`,\n          `Average Max Drawdown: ${(avgMaxDD * 100).toFixed(2)}%`,\n          `Risk-adjusted returns are ${avgSharpe > 1 ? \"favorable\" : \"unfavorable\"}.`\n        ].join(\" \");\n      }\n    }\n  ],\n  getPrompt: async (symbol, messages) => \"Risk-optimized strategy\"\n});\n```\n\n**Sources:** [src/interfaces/Optimizer.interface.ts:126-177](), [src/client/ClientOptimizer.ts:34-60]()\n\n---\n\n## Performance Considerations\n\n### Memory Management\n\n**Data Deduplication**: The `distinctDocuments()` function prevents memory bloat from overlapping pagination:\n- Maintains a `Set` of seen IDs\n- Filters out duplicate records\n- Critical for large datasets with many pages\n\n**Message Size Warning**: The `dumpJson()` function warns when user messages exceed 100KB [src/lib/services/template/OptimizerTemplateService.ts:508-515]()\n\n**Sources:** [src/client/ClientOptimizer.ts:70-88]()\n\n### Memoization\n\n**Optimizer Instance Caching**: `OptimizerConnectionService` memoizes `ClientOptimizer` instances by `optimizerName`:\n- Single instance per optimizer name\n- Template merging done once\n- Reduces initialization overhead\n\n**Memoization Key**: `[optimizerName]` [src/lib/services/connection/OptimizerConnectionService.ts:59-112]()\n\n**Sources:** [src/lib/services/connection/OptimizerConnectionService.ts:59-112]()\n\n### Pagination Efficiency\n\n**Iteration Limit**: `ITERATION_LIMIT = 25` records per page balances:\n- Network request overhead\n- Memory consumption\n- Response time\n\n**Optimal For**:\n- Database sources with efficient `LIMIT`/`OFFSET`\n- APIs with cursor-based pagination\n- Datasets with 100-10,000 total records\n\n**Sources:** [src/client/ClientOptimizer.ts:19]()"
                    },
                    {
                        "page_plan": {
                            "id": "10.2",
                            "title": "Optimizer System"
                        },
                        "content": "# Optimizer System\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/classes/Optimizer.ts](src/classes/Optimizer.ts)\n- [src/client/ClientOptimizer.ts](src/client/ClientOptimizer.ts)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [src/interfaces/Optimizer.interface.ts](src/interfaces/Optimizer.interface.ts)\n- [src/lib/services/connection/OptimizerConnectionService.ts](src/lib/services/connection/OptimizerConnectionService.ts)\n- [src/lib/services/global/OptimizerGlobalService.ts](src/lib/services/global/OptimizerGlobalService.ts)\n- [src/lib/services/schema/OptimizerSchemaService.ts](src/lib/services/schema/OptimizerSchemaService.ts)\n- [src/lib/services/template/OptimizerTemplateService.ts](src/lib/services/template/OptimizerTemplateService.ts)\n- [src/lib/services/validation/OptimizerValidationService.ts](src/lib/services/validation/OptimizerValidationService.ts)\n- [src/model/Message.model.ts](src/model/Message.model.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThe Optimizer System generates executable trading strategy code using Large Language Model (LLM) analysis of historical data. It collects data from configurable sources, builds conversation histories for LLM context, generates strategy logic via Ollama deepseek-v3.1:671b, and exports complete `.mjs` files with strategies, walker configurations, and test runners.\n\nThis document covers data source configuration, pagination handling, template customization, and code generation. For LLM prompt engineering details, see [LLM-Powered Strategy Generation](#10.1). For code template internals, see [Code Generation & Templates](#10.3).\n\n---\n\n## System Overview\n\nThe Optimizer System operates in three phases:\n\n1. **Data Collection**: Fetches records from multiple sources with automatic pagination and deduplication\n2. **Strategy Generation**: Builds LLM conversation history and generates strategy prompts via `getPrompt()`\n3. **Code Export**: Assembles executable `.mjs` files using template methods\n\nThe system supports multiple training ranges, custom message formatters, and template overrides for complete customization.\n\n**Key Components:**\n\n| Component | Purpose |\n|-----------|---------|\n| `IOptimizerSchema` | User configuration with sources, ranges, and prompt generator |\n| `ClientOptimizer` | Core implementation handling pagination and LLM conversation building |\n| `OptimizerTemplateService` | Default templates for code generation (imports, helpers, strategies, walker) |\n| `OptimizerConnectionService` | Memoized factory creating optimizer instances with merged templates |\n| `OptimizerGlobalService` | Public entry point with validation |\n| `Optimizer` class | Static API exposing `getData()`, `getCode()`, `dump()` |\n\nSources: [src/interfaces/Optimizer.interface.ts:1-490](), [src/client/ClientOptimizer.ts:1-448](), [src/lib/services/template/OptimizerTemplateService.ts:1-716](), [src/classes/Optimizer.ts:1-135]()\n\n---\n\n## Architecture Diagram\n\n```mermaid\ngraph TB\n    subgraph \"Public API Layer\"\n        OptimizerClass[\"Optimizer<br/>(static class)<br/>getData/getCode/dump\"]\n        addOptimizer[\"addOptimizer()<br/>function\"]\n        listenOptimizerProgress[\"listenOptimizerProgress()<br/>event listener\"]\n    end\n    \n    subgraph \"Service Layer\"\n        OptimizerGlobalService[\"OptimizerGlobalService<br/>Validation + delegation\"]\n        OptimizerValidationService[\"OptimizerValidationService<br/>Existence checks<br/>Memoized validation\"]\n        OptimizerConnectionService[\"OptimizerConnectionService<br/>Memoized factory<br/>Template merging\"]\n        OptimizerSchemaService[\"OptimizerSchemaService<br/>ToolRegistry storage<br/>Schema validation\"]\n    end\n    \n    subgraph \"Client Layer\"\n        ClientOptimizer[\"ClientOptimizer<br/>Pagination handler<br/>Conversation builder<br/>Code generator\"]\n    end\n    \n    subgraph \"Template System\"\n        OptimizerTemplateService[\"OptimizerTemplateService<br/>Default implementations\"]\n        IOptimizerTemplate[\"IOptimizerTemplate<br/>getTopBanner<br/>getExchangeTemplate<br/>getFrameTemplate<br/>getStrategyTemplate<br/>getWalkerTemplate<br/>getLauncherTemplate<br/>getTextTemplate<br/>getJsonTemplate<br/>getUserMessage<br/>getAssistantMessage\"]\n    end\n    \n    subgraph \"Data Structures\"\n        IOptimizerSchema[\"IOptimizerSchema<br/>optimizerName<br/>rangeTrain[]<br/>rangeTest<br/>source[]<br/>getPrompt()<br/>template?<br/>callbacks?\"]\n        IOptimizerSource[\"IOptimizerSource<br/>name<br/>fetch()<br/>user?()<br/>assistant?()\"]\n        IOptimizerStrategy[\"IOptimizerStrategy<br/>symbol<br/>name<br/>messages[]<br/>strategy\"]\n    end\n    \n    subgraph \"Event System\"\n        progressOptimizerEmitter[\"progressOptimizerEmitter<br/>Subject<ProgressOptimizerContract>\"]\n    end\n    \n    addOptimizer --> OptimizerSchemaService\n    addOptimizer --> OptimizerValidationService\n    \n    OptimizerClass --> OptimizerGlobalService\n    OptimizerGlobalService --> OptimizerValidationService\n    OptimizerGlobalService --> OptimizerConnectionService\n    \n    OptimizerConnectionService --> OptimizerSchemaService\n    OptimizerConnectionService --> OptimizerTemplateService\n    OptimizerConnectionService --> ClientOptimizer\n    \n    ClientOptimizer --> progressOptimizerEmitter\n    progressOptimizerEmitter --> listenOptimizerProgress\n    \n    IOptimizerSchema -.->|configuration| OptimizerSchemaService\n    IOptimizerSource -.->|part of| IOptimizerSchema\n    IOptimizerTemplate -.->|merged into| ClientOptimizer\n    \n    ClientOptimizer -.->|produces| IOptimizerStrategy\n    \n    OptimizerTemplateService -.->|implements| IOptimizerTemplate\n    \n    style OptimizerClass fill:#e1f5ff,stroke:#0066cc,stroke-width:3px\n    style ClientOptimizer fill:#ffe1e1,stroke:#cc0000,stroke-width:2px\n    style progressOptimizerEmitter fill:#f0f0f0,stroke:#666,stroke-width:2px\n```\n\n**Architecture Notes:**\n\n- **Memoization**: `OptimizerConnectionService.getOptimizer()` caches instances by `optimizerName` ([src/lib/services/connection/OptimizerConnectionService.ts:59-113]())\n- **Template Merging**: Custom templates from schema override defaults from `OptimizerTemplateService` ([src/lib/services/connection/OptimizerConnectionService.ts:67-97]())\n- **Validation**: `OptimizerValidationService` maintains a `Map<OptimizerName, IOptimizerSchema>` for existence checks ([src/lib/services/validation/OptimizerValidationService.ts:15-34]())\n- **Schema Storage**: `OptimizerSchemaService` uses `ToolRegistry` for immutable schema management ([src/lib/services/schema/OptimizerSchemaService.ts:16-32]())\n\nSources: [src/lib/services/connection/OptimizerConnectionService.ts:1-175](), [src/lib/services/global/OptimizerGlobalService.ts:1-105](), [src/lib/services/validation/OptimizerValidationService.ts:1-72](), [src/lib/services/schema/OptimizerSchemaService.ts:1-97]()\n\n---\n\n## Data Source Configuration\n\nData sources provide training data for strategy generation. Each source is queried with pagination and deduplication.\n\n### Source Types\n\n**Function Source:**\n```typescript\ntype IOptimizerSourceFn<Data extends IOptimizerData> = \n  (args: IOptimizerFetchArgs) => Data[] | Promise<Data[]>;\n```\n\n**Object Source:**\n```typescript\ninterface IOptimizerSource<Data extends IOptimizerData> {\n  name: string;\n  fetch: IOptimizerSourceFn<Data>;\n  user?: (symbol: string, data: Data[], name: string) => string | Promise<string>;\n  assistant?: (symbol: string, data: Data[], name: string) => string | Promise<string>;\n}\n```\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `fetch` | Function | Paginated query function receiving `{ symbol, startDate, endDate, limit, offset }` |\n| `name` | String | Identifier used in callbacks and logging |\n| `user` | Function | Custom formatter for user messages (optional, uses template default) |\n| `assistant` | Function | Custom formatter for assistant messages (optional, uses template default) |\n\n### Pagination and Deduplication\n\nThe system automatically handles pagination using `functools-kit` utilities:\n\n```typescript\nconst ITERATION_LIMIT = 25; // Records per page\n\nconst iterator = iterateDocuments<Data>({\n  limit: ITERATION_LIMIT,\n  async createRequest({ limit, offset }) {\n    return await fetch({ symbol, startDate, endDate, limit, offset });\n  },\n});\nconst distinct = distinctDocuments(iterator, (data) => data.id);\nconst allData = await resolveDocuments(distinct);\n```\n\n**Deduplication Key**: All data must implement `IOptimizerData` with unique `id: string | number` ([src/interfaces/Optimizer.interface.ts:38-44]()).\n\nSources: [src/interfaces/Optimizer.interface.ts:46-186](), [src/client/ClientOptimizer.ts:70-88]()\n\n---\n\n## LLM Conversation Building\n\nThe optimizer builds conversation history by iterating through training ranges and sources. Each source contributes a user/assistant message pair.\n\n### Conversation Flow\n\n```mermaid\ngraph TD\n    Start[\"Start getData()\"] --> InitLoop[\"For each rangeTrain\"]\n    InitLoop --> EmptyMessages[\"messages = []\"]\n    EmptyMessages --> SourceLoop[\"For each source\"]\n    \n    SourceLoop --> EmitProgress[\"Emit ProgressOptimizerContract<br/>processedSources / totalSources\"]\n    EmitProgress --> FetchData[\"Fetch paginated data<br/>RESOLVE_PAGINATION_FN\"]\n    FetchData --> OnSourceData[\"callbacks.onSourceData?()\"]\n    OnSourceData --> FormatMessages[\"Format user + assistant messages\"]\n    \n    FormatMessages --> IsFunctionSource{Source type?}\n    IsFunctionSource -->|Function| DefaultFormatters[\"Use DEFAULT_USER_FN<br/>DEFAULT_ASSISTANT_FN\"]\n    IsFunctionSource -->|Object| CustomFormatters[\"Use source.user<br/>source.assistant<br/>or template defaults\"]\n    \n    DefaultFormatters --> PushMessages[\"messages.push(<br/>  {role: 'user', content},<br/>  {role: 'assistant', content}<br/>)\"]\n    CustomFormatters --> PushMessages\n    \n    PushMessages --> NextSource{More sources?}\n    NextSource -->|Yes| SourceLoop\n    NextSource -->|No| GeneratePrompt[\"strategy = getPrompt(symbol, messages)\"]\n    \n    GeneratePrompt --> AddStrategy[\"strategyList.push({<br/>  symbol, name, messages, strategy<br/>})\"]\n    AddStrategy --> NextRange{More ranges?}\n    NextRange -->|Yes| InitLoop\n    NextRange -->|No| FinalProgress[\"Emit final progress (100%)\"]\n    FinalProgress --> CallbackData[\"callbacks.onData?()\"]\n    CallbackData --> Return[\"Return strategyList\"]\n    \n    style EmitProgress fill:#f0f0f0,stroke:#666\n    style FetchData fill:#ffe1e1,stroke:#cc0000\n    style GeneratePrompt fill:#e1f5ff,stroke:#0066cc\n```\n\n### Message Formatters\n\nDefault formatters delegate to template methods:\n\n```typescript\nconst DEFAULT_USER_FN = async (symbol, data, name, self) => {\n  return await self.params.template.getUserMessage(symbol, data, name);\n};\n\nconst DEFAULT_ASSISTANT_FN = async (symbol, data, name, self) => {\n  return await self.params.template.getAssistantMessage(symbol, data, name);\n};\n```\n\n**Default Template Output** ([src/lib/services/template/OptimizerTemplateService.ts:77-110]()):\n- User: `\"Прочитай данные и скажи ОК\\n\\n\" + JSON.stringify(data)`\n- Assistant: `\"ОК\"`\n\nSources: [src/client/ClientOptimizer.ts:99-215](), [src/lib/services/template/OptimizerTemplateService.ts:77-110]()\n\n---\n\n## Template System\n\nTemplates generate executable code sections. Each method returns a string of TypeScript/JavaScript code.\n\n### Template Interface\n\n| Method | Returns | Purpose |\n|--------|---------|---------|\n| `getTopBanner(symbol)` | Import statements, constants | Shebang, Ollama/CCXT imports, WARN_KB constant |\n| `getUserMessage(symbol, data, name)` | Message content string | Default user message format for LLM |\n| `getAssistantMessage(symbol, data, name)` | Message content string | Default assistant response format |\n| `getWalkerTemplate(walkerName, exchangeName, frameName, strategies[])` | `addWalker()` call | Walker configuration for strategy comparison |\n| `getStrategyTemplate(strategyName, interval, prompt)` | `addStrategy()` call | Strategy with LLM-integrated getSignal() |\n| `getExchangeTemplate(symbol, exchangeName)` | `addExchange()` call | CCXT Binance integration |\n| `getFrameTemplate(symbol, frameName, interval, startDate, endDate)` | `addFrame()` call | Timeframe configuration |\n| `getLauncherTemplate(symbol, walkerName)` | `Walker.background()` call | Event listeners and execution |\n| `getTextTemplate(symbol)` | `async text(messages)` function | LLM text generation helper |\n| `getJsonTemplate(symbol)` | `async json(messages)` function | LLM structured output with signal schema |\n| `getJsonDumpTemplate(symbol)` | `async dumpJson()` function | Debug output to ./dump/strategy/{resultId}/ |\n\n### Strategy Template Example\n\nThe generated strategy uses multi-timeframe analysis:\n\n```typescript\naddStrategy({\n    strategyName: \"abc123_strategy-1\",\n    interval: \"5m\",\n    getSignal: async (symbol) => {\n        const messages = [];\n        \n        // Load candles from multiple timeframes\n        const microTermCandles = await getCandles(symbol, \"1m\", 30);\n        const mainTermCandles = await getCandles(symbol, \"5m\", 24);\n        const shortTermCandles = await getCandles(symbol, \"15m\", 24);\n        const mediumTermCandles = await getCandles(symbol, \"1h\", 24);\n        \n        // Build conversation with 4 timeframe analysis messages\n        messages.push(\n            { role: \"user\", content: \"Проанализируй свечи 1h:\\n...\" },\n            { role: \"assistant\", content: \"Тренд 1h проанализирован\" }\n        );\n        // ... (3 more timeframe pairs)\n        \n        // Final message with strategy prompt\n        messages.push({\n            role: \"user\",\n            content: [\n                \"Проанализируй все таймфреймы и сгенерируй торговый сигнал...\",\n                \"\",\n                `${strategy_prompt_from_getPrompt}`,\n                \"\",\n                \"Если сигналы противоречивы или тренд слабый то position: wait\"\n            ].join(\"\\n\")\n        });\n        \n        const result = await json(messages);\n        result.id = uuid();\n        return result;\n    }\n});\n```\n\nSources: [src/interfaces/Optimizer.interface.ts:239-374](), [src/lib/services/template/OptimizerTemplateService.ts:27-716]()\n\n---\n\n## Code Generation Pipeline\n\nThe `getCode()` method assembles all components into a single executable file.\n\n```mermaid\ngraph TD\n    Start[\"getCode(symbol)\"] --> GetData[\"getData(symbol)<br/>→ IOptimizerStrategy[]\"]\n    GetData --> CreatePrefix[\"prefix = random string<br/>(e.g., 'abc123')\"]\n    CreatePrefix --> Sections[\"sections: string[] = []\"]\n    \n    Sections --> TopBanner[\"1. getTopBanner(symbol)<br/>#!/usr/bin/env node<br/>imports from backtest-kit<br/>WARN_KB constant\"]\n    TopBanner --> JsonDump[\"2. getJsonDumpTemplate(symbol)<br/>async dumpJson() function\"]\n    JsonDump --> TextHelper[\"3. getTextTemplate(symbol)<br/>async text() function\"]\n    TextHelper --> JsonHelper[\"4. getJsonTemplate(symbol)<br/>async json() function\"]\n    JsonHelper --> Exchange[\"5. getExchangeTemplate(symbol, prefix_exchange)<br/>CCXT integration\"]\n    \n    Exchange --> TrainFrames[\"6. For each rangeTrain:<br/>getFrameTemplate(prefix_train_frame-N)\"]\n    TrainFrames --> TestFrame[\"7. getFrameTemplate(prefix_test_frame)<br/>rangeTest configuration\"]\n    TestFrame --> Strategies[\"8. For each strategyData:<br/>getStrategyTemplate(prefix_strategy-N)\"]\n    \n    Strategies --> Walker[\"9. getWalkerTemplate(<br/>  prefix_walker,<br/>  prefix_exchange,<br/>  prefix_test_frame,<br/>  [prefix_strategy-1, ...]<br/>)\"]\n    Walker --> Launcher[\"10. getLauncherTemplate(<br/>  symbol,<br/>  prefix_walker<br/>)<br/>Walker.background + listeners\"]\n    \n    Launcher --> Join[\"code = sections.join('\\\\n')\"]\n    Join --> Callback[\"callbacks.onCode?()\"]\n    Callback --> Return[\"Return code string\"]\n    \n    style GetData fill:#ffe1e1,stroke:#cc0000\n    style Strategies fill:#e1f5ff,stroke:#0066cc\n    style Walker fill:#c8e6c9,stroke:#388e3c\n```\n\n### Generated File Structure\n\nThe output `.mjs` file contains:\n\n1. **Shebang and Imports**: `#!/usr/bin/env node`, Ollama, CCXT, backtest-kit\n2. **Helper Functions**: `dumpJson()`, `text()`, `json()`\n3. **Exchange Configuration**: CCXT Binance with `fetchOHLCV()`\n4. **Frame Configurations**: N training frames + 1 test frame\n5. **Strategy Configurations**: One per `rangeTrain` entry\n6. **Walker Configuration**: Compares all strategies on test frame\n7. **Launcher Code**: `Walker.background()` with event listeners\n\n**Naming Convention**:\n- Prefix: Random 7-character string (e.g., `abc123`)\n- Exchange: `{prefix}_exchange`\n- Train frames: `{prefix}_train_frame-1`, `{prefix}_train_frame-2`, ...\n- Test frame: `{prefix}_test_frame`\n- Strategies: `{prefix}_strategy-1`, `{prefix}_strategy-2`, ...\n- Walker: `{prefix}_walker`\n\nSources: [src/client/ClientOptimizer.ts:225-350]()\n\n---\n\n## Public API Usage\n\n### Registration\n\n```typescript\nimport { addOptimizer } from \"backtest-kit\";\n\naddOptimizer({\n  optimizerName: \"my-optimizer\",\n  rangeTrain: [\n    { startDate: new Date(\"2024-01-01\"), endDate: new Date(\"2024-01-31\") },\n    { startDate: new Date(\"2024-02-01\"), endDate: new Date(\"2024-02-28\") }\n  ],\n  rangeTest: { \n    startDate: new Date(\"2024-03-01\"), \n    endDate: new Date(\"2024-03-31\") \n  },\n  source: [\n    {\n      name: \"backtest-results\",\n      fetch: async ({ symbol, startDate, endDate, limit, offset }) => {\n        // Query database with pagination\n        return await db.query(\n          \"SELECT * FROM results WHERE symbol = ? AND date >= ? AND date <= ? LIMIT ? OFFSET ?\",\n          [symbol, startDate, endDate, limit, offset]\n        );\n      },\n      user: async (symbol, data, name) => {\n        return `Analyze ${data.length} backtest results for ${symbol}:\\n${JSON.stringify(data)}`;\n      },\n      assistant: async (symbol, data, name) => {\n        return `Analyzed ${data.length} results. Key patterns identified.`;\n      }\n    }\n  ],\n  getPrompt: async (symbol, messages) => {\n    // Call LLM to generate strategy description\n    const ollama = new Ollama({ host: \"https://ollama.com\" });\n    const response = await ollama.chat({\n      model: \"deepseek-v3.1:671b\",\n      messages\n    });\n    return response.message.content;\n  }\n});\n```\n\n### Execution\n\n```typescript\nimport { Optimizer, listenOptimizerProgress } from \"backtest-kit\";\n\n// Monitor progress\nlistenOptimizerProgress((event) => {\n  console.log(`${(event.progress * 100).toFixed(2)}% - ${event.processedSources}/${event.totalSources} sources`);\n});\n\n// Generate strategy data\nconst strategies = await Optimizer.getData(\"BTCUSDT\", {\n  optimizerName: \"my-optimizer\"\n});\n\n// Generate code\nconst code = await Optimizer.getCode(\"BTCUSDT\", {\n  optimizerName: \"my-optimizer\"\n});\n\n// Save to file\nawait Optimizer.dump(\"BTCUSDT\", {\n  optimizerName: \"my-optimizer\"\n}, \"./output\");\n// Creates: ./output/my-optimizer_BTCUSDT.mjs\n```\n\nSources: [src/classes/Optimizer.ts:1-135](), [src/function/event.ts:514-557]()\n\n---\n\n## Configuration Reference\n\n### IOptimizerSchema\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `optimizerName` | `string` | Yes | Unique identifier for this optimizer |\n| `rangeTrain` | `IOptimizerRange[]` | Yes | Training time ranges (≥1 required) |\n| `rangeTest` | `IOptimizerRange` | Yes | Testing time range for generated walker |\n| `source` | `Source[]` | Yes | Data sources (≥1 required) |\n| `getPrompt` | `Function` | Yes | Generates strategy prompt from conversation history |\n| `template` | `Partial<IOptimizerTemplate>` | No | Custom template method overrides |\n| `callbacks` | `Partial<IOptimizerCallbacks>` | No | Lifecycle event hooks |\n| `note` | `string` | No | Documentation string |\n\n### IOptimizerRange\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `startDate` | `Date` | Yes | Start of time range (inclusive) |\n| `endDate` | `Date` | Yes | End of time range (inclusive) |\n| `note` | `string` | No | Description of this range |\n\n### IOptimizerCallbacks\n\n| Callback | Parameters | Trigger |\n|----------|------------|---------|\n| `onData` | `(symbol, strategyData[])` | After all strategies generated |\n| `onCode` | `(symbol, code)` | After code generation complete |\n| `onDump` | `(symbol, filepath)` | After file written to disk |\n| `onSourceData` | `(symbol, sourceName, data[], startDate, endDate)` | After each source fetch |\n\nSources: [src/interfaces/Optimizer.interface.ts:377-433]()\n\n---\n\n## Progress Tracking\n\nThe optimizer emits `ProgressOptimizerContract` events during data collection:\n\n```typescript\ninterface ProgressOptimizerContract {\n  optimizerName: string;\n  symbol: string;\n  totalSources: number;       // rangeTrain.length × source.length\n  processedSources: number;   // Counter incremented after each source\n  progress: number;           // processedSources / totalSources (0.0 - 1.0)\n}\n```\n\n**Emission Points**:\n1. At start of each source processing (before `fetch()` call)\n2. After all sources complete (progress = 1.0)\n\nEvents are emitted via `progressOptimizerEmitter` ([src/config/emitters.ts:80]()) and accessible through `listenOptimizerProgress()` ([src/function/event.ts:514-557]()).\n\nSources: [src/client/ClientOptimizer.ts:104-208](), [src/lib/services/connection/OptimizerConnectionService.ts:20-21]()\n\n---\n\n## Service Layer Details\n\n### OptimizerConnectionService\n\nCreates memoized `ClientOptimizer` instances with merged templates:\n\n```typescript\npublic getOptimizer = memoize(\n  ([optimizerName]) => `${optimizerName}`,\n  (optimizerName: OptimizerName) => {\n    const schema = this.optimizerSchemaService.get(optimizerName);\n    const rawTemplate = schema.template || {};\n    \n    // Merge custom template with defaults\n    const template: IOptimizerTemplate = {\n      getTopBanner: rawTemplate.getTopBanner || this.optimizerTemplateService.getTopBanner,\n      getExchangeTemplate: rawTemplate.getExchangeTemplate || this.optimizerTemplateService.getExchangeTemplate,\n      // ... (all 11 template methods)\n    };\n    \n    return new ClientOptimizer({\n      optimizerName,\n      logger: this.loggerService,\n      getPrompt: schema.getPrompt,\n      rangeTrain: schema.rangeTrain,\n      rangeTest: schema.rangeTest,\n      source: schema.source,\n      template,\n      callbacks: schema.callbacks\n    }, COMMIT_PROGRESS_FN);\n  }\n);\n```\n\n**Key Points**:\n- One `ClientOptimizer` instance per `optimizerName`\n- Template methods use custom implementation or default\n- Progress emitted via `COMMIT_PROGRESS_FN` callback\n\nSources: [src/lib/services/connection/OptimizerConnectionService.ts:59-113]()\n\n### OptimizerValidationService\n\nMaintains registry and validates optimizer existence:\n\n```typescript\nprivate _optimizerMap = new Map<OptimizerName, IOptimizerSchema>();\n\npublic addOptimizer = (optimizerName: OptimizerName, optimizerSchema: IOptimizerSchema): void => {\n  if (this._optimizerMap.has(optimizerName)) {\n    throw new Error(`optimizer ${optimizerName} already exist`);\n  }\n  this._optimizerMap.set(optimizerName, optimizerSchema);\n};\n\npublic validate = memoize(\n  ([optimizerName]) => optimizerName,\n  (optimizerName: OptimizerName, source: string): void => {\n    const optimizer = this._optimizerMap.get(optimizerName);\n    if (!optimizer) {\n      throw new Error(`optimizer ${optimizerName} not found source=${source}`);\n    }\n  }\n);\n```\n\nSources: [src/lib/services/validation/OptimizerValidationService.ts:13-59]()\n\n### OptimizerSchemaService\n\nUses `ToolRegistry` for immutable schema storage:\n\n```typescript\nprivate _registry = new ToolRegistry<Record<OptimizerName, IOptimizerSchema>>(\"optimizerSchema\");\n\npublic register = (key: OptimizerName, value: IOptimizerSchema) => {\n  this.validateShallow(value); // Check required fields\n  this._registry = this._registry.register(key, value);\n};\n\nprivate validateShallow = (optimizerSchema: IOptimizerSchema) => {\n  if (typeof optimizerSchema.optimizerName !== \"string\") {\n    throw new Error(`optimizer template validation failed: missing optimizerName`);\n  }\n  if (!Array.isArray(optimizerSchema.rangeTrain) || optimizerSchema.rangeTrain.length === 0) {\n    throw new Error(`optimizer template validation failed: rangeTrain must be a non-empty array`);\n  }\n  if (!Array.isArray(optimizerSchema.source) || optimizerSchema.source.length === 0) {\n    throw new Error(`optimizer template validation failed: source must be a non-empty array`);\n  }\n  if (typeof optimizerSchema.getPrompt !== \"function\") {\n    throw new Error(`optimizer template validation failed: getPrompt must be a function`);\n  }\n};\n```\n\nSources: [src/lib/services/schema/OptimizerSchemaService.ts:16-67]()\n\n---\n\n## Error Handling\n\nThe system throws errors at multiple levels:\n\n**Schema Validation** (throws immediately on `addOptimizer()`):\n- Missing `optimizerName`\n- Empty `rangeTrain` array\n- Empty `source` array\n- Missing `getPrompt` function\n\n**Runtime Validation** (throws on API calls):\n- Optimizer not found (`OptimizerValidationService.validate()`)\n- Source fetch errors (propagated from `fetch()` function)\n- LLM errors (propagated from `getPrompt()`)\n- File write errors (propagated from `dump()`)\n\n**Pagination Errors**:\n- Invalid `limit` or `offset` (handled by `iterateDocuments`)\n- Duplicate IDs ignored via `distinctDocuments`\n\nSources: [src/lib/services/schema/OptimizerSchemaService.ts:41-67](), [src/lib/services/validation/OptimizerValidationService.ts:44-59](), [src/client/ClientOptimizer.ts:360-384]()"
                    },
                    {
                        "page_plan": {
                            "id": "10.3",
                            "title": "Code Generation & Templates"
                        },
                        "content": "# Code Generation & Templates\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/classes/Optimizer.ts](src/classes/Optimizer.ts)\n- [src/client/ClientOptimizer.ts](src/client/ClientOptimizer.ts)\n- [src/interfaces/Optimizer.interface.ts](src/interfaces/Optimizer.interface.ts)\n- [src/lib/services/connection/OptimizerConnectionService.ts](src/lib/services/connection/OptimizerConnectionService.ts)\n- [src/lib/services/global/OptimizerGlobalService.ts](src/lib/services/global/OptimizerGlobalService.ts)\n- [src/lib/services/schema/OptimizerSchemaService.ts](src/lib/services/schema/OptimizerSchemaService.ts)\n- [src/lib/services/template/OptimizerTemplateService.ts](src/lib/services/template/OptimizerTemplateService.ts)\n- [src/lib/services/validation/OptimizerValidationService.ts](src/lib/services/validation/OptimizerValidationService.ts)\n- [src/model/Message.model.ts](src/model/Message.model.ts)\n\n</details>\n\n\n\nThis document covers the template system used by the Optimizer to generate executable strategy code. It explains the `IOptimizerTemplate` interface, the default `OptimizerTemplateService` implementation, how templates are assembled into complete `.mjs` files, and how to customize code generation for specific use cases.\n\nFor information about the overall optimizer system and data collection, see [Optimizer System](#10.2). For details on LLM integration and prompt engineering, see [LLM-Powered Strategy Generation](#10.1).\n\n---\n\n## Template System Overview\n\nThe template system transforms optimizer data (market analysis, backtest results, etc.) into executable Node.js modules that run Walker-based strategy comparisons with integrated LLM decision-making. Templates are TypeScript/JavaScript code generators that return strings of code.\n\n**Template Workflow Diagram**\n\n```mermaid\ngraph TB\n    Schema[\"IOptimizerSchema<br/>with optional template overrides\"]\n    Connection[\"OptimizerConnectionService<br/>merges custom + defaults\"]\n    Default[\"OptimizerTemplateService<br/>default implementations\"]\n    Interface[\"IOptimizerTemplate<br/>complete template object\"]\n    Client[\"ClientOptimizer<br/>GET_STRATEGY_CODE_FN\"]\n    \n    Sections[\"Code Sections:<br/>1. Top Banner (imports)<br/>2. dumpJson helper<br/>3. text helper<br/>4. json helper<br/>5. Exchange config<br/>6. Train Frames<br/>7. Test Frame<br/>8. Strategies<br/>9. Walker<br/>10. Launcher\"]\n    \n    Output[\"Generated .mjs file<br/>executable strategy code\"]\n    \n    Schema --> Connection\n    Default --> Connection\n    Connection --> Interface\n    Interface --> Client\n    Client --> Sections\n    Sections --> Output\n    \n    style Interface fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style Client fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\nSources: [src/lib/services/template/OptimizerTemplateService.ts:27-713](), [src/client/ClientOptimizer.ts:217-350](), [src/lib/services/connection/OptimizerConnectionService.ts:59-113]()\n\n---\n\n## IOptimizerTemplate Interface\n\nThe `IOptimizerTemplate` interface defines 11 template methods that generate different sections of the final strategy code. Each method returns a string (or Promise<string>) containing valid TypeScript/JavaScript code.\n\n**Template Methods Table**\n\n| Method | Parameters | Purpose | Output |\n|--------|-----------|---------|--------|\n| `getTopBanner` | symbol | Imports and initialization | Shebang, imports, constants |\n| `getUserMessage` | symbol, data, name | Default LLM user message | Formatted data prompt |\n| `getAssistantMessage` | symbol, data, name | Default LLM assistant response | Acknowledgment message |\n| `getWalkerTemplate` | walkerName, exchangeName, frameName, strategies | Walker configuration | `addWalker()` call |\n| `getExchangeTemplate` | symbol, exchangeName | Exchange configuration | `addExchange()` with CCXT |\n| `getFrameTemplate` | symbol, frameName, interval, startDate, endDate | Timeframe configuration | `addFrame()` call |\n| `getStrategyTemplate` | strategyName, interval, prompt | Strategy with LLM logic | `addStrategy()` with getSignal |\n| `getLauncherTemplate` | symbol, walkerName | Walker execution | `Walker.background()` + listeners |\n| `getTextTemplate` | symbol | LLM text generation helper | `async text()` function |\n| `getJsonTemplate` | symbol | LLM JSON generation helper | `async json()` function with schema |\n| `getJsonDumpTemplate` | symbol | Debug output helper | `async dumpJson()` function |\n\nSources: [src/interfaces/Optimizer.interface.ts:238-374]()\n\n**Template Method Dependencies**\n\n```mermaid\ngraph TB\n    Banner[\"getTopBanner<br/>imports, constants\"]\n    Dump[\"getJsonDumpTemplate<br/>debug helper\"]\n    Text[\"getTextTemplate<br/>LLM text generation\"]\n    Json[\"getJsonTemplate<br/>LLM JSON with schema\"]\n    Exchange[\"getExchangeTemplate<br/>CCXT integration\"]\n    TrainFrames[\"getFrameTemplate<br/>x N train ranges\"]\n    TestFrame[\"getFrameTemplate<br/>1 test range\"]\n    Strategies[\"getStrategyTemplate<br/>x N strategies\"]\n    Walker[\"getWalkerTemplate<br/>comparison config\"]\n    Launcher[\"getLauncherTemplate<br/>execution + events\"]\n    \n    Banner --> Dump\n    Dump --> Text\n    Text --> Json\n    Json --> Exchange\n    Exchange --> TrainFrames\n    TrainFrames --> TestFrame\n    TestFrame --> Strategies\n    Strategies --> Walker\n    Walker --> Launcher\n    \n    style Banner fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style Launcher fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\nSources: [src/client/ClientOptimizer.ts:225-342]()\n\n---\n\n## OptimizerTemplateService Default Implementation\n\nThe `OptimizerTemplateService` class provides default implementations for all `IOptimizerTemplate` methods. It generates code optimized for multi-timeframe analysis (1m, 5m, 15m, 1h) with Ollama LLM integration and comprehensive debugging.\n\n**Key Features**\n\n- **Multi-Timeframe Analysis**: Loads candles from 4 timeframes and formats them for LLM context [src/lib/services/template/OptimizerTemplateService.ts:202-276]()\n- **JSON Structured Output**: Uses Ollama's `format` parameter with strict schema for trading signals [src/lib/services/template/OptimizerTemplateService.ts:675-705]()\n- **Debug Logging**: Saves LLM conversations and results to `./dump/strategy/{resultId}/` [src/lib/services/template/OptimizerTemplateService.ts:457-544]()\n- **Code Injection Prevention**: Escapes special characters in all string interpolations [src/lib/services/template/OptimizerTemplateService.ts:136-147](), [src/lib/services/template/OptimizerTemplateService.ts:183-192]()\n- **CCXT Integration**: Default exchange uses `ccxt.binance()` with standard formatters [src/lib/services/template/OptimizerTemplateService.ts:328-341]()\n\n**Default Template Method Implementations**\n\n| Method | Implementation Details | Key Escaping |\n|--------|----------------------|--------------|\n| `getTopBanner` | Returns shebang + imports (Ollama, ccxt, backtest-kit, fs, uuid, path) + `WARN_KB` constant | None (static) |\n| `getStrategyTemplate` | Generates 5-message conversation: 1h analysis → 15m analysis → 5m analysis → 1m analysis → signal request | strategyName, interval, prompt (backticks, $) |\n| `getExchangeTemplate` | CCXT Binance with fetchOHLCV, price/quantity formatters | exchangeName |\n| `getFrameTemplate` | addFrame with ISO date strings | frameName, interval |\n| `getWalkerTemplate` | addWalker with strategy array | walkerName, exchangeName, frameName, strategies[] |\n| `getLauncherTemplate` | Walker.background + 7 event listeners (signal, progress, complete, done, error) | symbol, walkerName |\n| `getTextTemplate` | Ollama chat with market analysis prompt, returns escaped text | symbol (in prompt) |\n| `getJsonTemplate` | Ollama chat with signal schema (position, note, prices, time) | None (static schema) |\n| `getJsonDumpTemplate` | Saves messages to numbered markdown files with size warnings | None (dynamic paths) |\n\nSources: [src/lib/services/template/OptimizerTemplateService.ts:27-716]()\n\n**getStrategyTemplate Multi-Timeframe Flow**\n\n```mermaid\ngraph TB\n    Start[\"getSignal called<br/>by framework\"]\n    Messages[\"messages = []\"]\n    \n    Load1h[\"Load mediumTermCandles<br/>getCandles('1h', 24)\"]\n    Format1h[\"formatCandles helper<br/>ISO timestamp + OHLCV\"]\n    Push1h[\"Push user message:<br/>'Analyze 1h candles'<br/>+ formatted data\"]\n    Ack1h[\"Push assistant:<br/>'1h trend analyzed'\"]\n    \n    Load15m[\"Load shortTermCandles<br/>getCandles('15m', 24)\"]\n    Format15m[\"formatCandles helper\"]\n    Push15m[\"Push user message:<br/>'Analyze 15m candles'\"]\n    Ack15m[\"Push assistant:<br/>'15m trend analyzed'\"]\n    \n    Load5m[\"Load mainTermCandles<br/>getCandles('5m', 24)\"]\n    Format5m[\"formatCandles helper\"]\n    Push5m[\"Push user message:<br/>'Analyze 5m candles'\"]\n    Ack5m[\"Push assistant:<br/>'5m timeframe analyzed'\"]\n    \n    Load1m[\"Load microTermCandles<br/>getCandles('1m', 30)\"]\n    Format1m[\"formatCandles helper\"]\n    Push1m[\"Push user message:<br/>'Analyze 1m candles'\"]\n    Ack1m[\"Push assistant:<br/>'1m microstructure analyzed'\"]\n    \n    Strategy[\"Push user message:<br/>Analyze all timeframes<br/>+ escapedPrompt<br/>'If conflicting, wait'\"]\n    \n    Json[\"Call json(messages)<br/>Ollama with schema\"]\n    Dump[\"Call dumpJson<br/>save to disk\"]\n    Return[\"Return signal object<br/>with resultId\"]\n    \n    Start --> Messages\n    Messages --> Load1h\n    Load1h --> Format1h\n    Format1h --> Push1h\n    Push1h --> Ack1h\n    \n    Ack1h --> Load15m\n    Load15m --> Format15m\n    Format15m --> Push15m\n    Push15m --> Ack15m\n    \n    Ack15m --> Load5m\n    Load5m --> Format5m\n    Format5m --> Push5m\n    Push5m --> Ack5m\n    \n    Ack5m --> Load1m\n    Load1m --> Format1m\n    Format1m --> Push1m\n    Push1m --> Ack1m\n    \n    Ack1m --> Strategy\n    Strategy --> Json\n    Json --> Dump\n    Dump --> Return\n    \n    style Start fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style Json fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style Return fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\nSources: [src/lib/services/template/OptimizerTemplateService.ts:168-303]()\n\n---\n\n## Code Generation Workflow in ClientOptimizer\n\nThe `ClientOptimizer.getCode` method orchestrates template calls to assemble a complete executable strategy file. The `GET_STRATEGY_CODE_FN` function [src/client/ClientOptimizer.ts:225-350]() performs the following steps:\n\n**Code Assembly Process**\n\n1. **Fetch Strategy Data**: Call `getData(symbol)` to collect LLM conversation history [src/client/ClientOptimizer.ts:226]()\n2. **Generate Prefix**: Create random prefix for unique naming (e.g., `\"a1b2c3\"`) [src/client/ClientOptimizer.ts:228]()\n3. **Initialize Sections Array**: Accumulate code strings [src/client/ClientOptimizer.ts:229]()\n4. **Top Banner**: Imports and constants [src/client/ClientOptimizer.ts:233-236]()\n5. **JSON Dump Helper**: Debug output function [src/client/ClientOptimizer.ts:238-242]()\n6. **Helper Functions**: `text()` and `json()` LLM wrappers [src/client/ClientOptimizer.ts:244-253]()\n7. **Exchange Configuration**: CCXT integration [src/client/ClientOptimizer.ts:256-264]()\n8. **Train Frames**: One frame per training range [src/client/ClientOptimizer.ts:267-282]()\n9. **Test Frame**: Single validation timeframe [src/client/ClientOptimizer.ts:285-297]()\n10. **Strategies**: One strategy per training range × source combination [src/client/ClientOptimizer.ts:300-314]()\n11. **Walker Configuration**: Compare all strategies [src/client/ClientOptimizer.ts:317-332]()\n12. **Launcher**: Execute Walker with event listeners [src/client/ClientOptimizer.ts:335-341]()\n13. **Join and Callback**: Combine sections, trigger `onCode` callback [src/client/ClientOptimizer.ts:343-348]()\n\n**Generated File Naming Convention**\n\n- **Exchange**: `{prefix}_exchange` (e.g., `\"a1b2c3_exchange\"`)\n- **Train Frames**: `{prefix}_train_frame-{N}` (e.g., `\"a1b2c3_train_frame-1\"`, `\"a1b2c3_train_frame-2\"`)\n- **Test Frame**: `{prefix}_test_frame`\n- **Strategies**: `{prefix}_strategy-{N}` (e.g., `\"a1b2c3_strategy-1\"`)\n- **Walker**: `{prefix}_walker`\n\nSources: [src/client/ClientOptimizer.ts:217-350]()\n\n**Code Generation Data Flow**\n\n```mermaid\ngraph TB\n    Input[\"symbol: string<br/>ClientOptimizer instance\"]\n    GetData[\"getData(symbol)<br/>returns IOptimizerStrategy[]\"]\n    Prefix[\"CREATE_PREFIX_FN()<br/>random identifier\"]\n    \n    Banner[\"template.getTopBanner(symbol)\"]\n    JsonDump[\"template.getJsonDumpTemplate(symbol)\"]\n    TextHelper[\"template.getTextTemplate(symbol)\"]\n    JsonHelper[\"template.getJsonTemplate(symbol)\"]\n    Exchange[\"template.getExchangeTemplate(symbol, exchangeName)\"]\n    \n    TrainLoop[\"for rangeTrain[i]\"]\n    TrainFrame[\"template.getFrameTemplate(symbol, frameName, '1m', start, end)\"]\n    \n    TestFrameGen[\"template.getFrameTemplate(symbol, testFrameName, '1m', start, end)\"]\n    \n    StratLoop[\"for strategyData[i]\"]\n    StratGen[\"template.getStrategyTemplate(strategyName, '5m', strategy.strategy)\"]\n    \n    WalkerGen[\"template.getWalkerTemplate(walkerName, exchangeName, testFrameName, strategies[])\"]\n    LauncherGen[\"template.getLauncherTemplate(symbol, walkerName)\"]\n    \n    Join[\"sections.join('\\\\n')<br/>combine all code\"]\n    Callback[\"callbacks?.onCode(symbol, code)\"]\n    Output[\"code: string<br/>executable .mjs content\"]\n    \n    Input --> GetData\n    GetData --> Prefix\n    Prefix --> Banner\n    Banner --> JsonDump\n    JsonDump --> TextHelper\n    TextHelper --> JsonHelper\n    JsonHelper --> Exchange\n    Exchange --> TrainLoop\n    TrainLoop --> TrainFrame\n    TrainFrame --> TrainLoop\n    TrainLoop --> TestFrameGen\n    TestFrameGen --> StratLoop\n    StratLoop --> StratGen\n    StratGen --> StratLoop\n    StratLoop --> WalkerGen\n    WalkerGen --> LauncherGen\n    LauncherGen --> Join\n    Join --> Callback\n    Callback --> Output\n    \n    style GetData fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style Join fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style Output fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\nSources: [src/client/ClientOptimizer.ts:225-350]()\n\n---\n\n## Template Customization\n\nUsers can override individual template methods in the `IOptimizerSchema.template` property. The `OptimizerConnectionService` merges custom overrides with defaults from `OptimizerTemplateService`.\n\n**Template Merging Process**\n\n```mermaid\ngraph TB\n    Schema[\"IOptimizerSchema<br/>addOptimizer() call\"]\n    Custom[\"schema.template<br/>Partial<IOptimizerTemplate>\"]\n    Default[\"OptimizerTemplateService<br/>all 11 methods\"]\n    \n    GetOptimizer[\"OptimizerConnectionService.getOptimizer<br/>memoized factory\"]\n    Destructure[\"Destructure custom overrides<br/>with default fallbacks\"]\n    Merged[\"Complete IOptimizerTemplate<br/>all 11 methods defined\"]\n    \n    ClientParams[\"IOptimizerParams<br/>{ template: IOptimizerTemplate }\"]\n    ClientInstance[\"new ClientOptimizer(params)\"]\n    \n    Schema --> Custom\n    Schema --> GetOptimizer\n    Custom --> Destructure\n    Default --> Destructure\n    GetOptimizer --> Destructure\n    Destructure --> Merged\n    Merged --> ClientParams\n    ClientParams --> ClientInstance\n    \n    style Merged fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\nSources: [src/lib/services/connection/OptimizerConnectionService.ts:59-113]()\n\n**Custom Template Example**\n\n```typescript\naddOptimizer({\n  optimizerName: \"custom-template-optimizer\",\n  rangeTrain: [...],\n  rangeTest: {...},\n  source: [...],\n  getPrompt: async (symbol, messages) => {...},\n  \n  // Override specific templates\n  template: {\n    // Custom strategy template with different timeframes\n    getStrategyTemplate: async (strategyName, interval, prompt) => {\n      return [\n        `addStrategy({`,\n        `    strategyName: \"${strategyName}\",`,\n        `    interval: \"${interval}\",`,\n        `    getSignal: async (symbol) => {`,\n        `        // Load only 15m and 1h candles`,\n        `        const shortTerm = await getCandles(symbol, \"15m\", 12);`,\n        `        const mediumTerm = await getCandles(symbol, \"1h\", 12);`,\n        `        `,\n        `        // Custom analysis logic`,\n        `        const signal = await analyzeCustom(shortTerm, mediumTerm);`,\n        `        return signal;`,\n        `    },`,\n        `});`\n      ].join(\"\\n\");\n    },\n    \n    // Custom exchange with different CCXT exchange\n    getExchangeTemplate: async (symbol, exchangeName) => {\n      return [\n        `addExchange({`,\n        `    exchangeName: \"${exchangeName}\",`,\n        `    getCandles: async (symbol, interval, since, limit) => {`,\n        `        const exchange = new ccxt.kraken(); // Use Kraken instead`,\n        `        const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);`,\n        `        return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({`,\n        `            timestamp, open, high, low, close, volume`,\n        `        }));`,\n        `    },`,\n        `    formatPrice: async (symbol, price) => price.toFixed(4), // Different precision`,\n        `    formatQuantity: async (symbol, quantity) => quantity.toFixed(6),`,\n        `});`\n      ].join(\"\\n\");\n    },\n    \n    // All other methods use defaults from OptimizerTemplateService\n  }\n});\n```\n\n**Partial Override Behavior**\n\nThe merging logic in `OptimizerConnectionService.getOptimizer` [src/lib/services/connection/OptimizerConnectionService.ts:72-97]() uses destructuring with default fallbacks:\n\n```typescript\nconst {\n  getAssistantMessage = this.optimizerTemplateService.getAssistantMessage,\n  getExchangeTemplate = this.optimizerTemplateService.getExchangeTemplate,\n  getFrameTemplate = this.optimizerTemplateService.getFrameTemplate,\n  // ... all 11 methods\n} = rawTemplate;\n```\n\nAny method not provided in `schema.template` automatically uses the default implementation.\n\nSources: [src/lib/services/connection/OptimizerConnectionService.ts:59-113](), [src/interfaces/Optimizer.interface.ts:426-427]()\n\n---\n\n## Generated Code Structure\n\nThe final `.mjs` file produced by `ClientOptimizer.getCode` follows a 10-section structure with strict ordering to ensure correct dependency resolution.\n\n**Complete File Structure**\n\n```javascript\n#!/usr/bin/env node\n\n// ===== SECTION 1: Top Banner =====\nimport { Ollama } from \"ollama\";\nimport ccxt from \"ccxt\";\nimport {\n    addExchange,\n    addStrategy,\n    addFrame,\n    addWalker,\n    Walker,\n    Backtest,\n    getCandles,\n    listenSignalBacktest,\n    listenWalkerComplete,\n    listenDoneBacktest,\n    listenBacktestProgress,\n    listenWalkerProgress,\n    listenError,\n} from \"backtest-kit\";\nimport { promises as fs } from \"fs\";\nimport { v4 as uuid } from \"uuid\";\nimport path from \"path\";\n\nconst WARN_KB = 100;\n\n// ===== SECTION 2: dumpJson Helper =====\nasync function dumpJson(resultId, history, result, outputDir = \"./dump/strategy\") {\n    // Saves to ./dump/strategy/{resultId}/00_system_prompt.md\n    // Saves to ./dump/strategy/{resultId}/01_user_message.md\n    // ... etc\n}\n\n// ===== SECTION 3: text Helper =====\nasync function text(messages) {\n    // Ollama chat for text generation\n    // Returns escaped string\n}\n\n// ===== SECTION 4: json Helper =====\nasync function json(messages) {\n    // Ollama chat with JSON schema\n    // Returns parsed signal object\n}\n\n// ===== SECTION 5: Exchange Configuration =====\naddExchange({\n    exchangeName: \"a1b2c3_exchange\",\n    getCandles: async (symbol, interval, since, limit) => {\n        const exchange = new ccxt.binance();\n        const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n        return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n            timestamp, open, high, low, close, volume\n        }));\n    },\n    formatPrice: async (symbol, price) => price.toFixed(2),\n    formatQuantity: async (symbol, quantity) => quantity.toFixed(8),\n});\n\n// ===== SECTION 6: Train Frames (one per training range) =====\naddFrame({\n    frameName: \"a1b2c3_train_frame-1\",\n    interval: \"1m\",\n    startDate: new Date(\"2024-01-01T00:00:00.000Z\"),\n    endDate: new Date(\"2024-02-01T00:00:00.000Z\"),\n});\n\naddFrame({\n    frameName: \"a1b2c3_train_frame-2\",\n    interval: \"1m\",\n    startDate: new Date(\"2024-02-01T00:00:00.000Z\"),\n    endDate: new Date(\"2024-03-01T00:00:00.000Z\"),\n});\n\n// ===== SECTION 7: Test Frame =====\naddFrame({\n    frameName: \"a1b2c3_test_frame\",\n    interval: \"1m\",\n    startDate: new Date(\"2024-03-01T00:00:00.000Z\"),\n    endDate: new Date(\"2024-04-01T00:00:00.000Z\"),\n});\n\n// ===== SECTION 8: Strategies (one per training range) =====\naddStrategy({\n    strategyName: \"a1b2c3_strategy-1\",\n    interval: \"5m\",\n    getSignal: async (symbol) => {\n        const messages = [];\n        \n        // Load 4 timeframes\n        const microTermCandles = await getCandles(symbol, \"1m\", 30);\n        const mainTermCandles = await getCandles(symbol, \"5m\", 24);\n        const shortTermCandles = await getCandles(symbol, \"15m\", 24);\n        const mediumTermCandles = await getCandles(symbol, \"1h\", 24);\n        \n        function formatCandles(candles, timeframe) {\n            return candles.map((c) =>\n                `${new Date(c.timestamp).toISOString()}[${timeframe}]: O:${c.open} H:${c.high} L:${c.low} C:${c.close} V:${c.volume}`\n            ).join(\"\\n\");\n        }\n        \n        // Build 5-message conversation\n        messages.push(\n            { role: \"user\", content: \"Analyze 1h candles:\\n\\n\" + formatCandles(mediumTermCandles, \"1h\") },\n            { role: \"assistant\", content: \"1h trend analyzed\" }\n        );\n        messages.push(\n            { role: \"user\", content: \"Analyze 15m candles:\\n\\n\" + formatCandles(shortTermCandles, \"15m\") },\n            { role: \"assistant\", content: \"15m trend analyzed\" }\n        );\n        messages.push(\n            { role: \"user\", content: \"Analyze 5m candles:\\n\\n\" + formatCandles(mainTermCandles, \"5m\") },\n            { role: \"assistant\", content: \"5m timeframe analyzed\" }\n        );\n        messages.push(\n            { role: \"user\", content: \"Analyze 1m candles:\\n\\n\" + formatCandles(microTermCandles, \"1m\") },\n            { role: \"assistant\", content: \"1m microstructure analyzed\" }\n        );\n        messages.push({\n            role: \"user\",\n            content: \"Generate signal according to strategy:\\n\\n[STRATEGY_PROMPT_HERE]\\n\\nIf conflicting, wait\"\n        });\n        \n        const resultId = uuid();\n        const result = await json(messages);\n        await dumpJson(resultId, messages, result);\n        result.id = resultId;\n        \n        return result;\n    },\n});\n\naddStrategy({\n    strategyName: \"a1b2c3_strategy-2\",\n    interval: \"5m\",\n    getSignal: async (symbol) => {\n        // Same structure, different strategy prompt\n    },\n});\n\n// ===== SECTION 9: Walker Configuration =====\naddWalker({\n    walkerName: \"a1b2c3_walker\",\n    exchangeName: \"a1b2c3_exchange\",\n    frameName: \"a1b2c3_test_frame\",\n    strategies: [\"a1b2c3_strategy-1\", \"a1b2c3_strategy-2\"],\n});\n\n// ===== SECTION 10: Launcher =====\nWalker.background(\"BTCUSDT\", {\n    walkerName: \"a1b2c3_walker\"\n});\n\nlistenSignalBacktest((event) => {\n    console.log(event);\n});\n\nlistenBacktestProgress((event) => {\n    console.log(`Progress: ${(event.progress * 100).toFixed(2)}%`);\n    console.log(`Processed: ${event.processedFrames} / ${event.totalFrames}`);\n});\n\nlistenWalkerProgress((event) => {\n    console.log(`Progress: ${(event.progress * 100).toFixed(2)}%`);\n    console.log(`${event.processedStrategies} / ${event.totalStrategies} strategies`);\n    console.log(`Walker: ${event.walkerName}, Symbol: ${event.symbol}`);\n});\n\nlistenWalkerComplete((results) => {\n    console.log(\"Walker completed:\", results.bestStrategy);\n    Walker.dump(\"BTCUSDT\", results.walkerName);\n});\n\nlistenDoneBacktest((event) => {\n    console.log(\"Backtest completed:\", event.symbol);\n    Backtest.dump(event.symbol, event.strategyName);\n});\n\nlistenError((error) => {\n    console.error(\"Error occurred:\", error);\n});\n```\n\n**Section Dependencies**\n\n```mermaid\ngraph TB\n    S1[\"Section 1: Top Banner<br/>Imports all dependencies\"]\n    S2[\"Section 2: dumpJson<br/>Uses fs, path, uuid\"]\n    S3[\"Section 3: text<br/>Uses Ollama\"]\n    S4[\"Section 4: json<br/>Uses Ollama\"]\n    S5[\"Section 5: Exchange<br/>Uses ccxt, addExchange\"]\n    S6[\"Section 6: Train Frames<br/>Uses addFrame\"]\n    S7[\"Section 7: Test Frame<br/>Uses addFrame\"]\n    S8[\"Section 8: Strategies<br/>Uses addStrategy, getCandles, json, dumpJson\"]\n    S9[\"Section 9: Walker<br/>Uses addWalker, references exchange/frame/strategies\"]\n    S10[\"Section 10: Launcher<br/>Uses Walker.background, event listeners\"]\n    \n    S1 --> S2\n    S1 --> S3\n    S1 --> S4\n    S1 --> S5\n    S1 --> S6\n    S1 --> S7\n    S1 --> S8\n    S1 --> S9\n    S1 --> S10\n    \n    S2 --> S8\n    S3 --> S8\n    S4 --> S8\n    S5 --> S9\n    S6 --> S9\n    S7 --> S9\n    S8 --> S9\n    S9 --> S10\n    \n    style S1 fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style S9 fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style S10 fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\nSources: [src/client/ClientOptimizer.ts:225-350](), [src/lib/services/template/OptimizerTemplateService.ts:27-716]()\n\n---\n\n## LLM Integration Templates\n\nThe `getTextTemplate`, `getJsonTemplate`, and `getJsonDumpTemplate` methods generate helper functions that integrate Ollama LLM into the strategy's `getSignal` function.\n\n**JSON Template Signal Schema**\n\nThe `json()` helper enforces a strict signal schema using Ollama's `format` parameter [src/lib/services/template/OptimizerTemplateService.ts:675-705]():\n\n```json\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"position\": {\n      \"type\": \"string\",\n      \"enum\": [\"wait\", \"long\", \"short\"],\n      \"description\": \"Trade decision: wait (no signal), long (buy), or short (sell)\"\n    },\n    \"note\": {\n      \"type\": \"string\",\n      \"description\": \"Professional trading recommendation with price levels\"\n    },\n    \"priceOpen\": {\n      \"type\": \"number\",\n      \"description\": \"Entry price (current market price or limit order price)\"\n    },\n    \"priceTakeProfit\": {\n      \"type\": \"number\",\n      \"description\": \"Take profit target price\"\n    },\n    \"priceStopLoss\": {\n      \"type\": \"number\",\n      \"description\": \"Stop loss exit price\"\n    },\n    \"minuteEstimatedTime\": {\n      \"type\": \"number\",\n      \"description\": \"Expected time to reach TP in minutes (max 360)\"\n    }\n  },\n  \"required\": [\"position\", \"note\", \"priceOpen\", \"priceTakeProfit\", \"priceStopLoss\", \"minuteEstimatedTime\"]\n}\n```\n\n**System Prompt for JSON Signals**\n\nThe system message defines position opening rules [src/lib/services/template/OptimizerTemplateService.ts:646-671]():\n\n- Position types: `wait` (no clear signal), `long` (bullish), `short` (bearish)\n- Entry price: can be immediate (market) or delayed (limit order)\n- Exit levels: must have technical justification (Fibonacci, S/R, Bollinger)\n- Time estimates: based on ATR, ADX, MACD, Momentum, Slope (max 360 minutes)\n- TP/SL logic validation: LONG requires `priceTakeProfit > priceOpen > priceStopLoss`, SHORT requires `priceStopLoss > priceOpen > priceTakeProfit`\n\n**Debug Output Structure**\n\nThe `dumpJson()` function saves three types of files to `./dump/strategy/{resultId}/` [src/lib/services/template/OptimizerTemplateService.ts:457-544]():\n\n1. `00_system_prompt.md`: System messages + output JSON + result ID\n2. `{NN}_user_message.md`: Each user message with size warning if > 100 KB\n3. `{NN+1}_llm_output.md`: Final LLM JSON output with result ID\n\n**LLM Template Workflow**\n\n```mermaid\ngraph TB\n    GetSignal[\"getSignal called<br/>in strategy execution\"]\n    LoadCandles[\"Load 4 timeframes:<br/>1m, 5m, 15m, 1h\"]\n    BuildMessages[\"Build message array<br/>4 timeframe analyses\"]\n    AddStrategy[\"Add strategy prompt<br/>from getPrompt()\"]\n    \n    CallJson[\"Call json(messages)<br/>generated helper function\"]\n    \n    Ollama[\"Ollama API call<br/>model: deepseek-v3.1:671b<br/>with JSON schema\"]\n    Parse[\"JSON.parse response\"]\n    \n    UUID[\"Generate uuid()<br/>for resultId\"]\n    CallDump[\"Call dumpJson(resultId, messages, result)\"]\n    \n    SaveSystem[\"Save 00_system_prompt.md\"]\n    SaveUser[\"Save NN_user_message.md<br/>for each user message\"]\n    SaveOutput[\"Save NN+1_llm_output.md\"]\n    \n    AttachId[\"Attach resultId to signal\"]\n    Return[\"Return signal object<br/>to framework\"]\n    \n    GetSignal --> LoadCandles\n    LoadCandles --> BuildMessages\n    BuildMessages --> AddStrategy\n    AddStrategy --> CallJson\n    \n    CallJson --> Ollama\n    Ollama --> Parse\n    \n    Parse --> UUID\n    UUID --> CallDump\n    \n    CallDump --> SaveSystem\n    CallDump --> SaveUser\n    CallDump --> SaveOutput\n    \n    SaveOutput --> AttachId\n    AttachId --> Return\n    \n    style CallJson fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style Ollama fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style CallDump fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\nSources: [src/lib/services/template/OptimizerTemplateService.ts:168-303](), [src/lib/services/template/OptimizerTemplateService.ts:629-712](), [src/lib/services/template/OptimizerTemplateService.ts:452-546]()\n\n---\n\n## Code Escaping and Security\n\nAll template methods that interpolate user-provided strings perform escaping to prevent code injection. The escaping strategy varies by context:\n\n**Escaping Patterns**\n\n| Context | Special Characters | Escape Method | Example |\n|---------|-------------------|---------------|---------|\n| Double-quoted strings | `\\` `\"` | Backslash prefix | `\\\"optimizerName\\\"` |\n| Template literals | `` ` `` `$` | Backslash prefix | `` \\`symbol\\` `` |\n| Plain strings | None | None | Used for ISO dates, static code |\n\n**Escape Implementation Examples**\n\nStrategy name escaping [src/lib/services/template/OptimizerTemplateService.ts:183-186]():\n```typescript\nconst escapedStrategyName = String(strategyName)\n  .replace(/\\\\/g, '\\\\\\\\')\n  .replace(/\"/g, '\\\\\"');\n```\n\nPrompt content escaping [src/lib/services/template/OptimizerTemplateService.ts:189-192]():\n```typescript\nconst escapedPrompt = String(plainPrompt)\n  .replace(/\\\\/g, '\\\\\\\\')\n  .replace(/`/g, '\\\\`')\n  .replace(/\\$/g, '\\\\$');\n```\n\nSymbol escaping for template literals [src/lib/services/template/OptimizerTemplateService.ts:561-565]():\n```typescript\nconst escapedSymbol = String(symbol)\n  .replace(/\\\\/g, '\\\\\\\\')\n  .replace(/`/g, '\\\\`')\n  .replace(/\\$/g, '\\\\$')\n  .toUpperCase();\n```\n\n**Injection Prevention**\n\nThe escaping prevents several attack vectors:\n- **Command injection**: Escaped backslashes prevent shell command expansion\n- **String termination**: Escaped quotes prevent breaking out of string literals\n- **Variable interpolation**: Escaped `$` prevents unintended template variable expansion\n- **Template literal escape**: Escaped backticks prevent breaking out of template literals\n\nAll user-controlled inputs (names, prompts, symbols) are escaped before code generation.\n\nSources: [src/lib/services/template/OptimizerTemplateService.ts:136-147](), [src/lib/services/template/OptimizerTemplateService.ts:183-192](), [src/lib/services/template/OptimizerTemplateService.ts:324-326](), [src/lib/services/template/OptimizerTemplateService.ts:370-375](), [src/lib/services/template/OptimizerTemplateService.ts:402-407](), [src/lib/services/template/OptimizerTemplateService.ts:561-565]()\n\n---\n\n## File Output and Persistence\n\nThe `ClientOptimizer.dump` method saves generated code to the file system using the `GET_STRATEGY_DUMP_FN` function [src/client/ClientOptimizer.ts:360-384]().\n\n**Dump Workflow**\n\n```mermaid\ngraph TB\n    Input[\"dump(symbol, path)<br/>called by user\"]\n    GetCode[\"await getCode(symbol)<br/>generate complete code\"]\n    \n    Cwd[\"process.cwd()\"]\n    Join[\"path.join(cwd, path)\"]\n    Mkdir[\"mkdir(dir, recursive: true)\"]\n    \n    Filename[\"filename =<br/>{optimizerName}_{symbol}.mjs\"]\n    FilePath[\"filepath = path.join(dir, filename)\"]\n    \n    WriteFile[\"writeFile(filepath, report, 'utf-8')\"]\n    LogInfo[\"logger.info('saved: ' + filepath)\"]\n    \n    Callback[\"callbacks?.onDump(symbol, filepath)\"]\n    \n    Catch[\"catch error\"]\n    LogWarn[\"logger.warn('failed to save')\"]\n    Throw[\"throw error\"]\n    \n    Input --> GetCode\n    GetCode --> Cwd\n    Cwd --> Join\n    Join --> Mkdir\n    Mkdir --> Filename\n    Filename --> FilePath\n    FilePath --> WriteFile\n    WriteFile --> LogInfo\n    LogInfo --> Callback\n    \n    WriteFile --> Catch\n    Catch --> LogWarn\n    LogWarn --> Throw\n    \n    style GetCode fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style WriteFile fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style Callback fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\n**File Naming Convention**\n\nFormat: `{optimizerName}_{symbol}.mjs`\n\nExamples:\n- `\"momentum-optimizer_BTCUSDT.mjs\"`\n- `\"reversal-strategy_ETHUSDT.mjs\"`\n- `\"trend-following_BNBUSDT.mjs\"`\n\nThe `.mjs` extension indicates ES module format, allowing the file to be executed directly:\n```bash\nchmod +x momentum-optimizer_BTCUSDT.mjs\n./momentum-optimizer_BTCUSDT.mjs\n```\n\nOr with Node.js:\n```bash\nnode momentum-optimizer_BTCUSDT.mjs\n```\n\n**Directory Creation**\n\nThe `mkdir` call uses `{ recursive: true }` to create parent directories if they don't exist [src/client/ClientOptimizer.ts:369](). This allows paths like:\n- `\"./output/optimizers/\"` (creates `output` then `optimizers`)\n- `\"./strategies/2024/Q1/\"` (creates entire nested structure)\n\n**Callback Integration**\n\nAfter successful write, the `onDump` callback is invoked [src/client/ClientOptimizer.ts:377-379]():\n```typescript\nif (self.params.callbacks?.onDump) {\n  await self.params.callbacks.onDump(symbol, filepath);\n}\n```\n\nThis enables users to:\n- Log to external systems\n- Trigger CI/CD pipelines\n- Update strategy registries\n- Send notifications\n\nSources: [src/client/ClientOptimizer.ts:360-384](), [src/client/ClientOptimizer.ts:438-444]()\n\n---\n\n## Public API Usage\n\nUsers interact with the template system through three primary methods on the `Optimizer` class.\n\n**Optimizer API Methods**\n\n| Method | Parameters | Returns | Description |\n|--------|-----------|---------|-------------|\n| `getData` | symbol, { optimizerName } | Promise<IOptimizerStrategy[]> | Collects data from sources, returns strategies with conversation history |\n| `getCode` | symbol, { optimizerName } | Promise<string> | Generates complete executable code |\n| `dump` | symbol, { optimizerName }, path? | Promise<void> | Saves code to file (default: `\"./\"`) |\n\n**Usage Example**\n\n```typescript\nimport { addOptimizer, Optimizer } from \"backtest-kit\";\n\n// 1. Register optimizer with custom templates\naddOptimizer({\n  optimizerName: \"my-optimizer\",\n  rangeTrain: [\n    { startDate: new Date(\"2024-01-01\"), endDate: new Date(\"2024-02-01\") }\n  ],\n  rangeTest: { startDate: new Date(\"2024-03-01\"), endDate: new Date(\"2024-04-01\") },\n  source: [\n    {\n      name: \"backtest-results\",\n      fetch: async ({ symbol, startDate, endDate, limit, offset }) => {\n        // Fetch your training data\n        return data;\n      }\n    }\n  ],\n  getPrompt: async (symbol, messages) => {\n    // Generate strategy description from conversation\n    return \"Buy when RSI < 30, sell when RSI > 70\";\n  },\n  template: {\n    // Optional: override specific templates\n    getStrategyTemplate: async (strategyName, interval, prompt) => {\n      return `addStrategy({ strategyName: \"${strategyName}\", ... })`;\n    }\n  }\n});\n\n// 2. Generate and view code\nconst code = await Optimizer.getCode(\"BTCUSDT\", {\n  optimizerName: \"my-optimizer\"\n});\nconsole.log(code);\n\n// 3. Save to file\nawait Optimizer.dump(\"BTCUSDT\", {\n  optimizerName: \"my-optimizer\"\n}, \"./output\");\n// Creates: ./output/my-optimizer_BTCUSDT.mjs\n\n// 4. Get strategy data (for debugging/analysis)\nconst strategies = await Optimizer.getData(\"BTCUSDT\", {\n  optimizerName: \"my-optimizer\"\n});\nconsole.log(strategies[0].messages); // View LLM conversation\nconsole.log(strategies[0].strategy); // View generated strategy prompt\n```\n\n**Method Call Flow**\n\n```mermaid\ngraph TB\n    User[\"User calls<br/>Optimizer.getData/getCode/dump\"]\n    OptimizerUtils[\"OptimizerUtils class<br/>src/classes/Optimizer.ts\"]\n    LoggerInfo[\"loggerService.info(methodName)\"]\n    Validation[\"optimizerValidationService.validate(optimizerName)\"]\n    GlobalService[\"optimizerGlobalService[method]\"]\n    ConnectionService[\"optimizerConnectionService[method]\"]\n    GetOptimizer[\"getOptimizer(optimizerName)<br/>memoized factory\"]\n    ClientOptimizer[\"ClientOptimizer instance\"]\n    Execute[\"Execute getData/getCode/dump\"]\n    Return[\"Return result to user\"]\n    \n    User --> OptimizerUtils\n    OptimizerUtils --> LoggerInfo\n    LoggerInfo --> Validation\n    Validation --> GlobalService\n    GlobalService --> ConnectionService\n    ConnectionService --> GetOptimizer\n    GetOptimizer --> ClientOptimizer\n    ClientOptimizer --> Execute\n    Execute --> Return\n    \n    style OptimizerUtils fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style ClientOptimizer fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style Execute fill:#f9f9f9,stroke:#333,stroke-width:2px\n```\n\nSources: [src/classes/Optimizer.ts:1-135](), [src/lib/services/global/OptimizerGlobalService.ts:1-105](), [src/lib/services/connection/OptimizerConnectionService.ts:1-175]()\n\n---\n\n## Template System Design Rationale\n\nThe template system follows several key design principles:\n\n**1. Composability**: Each template method generates a self-contained code section. Users can override individual methods without affecting others.\n\n**2. Safety**: All user inputs are escaped before code generation, preventing injection attacks.\n\n**3. Debuggability**: The `dumpJson` helper saves complete LLM conversations for analysis. Generated files include unique IDs linking signals to debug logs.\n\n**4. Flexibility**: Default templates work for common cases (CCXT + Ollama), but all methods can be overridden for custom integrations.\n\n**5. Memoization**: `OptimizerConnectionService` caches optimizer instances, so template merging happens only once per optimizer name.\n\n**6. Separation of Concerns**: Templates generate code; ClientOptimizer orchestrates assembly; ConnectionService handles instantiation; GlobalService validates.\n\n**Architecture Alignment**\n\nThe template system integrates with the broader optimizer architecture as follows:\n\n- **Schema Layer**: `IOptimizerSchema` defines `template?: Partial<IOptimizerTemplate>` for customization\n- **Connection Layer**: `OptimizerConnectionService` merges custom and default templates\n- **Client Layer**: `ClientOptimizer` calls template methods to generate code sections\n- **Template Layer**: `OptimizerTemplateService` provides sensible defaults\n- **Validation Layer**: `OptimizerValidationService` ensures optimizer exists before template usage\n\nSources: [src/interfaces/Optimizer.interface.ts:376-433](), [src/lib/services/template/OptimizerTemplateService.ts:14-26](), [src/lib/services/connection/OptimizerConnectionService.ts:41-49](), [src/client/ClientOptimizer.ts:387-397]()"
                    },
                    {
                        "page_plan": {
                            "id": "10.4",
                            "title": "Crash Recovery & Persistence"
                        },
                        "content": "# Crash Recovery & Persistence\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [assets/uml.svg](assets/uml.svg)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/config/params.ts](src/config/params.ts)\n- [test/README.md](test/README.md)\n- [test/config/setup.mjs](test/config/setup.mjs)\n- [test/e2e/close.test.mjs](test/e2e/close.test.mjs)\n- [test/e2e/edge.test.mjs](test/e2e/edge.test.mjs)\n- [test/e2e/other.test.mjs](test/e2e/other.test.mjs)\n- [test/e2e/persist.test.mjs](test/e2e/persist.test.mjs)\n- [test/e2e/sanitize.test.mjs](test/e2e/sanitize.test.mjs)\n- [test/e2e/sequence.test.mjs](test/e2e/sequence.test.mjs)\n\n</details>\n\n\n\nThis document describes the crash-safe persistence system that enables live trading strategies to survive system crashes, process restarts, and unexpected failures. When a live trading bot restarts, it can seamlessly restore active signals and continue monitoring positions without data loss or duplicate trades.\n\nFor information about live trading execution modes, see [Live Trading Mode](#5.2). For custom adapter implementation details, see [Custom Persistence Backends](#10.5).\n\n---\n\n## Purpose and Scope\n\nThe persistence system provides **atomic state storage** for live trading operations. It ensures that:\n\n- **Active signals survive crashes**: Opened positions are restored after restart\n- **No duplicate trades**: The system recognizes existing positions and doesn't re-open them\n- **Clean state management**: Closed signals are automatically removed from storage\n- **Pluggable backends**: Default file-based storage can be replaced with Redis, MongoDB, or custom solutions\n\n**Critical Design Principle**: Only **opened** (active) signals are persisted. Scheduled signals (limit orders waiting for activation) are ephemeral and not saved to storage. This prevents data bloat and ensures the persistence layer only tracks real positions.\n\n---\n\n## Persistence Architecture\n\nThe framework provides four specialized persistence adapters, each responsible for a different aspect of trading state:\n\n```mermaid\ngraph TB\n    subgraph \"Persistence Layer\"\n        PSA[\"PersistSignalAdapter<br/>(Active Signals)\"]\n        PRA[\"PersistRiskAdapter<br/>(Portfolio Limits)\"]\n        PSCA[\"PersistScheduleAdapter<br/>(Schedule Tracking)\"]\n        PPA[\"PersistPartialAdapter<br/>(Profit/Loss Milestones)\"]\n    end\n    \n    subgraph \"PersistBase Interface\"\n        PB[\"PersistBase<br/>waitForInit()<br/>readValue()<br/>hasValue()<br/>writeValue()<br/>deleteValue()\"]\n    end\n    \n    subgraph \"Storage Backends\"\n        FILE[\"File System<br/>(Default)\"]\n        REDIS[\"Redis<br/>(Custom)\"]\n        MONGO[\"MongoDB<br/>(Custom)\"]\n        CUSTOM[\"Custom Backend<br/>(Your Implementation)\"]\n    end\n    \n    subgraph \"Client Layer\"\n        CS[\"ClientStrategy<br/>(tick, backtest methods)\"]\n        CR[\"ClientRisk<br/>(checkSignal, addSignal)\"]\n        CPART[\"ClientPartial<br/>(profit/loss tracking)\"]\n    end\n    \n    CS -->|\"setPendingSignal()\"| PSA\n    CS -->|\"waitForInit()\"| PSA\n    CR -->|\"portfolio state\"| PRA\n    CPART -->|\"partial events\"| PPA\n    \n    PSA -.->|implements| PB\n    PRA -.->|implements| PB\n    PSCA -.->|implements| PB\n    PPA -.->|implements| PB\n    \n    PB -->|\"atomic writes\"| FILE\n    PB -.->|\"can use\"| REDIS\n    PB -.->|\"can use\"| MONGO\n    PB -.->|\"can use\"| CUSTOM\n```\n\n**Sources**: [test/config/setup.mjs:13-87](), [docs/internals.md:38](), [README.md:20]()\n\n### Adapter Responsibilities\n\n| Adapter | Purpose | Persists When | Key Data |\n|---------|---------|---------------|----------|\n| `PersistSignalAdapter` | Active signal state | Signal opens (not scheduled) | `ISignalRow` with prices, position, timestamps |\n| `PersistRiskAdapter` | Portfolio-wide risk tracking | Risk limits updated | Active signal counts, exposure totals |\n| `PersistScheduleAdapter` | Schedule metadata | Scheduled signals created | Pending order details (ephemeral) |\n| `PersistPartialAdapter` | Profit/loss milestones | Partial levels hit | 10%, 20%, 30%+ profit/loss events |\n\n**Sources**: [test/config/setup.mjs:13-87]()\n\n---\n\n## PersistBase Interface\n\nAll persistence adapters implement the `PersistBase` interface, which defines the contract for crash-safe storage:\n\n```mermaid\nclassDiagram\n    class PersistBase {\n        <<interface>>\n        +waitForInit() Promise~void~\n        +readValue(key) Promise~T~\n        +hasValue(key) Promise~boolean~\n        +writeValue(key, value) Promise~void~\n        +deleteValue(key) Promise~void~\n    }\n    \n    class PersistSignalAdapter {\n        +usePersistSignalAdapter(class)\n        -instance: PersistBase\n        +waitForInit()\n        +readSignalData(symbol, strategyName)\n        +writeSignalData(symbol, strategyName, data)\n        +deleteSignalData(symbol, strategyName)\n    }\n    \n    class FileBasedStorage {\n        +waitForInit()\n        +readValue(key)\n        +hasValue(key)\n        +writeValue(key, value)\n        +deleteValue(key)\n    }\n    \n    class RedisStorage {\n        +waitForInit()\n        +readValue(key)\n        +hasValue(key)\n        +writeValue(key, value)\n        +deleteValue(key)\n    }\n    \n    PersistBase <|.. FileBasedStorage\n    PersistBase <|.. RedisStorage\n    PersistSignalAdapter ..> PersistBase : uses\n```\n\n**Sources**: [test/config/setup.mjs:13-30](), [docs/internals.md:38]()\n\n### Method Contracts\n\n**`waitForInit(): Promise<void>`**\n- Called once during adapter initialization\n- Must complete before any read/write operations\n- Use for connection establishment, file system setup, or authentication\n- Example: Redis client connection, file directory creation\n\n**`readValue(key: string): Promise<T>`**\n- Retrieves persisted value for the given key\n- Throws error if key doesn't exist\n- Must return typed data (deserialization handled by implementation)\n\n**`hasValue(key: string): Promise<boolean>`**\n- Checks if persisted data exists for the key\n- Returns `true` if data exists, `false` otherwise\n- Used before `readValue()` to avoid errors\n\n**`writeValue(key: string, value: T): Promise<void>`**\n- **Atomic operation**: Saves value to storage\n- Must be crash-safe (use temp files + rename for file systems)\n- Should be idempotent (multiple writes produce same result)\n\n**`deleteValue(key: string): Promise<void>`**\n- Removes persisted data for the key\n- Called when signals close\n- Must be idempotent (safe to call on non-existent keys)\n\n**Sources**: [test/config/setup.mjs:15-29]()\n\n---\n\n## Signal Persistence Lifecycle\n\nSignals transition through multiple states, but only **opened** signals are persisted. This diagram shows when persistence operations occur:\n\n```mermaid\nstateDiagram-v2\n    [*] --> Idle: \"No signal\"\n    \n    Idle --> Scheduled: \"getSignal() returns signal<br/>priceOpen not reached\"\n    \n    Scheduled --> Opened: \"Price reaches priceOpen<br/>⚡ writeValue() CALLED\"\n    Scheduled --> Cancelled: \"SL hit or timeout<br/>(no persistence)\"\n    \n    Opened --> Active: \"Position monitoring begins<br/>(persisted state)\"\n    \n    Active --> PartialProfit: \"10%, 20%, 30%+ profit<br/>PersistPartialAdapter updates\"\n    Active --> PartialLoss: \"-10%, -20%, -30%+ loss<br/>PersistPartialAdapter updates\"\n    \n    PartialProfit --> Active: \"Continue monitoring\"\n    PartialLoss --> Active: \"Continue monitoring\"\n    \n    Active --> Closed_TP: \"TP reached<br/>⚡ deleteValue() CALLED\"\n    Active --> Closed_SL: \"SL reached<br/>⚡ deleteValue() CALLED\"\n    Active --> Closed_Time: \"Time expired<br/>⚡ deleteValue() CALLED\"\n    \n    Closed_TP --> Idle: \"State cleaned up\"\n    Closed_SL --> Idle: \"State cleaned up\"\n    Closed_Time --> Idle: \"State cleaned up\"\n    Cancelled --> Idle: \"No cleanup needed\"\n    \n    note right of Scheduled\n        NOT PERSISTED\n        Ephemeral state\n        No crash recovery\n    end note\n    \n    note right of Opened\n        PERSIST START\n        writeValue() atomically\n        saves ISignalRow to storage\n    end note\n    \n    note right of Closed_TP\n        PERSIST END\n        deleteValue() removes\n        signal from storage\n    end note\n```\n\n**Sources**: [test/e2e/persist.test.mjs:1-300](), [docs/internals.md:78](), [README.md:20]()\n\n### Key State Transitions\n\n**Scheduled → Opened**: `writeValue()` called\n- Signal transitions from limit order to active position\n- `ClientStrategy.setPendingSignal()` triggers `PersistSignalAdapter.writeSignalData()`\n- Data written: `{ id, position, priceOpen, priceTakeProfit, priceStopLoss, minuteEstimatedTime, timestamp, symbol, exchangeName, strategyName }`\n\n**Active → Closed**: `deleteValue()` called\n- Position closes via TP, SL, or time expiration\n- `ClientStrategy` detects close condition and triggers deletion\n- Storage cleanup ensures no stale data remains\n\n**Crash During Active**: System restart\n- `Live.background()` starts\n- `ClientStrategy.waitForInit()` calls `PersistSignalAdapter.readSignalData()`\n- Signal state restored, monitoring continues from last known state\n\n**Sources**: [test/e2e/persist.test.mjs:36-50]()\n\n---\n\n## Atomic Write Operations\n\nPersistence operations must be **atomic** to prevent data corruption during crashes. The default file-based implementation uses a temp-file-and-rename pattern:\n\n```mermaid\nsequenceDiagram\n    participant CS as \"ClientStrategy<br/>(tick method)\"\n    participant PSA as \"PersistSignalAdapter<br/>(writeSignalData)\"\n    participant FS as \"File System\"\n    \n    Note over CS: Signal opens<br/>priceOpen reached\n    \n    CS->>PSA: writeSignalData(symbol, strategyName, data)\n    \n    Note over PSA: Generate key<br/>`${symbol}:${strategyName}`\n    \n    PSA->>FS: Write to temp file<br/>`./persist/signals/${key}.tmp`\n    FS-->>PSA: Write complete\n    \n    PSA->>FS: Atomic rename<br/>`${key}.tmp` → `${key}.json`\n    FS-->>PSA: Rename complete\n    \n    Note over PSA,FS: CRASH-SAFE POINT<br/>Either old data or new data exists<br/>Never partial/corrupted data\n    \n    PSA-->>CS: writeValue() complete\n    \n    Note over CS: Continue monitoring<br/>Signal persisted\n```\n\n**Sources**: [README.md:20](), [docs/internals.md:38]()\n\n### Why Atomic Writes Matter\n\n**Problem**: Direct file writes are not atomic\n```\n# Without atomicity - DANGEROUS\nwrite_to_file(\"signal.json\", new_data)  # Crash here = corrupted file\n```\n\n**Solution**: Temp-file-and-rename pattern\n```\n# With atomicity - SAFE\nwrite_to_file(\"signal.tmp\", new_data)   # Crash here = old data still exists\natomic_rename(\"signal.tmp\", \"signal.json\")  # Atomic OS operation\n```\n\nThe `rename()` system call is atomic on POSIX systems. Either the old file exists (before rename) or the new file exists (after rename). There's no intermediate state where the file is partially written.\n\n**Sources**: [README.md:20]()\n\n---\n\n## Recovery Flow\n\nWhen a live trading bot restarts after a crash, the recovery process follows this sequence:\n\n```mermaid\nsequenceDiagram\n    participant User as \"User Code\"\n    participant Live as \"Live.background()\"\n    participant CS as \"ClientStrategy\"\n    participant PSA as \"PersistSignalAdapter\"\n    participant FS as \"File System\"\n    \n    Note over User: Process crashed<br/>System restarts\n    \n    User->>Live: Live.background(\"BTCUSDT\", {<br/>  strategyName, exchangeName<br/>})\n    \n    Live->>CS: Create ClientStrategy instance\n    \n    CS->>PSA: waitForInit()\n    Note over PSA: Initialize storage<br/>Check file system ready\n    PSA-->>CS: Init complete\n    \n    CS->>PSA: hasValue(\"BTCUSDT:strategy\")\n    PSA->>FS: Check file exists<br/>`./persist/signals/BTCUSDT:strategy.json`\n    FS-->>PSA: File exists: true\n    PSA-->>CS: true\n    \n    CS->>PSA: readSignalData(\"BTCUSDT\", \"strategy\")\n    PSA->>FS: Read file<br/>`./persist/signals/BTCUSDT:strategy.json`\n    FS-->>PSA: Raw JSON data\n    PSA->>PSA: Parse JSON<br/>Validate ISignalRow schema\n    PSA-->>CS: Restored ISignalRow object\n    \n    Note over CS: Signal state restored<br/>{ position, priceOpen, TP, SL, ... }\n    \n    CS->>CS: tick(when, backtest=false)\n    Note over CS: Resume monitoring<br/>Check TP/SL/time conditions<br/>Continue as if no crash occurred\n    \n    alt \"TP Reached\"\n        CS->>CS: Calculate PNL\n        CS->>PSA: deleteSignalData(\"BTCUSDT\", \"strategy\")\n        PSA->>FS: Delete file\n        Note over CS,PSA: Position closed cleanly\n    end\n```\n\n**Sources**: [test/e2e/persist.test.mjs:23-94](), [docs/internals.md:74-81]()\n\n### Recovery Scenarios\n\n**Scenario 1: Crash with active LONG signal**\n```\nBefore crash:\n- Signal opened at priceOpen=43000\n- TP=44000, SL=42000\n- Position active, monitoring\n\nAfter restart:\n- readSignalData() returns saved state\n- Current price checked via VWAP\n- If price=44500 → closes by TP immediately\n- If price=43500 → continues monitoring\n```\n\n**Scenario 2: Crash during scheduled signal**\n```\nBefore crash:\n- Signal scheduled, waiting for priceOpen=42000\n- Current price=43000 (above priceOpen)\n- Not yet persisted (scheduled ≠ opened)\n\nAfter restart:\n- hasValue() returns false\n- No restoration needed\n- Signal lost (acceptable, was never opened)\n- getSignal() will generate new signal on next tick\n```\n\n**Scenario 3: Multiple strategies per symbol**\n```\nKeys stored:\n- BTCUSDT:strategy-1 → Long position\n- BTCUSDT:strategy-2 → Short position\n- ETHUSDT:strategy-1 → Long position\n\nAfter restart:\n- Each ClientStrategy instance reads its own key\n- Positions restored independently\n- No collision between strategies\n```\n\n**Sources**: [test/e2e/persist.test.mjs:23-150]()\n\n---\n\n## Default File-Based Storage\n\nThe framework includes a default file-based persistence implementation. It stores data as JSON files in the `./persist/` directory:\n\n```\n./persist/\n├── signals/\n│   ├── BTCUSDT:my-strategy.json\n│   ├── ETHUSDT:my-strategy.json\n│   └── BTCUSDT:another-strategy.json\n├── risks/\n│   ├── default-risk.json\n│   └── aggressive-risk.json\n├── schedules/\n│   └── BTCUSDT:my-strategy.json\n└── partials/\n    └── BTCUSDT:my-strategy.json\n```\n\n### File Structure Example\n\n**Signal persistence file** (`./persist/signals/BTCUSDT:my-strategy.json`):\n```json\n{\n  \"id\": \"signal-uuid-123\",\n  \"position\": \"long\",\n  \"priceOpen\": 43000,\n  \"priceTakeProfit\": 44000,\n  \"priceStopLoss\": 42000,\n  \"minuteEstimatedTime\": 60,\n  \"timestamp\": 1704067200000,\n  \"symbol\": \"BTCUSDT\",\n  \"exchangeName\": \"binance\",\n  \"strategyName\": \"my-strategy\",\n  \"note\": \"Optional signal note\"\n}\n```\n\n**Risk persistence file** (`./persist/risks/default-risk.json`):\n```json\n{\n  \"activeSignals\": {\n    \"BTCUSDT:my-strategy\": 1,\n    \"ETHUSDT:my-strategy\": 1\n  },\n  \"totalExposure\": 2,\n  \"lastUpdate\": 1704067200000\n}\n```\n\n**Sources**: [test/e2e/persist.test.mjs:33-57]()\n\n---\n\n## Testing Persistence\n\nThe test suite includes comprehensive persistence recovery scenarios. Tests verify that signals correctly restore after simulated crashes:\n\n```mermaid\ngraph TB\n    subgraph \"Test Setup\"\n        MOCK[\"Mock PersistSignalAdapter<br/>Simulates saved signal\"]\n        RESTORE[\"readValue() returns<br/>pre-crash signal state\"]\n    end\n    \n    subgraph \"Test Execution\"\n        LIVE[\"Live.background()<br/>starts with restored signal\"]\n        TICK[\"tick() method called<br/>with current price\"]\n    end\n    \n    subgraph \"Test Assertions\"\n        CALLBACK[\"onClose callback<br/>should be called\"]\n        DELETE[\"deleteValue()<br/>should be called\"]\n        PNL[\"PNL calculation<br/>should be correct\"]\n    end\n    \n    MOCK --> RESTORE\n    RESTORE --> LIVE\n    LIVE --> TICK\n    TICK --> CALLBACK\n    TICK --> DELETE\n    TICK --> PNL\n```\n\n**Sources**: [test/e2e/persist.test.mjs:1-300](), [test/config/setup.mjs:13-87]()\n\n### Example Test: LONG Signal TP After Restart\n\nThis test verifies that a LONG signal correctly closes by TP after the system restarts:\n\n```typescript\n// From test/e2e/persist.test.mjs:25-94\n\n// 1. Mock PersistSignalAdapter to return saved signal\nPersistSignalAdapter.usePersistSignalAdapter(class {\n  async readValue() {\n    return {\n      id: \"persist-long-tp\",\n      position: \"long\",\n      priceOpen: 43000,\n      priceTakeProfit: 44000,  // Current price will be at TP level\n      priceStopLoss: 42000,\n      // ... other fields\n    };\n  }\n  async hasValue() { return true; }  // Signal exists in storage\n});\n\n// 2. Configure exchange to return candles at TP level\naddExchange({\n  getCandles: async () => [{\n    open: 44000,   // Price at TP level\n    high: 44100,\n    low: 43900,\n    close: 44000,\n    // ...\n  }]\n});\n\n// 3. Register strategy with onClose callback\nlet onCloseCalled = false;\naddStrategy({\n  getSignal: async () => null,  // No new signals\n  callbacks: {\n    onClose: () => { onCloseCalled = true; }\n  }\n});\n\n// 4. Start live trading (will restore signal)\nLive.background(\"BTCUSDT\", { strategyName, exchangeName });\n\n// 5. Verify signal closed by TP after restart\n// onCloseCalled === true\n// closeReason === \"take_profit\"\n```\n\n**Sources**: [test/e2e/persist.test.mjs:25-94]()\n\n### Test Coverage Matrix\n\n| Test | Scenario | Verifies |\n|------|----------|----------|\n| PERSIST #1 | LONG TP after restart | Signal restores, closes by TP, callback fires |\n| PERSIST #2 | LONG SL after restart | Signal restores, closes by SL, negative PNL |\n| PERSIST #3 | SHORT TP after restart | Short position logic, closes by TP |\n| PERSIST #4 | SHORT SL after restart | Short position logic, closes by SL |\n| PERSIST #5 | Time expired after restart | Signal restores, closes by time expiration |\n| PERSIST #6 | No persisted data | hasValue()=false, starts fresh |\n\n**Sources**: [test/e2e/persist.test.mjs:1-300]()\n\n---\n\n## Disabling Persistence in Tests\n\nFor unit tests and backtests, persistence is typically disabled to avoid file system I/O and improve test speed. The test setup provides mock adapters that implement `PersistBase` but don't actually write to disk:\n\n```typescript\n// From test/config/setup.mjs:13-30\n\nPersistSignalAdapter.usePersistSignalAdapter(class {\n  async waitForInit() { /* no-op */ }\n  \n  async readValue() {\n    throw new Error(\"Should not be called in testbed\");\n  }\n  \n  async hasValue() {\n    return false;  // Always return false in tests\n  }\n  \n  async writeValue() { /* no-op */ }\n  async deleteValue() { /* no-op */ }\n});\n```\n\nThis approach ensures:\n- Tests run in-memory without disk I/O\n- No cleanup required after test runs\n- Faster test execution\n- No file system side effects\n\n**Sources**: [test/config/setup.mjs:13-87]()\n\n---\n\n## Integration Points\n\nThe persistence system integrates with multiple framework components:\n\n```mermaid\ngraph TB\n    subgraph \"Strategy Layer\"\n        CS[\"ClientStrategy<br/>(tick, backtest methods)\"]\n        SCS[\"StrategyConnectionService<br/>(memoized instances)\"]\n    end\n    \n    subgraph \"Persistence Layer\"\n        PSA[\"PersistSignalAdapter\"]\n        PB[\"PersistBase implementation\"]\n    end\n    \n    subgraph \"Execution Modes\"\n        LIVE[\"LiveLogicPrivateService<br/>(infinite loop)\"]\n        BT[\"BacktestLogicPrivateService<br/>(historical simulation)\"]\n    end\n    \n    subgraph \"Public API\"\n        LIVE_CMD[\"Live.background()\"]\n        BT_CMD[\"Backtest.background()\"]\n    end\n    \n    LIVE_CMD -->|\"starts\"| LIVE\n    BT_CMD -->|\"starts\"| BT\n    \n    LIVE -->|\"calls\"| SCS\n    BT -->|\"calls\"| SCS\n    \n    SCS -->|\"creates\"| CS\n    \n    CS -->|\"waitForInit()\"| PSA\n    CS -->|\"readSignalData()\"| PSA\n    CS -->|\"writeSignalData()\"| PSA\n    CS -->|\"deleteSignalData()\"| PSA\n    \n    PSA -->|\"delegates to\"| PB\n    \n    Note1[\"Live mode:<br/>Persistence ENABLED<br/>Signals restored on restart\"]\n    Note2[\"Backtest mode:<br/>Persistence DISABLED<br/>In-memory only\"]\n    \n    LIVE -.->|reads| Note1\n    BT -.->|reads| Note2\n```\n\n**Sources**: [docs/internals.md:54-81](), [test/config/setup.mjs:13-87]()\n\n### ClientStrategy Integration\n\n**`ClientStrategy.waitForInit()`** - [docs/internals.md:76]()\n- Called once per strategy instance before any tick operations\n- Triggers `PersistSignalAdapter.waitForInit()` and `hasValue()` check\n- If persisted data exists, calls `readSignalData()` to restore state\n\n**`ClientStrategy.setPendingSignal()`** - [docs/internals.md:77]()\n- Called when signal transitions from scheduled to opened\n- Triggers `PersistSignalAdapter.writeSignalData()`\n- Atomic write ensures crash safety\n\n**`ClientStrategy.tick()`** - [docs/internals.md:62-67]()\n- Monitors active signals for TP/SL/time conditions\n- When signal closes, triggers `PersistSignalAdapter.deleteSignalData()`\n- Cleanup ensures no stale data remains\n\n**Sources**: [docs/internals.md:54-81]()\n\n---\n\n## Configuration Options\n\nPersistence behavior can be configured globally via `GLOBAL_CONFIG`:\n\n```typescript\n// From src/config/params.ts:1-122\n\nsetConfig({\n  CC_SCHEDULE_AWAIT_MINUTES: 120,  // Scheduled signal timeout\n  CC_AVG_PRICE_CANDLES_COUNT: 5,   // VWAP calculation window\n  // ... other config options\n});\n```\n\n**Key Configuration Parameters**:\n\n| Parameter | Default | Impact on Persistence |\n|-----------|---------|----------------------|\n| `CC_SCHEDULE_AWAIT_MINUTES` | 120 | Max time scheduled signals wait before cancellation (not persisted) |\n| `CC_MAX_SIGNAL_LIFETIME_MINUTES` | 1440 | Max lifetime for persisted signals (auto-close after 1 day) |\n| `CC_PERCENT_FEE` | 0.1 | Fee applied to PNL calculations (persisted in closed signal data) |\n| `CC_PERCENT_SLIPPAGE` | 0.1 | Slippage applied to PNL (persisted in closed signal data) |\n\n**Sources**: [src/config/params.ts:1-122](), [test/config/setup.mjs:89-102]()\n\n---\n\n## Best Practices\n\n**1. Always use atomic writes for custom backends**\n```typescript\n// ✅ GOOD: Atomic writes with temp files\nasync writeValue(key, value) {\n  const tmpPath = `${key}.tmp`;\n  const finalPath = `${key}.json`;\n  await fs.writeFile(tmpPath, JSON.stringify(value));\n  await fs.rename(tmpPath, finalPath);  // Atomic on POSIX\n}\n\n// ❌ BAD: Direct writes (not crash-safe)\nasync writeValue(key, value) {\n  await fs.writeFile(`${key}.json`, JSON.stringify(value));\n  // Crash during write = corrupted file\n}\n```\n\n**2. Implement proper error handling in readValue()**\n```typescript\n// ✅ GOOD: Clear error messages\nasync readValue(key) {\n  if (!await this.hasValue(key)) {\n    throw new Error(`No persisted data found for key: ${key}`);\n  }\n  const data = await fs.readFile(`${key}.json`, 'utf-8');\n  return JSON.parse(data);\n}\n\n// ❌ BAD: Generic errors\nasync readValue(key) {\n  return JSON.parse(await fs.readFile(`${key}.json`));\n  // Crash with unhelpful \"ENOENT\" error\n}\n```\n\n**3. Make deleteValue() idempotent**\n```typescript\n// ✅ GOOD: Safe to call multiple times\nasync deleteValue(key) {\n  try {\n    await fs.unlink(`${key}.json`);\n  } catch (err) {\n    if (err.code !== 'ENOENT') throw err;\n    // Ignore \"file not found\" errors\n  }\n}\n\n// ❌ BAD: Crashes on missing file\nasync deleteValue(key) {\n  await fs.unlink(`${key}.json`);\n  // Crash if file already deleted\n}\n```\n\n**4. Validate restored data**\n```typescript\n// ✅ GOOD: Schema validation after restore\nasync readValue(key) {\n  const data = await this.storage.get(key);\n  \n  // Validate required fields\n  if (!data.position || !data.priceOpen || !data.priceTakeProfit) {\n    throw new Error(`Invalid signal data in storage: ${key}`);\n  }\n  \n  // Validate data types\n  if (typeof data.priceOpen !== 'number') {\n    throw new Error(`Invalid priceOpen type: ${typeof data.priceOpen}`);\n  }\n  \n  return data;\n}\n\n// ❌ BAD: Blindly trust storage\nasync readValue(key) {\n  return await this.storage.get(key);\n  // Corrupted data crashes the system\n}\n```\n\n**5. Test recovery scenarios**\n```typescript\n// ✅ GOOD: Test all close conditions after restart\ntest(\"PERSIST: Signal closes by TP after restart\", async () => { /* ... */ });\ntest(\"PERSIST: Signal closes by SL after restart\", async () => { /* ... */ });\ntest(\"PERSIST: Signal closes by time after restart\", async () => { /* ... */ });\n```\n\n**Sources**: [test/e2e/persist.test.mjs:1-300](), [README.md:20]()\n\n---\n\n## Limitations and Considerations\n\n**1. Scheduled signals are not persisted**\n- Limit orders waiting for activation are ephemeral\n- Lost on crash/restart (acceptable trade-off)\n- Prevents data bloat for signals that never opened\n- `getSignal()` will generate new signals after restart\n\n**2. File-based storage is not distributed**\n- Default implementation uses local file system\n- Cannot share state across multiple processes/servers\n- For distributed systems, implement Redis or database backend\n\n**3. Storage keys must be unique**\n- Key format: `${symbol}:${strategyName}`\n- Multiple strategies on same symbol use different keys\n- Collision prevention is critical\n\n**4. No transaction support**\n- Each adapter operates independently\n- No atomic multi-adapter writes\n- Consider distributed transactions for custom backends\n\n**5. Performance considerations**\n- File I/O on every signal open/close\n- For high-frequency strategies, consider in-memory caching\n- Redis backend recommended for < 1ms persistence latency\n\n**Sources**: [docs/internals.md:38](), [test/README.md:7-26]()\n\n---\n\n## Summary\n\nThe persistence system provides **crash-safe state storage** for live trading through:\n\n- **Atomic write operations** prevent data corruption\n- **Selective persistence** (opened signals only) prevents bloat\n- **Pluggable backends** enable Redis, MongoDB, or custom storage\n- **Automatic recovery** restores signals on restart\n- **Clean cleanup** deletes closed signals automatically\n\nKey integration points:\n- `ClientStrategy.waitForInit()` - Initialization and restoration\n- `ClientStrategy.setPendingSignal()` - Write on signal open\n- `ClientStrategy.tick()` - Delete on signal close\n\nFor custom backend implementation, see [Custom Persistence Backends](#10.5).\n\n**Sources**: [README.md:20](), [docs/internals.md:38](), [test/e2e/persist.test.mjs:1-300]()"
                    },
                    {
                        "page_plan": {
                            "id": "10.5",
                            "title": "Custom Persistence Backends"
                        },
                        "content": "# Custom Persistence Backends\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [assets/uml.svg](assets/uml.svg)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [scripts/uml.mjs](scripts/uml.mjs)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page explains how to implement custom persistence backends for signal storage in Backtest Kit. The default framework uses file-based atomic writes, but you can extend it to use Redis, MongoDB, PostgreSQL, or any other storage system by implementing the `PersistBase` interface.\n\nFor information about the built-in persistence system and crash recovery mechanisms, see [Crash Recovery & Persistence](#10.4). For general signal lifecycle concepts, see [Signals & Signal Lifecycle](#3.1).\n\n---\n\n## Persistence Architecture Overview\n\nThe persistence layer in Backtest Kit follows a pluggable adapter pattern, allowing custom storage backends to be seamlessly integrated without modifying core framework code.\n\n```mermaid\ngraph TB\n    subgraph \"Client Layer\"\n        CS[\"ClientStrategy\"]\n    end\n    \n    subgraph \"Persistence Layer\"\n        PSA[\"PersistSignalAdapter<br/>(Framework Adapter)\"]\n        PB[\"PersistBase<br/>(Abstract Interface)\"]\n    end\n    \n    subgraph \"Built-in Implementation\"\n        FILE[\"PersistFile<br/>(Default File Storage)\"]\n    end\n    \n    subgraph \"Custom Implementations\"\n        REDIS[\"PersistRedis<br/>(Custom Redis Backend)\"]\n        MONGO[\"PersistMongo<br/>(Custom MongoDB Backend)\"]\n        SQL[\"PersistPostgres<br/>(Custom SQL Backend)\"]\n    end\n    \n    CS -->|\"setPendingSignal()\"| PSA\n    CS -->|\"waitForInit()\"| PSA\n    \n    PSA -->|\"extends\"| PB\n    \n    FILE -.->|\"extends\"| PB\n    REDIS -.->|\"extends\"| PB\n    MONGO -.->|\"extends\"| PB\n    SQL -.->|\"extends\"| PB\n    \n    PSA -->|\"writeSignalData()\"| FILE\n    PSA -->|\"readSignalData()\"| FILE\n    PSA -->|\"deleteSignalData()\"| FILE\n```\n\n**Persistence Architecture**\n\nThe `ClientStrategy` class uses `PersistSignalAdapter` for all persistence operations. The adapter delegates to a `PersistBase` implementation, which can be the default file-based storage or a custom backend. The adapter provides:\n\n- **Atomic Operations**: Ensures signals are never partially written or lost\n- **Crash Recovery**: Restores state via `waitForInit()` on live trading startup\n- **Lazy Initialization**: Defers I/O until first signal is opened\n- **Error Handling**: Propagates storage errors to the event system\n\nSources: High-level diagrams from context, [docs/internals.md]()\n\n---\n\n## The PersistBase Interface\n\nCustom persistence backends must implement the `PersistBase` interface, which defines three core methods for signal lifecycle management:\n\n```mermaid\nclassDiagram\n    class PersistBase {\n        <<interface>>\n        +writeSignalData(symbol: string, strategyName: string, data: ISignalRow) Promise~void~\n        +readSignalData(symbol: string, strategyName: string) Promise~ISignalRow | null~\n        +deleteSignalData(symbol: string, strategyName: string) Promise~void~\n    }\n    \n    class PersistSignalAdapter {\n        -persistBase: PersistBase\n        -initPromise: Map~string, Promise~ISignalRow~\n        +waitForInit(symbol: string, strategyName: string) Promise~ISignalRow~\n        +setPendingSignal(symbol: string, strategyName: string, data: ISignalRow) Promise~void~\n        +deletePendingSignal(symbol: string, strategyName: string) Promise~void~\n    }\n    \n    class ISignalRow {\n        <<interface>>\n        +id: string\n        +position: \"long\" | \"short\"\n        +priceOpen: number\n        +priceTakeProfit: number\n        +priceStopLoss: number\n        +openTimestamp: number\n        +...more fields\n    }\n    \n    PersistSignalAdapter --> PersistBase : delegates to\n    PersistSignalAdapter ..> ISignalRow : reads/writes\n    PersistBase ..> ISignalRow : serializes\n```\n\n**PersistBase Interface Contract**\n\n### Method Signatures\n\n| Method | Purpose | Atomicity Requirement |\n|--------|---------|----------------------|\n| `writeSignalData()` | Persist an opened signal to storage | Must be atomic - no partial writes |\n| `readSignalData()` | Load persisted signal on startup | Must return `null` if not found |\n| `deleteSignalData()` | Remove closed signal from storage | Must be idempotent |\n\n### Key Considerations\n\nThe interface uses a **composite key** of `(symbol, strategyName)` because:\n- Only one active signal per symbol-strategy pair is allowed\n- This prevents duplicate position entries\n- Enables efficient lookup without scanning all records\n\nThe `ISignalRow` type contains all signal state:\n- Entry/exit prices (`priceOpen`, `priceTakeProfit`, `priceStopLoss`)\n- Timestamps (`openTimestamp`, `minuteEstimatedTime`)\n- Position direction (`position: \"long\" | \"short\"`)\n- Unique identifier (`id`)\n\nImplementations must serialize/deserialize this object correctly, preserving numeric precision for prices.\n\nSources: [docs/internals.md](), High-level architecture diagrams\n\n---\n\n## Built-in File-Based Persistence\n\nThe default `PersistFile` implementation provides a reference for custom backends:\n\n```mermaid\nsequenceDiagram\n    participant CS as ClientStrategy\n    participant PSA as PersistSignalAdapter\n    participant PF as PersistFile\n    participant FS as File System\n    \n    Note over CS,FS: Signal Opening Flow\n    CS->>PSA: setPendingSignal(symbol, strategy, data)\n    PSA->>PF: writeSignalData(symbol, strategy, data)\n    PF->>PF: Build file path: ./data/{strategy}/{symbol}.json\n    PF->>FS: Write JSON atomically (tmp + rename)\n    FS-->>PF: Write complete\n    PF-->>PSA: Success\n    PSA-->>CS: Persisted\n    \n    Note over CS,FS: Crash Recovery Flow\n    CS->>PSA: waitForInit(symbol, strategy)\n    PSA->>PF: readSignalData(symbol, strategy)\n    PF->>FS: Read ./data/{strategy}/{symbol}.json\n    alt File exists\n        FS-->>PF: JSON content\n        PF->>PF: Parse JSON to ISignalRow\n        PF-->>PSA: ISignalRow\n    else File not found\n        FS-->>PF: File not found\n        PF-->>PSA: null\n    end\n    PSA-->>CS: Restored signal or null\n    \n    Note over CS,FS: Signal Closing Flow\n    CS->>PSA: deletePendingSignal(symbol, strategy)\n    PSA->>PF: deleteSignalData(symbol, strategy)\n    PF->>FS: Delete ./data/{strategy}/{symbol}.json\n    FS-->>PF: Deleted\n    PF-->>PSA: Success\n    PSA-->>CS: Removed\n```\n\n**File-Based Persistence Flow**\n\n### Atomic Write Strategy\n\nThe file-based implementation uses a **write-to-temporary-then-rename** pattern:\n1. Write new data to `{symbol}.json.tmp`\n2. Call `fsync()` to ensure data reaches disk\n3. Rename `{symbol}.json.tmp` to `{symbol}.json` (atomic operation on POSIX systems)\n4. This prevents partial writes if the process crashes mid-write\n\n### Directory Structure\n\n```\n./data/\n├── strategy1/\n│   ├── BTCUSDT.json\n│   └── ETHUSDT.json\n└── strategy2/\n    └── BTCUSDT.json\n```\n\nEach strategy gets its own directory to organize signals. The composite key `(strategyName, symbol)` maps to the file path.\n\nSources: [docs/internals.md](), README.md references to crash-safe persistence\n\n---\n\n## Implementing a Custom Backend\n\n### Redis Implementation Example\n\nRedis is ideal for live trading due to its speed and built-in data expiration features:\n\n```mermaid\ngraph LR\n    subgraph \"Redis Data Model\"\n        KEY[\"Key Format:<br/>signal:{strategyName}:{symbol}\"]\n        VALUE[\"Value: JSON String<br/>{id, position, priceOpen, ...}\"]\n        TTL[\"TTL: Optional expiration<br/>(e.g., 7 days)\"]\n    end\n    \n    KEY --> VALUE\n    VALUE --> TTL\n    \n    subgraph \"Operations\"\n        SET[\"SET signal:strategy1:BTCUSDT '{...}'\"]\n        GET[\"GET signal:strategy1:BTCUSDT\"]\n        DEL[\"DEL signal:strategy1:BTCUSDT\"]\n    end\n    \n    subgraph \"Atomicity\"\n        ATOMIC[\"Redis commands are atomic<br/>No need for transactions\"]\n    end\n```\n\n**Redis Persistence Schema**\n\n#### Implementation Pattern\n\n```typescript\n// Hypothetical implementation - not actual framework code\nclass PersistRedis extends PersistBase {\n  \n  constructor(private redisClient: RedisClient, private ttlSeconds?: number) {\n    super();\n  }\n  \n  async writeSignalData(\n    symbol: string,\n    strategyName: string,\n    data: ISignalRow\n  ): Promise<void> {\n    const key = `signal:${strategyName}:${symbol}`;\n    const value = JSON.stringify(data);\n    \n    if (this.ttlSeconds) {\n      // Set with expiration to auto-cleanup old signals\n      await this.redisClient.setex(key, this.ttlSeconds, value);\n    } else {\n      await this.redisClient.set(key, value);\n    }\n  }\n  \n  async readSignalData(\n    symbol: string,\n    strategyName: string\n  ): Promise<ISignalRow | null> {\n    const key = `signal:${strategyName}:${symbol}`;\n    const value = await this.redisClient.get(key);\n    \n    if (!value) {\n      return null;\n    }\n    \n    return JSON.parse(value) as ISignalRow;\n  }\n  \n  async deleteSignalData(\n    symbol: string,\n    strategyName: string\n  ): Promise<void> {\n    const key = `signal:${strategyName}:${symbol}`;\n    await this.redisClient.del(key);\n  }\n}\n```\n\n#### Key Design Decisions\n\n| Aspect | Decision | Rationale |\n|--------|----------|-----------|\n| Key Format | `signal:{strategy}:{symbol}` | Clear namespace, easy pattern matching |\n| Serialization | JSON string | Compatible with `ISignalRow` structure |\n| TTL | Optional expiration | Auto-cleanup for abandoned signals |\n| Atomicity | Native Redis commands | `SET`/`GET`/`DEL` are inherently atomic |\n| Error Handling | Throw on connection failure | Framework propagates to `errorEmitter` |\n\n#### Connection Management\n\n```typescript\n// Example connection setup\nimport Redis from 'ioredis';\n\nconst redisClient = new Redis({\n  host: process.env.REDIS_HOST,\n  port: parseInt(process.env.REDIS_PORT),\n  password: process.env.REDIS_PASSWORD,\n  retryStrategy: (times) => Math.min(times * 50, 2000),\n  // Reconnect automatically\n});\n\nconst persistRedis = new PersistRedis(redisClient, 7 * 24 * 3600); // 7-day TTL\n```\n\nSources: Architecture diagrams, general Redis best practices\n\n---\n\n### MongoDB Implementation Example\n\nMongoDB provides rich query capabilities and automatic schema evolution:\n\n```mermaid\ngraph TB\n    subgraph \"MongoDB Schema\"\n        COLL[\"Collection: signals\"]\n        DOC[\"Document Structure\"]\n    end\n    \n    subgraph \"Document Fields\"\n        ID[\"_id: ObjectId (auto-generated)\"]\n        COMP[\"compositeKey: 'strategy1:BTCUSDT'\"]\n        STRAT[\"strategyName: 'strategy1'\"]\n        SYM[\"symbol: 'BTCUSDT'\"]\n        DATA[\"signalData: { id, position, priceOpen, ... }\"]\n        TS[\"updatedAt: ISODate (auto)\"]\n    end\n    \n    subgraph \"Indexes\"\n        IDX1[\"Unique index on compositeKey\"]\n        IDX2[\"Index on strategyName + symbol\"]\n        IDX3[\"TTL index on updatedAt (optional)\"]\n    end\n    \n    COLL --> DOC\n    DOC --> ID\n    DOC --> COMP\n    DOC --> STRAT\n    DOC --> SYM\n    DOC --> DATA\n    DOC --> TS\n    \n    IDX1 -.->|\"enforces\"| COMP\n    IDX2 -.->|\"optimizes\"| STRAT\n    IDX2 -.->|\"optimizes\"| SYM\n    IDX3 -.->|\"auto-deletes\"| TS\n```\n\n**MongoDB Document Schema**\n\n#### Implementation Pattern\n\n```typescript\n// Hypothetical implementation\nimport { MongoClient, Collection } from 'mongodb';\n\nclass PersistMongo extends PersistBase {\n  private collection: Collection;\n  \n  constructor(mongoClient: MongoClient, dbName: string) {\n    super();\n    this.collection = mongoClient.db(dbName).collection('signals');\n    this.ensureIndexes();\n  }\n  \n  private async ensureIndexes(): Promise<void> {\n    // Unique index on composite key to prevent duplicates\n    await this.collection.createIndex(\n      { compositeKey: 1 },\n      { unique: true }\n    );\n    \n    // Optional TTL index for auto-cleanup (7 days)\n    await this.collection.createIndex(\n      { updatedAt: 1 },\n      { expireAfterSeconds: 7 * 24 * 3600 }\n    );\n  }\n  \n  async writeSignalData(\n    symbol: string,\n    strategyName: string,\n    data: ISignalRow\n  ): Promise<void> {\n    const compositeKey = `${strategyName}:${symbol}`;\n    \n    // Use upsert for atomic write-or-update\n    await this.collection.updateOne(\n      { compositeKey },\n      {\n        $set: {\n          strategyName,\n          symbol,\n          signalData: data,\n          updatedAt: new Date(),\n        },\n      },\n      { upsert: true }\n    );\n  }\n  \n  async readSignalData(\n    symbol: string,\n    strategyName: string\n  ): Promise<ISignalRow | null> {\n    const compositeKey = `${strategyName}:${symbol}`;\n    \n    const doc = await this.collection.findOne({ compositeKey });\n    \n    if (!doc) {\n      return null;\n    }\n    \n    return doc.signalData as ISignalRow;\n  }\n  \n  async deleteSignalData(\n    symbol: string,\n    strategyName: string\n  ): Promise<void> {\n    const compositeKey = `${strategyName}:${symbol}`;\n    \n    await this.collection.deleteOne({ compositeKey });\n  }\n}\n```\n\n#### Upsert Strategy\n\nThe MongoDB implementation uses **upsert** (update-or-insert) for atomic writes:\n- If document exists with matching `compositeKey`, update it\n- If document doesn't exist, insert new document\n- This prevents race conditions between read-check-write operations\n\n#### Indexing Strategy\n\n| Index | Type | Purpose |\n|-------|------|---------|\n| `compositeKey` | Unique | Enforce one signal per strategy-symbol pair |\n| `strategyName + symbol` | Compound | Optimize queries by both fields |\n| `updatedAt` | TTL | Auto-delete signals after 7 days |\n\nThe TTL index uses MongoDB's native expiration feature to clean up abandoned signals automatically.\n\nSources: MongoDB best practices, [docs/internals.md]()\n\n---\n\n### PostgreSQL Implementation Example\n\nPostgreSQL provides ACID guarantees and relational integrity:\n\n```mermaid\nerDiagram\n    SIGNALS {\n        serial id PK\n        varchar strategy_name\n        varchar symbol\n        jsonb signal_data\n        timestamp created_at\n        timestamp updated_at\n    }\n    \n    SIGNALS ||--o{ UNIQUE_CONSTRAINT : \"strategy_name + symbol\"\n```\n\n**PostgreSQL Table Schema**\n\n#### Implementation Pattern\n\n```typescript\n// Hypothetical implementation\nimport { Pool } from 'pg';\n\nclass PersistPostgres extends PersistBase {\n  private pool: Pool;\n  \n  constructor(pool: Pool) {\n    super();\n    this.pool = pool;\n    this.ensureTable();\n  }\n  \n  private async ensureTable(): Promise<void> {\n    await this.pool.query(`\n      CREATE TABLE IF NOT EXISTS signals (\n        id SERIAL PRIMARY KEY,\n        strategy_name VARCHAR(255) NOT NULL,\n        symbol VARCHAR(50) NOT NULL,\n        signal_data JSONB NOT NULL,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        UNIQUE(strategy_name, symbol)\n      );\n      \n      CREATE INDEX IF NOT EXISTS idx_signals_composite \n        ON signals(strategy_name, symbol);\n    `);\n  }\n  \n  async writeSignalData(\n    symbol: string,\n    strategyName: string,\n    data: ISignalRow\n  ): Promise<void> {\n    // Use ON CONFLICT for upsert behavior\n    await this.pool.query(\n      `\n      INSERT INTO signals (strategy_name, symbol, signal_data, updated_at)\n      VALUES ($1, $2, $3, CURRENT_TIMESTAMP)\n      ON CONFLICT (strategy_name, symbol)\n      DO UPDATE SET \n        signal_data = EXCLUDED.signal_data,\n        updated_at = CURRENT_TIMESTAMP\n      `,\n      [strategyName, symbol, JSON.stringify(data)]\n    );\n  }\n  \n  async readSignalData(\n    symbol: string,\n    strategyName: string\n  ): Promise<ISignalRow | null> {\n    const result = await this.pool.query(\n      `\n      SELECT signal_data \n      FROM signals \n      WHERE strategy_name = $1 AND symbol = $2\n      `,\n      [strategyName, symbol]\n    );\n    \n    if (result.rows.length === 0) {\n      return null;\n    }\n    \n    return result.rows[0].signal_data as ISignalRow;\n  }\n  \n  async deleteSignalData(\n    symbol: string,\n    strategyName: string\n  ): Promise<void> {\n    await this.pool.query(\n      `\n      DELETE FROM signals \n      WHERE strategy_name = $1 AND symbol = $2\n      `,\n      [strategyName, symbol]\n    );\n  }\n}\n```\n\n#### Transaction Considerations\n\nPostgreSQL's `ON CONFLICT` clause provides **atomic upsert** behavior without explicit transactions. For more complex scenarios (e.g., multi-signal operations), you can use explicit transactions:\n\n```typescript\nasync writeMultipleSignals(signals: Array<{\n  symbol: string;\n  strategyName: string;\n  data: ISignalRow;\n}>): Promise<void> {\n  const client = await this.pool.connect();\n  \n  try {\n    await client.query('BEGIN');\n    \n    for (const { symbol, strategyName, data } of signals) {\n      await client.query(\n        `INSERT INTO signals ... ON CONFLICT ... DO UPDATE ...`,\n        [strategyName, symbol, JSON.stringify(data)]\n      );\n    }\n    \n    await client.query('COMMIT');\n  } catch (error) {\n    await client.query('ROLLBACK');\n    throw error;\n  } finally {\n    client.release();\n  }\n}\n```\n\nSources: PostgreSQL documentation, SQL best practices\n\n---\n\n## Integration with the Framework\n\nTo use a custom persistence backend, you need to instantiate your implementation and pass it to the framework during initialization:\n\n```mermaid\nsequenceDiagram\n    participant USER as User Code\n    participant FACTORY as PersistFactory (Hypothetical)\n    participant CUSTOM as Custom PersistBase\n    participant PSA as PersistSignalAdapter\n    participant CS as ClientStrategy\n    \n    USER->>FACTORY: createPersistAdapter(customBackend)\n    FACTORY->>CUSTOM: new PersistRedis(config)\n    FACTORY->>PSA: new PersistSignalAdapter(customBackend)\n    \n    Note over USER,CS: Framework uses adapter internally\n    \n    USER->>CS: Live.run() or Backtest.run()\n    CS->>PSA: waitForInit(symbol, strategy)\n    PSA->>CUSTOM: readSignalData(symbol, strategy)\n    CUSTOM-->>PSA: ISignalRow or null\n    PSA-->>CS: Restored state\n    \n    CS->>PSA: setPendingSignal(symbol, strategy, data)\n    PSA->>CUSTOM: writeSignalData(symbol, strategy, data)\n    CUSTOM-->>PSA: Success\n    PSA-->>CS: Persisted\n```\n\n**Custom Backend Integration Flow**\n\n### Configuration Pattern\n\nThe framework typically accepts custom persistence backends through configuration or dependency injection. Here's a conceptual integration approach:\n\n```typescript\n// Example configuration approach (not actual framework code)\nimport { setConfig, Live } from 'backtest-kit';\nimport { PersistRedis } from './persist-redis';\nimport Redis from 'ioredis';\n\n// Initialize your custom backend\nconst redisClient = new Redis({\n  host: process.env.REDIS_HOST,\n  port: parseInt(process.env.REDIS_PORT),\n});\n\nconst persistRedis = new PersistRedis(redisClient, 7 * 24 * 3600);\n\n// Configure framework to use custom backend\nsetConfig({\n  persistAdapter: persistRedis, // Hypothetical configuration option\n});\n\n// Now all live trading will use Redis for persistence\nLive.background('BTCUSDT', {\n  strategyName: 'my-strategy',\n  exchangeName: 'binance',\n});\n```\n\n### Adapter Instantiation\n\nThe framework's `PersistSignalAdapter` wraps your custom backend:\n\n| Component | Responsibility |\n|-----------|----------------|\n| `PersistSignalAdapter` | Provides lazy initialization, caching, and error handling |\n| Custom `PersistBase` | Implements actual storage operations (read/write/delete) |\n| `ClientStrategy` | Consumes adapter for signal persistence |\n\nThe adapter handles:\n- **Lazy Loading**: Only reads from storage when first signal opens\n- **Caching**: Stores `initPromise` to prevent duplicate reads\n- **Error Propagation**: Emits errors to `errorEmitter` if storage fails\n\n### Environment-Specific Configuration\n\nDifferent persistence backends for different environments:\n\n```typescript\n// Production: Redis for speed\nif (process.env.NODE_ENV === 'production') {\n  setConfig({\n    persistAdapter: new PersistRedis(redisClient),\n  });\n}\n\n// Staging: MongoDB for analysis\nelse if (process.env.NODE_ENV === 'staging') {\n  setConfig({\n    persistAdapter: new PersistMongo(mongoClient, 'backtest_staging'),\n  });\n}\n\n// Development: File-based (default)\nelse {\n  // No configuration needed - uses built-in PersistFile\n}\n```\n\nSources: [docs/internals.md](), README.md configuration examples\n\n---\n\n## Best Practices\n\n### Atomicity Requirements\n\nAll persistence operations must be **atomic** to prevent data corruption during crashes:\n\n```mermaid\ngraph TB\n    subgraph \"Atomic Write Strategies\"\n        REDIS[\"Redis:<br/>Single SET command<br/>(native atomicity)\"]\n        MONGO[\"MongoDB:<br/>updateOne with upsert<br/>(native atomicity)\"]\n        SQL[\"SQL:<br/>INSERT...ON CONFLICT<br/>(native atomicity)\"]\n        FILE[\"File System:<br/>write-tmp + rename<br/>(POSIX atomicity)\"]\n    end\n    \n    subgraph \"Anti-Patterns\"\n        MULTI[\"Multiple separate commands\"]\n        CHECK[\"Read-check-write pattern\"]\n        CACHE[\"Write to cache then flush\"]\n    end\n    \n    REDIS -.->|\"Avoid\"| MULTI\n    MONGO -.->|\"Avoid\"| CHECK\n    SQL -.->|\"Avoid\"| CACHE\n```\n\n**Atomic Write Strategies by Backend**\n\n#### Why Atomicity Matters\n\nConsider this crash scenario:\n\n1. Signal opens, framework writes `priceOpen = 50000`\n2. Process crashes mid-write\n3. On restart, framework reads **partial data** with corrupt price\n4. Strategy makes incorrect TP/SL calculations\n5. Real money is lost due to bad position sizing\n\nAtomic writes prevent this by ensuring **all-or-nothing** semantics - either the entire signal is persisted correctly, or nothing is written.\n\n#### Testing Atomicity\n\n```typescript\n// Hypothetical test approach\nasync function testAtomicity(persist: PersistBase) {\n  const signal: ISignalRow = {\n    id: 'test-123',\n    position: 'long',\n    priceOpen: 50000,\n    priceTakeProfit: 51000,\n    priceStopLoss: 49500,\n    // ... more fields\n  };\n  \n  // Start write operation\n  const writePromise = persist.writeSignalData('BTCUSDT', 'test-strategy', signal);\n  \n  // Simulate crash by killing process mid-write\n  // (In real tests, use process signals or container restarts)\n  \n  // After restart, read should return either:\n  // 1. Complete signal (if write finished before crash)\n  // 2. null (if write hadn't started)\n  // Never partial/corrupted data\n  const restored = await persist.readSignalData('BTCUSDT', 'test-strategy');\n  \n  assert(restored === null || deepEqual(restored, signal));\n}\n```\n\nSources: [docs/internals.md](), crash recovery patterns\n\n---\n\n### Error Handling Strategy\n\nPersistence failures should be **propagated** to the framework's event system, not silently swallowed:\n\n```mermaid\nsequenceDiagram\n    participant CS as ClientStrategy\n    participant PSA as PersistSignalAdapter\n    participant CUSTOM as Custom Backend\n    participant STORAGE as Storage System\n    participant ERR as errorEmitter\n    \n    CS->>PSA: setPendingSignal(data)\n    PSA->>CUSTOM: writeSignalData(data)\n    CUSTOM->>STORAGE: Write operation\n    \n    alt Storage Success\n        STORAGE-->>CUSTOM: OK\n        CUSTOM-->>PSA: Success\n        PSA-->>CS: Persisted\n    else Storage Failure\n        STORAGE-->>CUSTOM: Connection error\n        CUSTOM->>CUSTOM: Throw error\n        CUSTOM-->>PSA: Error thrown\n        PSA->>ERR: Emit error event\n        PSA-->>CS: Error propagated\n    end\n```\n\n**Error Handling Flow**\n\n#### Implementation Pattern\n\n```typescript\nclass PersistRedis extends PersistBase {\n  async writeSignalData(\n    symbol: string,\n    strategyName: string,\n    data: ISignalRow\n  ): Promise<void> {\n    const key = `signal:${strategyName}:${symbol}`;\n    \n    try {\n      await this.redisClient.set(key, JSON.stringify(data));\n    } catch (error) {\n      // Wrap with context for better debugging\n      throw new Error(\n        `Failed to persist signal for ${strategyName}:${symbol} - ${error.message}`\n      );\n    }\n  }\n}\n```\n\n#### Error Categories\n\n| Error Type | Handling | Retry Strategy |\n|------------|----------|----------------|\n| Connection timeout | Throw immediately | Let framework retry with exponential backoff |\n| Serialization error | Throw immediately | Don't retry - fix data schema |\n| Disk full / quota exceeded | Throw immediately | Alert operator, don't retry |\n| Temporary network issue | Throw immediately | Framework retries automatically |\n\nThe framework's `errorEmitter` allows monitoring these failures:\n\n```typescript\nimport { listenError } from 'backtest-kit';\n\nlistenError((error) => {\n  if (error.message.includes('Failed to persist')) {\n    // Send alert to ops team\n    sendAlert('Persistence failure detected', error);\n  }\n});\n```\n\nSources: [docs/internals.md](), event system architecture\n\n---\n\n### Performance Considerations\n\nCustom backends must handle **high-frequency writes** during backtests and **low-latency reads** during live trading:\n\n```mermaid\ngraph LR\n    subgraph \"Performance Metrics\"\n        BT[\"Backtest Mode:<br/>Thousands of writes/sec<br/>(fast mode)\"]\n        LIVE[\"Live Mode:<br/>1 read on startup<br/>1 write per signal<br/>1 delete on close\"]\n    end\n    \n    subgraph \"Optimization Techniques\"\n        BATCH[\"Batch writes in backtest\"]\n        CACHE[\"Cache reads in memory\"]\n        ASYNC[\"Non-blocking async I/O\"]\n        POOL[\"Connection pooling\"]\n    end\n    \n    BT --> BATCH\n    LIVE --> CACHE\n    BATCH --> ASYNC\n    CACHE --> ASYNC\n    ASYNC --> POOL\n```\n\n**Performance Optimization Strategies**\n\n#### Backtest Mode Optimization\n\nDuring backtests, signals open and close rapidly. Consider **batch writes**:\n\n```typescript\nclass PersistRedisBatched extends PersistBase {\n  private writeQueue: Array<{ symbol: string; strategy: string; data: ISignalRow }> = [];\n  private flushTimer: NodeJS.Timeout | null = null;\n  \n  async writeSignalData(\n    symbol: string,\n    strategyName: string,\n    data: ISignalRow\n  ): Promise<void> {\n    // Queue write instead of executing immediately\n    this.writeQueue.push({ symbol, strategy: strategyName, data });\n    \n    // Flush every 100ms or 100 items\n    if (this.writeQueue.length >= 100) {\n      await this.flush();\n    } else if (!this.flushTimer) {\n      this.flushTimer = setTimeout(() => this.flush(), 100);\n    }\n  }\n  \n  private async flush(): Promise<void> {\n    if (this.writeQueue.length === 0) return;\n    \n    const pipeline = this.redisClient.pipeline();\n    \n    for (const { symbol, strategy, data } of this.writeQueue) {\n      const key = `signal:${strategy}:${symbol}`;\n      pipeline.set(key, JSON.stringify(data));\n    }\n    \n    await pipeline.exec();\n    this.writeQueue = [];\n    \n    if (this.flushTimer) {\n      clearTimeout(this.flushTimer);\n      this.flushTimer = null;\n    }\n  }\n}\n```\n\n**Warning**: Batching sacrifices atomicity. Only use for backtests, never for live trading.\n\n#### Connection Pooling\n\nReuse database connections to avoid connection overhead:\n\n```typescript\n// PostgreSQL example with connection pooling\nimport { Pool } from 'pg';\n\nconst pool = new Pool({\n  host: process.env.DB_HOST,\n  port: parseInt(process.env.DB_PORT),\n  database: process.env.DB_NAME,\n  user: process.env.DB_USER,\n  password: process.env.DB_PASSWORD,\n  max: 20, // Maximum 20 connections in pool\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 2000,\n});\n\nconst persist = new PersistPostgres(pool);\n```\n\n#### Benchmarking\n\nMeasure your backend performance:\n\n```typescript\nasync function benchmarkBackend(persist: PersistBase) {\n  const iterations = 10000;\n  \n  // Write benchmark\n  const writeStart = Date.now();\n  for (let i = 0; i < iterations; i++) {\n    await persist.writeSignalData(\n      'BTCUSDT',\n      `strategy${i}`,\n      createMockSignal()\n    );\n  }\n  const writeTime = Date.now() - writeStart;\n  console.log(`Write: ${iterations / (writeTime / 1000)} ops/sec`);\n  \n  // Read benchmark\n  const readStart = Date.now();\n  for (let i = 0; i < iterations; i++) {\n    await persist.readSignalData('BTCUSDT', `strategy${i}`);\n  }\n  const readTime = Date.now() - readStart;\n  console.log(`Read: ${iterations / (readTime / 1000)} ops/sec`);\n}\n```\n\nTarget performance for live trading:\n- **Reads**: < 10ms per operation\n- **Writes**: < 50ms per operation\n- **Deletes**: < 50ms per operation\n\nSources: Performance optimization patterns, [docs/internals.md]()\n\n---\n\n## Testing Your Implementation\n\nComprehensive testing ensures your custom backend handles crash recovery correctly:\n\n```mermaid\ngraph TB\n    subgraph \"Test Categories\"\n        UNIT[\"Unit Tests:<br/>Read/Write/Delete operations\"]\n        INTEG[\"Integration Tests:<br/>Actual storage system\"]\n        CRASH[\"Crash Recovery Tests:<br/>Process restarts\"]\n        RACE[\"Race Condition Tests:<br/>Concurrent operations\"]\n    end\n    \n    subgraph \"Test Scenarios\"\n        HAPPY[\"Happy path:<br/>Normal signal lifecycle\"]\n        NOTFOUND[\"Not found:<br/>Read nonexistent signal\"]\n        OVERWRITE[\"Overwrite:<br/>Update existing signal\"]\n        DELETE[\"Delete idempotency:<br/>Delete twice\"]\n        CRASH_BEFORE[\"Crash before write:<br/>Data not persisted\"]\n        CRASH_DURING[\"Crash during write:<br/>Atomic guarantee\"]\n        CRASH_AFTER[\"Crash after write:<br/>Data restored\"]\n    end\n    \n    UNIT --> HAPPY\n    UNIT --> NOTFOUND\n    INTEG --> OVERWRITE\n    INTEG --> DELETE\n    CRASH --> CRASH_BEFORE\n    CRASH --> CRASH_DURING\n    CRASH --> CRASH_AFTER\n```\n\n**Test Coverage Matrix**\n\n### Unit Test Example\n\n```typescript\nimport { describe, it, assert } from 'your-test-framework';\nimport { PersistRedis } from './persist-redis';\nimport Redis from 'ioredis-mock'; // Use mock for unit tests\n\ndescribe('PersistRedis', () => {\n  it('should write and read signal data', async () => {\n    const redis = new Redis();\n    const persist = new PersistRedis(redis);\n    \n    const signal: ISignalRow = {\n      id: 'test-123',\n      position: 'long',\n      priceOpen: 50000,\n      priceTakeProfit: 51000,\n      priceStopLoss: 49500,\n      openTimestamp: Date.now(),\n      minuteEstimatedTime: 60,\n    };\n    \n    // Write signal\n    await persist.writeSignalData('BTCUSDT', 'strategy1', signal);\n    \n    // Read it back\n    const restored = await persist.readSignalData('BTCUSDT', 'strategy1');\n    \n    assert.deepEqual(restored, signal);\n  });\n  \n  it('should return null for nonexistent signal', async () => {\n    const redis = new Redis();\n    const persist = new PersistRedis(redis);\n    \n    const restored = await persist.readSignalData('ETHUSDT', 'strategy2');\n    \n    assert.equal(restored, null);\n  });\n  \n  it('should overwrite existing signal', async () => {\n    const redis = new Redis();\n    const persist = new PersistRedis(redis);\n    \n    const signal1: ISignalRow = { /* ... */ priceOpen: 50000 };\n    const signal2: ISignalRow = { /* ... */ priceOpen: 51000 };\n    \n    await persist.writeSignalData('BTCUSDT', 'strategy1', signal1);\n    await persist.writeSignalData('BTCUSDT', 'strategy1', signal2);\n    \n    const restored = await persist.readSignalData('BTCUSDT', 'strategy1');\n    \n    assert.equal(restored.priceOpen, 51000);\n  });\n  \n  it('should be idempotent for delete', async () => {\n    const redis = new Redis();\n    const persist = new PersistRedis(redis);\n    \n    const signal: ISignalRow = { /* ... */ };\n    \n    await persist.writeSignalData('BTCUSDT', 'strategy1', signal);\n    await persist.deleteSignalData('BTCUSDT', 'strategy1');\n    await persist.deleteSignalData('BTCUSDT', 'strategy1'); // Second delete\n    \n    // Should not throw\n  });\n});\n```\n\n### Integration Test Example\n\n```typescript\ndescribe('PersistRedis Integration', () => {\n  let redis: Redis;\n  let persist: PersistRedis;\n  \n  beforeEach(async () => {\n    // Use real Redis instance (e.g., in Docker)\n    redis = new Redis({\n      host: 'localhost',\n      port: 6379,\n      db: 15, // Use separate DB for tests\n    });\n    \n    persist = new PersistRedis(redis);\n    \n    // Clean up test data\n    await redis.flushdb();\n  });\n  \n  afterEach(async () => {\n    await redis.quit();\n  });\n  \n  it('should handle connection failures gracefully', async () => {\n    // Disconnect Redis\n    await redis.quit();\n    \n    const signal: ISignalRow = { /* ... */ };\n    \n    // Should throw meaningful error\n    await assert.rejects(\n      () => persist.writeSignalData('BTCUSDT', 'strategy1', signal),\n      /Connection closed/\n    );\n  });\n  \n  it('should survive process restart', async () => {\n    const signal: ISignalRow = { /* ... */ };\n    \n    // Write signal\n    await persist.writeSignalData('BTCUSDT', 'strategy1', signal);\n    \n    // Simulate process restart by creating new connection\n    const redis2 = new Redis({ host: 'localhost', port: 6379, db: 15 });\n    const persist2 = new PersistRedis(redis2);\n    \n    // Read from new connection\n    const restored = await persist2.readSignalData('BTCUSDT', 'strategy1');\n    \n    assert.deepEqual(restored, signal);\n    \n    await redis2.quit();\n  });\n});\n```\n\n### Crash Recovery Test Approach\n\nTesting actual crash scenarios requires process management:\n\n```typescript\nimport { spawn } from 'child_process';\nimport { writeFile } from 'fs/promises';\n\ndescribe('Crash Recovery', () => {\n  it('should restore state after crash', async () => {\n    // Step 1: Write test script that opens signal and crashes\n    const testScript = `\n      import { Live } from 'backtest-kit';\n      import { PersistRedis } from './persist-redis';\n      \n      // Configure custom backend\n      setConfig({ persistAdapter: new PersistRedis(...) });\n      \n      // Start live trading\n      Live.background('BTCUSDT', { strategyName: 'crash-test', ... });\n      \n      // Wait for signal to open\n      listenSignalLive((event) => {\n        if (event.action === 'opened') {\n          console.log('SIGNAL_OPENED');\n          process.exit(1); // Simulate crash\n        }\n      });\n    `;\n    \n    await writeFile('/tmp/crash-test.mjs', testScript);\n    \n    // Step 2: Run script until it crashes\n    const proc1 = spawn('node', ['/tmp/crash-test.mjs']);\n    await waitForOutput(proc1, 'SIGNAL_OPENED');\n    // Process exits with code 1 (crash)\n    \n    // Step 3: Run again - should restore signal\n    const proc2 = spawn('node', ['/tmp/crash-test.mjs']);\n    const output = await waitForOutput(proc2, 'SIGNAL_RESTORED');\n    assert(output.includes('SIGNAL_RESTORED'));\n    \n    proc2.kill();\n  });\n});\n```\n\nThis approach verifies that:\n1. Signal is persisted before crash\n2. Signal is loaded on restart via `waitForInit()`\n3. Strategy continues monitoring from previous state\n\nSources: Testing best practices, [docs/internals.md]()\n\n---\n\n## Summary\n\nCustom persistence backends extend Backtest Kit's crash-safe storage to any system:\n\n| Backend | Use Case | Key Benefit |\n|---------|----------|-------------|\n| **Redis** | High-frequency live trading | Sub-millisecond latency, auto-expiration |\n| **MongoDB** | Multi-strategy portfolios | Rich queries, schema evolution |\n| **PostgreSQL** | Regulated environments | ACID compliance, relational integrity |\n| **File System** | Development/testing | Zero dependencies, easy debugging |\n\n### Implementation Checklist\n\n- [ ] Implement `PersistBase` interface (3 methods)\n- [ ] Ensure atomic write operations\n- [ ] Handle errors with proper context\n- [ ] Test crash recovery scenarios\n- [ ] Benchmark performance for your workload\n- [ ] Configure environment-specific backends\n- [ ] Monitor via `errorEmitter` events\n\nCustom backends integrate seamlessly through the `PersistSignalAdapter`, which handles lazy initialization, caching, and error propagation. The adapter ensures consistent behavior whether using file storage, Redis, or any other backend.\n\nSources: All previous sections"
                    },
                    {
                        "page_plan": {
                            "id": "11",
                            "title": "Configuration Reference"
                        },
                        "content": "# Configuration Reference\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/config/params.ts](src/config/params.ts)\n- [test/README.md](test/README.md)\n- [test/config/setup.mjs](test/config/setup.mjs)\n- [test/e2e/close.test.mjs](test/e2e/close.test.mjs)\n- [test/e2e/edge.test.mjs](test/e2e/edge.test.mjs)\n- [test/e2e/other.test.mjs](test/e2e/other.test.mjs)\n- [test/e2e/persist.test.mjs](test/e2e/persist.test.mjs)\n- [test/e2e/sanitize.test.mjs](test/e2e/sanitize.test.mjs)\n- [test/e2e/sequence.test.mjs](test/e2e/sequence.test.mjs)\n\n</details>\n\n\n\nThis page documents the global configuration system in Backtest Kit, including all `GLOBAL_CONFIG` parameters, their purposes, default values, and how they affect system behavior. Configuration controls signal validation, cost simulation, data fetching, and reporting across all execution modes.\n\nFor defining custom trading strategies, see [Strategy Development](#6). For risk validation rules, see [Risk Management](#7). For logger setup, see [Logger Configuration](#11.3).\n\n---\n\n## Configuration System Overview\n\nBacktest Kit uses a global configuration object (`GLOBAL_CONFIG`) that controls system-wide behavior. All parameters use the `CC_` prefix convention for clarity. Configuration is set via the `setConfig()` function and affects all execution modes (Backtest, Live, Walker).\n\n**Configuration Flow Diagram:**\n\n```mermaid\ngraph TD\n    User[\"User Code<br/>setConfig()\"]\n    GlobalConfig[\"GLOBAL_CONFIG<br/>src/config/params.ts:1-114\"]\n    \n    ValidationServices[\"Signal Validation<br/>TP/SL checks\"]\n    CostServices[\"Cost Simulation<br/>Fees + Slippage\"]\n    DataServices[\"Data Fetching<br/>Retry logic + Anomaly detection\"]\n    VWAPServices[\"VWAP Calculation<br/>Average price\"]\n    ReportServices[\"Markdown Reports<br/>Column visibility\"]\n    TimeoutServices[\"Timeouts<br/>Signal generation + Lifetime\"]\n    \n    User --> GlobalConfig\n    GlobalConfig --> ValidationServices\n    GlobalConfig --> CostServices\n    GlobalConfig --> DataServices\n    GlobalConfig --> VWAPServices\n    GlobalConfig --> ReportServices\n    GlobalConfig --> TimeoutServices\n    \n    ValidationServices --> SignalPipeline[\"Signal Processing Pipeline\"]\n    CostServices --> PNLCalc[\"PNL Calculation\"]\n    DataServices --> ExchangeClient[\"ClientExchange\"]\n    VWAPServices --> ExchangeClient\n    ReportServices --> MarkdownServices[\"Markdown Services\"]\n    TimeoutServices --> StrategyCore[\"StrategyCoreService\"]\n```\n\nSources: [src/config/params.ts:1-122](), [README.md:46-63]()\n\n---\n\n## Setting Configuration\n\nConfiguration is set using the `setConfig()` function with a partial configuration object. Only specified parameters are updated; unspecified parameters retain their default values.\n\n```typescript\nimport { setConfig } from 'backtest-kit';\n\nsetConfig({\n  CC_PERCENT_SLIPPAGE: 0.15,      // Override slippage to 0.15%\n  CC_PERCENT_FEE: 0.08,            // Override fee to 0.08%\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.6,\n});\n```\n\n**Test mode override** (second parameter forces reset to defaults first):\n\n```typescript\nsetConfig({\n  CC_MAX_STOPLOSS_DISTANCE_PERCENT: 100,  // Allow any SL distance\n}, true);  // Reset to defaults first, then apply overrides\n```\n\nSources: [README.md:46-63](), [test/config/setup.mjs:89-102]()\n\n---\n\n## Configuration Parameters by Category\n\n### Cost Simulation Parameters\n\nThese parameters simulate real-world trading costs applied to all signals.\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `CC_PERCENT_SLIPPAGE` | `0.1` | Slippage percentage per transaction (applied 2×: entry + exit). Simulates market impact and order book depth. |\n| `CC_PERCENT_FEE` | `0.1` | Fee percentage per transaction (applied 2×: entry + exit). Total effective cost = 0.4% (0.2% fees + 0.2% slippage). |\n\n**Cost Calculation Example:**\n\n```\nEntry:  -0.1% fee - 0.1% slippage = -0.2%\nExit:   -0.1% fee - 0.1% slippage = -0.2%\nTotal:  -0.4% cost per round trip\n```\n\nTo achieve profitable trades, `priceTakeProfit` must provide at least 0.5% distance from `priceOpen` to cover these costs plus minimum profit margin.\n\nSources: [src/config/params.ts:13-24]()\n\n---\n\n### Signal Validation Parameters\n\nThese parameters enforce safety constraints on signal geometry, preventing dangerous configurations.\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` | `0.5` | Minimum TP distance from `priceOpen`. Ensures profit covers fees (0.2%) + slippage (0.2%) + minimum margin (0.1%). |\n| `CC_MIN_STOPLOSS_DISTANCE_PERCENT` | `0.5` | Minimum SL distance from `priceOpen`. Prevents instant stop-out due to normal price volatility. |\n| `CC_MAX_STOPLOSS_DISTANCE_PERCENT` | `20` | Maximum SL distance from `priceOpen`. Prevents catastrophic losses (one signal cannot lose >20% of position). |\n| `CC_MAX_SIGNAL_LIFETIME_MINUTES` | `1440` | Maximum signal lifetime in minutes (default: 1 day). Prevents \"eternal\" signals that block risk limits indefinitely. |\n\n**Validation Logic Diagram:**\n\n```mermaid\ngraph TB\n    Signal[\"ISignalDto<br/>from getSignal()\"]\n    \n    CheckPositive[\"Check prices > 0<br/>isFinite, not NaN\"]\n    CheckTPSL[\"Check TP/SL logic<br/>LONG: TP>open>SL<br/>SHORT: SL>open>TP\"]\n    CheckTPDistance[\"Check TP distance >=<br/>CC_MIN_TAKEPROFIT_DISTANCE_PERCENT\"]\n    CheckSLMin[\"Check SL distance >=<br/>CC_MIN_STOPLOSS_DISTANCE_PERCENT\"]\n    CheckSLMax[\"Check SL distance <=<br/>CC_MAX_STOPLOSS_DISTANCE_PERCENT\"]\n    CheckLifetime[\"Check lifetime <=<br/>CC_MAX_SIGNAL_LIFETIME_MINUTES\"]\n    \n    Pass[\"Validation Passed<br/>Signal Scheduled/Opened\"]\n    Reject[\"Validation Failed<br/>Signal Rejected<br/>Emit riskSubject\"]\n    \n    Signal --> CheckPositive\n    CheckPositive -->|Pass| CheckTPSL\n    CheckPositive -->|Fail| Reject\n    CheckTPSL -->|Pass| CheckTPDistance\n    CheckTPSL -->|Fail| Reject\n    CheckTPDistance -->|Pass| CheckSLMin\n    CheckTPDistance -->|Fail| Reject\n    CheckSLMin -->|Pass| CheckSLMax\n    CheckSLMin -->|Fail| Reject\n    CheckSLMax -->|Pass| CheckLifetime\n    CheckSLMax -->|Fail| Reject\n    CheckLifetime -->|Pass| Pass\n    CheckLifetime -->|Fail| Reject\n```\n\n**Example: Signal rejected by TP distance validation**\n\n```typescript\n// This signal will be REJECTED\ngetSignal: async () => ({\n  position: 'long',\n  priceOpen: 42000,\n  priceTakeProfit: 42010,  // Only 0.024% profit - below 0.5% minimum\n  priceStopLoss: 41000,\n  minuteEstimatedTime: 60,\n})\n// Result: Validation error, signal not executed\n// Reason: TP distance (0.024%) < CC_MIN_TAKEPROFIT_DISTANCE_PERCENT (0.5%)\n```\n\nSources: [src/config/params.ts:25-56](), [test/e2e/sanitize.test.mjs:27-122]()\n\n---\n\n### Data Fetching & Retry Parameters\n\nThese parameters control how candle data is fetched from exchanges and how anomalies are detected.\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `CC_GET_CANDLES_RETRY_COUNT` | `3` | Number of retry attempts for `getCandles()` function when exchange requests fail. |\n| `CC_GET_CANDLES_RETRY_DELAY_MS` | `5000` | Delay in milliseconds between retry attempts (5 seconds). |\n| `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR` | `1000` | Maximum allowed deviation factor for price anomaly detection. Price should not be more than this factor lower than reference price. Catches incomplete candles with prices near $0. |\n| `CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN` | `5` | Minimum number of candles required for reliable median calculation. Below this threshold, simple average is used instead of median. |\n\n**Anomaly Detection Rationale:**\n\nIncomplete candles from exchange APIs (e.g., Binance) typically have prices near $0 (e.g., $0.01-1) while normal BTC prices range $20,000-100,000. Factor 1000 catches prices below $20-100 when median is $20,000-100,000.\n\n```\nExample: BTC median = $50,000\nThreshold = $50,000 / 1000 = $50\nAnomaly detected: Price $0.01 < $50 → Reject candle\n```\n\n**Retry Logic Flow:**\n\n```mermaid\ngraph LR\n    Request[\"getCandles() request\"]\n    Attempt[\"Attempt #1\"]\n    Success[\"Return candles\"]\n    Fail1[\"Request failed\"]\n    Delay1[\"Wait CC_GET_CANDLES_RETRY_DELAY_MS\"]\n    Attempt2[\"Attempt #2\"]\n    Fail2[\"Request failed\"]\n    Delay2[\"Wait CC_GET_CANDLES_RETRY_DELAY_MS\"]\n    Attempt3[\"Attempt #3\"]\n    FinalFail[\"Throw error\"]\n    \n    Request --> Attempt\n    Attempt -->|Success| Success\n    Attempt -->|Fail| Fail1\n    Fail1 --> Delay1\n    Delay1 --> Attempt2\n    Attempt2 -->|Success| Success\n    Attempt2 -->|Fail| Fail2\n    Fail2 --> Delay2\n    Delay2 --> Attempt3\n    Attempt3 -->|Success| Success\n    Attempt3 -->|Fail| FinalFail\n```\n\nSources: [src/config/params.ts:66-104]()\n\n---\n\n### VWAP Calculation Parameters\n\nThese parameters control Volume Weighted Average Price calculation used for realistic entry/exit pricing.\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `CC_AVG_PRICE_CANDLES_COUNT` | `5` | Number of candles to use for VWAP calculation. Default uses last 5 1-minute candles when interval is `1m`. |\n\n**VWAP Calculation Formula:**\n\n```\nVWAP = Σ(price × volume) / Σ(volume)\n\nWhere:\n- price = (high + low + close) / 3 (typical price)\n- Summation over last CC_AVG_PRICE_CANDLES_COUNT candles\n- Fallback to simple average if total volume = 0\n```\n\n**Usage in Signal Lifecycle:**\n\n1. **Scheduled Signal Activation**: When `priceOpen` is reached, VWAP is used as actual entry price\n2. **Signal Closure**: TP/SL prices are compared against VWAP (not raw candle close)\n3. **PNL Calculation**: Entry and exit prices use VWAP for realistic execution simulation\n\nSources: [src/config/params.ts:6-11]()\n\n---\n\n### Timing & Timeout Parameters\n\nThese parameters control time-based constraints and limits.\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `CC_SCHEDULE_AWAIT_MINUTES` | `120` | Time to wait for scheduled signal to activate (in minutes). If signal does not activate within this time, it will be cancelled. Default: 2 hours. |\n| `CC_MAX_SIGNAL_GENERATION_SECONDS` | `180` | Maximum time allowed for signal generation (in seconds). Prevents long-running or stuck `getSignal()` routines from blocking execution. Default: 3 minutes. |\n\n**Scheduled Signal Timeout Diagram:**\n\n```mermaid\nstateDiagram-v2\n    [*] --> Scheduled: getSignal returns signal<br/>priceOpen not reached\n    \n    Scheduled --> Opened: Price reaches priceOpen<br/>within CC_SCHEDULE_AWAIT_MINUTES\n    Scheduled --> Cancelled: Timeout after<br/>CC_SCHEDULE_AWAIT_MINUTES\n    Scheduled --> Cancelled: SL hit before activation\n    \n    Opened --> Closed: TP/SL/time_expired\n    Cancelled --> [*]\n    Closed --> [*]\n    \n    note right of Scheduled\n        Timer starts when signal enters\n        scheduled state. Tracks elapsed\n        time in minutes.\n    end note\n```\n\nSources: [src/config/params.ts:3-6](), [src/config/params.ts:57-64]()\n\n---\n\n### Reporting Configuration Parameters\n\nThese parameters control markdown report generation and visibility.\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `CC_REPORT_SHOW_SIGNAL_NOTE` | `false` | Controls visibility of signal notes in markdown report tables. When enabled, \"Note\" column is displayed in all reports (backtest, live, schedule, risk, etc.). Default: hidden to reduce table width. |\n\n**Report Column Impact:**\n\nWhen `CC_REPORT_SHOW_SIGNAL_NOTE = true`:\n\n```markdown\n| Symbol   | Position | Open    | TP      | SL      | Note              | Status |\n|----------|----------|---------|---------|---------|-------------------|--------|\n| BTCUSDT  | long     | 42000   | 43000   | 41000   | Test signal #1    | closed |\n| ETHUSDT  | short    | 3000    | 2800    | 3200    | Momentum reversal | opened |\n```\n\nWhen `CC_REPORT_SHOW_SIGNAL_NOTE = false` (default):\n\n```markdown\n| Symbol   | Position | Open    | TP      | SL      | Status |\n|----------|----------|---------|---------|---------|--------|\n| BTCUSDT  | long     | 42000   | 43000   | 41000   | closed |\n| ETHUSDT  | short    | 3000    | 2800    | 3200    | opened |\n```\n\nSources: [src/config/params.ts:106-114]()\n\n---\n\n## Parameter Relationships & Dependencies\n\n**Configuration Impact Map:**\n\n```mermaid\ngraph TD\n    Validation[\"Signal Validation Layer\"]\n    CostSim[\"Cost Simulation Layer\"]\n    DataFetch[\"Data Fetching Layer\"]\n    Reporting[\"Reporting Layer\"]\n    \n    MinTP[\"CC_MIN_TAKEPROFIT_DISTANCE_PERCENT<br/>Default: 0.5%\"]\n    Fee[\"CC_PERCENT_FEE<br/>Default: 0.1%\"]\n    Slip[\"CC_PERCENT_SLIPPAGE<br/>Default: 0.1%\"]\n    \n    MinTP --> Validation\n    Fee --> CostSim\n    Slip --> CostSim\n    \n    Validation -->|Rejects signals where| Constraint1[\"TP distance < 0.5%\"]\n    CostSim -->|Applies| Constraint2[\"Total cost = 0.4%<br/>2× (fee + slippage)\"]\n    \n    Relationship[\"Relationship:<br/>CC_MIN_TAKEPROFIT_DISTANCE_PERCENT (0.5%)<br/>must cover<br/>Total costs (0.4%) + profit margin (0.1%)\"]\n    \n    MinTP --> Relationship\n    Fee --> Relationship\n    Slip --> Relationship\n    \n    MaxSL[\"CC_MAX_STOPLOSS_DISTANCE_PERCENT<br/>Default: 20%\"]\n    MinSL[\"CC_MIN_STOPLOSS_DISTANCE_PERCENT<br/>Default: 0.5%\"]\n    \n    MaxSL --> Validation\n    MinSL --> Validation\n    \n    Validation -->|Enforces| Range[\"SL distance must be:<br/>0.5% <= distance <= 20%\"]\n    \n    RetryCount[\"CC_GET_CANDLES_RETRY_COUNT<br/>Default: 3\"]\n    RetryDelay[\"CC_GET_CANDLES_RETRY_DELAY_MS<br/>Default: 5000\"]\n    \n    RetryCount --> DataFetch\n    RetryDelay --> DataFetch\n    \n    DataFetch -->|Max wait time| TotalRetryTime[\"Total: 3 attempts × 5 sec = 15 sec<br/>before final failure\"]\n```\n\nSources: [src/config/params.ts:25-56]()\n\n---\n\n## Default Configuration Object\n\nThe complete default configuration is defined in `DEFAULT_CONFIG` constant:\n\n```typescript\nexport const DEFAULT_CONFIG = Object.freeze({\n  CC_SCHEDULE_AWAIT_MINUTES: 120,\n  CC_AVG_PRICE_CANDLES_COUNT: 5,\n  CC_PERCENT_SLIPPAGE: 0.1,\n  CC_PERCENT_FEE: 0.1,\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.5,\n  CC_MIN_STOPLOSS_DISTANCE_PERCENT: 0.5,\n  CC_MAX_STOPLOSS_DISTANCE_PERCENT: 20,\n  CC_MAX_SIGNAL_LIFETIME_MINUTES: 1440,\n  CC_MAX_SIGNAL_GENERATION_SECONDS: 180,\n  CC_GET_CANDLES_RETRY_COUNT: 3,\n  CC_GET_CANDLES_RETRY_DELAY_MS: 5000,\n  CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR: 1000,\n  CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN: 5,\n  CC_REPORT_SHOW_SIGNAL_NOTE: false,\n});\n```\n\nThis object is frozen to prevent accidental mutations. Use `setConfig()` to apply changes.\n\nSources: [src/config/params.ts:116-122]()\n\n---\n\n## Configuration in Test Environment\n\nTest environments often require different configuration to speed up execution or disable validation:\n\n```typescript\nsetConfig({\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0,      // Disable TP validation\n  CC_MIN_STOPLOSS_DISTANCE_PERCENT: 0,        // Disable SL validation\n  CC_MAX_STOPLOSS_DISTANCE_PERCENT: 100,      // Allow any SL distance\n  CC_MAX_SIGNAL_LIFETIME_MINUTES: 999999,     // Allow any lifetime\n  CC_GET_CANDLES_RETRY_COUNT: 1,              // Disable retries for speed\n  CC_GET_CANDLES_RETRY_DELAY_MS: 100,         // Minimal retry delay\n}, true);  // Reset to defaults first\n```\n\nThis allows testing extreme edge cases without validation interference.\n\nSources: [test/config/setup.mjs:89-102]()\n\n---\n\n## Configuration Best Practices\n\n### Production Configuration\n\nFor live trading, use conservative validation:\n\n```typescript\nsetConfig({\n  CC_PERCENT_SLIPPAGE: 0.15,                     // Higher slippage for safety\n  CC_PERCENT_FEE: 0.1,                           // Actual exchange fee\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.8,       // Higher minimum for profitability\n  CC_MAX_STOPLOSS_DISTANCE_PERCENT: 10,          // Lower max for capital protection\n  CC_SCHEDULE_AWAIT_MINUTES: 60,                 // Shorter timeout for faster cancellation\n});\n```\n\n### Backtesting Configuration\n\nFor historical simulation with realistic costs:\n\n```typescript\nsetConfig({\n  CC_PERCENT_SLIPPAGE: 0.1,                      // Standard slippage\n  CC_PERCENT_FEE: 0.1,                           // Standard fee\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.5,       // Default validation\n  // Keep other parameters at defaults\n});\n```\n\n### High-Frequency Strategy Configuration\n\nFor strategies generating frequent signals:\n\n```typescript\nsetConfig({\n  CC_MAX_SIGNAL_LIFETIME_MINUTES: 60,            // Max 1 hour per signal\n  CC_SCHEDULE_AWAIT_MINUTES: 10,                 // Fast cancellation\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.3,       // Allow smaller profits\n  CC_AVG_PRICE_CANDLES_COUNT: 3,                 // Faster VWAP response\n});\n```\n\nSources: [README.md:56-63]()\n\n---\n\n## Configuration Type Definition\n\n```typescript\nexport type GlobalConfig = {\n  CC_SCHEDULE_AWAIT_MINUTES: number;\n  CC_AVG_PRICE_CANDLES_COUNT: number;\n  CC_PERCENT_SLIPPAGE: number;\n  CC_PERCENT_FEE: number;\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: number;\n  CC_MIN_STOPLOSS_DISTANCE_PERCENT: number;\n  CC_MAX_STOPLOSS_DISTANCE_PERCENT: number;\n  CC_MAX_SIGNAL_LIFETIME_MINUTES: number;\n  CC_MAX_SIGNAL_GENERATION_SECONDS: number;\n  CC_GET_CANDLES_RETRY_COUNT: number;\n  CC_GET_CANDLES_RETRY_DELAY_MS: number;\n  CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR: number;\n  CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN: number;\n  CC_REPORT_SHOW_SIGNAL_NOTE: boolean;\n};\n```\n\nAll configuration parameters are strongly typed. TypeScript will enforce correct parameter names and types when calling `setConfig()`.\n\nSources: [src/config/params.ts:118-122]()"
                    },
                    {
                        "page_plan": {
                            "id": "11.1",
                            "title": "GLOBAL_CONFIG Parameters"
                        },
                        "content": "# GLOBAL_CONFIG Parameters\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/config/params.ts](src/config/params.ts)\n- [test/README.md](test/README.md)\n- [test/config/setup.mjs](test/config/setup.mjs)\n- [test/e2e/close.test.mjs](test/e2e/close.test.mjs)\n- [test/e2e/edge.test.mjs](test/e2e/edge.test.mjs)\n- [test/e2e/other.test.mjs](test/e2e/other.test.mjs)\n- [test/e2e/persist.test.mjs](test/e2e/persist.test.mjs)\n- [test/e2e/sanitize.test.mjs](test/e2e/sanitize.test.mjs)\n- [test/e2e/sequence.test.mjs](test/e2e/sequence.test.mjs)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page documents all configuration parameters in the `GLOBAL_CONFIG` object, which controls system-wide behavior including trading execution, signal validation, data fetching, anomaly detection, and reporting. These parameters provide critical safeguards to prevent unprofitable trades, data corruption, and system instability.\n\nFor information about customizing report columns, see [Column Configuration](#11.2). For logger configuration, see [Logger Configuration](#11.3). For strategy-level configuration, see [Strategy Schema Definition](#6.1).\n\n**Sources:** [src/config/params.ts:1-122]()\n\n---\n\n## Configuration Architecture\n\n```mermaid\ngraph TB\n    subgraph \"Configuration Layer\"\n        GLOBAL[\"GLOBAL_CONFIG<br/>{CC_PERCENT_FEE, CC_PERCENT_SLIPPAGE,<br/>CC_MIN_TAKEPROFIT_DISTANCE_PERCENT,<br/>CC_MAX_STOPLOSS_DISTANCE_PERCENT,<br/>CC_MAX_SIGNAL_LIFETIME_MINUTES,<br/>...14 parameters}\"]\n        DEFAULT[\"DEFAULT_CONFIG<br/>Object.freeze(GLOBAL_CONFIG)<br/>Immutable backup\"]\n        SET_CONFIG[\"setConfig(partial, reset?)<br/>Public API for runtime updates\"]\n    end\n    \n    subgraph \"Validation Layer\"\n        VALIDATE_SIGNAL[\"VALIDATE_SIGNAL_FN<br/>src/client/ClientStrategy.ts\"]\n        VALIDATE_PRICES[\"Price validation:<br/>positive, finite, not NaN\"]\n        VALIDATE_TP_SL[\"TP/SL logic validation:<br/>LONG: TP>open>SL<br/>SHORT: SL>open>TP\"]\n        VALIDATE_DISTANCE[\"Distance validation:<br/>CC_MIN_TAKEPROFIT_DISTANCE_PERCENT<br/>CC_MAX_STOPLOSS_DISTANCE_PERCENT\"]\n        VALIDATE_LIFETIME[\"Lifetime validation:<br/>CC_MAX_SIGNAL_LIFETIME_MINUTES\"]\n    end\n    \n    subgraph \"Execution Layer\"\n        CALC_PNL[\"PNL Calculation<br/>Apply CC_PERCENT_FEE<br/>Apply CC_PERCENT_SLIPPAGE\"]\n        GET_CANDLES[\"Exchange.getCandles<br/>Retry: CC_GET_CANDLES_RETRY_COUNT<br/>Delay: CC_GET_CANDLES_RETRY_DELAY_MS\"]\n        VWAP[\"VWAP Calculation<br/>CC_AVG_PRICE_CANDLES_COUNT\"]\n        ANOMALY[\"Anomaly Detection<br/>CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR<br/>CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN\"]\n    end\n    \n    subgraph \"Reporting Layer\"\n        MARKDOWN[\"Markdown Reports<br/>CC_REPORT_SHOW_SIGNAL_NOTE\"]\n    end\n    \n    GLOBAL --> VALIDATE_SIGNAL\n    SET_CONFIG --> GLOBAL\n    DEFAULT -.->|restore on reset| GLOBAL\n    \n    VALIDATE_SIGNAL --> VALIDATE_PRICES\n    VALIDATE_SIGNAL --> VALIDATE_TP_SL\n    VALIDATE_SIGNAL --> VALIDATE_DISTANCE\n    VALIDATE_SIGNAL --> VALIDATE_LIFETIME\n    \n    VALIDATE_DISTANCE --> CALC_PNL\n    GLOBAL --> CALC_PNL\n    GLOBAL --> GET_CANDLES\n    GLOBAL --> VWAP\n    GLOBAL --> ANOMALY\n    GLOBAL --> MARKDOWN\n    \n    style GLOBAL fill:#fff3cd,stroke:#856404,stroke-width:3px\n    style VALIDATE_SIGNAL fill:#ffe1e1,stroke:#cc0000,stroke-width:2px\n    style CALC_PNL fill:#e3f2fd,stroke:#1976d2,stroke-width:2px\n```\n\n**Configuration Flow Overview**\n\nThe `GLOBAL_CONFIG` object serves as the single source of truth for system-wide parameters. Parameters are enforced at multiple layers: signal validation (before execution), execution (during trading), and data fetching (during candle retrieval). The `setConfig()` function allows runtime modification, with optional reset to `DEFAULT_CONFIG`.\n\n**Sources:** [src/config/params.ts:1-122](), [test/config/setup.mjs:89-102]()\n\n---\n\n## Accessing and Modifying Configuration\n\n### Reading Configuration\n\n```typescript\nimport { GLOBAL_CONFIG } from 'backtest-kit';\n\n// Read current values\nconst feePercent = GLOBAL_CONFIG.CC_PERCENT_FEE;\nconst minTPDistance = GLOBAL_CONFIG.CC_MIN_TAKEPROFIT_DISTANCE_PERCENT;\n```\n\n### Modifying Configuration\n\n```typescript\nimport { setConfig } from 'backtest-kit';\n\n// Partial update (merge with existing)\nsetConfig({\n  CC_PERCENT_FEE: 0.15,  // Increase fees\n  CC_PERCENT_SLIPPAGE: 0.2,  // Increase slippage\n});\n\n// Full reset to defaults, then apply\nsetConfig({\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 1.0,\n}, true);  // true = reset to defaults first\n```\n\n**Important:** Configuration changes affect all subsequent signal validations and executions. Changes do not affect already-opened signals.\n\n**Sources:** [src/config/params.ts:1-122](), [test/config/setup.mjs:89-102](), [test/e2e/sanitize.test.mjs:30-32]()\n\n---\n\n## Parameter Categories\n\n### Trading Execution Parameters\n\n| Parameter | Default | Description | Applied When |\n|-----------|---------|-------------|--------------|\n| `CC_PERCENT_FEE` | `0.1` | Fee percentage per transaction (0.1% = 10 basis points). Applied twice: entry and exit, total 0.2%. | PNL calculation on signal close |\n| `CC_PERCENT_SLIPPAGE` | `0.1` | Slippage percentage per transaction (0.1% = 10 basis points). Simulates market impact and order book depth. Applied twice: entry and exit, total ~0.2%. | PNL calculation on signal close |\n\n**Cost Calculation Formula:**\n\n```\nLONG PNL = ((priceClose / priceOpen) - 1) * 100\n         - (CC_PERCENT_FEE * 2)\n         - (CC_PERCENT_SLIPPAGE * 2)\n\nSHORT PNL = ((priceOpen / priceClose) - 1) * 100\n          - (CC_PERCENT_FEE * 2)\n          - (CC_PERCENT_SLIPPAGE * 2)\n```\n\n**Example:** LONG entry at $42,000, exit at $43,000:\n- Gross profit: +2.38%\n- Fees (2 × 0.1%): -0.2%\n- Slippage (2 × 0.1%): -0.2%\n- **Net profit: ~1.98%**\n\n**Sources:** [src/config/params.ts:13-24](), [test/config/setup.mjs:92-93]()\n\n---\n\n### Signal Validation Parameters\n\nThese parameters enforce minimum quality standards for signals, preventing unprofitable or catastrophic trades.\n\n```mermaid\ngraph TB\n    subgraph \"Validation Pipeline\"\n        SIGNAL[\"ISignalDto<br/>{position, priceOpen,<br/>priceTakeProfit, priceStopLoss,<br/>minuteEstimatedTime}\"]\n        \n        V1[\"Step 1: Price Positivity<br/>All prices > 0<br/>isFinite, not NaN\"]\n        V2[\"Step 2: TP/SL Logic<br/>LONG: TP > priceOpen > SL<br/>SHORT: SL > priceOpen > TP\"]\n        V3[\"Step 3: Min TP Distance<br/>|TP - priceOpen| / priceOpen * 100<br/>>= CC_MIN_TAKEPROFIT_DISTANCE_PERCENT\"]\n        V4[\"Step 4: Min SL Distance<br/>|SL - priceOpen| / priceOpen * 100<br/>>= CC_MIN_STOPLOSS_DISTANCE_PERCENT\"]\n        V5[\"Step 5: Max SL Distance<br/>|SL - priceOpen| / priceOpen * 100<br/><= CC_MAX_STOPLOSS_DISTANCE_PERCENT\"]\n        V6[\"Step 6: Max Lifetime<br/>minuteEstimatedTime<br/><= CC_MAX_SIGNAL_LIFETIME_MINUTES\"]\n        V7[\"Step 7: Candle Anomalies<br/>CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR\"]\n        \n        ACCEPT[\"Signal Accepted<br/>Schedule or Open\"]\n        REJECT[\"Signal Rejected<br/>Error logged, riskSubject emitted\"]\n    end\n    \n    SIGNAL --> V1\n    V1 -->|pass| V2\n    V1 -->|fail| REJECT\n    V2 -->|pass| V3\n    V2 -->|fail| REJECT\n    V3 -->|pass| V4\n    V3 -->|fail| REJECT\n    V4 -->|pass| V5\n    V4 -->|fail| REJECT\n    V5 -->|pass| V6\n    V5 -->|fail| REJECT\n    V6 -->|pass| V7\n    V6 -->|fail| REJECT\n    V7 -->|pass| ACCEPT\n    V7 -->|fail| REJECT\n    \n    style ACCEPT fill:#ccffcc,stroke:#00cc00,stroke-width:2px\n    style REJECT fill:#ffcccc,stroke:#cc0000,stroke-width:2px\n```\n\n**7-Stage Signal Validation Pipeline**\n\nEvery signal passes through seven validation stages before execution. Any failure results in immediate rejection with error logging and risk event emission.\n\n**Sources:** [src/config/params.ts:26-55](), [test/e2e/sanitize.test.mjs:27-122]()\n\n---\n\n#### CC_MIN_TAKEPROFIT_DISTANCE_PERCENT\n\n**Default:** `0.5`  \n**Unit:** Percentage (0.5 = 0.5%)  \n**Purpose:** Ensures TakeProfit is far enough from `priceOpen` to cover transaction costs and provide minimum profit margin.\n\n**Calculation:**\n```\nLONG:   distance = ((priceTakeProfit - priceOpen) / priceOpen) * 100\nSHORT:  distance = ((priceOpen - priceTakeProfit) / priceOpen) * 100\n\nMust be >= CC_MIN_TAKEPROFIT_DISTANCE_PERCENT\n```\n\n**Rationale:**\n- Slippage effect: ~0.2% (0.1% × 2 transactions)\n- Fees: 0.2% (0.1% × 2 transactions)\n- Minimum profit buffer: 0.1%\n- **Total: 0.5%**\n\n**Example Validation:**\n```typescript\n// REJECTED: TP too close\n{\n  position: \"long\",\n  priceOpen: 42000,\n  priceTakeProfit: 42010,  // Only 0.024% distance - fails validation\n  priceStopLoss: 41000,\n}\n\n// ACCEPTED: TP covers costs\n{\n  position: \"long\",\n  priceOpen: 42000,\n  priceTakeProfit: 42210,  // 0.5% distance - passes validation\n  priceStopLoss: 41000,\n}\n```\n\n**Test Coverage:** [test/e2e/sanitize.test.mjs:27-122]() demonstrates rejection of micro-profit signals (0.024% TP distance).\n\n**Sources:** [src/config/params.ts:26-37](), [test/e2e/sanitize.test.mjs:27-122]()\n\n---\n\n#### CC_MIN_STOPLOSS_DISTANCE_PERCENT\n\n**Default:** `0.5`  \n**Unit:** Percentage (0.5 = 0.5%)  \n**Purpose:** Prevents signals from being immediately stopped out due to normal price volatility.\n\n**Calculation:**\n```\nLONG:   distance = ((priceOpen - priceStopLoss) / priceOpen) * 100\nSHORT:  distance = ((priceStopLoss - priceOpen) / priceOpen) * 100\n\nMust be >= CC_MIN_STOPLOSS_DISTANCE_PERCENT\n```\n\n**Rationale:** Normal market fluctuations can move price ±0.3% without trend change. A 0.5% minimum prevents \"instant stop-out\" scenarios where price briefly touches SL on noise.\n\n**Sources:** [src/config/params.ts:39-43]()\n\n---\n\n#### CC_MAX_STOPLOSS_DISTANCE_PERCENT\n\n**Default:** `20`  \n**Unit:** Percentage (20 = 20%)  \n**Purpose:** Prevents catastrophic losses from extreme StopLoss values that could destroy portfolio.\n\n**Calculation:**\n```\nLONG:   distance = ((priceOpen - priceStopLoss) / priceOpen) * 100\nSHORT:  distance = ((priceStopLoss - priceOpen) / priceOpen) * 100\n\nMust be <= CC_MAX_STOPLOSS_DISTANCE_PERCENT\n```\n\n**Example Validation:**\n```typescript\n// REJECTED: SL too far\n{\n  position: \"long\",\n  priceOpen: 42000,\n  priceTakeProfit: 43000,\n  priceStopLoss: 20000,  // -52% risk - CATASTROPHIC!\n}\n\n// ACCEPTED: Reasonable SL\n{\n  position: \"long\",\n  priceOpen: 42000,\n  priceTakeProfit: 43000,\n  priceStopLoss: 34000,  // -19% risk - within 20% limit\n}\n```\n\n**Test Coverage:** [test/e2e/sanitize.test.mjs:134-229]() demonstrates rejection of extreme StopLoss (-52% risk).\n\n**Sources:** [src/config/params.ts:44-49](), [test/e2e/sanitize.test.mjs:134-229]()\n\n---\n\n#### CC_MAX_SIGNAL_LIFETIME_MINUTES\n\n**Default:** `1440`  \n**Unit:** Minutes (1440 = 1 day)  \n**Purpose:** Prevents \"eternal signals\" that block risk limits for extended periods, causing strategy deadlock.\n\n**Validation:**\n```\nminuteEstimatedTime <= CC_MAX_SIGNAL_LIFETIME_MINUTES\n```\n\n**Problem Scenario:**\n- Signal with `minuteEstimatedTime: 50000` (34+ days)\n- Blocks risk limit for entire month\n- No new signals can open while this one is active\n- Strategy effectively dead for 30+ days\n\n**Example Validation:**\n```typescript\n// REJECTED: Excessive lifetime\n{\n  position: \"long\",\n  priceOpen: 42000,\n  priceTakeProfit: 43000,\n  priceStopLoss: 41000,\n  minuteEstimatedTime: 50000,  // 34+ days - REJECTED\n}\n\n// ACCEPTED: Reasonable lifetime\n{\n  position: \"long\",\n  priceOpen: 42000,\n  priceTakeProfit: 43000,\n  priceStopLoss: 41000,\n  minuteEstimatedTime: 1440,  // 1 day - ACCEPTED\n}\n```\n\n**Test Coverage:** [test/e2e/sanitize.test.mjs:241-339]() demonstrates rejection of excessive lifetime (50,000 minutes).\n\n**Sources:** [src/config/params.ts:51-55](), [test/e2e/sanitize.test.mjs:241-339]()\n\n---\n\n#### CC_SCHEDULE_AWAIT_MINUTES\n\n**Default:** `120`  \n**Unit:** Minutes (120 = 2 hours)  \n**Purpose:** Maximum time a scheduled signal waits for `priceOpen` activation before automatic cancellation.\n\n**Behavior:**\n```\nWhen signal becomes scheduled:\n  scheduledAt = timestamp of scheduling\n  \nOn each tick:\n  if (currentTime - scheduledAt > CC_SCHEDULE_AWAIT_MINUTES * 60000):\n    Cancel signal with reason: \"time_expired\"\n```\n\n**Use Case:** Prevents scheduled signals from waiting indefinitely if market moves away from `priceOpen` entry level.\n\n**Sources:** [src/config/params.ts:3-6]()\n\n---\n\n#### CC_MAX_SIGNAL_GENERATION_SECONDS\n\n**Default:** `180`  \n**Unit:** Seconds (180 = 3 minutes)  \n**Purpose:** Maximum execution time for `getSignal` function. Prevents long-running or stuck signal generation routines from blocking system.\n\n**Note:** This timeout is documented but enforcement depends on execution environment. Used primarily for monitoring and alerting.\n\n**Sources:** [src/config/params.ts:57-64]()\n\n---\n\n### Data Fetching Parameters\n\nParameters controlling `Exchange.getCandles()` retry logic and VWAP calculation.\n\n```mermaid\ngraph TB\n    subgraph \"Candle Fetching Flow\"\n        REQUEST[\"getCandles Request<br/>symbol, interval, since, limit\"]\n        \n        ATTEMPT_1[\"Attempt 1<br/>Call Exchange.getCandles()\"]\n        CHECK_1{Success?}\n        \n        WAIT_1[\"Wait CC_GET_CANDLES_RETRY_DELAY_MS<br/>Default: 5000ms\"]\n        \n        ATTEMPT_2[\"Attempt 2<br/>Call Exchange.getCandles()\"]\n        CHECK_2{Success?}\n        \n        WAIT_2[\"Wait CC_GET_CANDLES_RETRY_DELAY_MS<br/>Default: 5000ms\"]\n        \n        ATTEMPT_3[\"Attempt 3<br/>Call Exchange.getCandles()\"]\n        CHECK_3{Success?}\n        \n        VALIDATE[\"Validate Candles<br/>Price Anomaly Detection\"]\n        VWAP[\"Calculate VWAP<br/>Last CC_AVG_PRICE_CANDLES_COUNT\"]\n        \n        SUCCESS[\"Return Candles\"]\n        FAIL[\"Throw Error<br/>Log + Exit\"]\n    end\n    \n    REQUEST --> ATTEMPT_1\n    ATTEMPT_1 --> CHECK_1\n    CHECK_1 -->|yes| VALIDATE\n    CHECK_1 -->|no| WAIT_1\n    \n    WAIT_1 --> ATTEMPT_2\n    ATTEMPT_2 --> CHECK_2\n    CHECK_2 -->|yes| VALIDATE\n    CHECK_2 -->|no| WAIT_2\n    \n    WAIT_2 --> ATTEMPT_3\n    ATTEMPT_3 --> CHECK_3\n    CHECK_3 -->|yes| VALIDATE\n    CHECK_3 -->|no| FAIL\n    \n    VALIDATE --> VWAP\n    VWAP --> SUCCESS\n    \n    style SUCCESS fill:#ccffcc,stroke:#00cc00,stroke-width:2px\n    style FAIL fill:#ffcccc,stroke:#cc0000,stroke-width:2px\n```\n\n**Retry Logic Flow**\n\nCandle fetching uses exponential backoff with configurable retry count and delay. Maximum 3 attempts by default before failure.\n\n**Sources:** [src/config/params.ts:66-74]()\n\n---\n\n#### CC_GET_CANDLES_RETRY_COUNT\n\n**Default:** `3`  \n**Unit:** Count (integer)  \n**Purpose:** Number of retry attempts for `Exchange.getCandles()` before failing.\n\n**Behavior:**\n```typescript\nlet attempts = 0;\nwhile (attempts < CC_GET_CANDLES_RETRY_COUNT) {\n  try {\n    return await exchange.getCandles(...);\n  } catch (error) {\n    attempts++;\n    if (attempts >= CC_GET_CANDLES_RETRY_COUNT) throw error;\n    await sleep(CC_GET_CANDLES_RETRY_DELAY_MS);\n  }\n}\n```\n\n**Use Case:** Handles transient network errors, API rate limits, and temporary exchange downtime.\n\n**Test Configuration:** [test/config/setup.mjs:98]() sets this to `1` in tests for speed.\n\n**Sources:** [src/config/params.ts:66-69](), [test/config/setup.mjs:98]()\n\n---\n\n#### CC_GET_CANDLES_RETRY_DELAY_MS\n\n**Default:** `5000`  \n**Unit:** Milliseconds (5000 = 5 seconds)  \n**Purpose:** Delay between retry attempts for `Exchange.getCandles()`.\n\n**Rationale:** 5-second delay allows exchange APIs to recover from rate limiting or temporary errors without hammering the endpoint.\n\n**Test Configuration:** [test/config/setup.mjs:99]() sets this to `100` (100ms) in tests for speed.\n\n**Sources:** [src/config/params.ts:70-74](), [test/config/setup.mjs:99]()\n\n---\n\n#### CC_AVG_PRICE_CANDLES_COUNT\n\n**Default:** `5`  \n**Unit:** Count (integer, candles)  \n**Purpose:** Number of 1-minute candles used for VWAP (Volume Weighted Average Price) calculation.\n\n**VWAP Calculation:**\n```typescript\n// Fetch last 5 1-minute candles\nconst candles = await exchange.getCandles(symbol, \"1m\", since, 5);\n\n// Calculate VWAP\nlet totalVolume = 0;\nlet weightedSum = 0;\n\nfor (const candle of candles) {\n  const midPrice = (candle.high + candle.low) / 2;\n  weightedSum += midPrice * candle.volume;\n  totalVolume += candle.volume;\n}\n\nconst vwap = totalVolume > 0 \n  ? weightedSum / totalVolume \n  : candles.map(c => c.close).reduce((a,b) => a+b) / candles.length;\n```\n\n**Fallback:** If `totalVolume === 0`, uses simple average of close prices.\n\n**Test Coverage:** [test/e2e/edge.test.mjs:148-283]() tests VWAP calculation with zero volume.\n\n**Sources:** [src/config/params.ts:8-11](), [test/e2e/edge.test.mjs:148-283]()\n\n---\n\n### Anomaly Detection Parameters\n\nParameters for detecting and rejecting incomplete or corrupted candle data from exchanges.\n\n#### CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR\n\n**Default:** `1000`  \n**Unit:** Factor (multiplier)  \n**Purpose:** Maximum allowed deviation factor for price anomaly detection. Rejects candles with prices more than `1/factor` below the reference price.\n\n**Algorithm:**\n```typescript\n// Calculate reference price (median or average)\nconst prices = candles.flatMap(c => [c.open, c.high, c.low, c.close]);\nconst referencePrice = candles.length >= CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN\n  ? median(prices)\n  : average(prices);\n\n// Calculate threshold\nconst threshold = referencePrice / CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR;\n\n// Validate each candle\nfor (const candle of candles) {\n  if (candle.open < threshold || candle.high < threshold || \n      candle.low < threshold || candle.close < threshold) {\n    throw new Error(`Anomalously low price detected`);\n  }\n}\n```\n\n**Reasoning:**\n- Incomplete candles from Binance API typically have prices near $0.01-$1\n- Normal BTC price ranges: $20,000-$100,000\n- Factor 1000 catches prices below $20-$100 when median is $20,000-$100,000\n- Factor 100 would be too permissive (allows $200 when median is $20,000)\n- Factor 10,000 might be too strict for low-cap altcoins\n\n**Example:**\n```typescript\n// Normal candles: BTC at $50,000\n// referencePrice = $50,000\n// threshold = $50,000 / 1000 = $50\n// Any price < $50 is rejected\n\n// Incomplete candle: open=$0.10, high=$0.12, low=$0.08, close=$0.10\n// All prices < $50 → REJECTED\n```\n\n**Test Coverage:** [test/e2e/sanitize.test.mjs:666-784]() tests rejection of incomplete Binance candles with anomalous prices ($0.1 vs $42,000 median).\n\n**Sources:** [src/config/params.ts:76-89](), [test/e2e/sanitize.test.mjs:666-784]()\n\n---\n\n#### CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN\n\n**Default:** `5`  \n**Unit:** Count (integer, candles)  \n**Purpose:** Minimum number of candles required for reliable median calculation. Below this threshold, uses simple average instead.\n\n**Statistical Reasoning:**\n- Each candle provides 4 price points (OHLC)\n- 5 candles = 20 price points, sufficient for robust median calculation\n- Below 5 candles, single anomaly can heavily skew median\n- Statistical rule of thumb: minimum 7-10 data points for median stability\n- Average is more stable than median for small datasets (n < 20)\n\n**Example:**\n```typescript\nif (candles.length >= 5) {\n  // Use median (more robust to outliers)\n  const prices = candles.flatMap(c => [c.open, c.high, c.low, c.close]);\n  referencePrice = median(prices);\n} else {\n  // Use average (more stable for small datasets)\n  const prices = candles.flatMap(c => [c.open, c.high, c.low, c.close]);\n  referencePrice = average(prices);\n}\n```\n\n**Sources:** [src/config/params.ts:91-104]()\n\n---\n\n### Reporting Parameters\n\nParameters controlling markdown report generation and output formatting.\n\n#### CC_REPORT_SHOW_SIGNAL_NOTE\n\n**Default:** `false`  \n**Type:** Boolean  \n**Purpose:** Controls visibility of the \"Note\" column in markdown report tables.\n\n**Behavior:**\n```typescript\n// When CC_REPORT_SHOW_SIGNAL_NOTE = false (default)\n// Report columns: Symbol | Position | Entry | Exit | PNL | ...\n\n// When CC_REPORT_SHOW_SIGNAL_NOTE = true\n// Report columns: Symbol | Position | Entry | Exit | PNL | Note | ...\n```\n\n**Rationale:** Signal notes can be verbose and clutter reports. Default to hidden for cleaner output. Enable when debugging specific signals.\n\n**Use Case:**\n```typescript\n// Enable notes for debugging\nsetConfig({ CC_REPORT_SHOW_SIGNAL_NOTE: true });\n\n// Signal with detailed note\nconst signal = {\n  position: \"long\",\n  priceOpen: 42000,\n  priceTakeProfit: 43000,\n  priceStopLoss: 41000,\n  note: \"RSI oversold + MACD crossover at 2024-01-01 08:30:00\",\n};\n```\n\n**Sources:** [src/config/params.ts:106-113]()\n\n---\n\n## Configuration Reference Table\n\n| Parameter | Default | Type | Category | Validation Impact |\n|-----------|---------|------|----------|-------------------|\n| `CC_PERCENT_FEE` | `0.1` | number | Trading | PNL calculation |\n| `CC_PERCENT_SLIPPAGE` | `0.1` | number | Trading | PNL calculation |\n| `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` | `0.5` | number | Validation | Signal rejection if TP too close |\n| `CC_MIN_STOPLOSS_DISTANCE_PERCENT` | `0.5` | number | Validation | Signal rejection if SL too close |\n| `CC_MAX_STOPLOSS_DISTANCE_PERCENT` | `20` | number | Validation | Signal rejection if SL too far |\n| `CC_MAX_SIGNAL_LIFETIME_MINUTES` | `1440` | number | Validation | Signal rejection if lifetime excessive |\n| `CC_SCHEDULE_AWAIT_MINUTES` | `120` | number | Validation | Scheduled signal auto-cancel timeout |\n| `CC_MAX_SIGNAL_GENERATION_SECONDS` | `180` | number | Validation | getSignal timeout (monitoring) |\n| `CC_GET_CANDLES_RETRY_COUNT` | `3` | number | Data Fetching | Number of retry attempts |\n| `CC_GET_CANDLES_RETRY_DELAY_MS` | `5000` | number | Data Fetching | Delay between retries |\n| `CC_AVG_PRICE_CANDLES_COUNT` | `5` | number | Data Fetching | VWAP calculation window |\n| `CC_GET_CANDLES_PRICE_ANOMALY_THRESHOLD_FACTOR` | `1000` | number | Anomaly Detection | Price anomaly rejection threshold |\n| `CC_GET_CANDLES_MIN_CANDLES_FOR_MEDIAN` | `5` | number | Anomaly Detection | Median vs average calculation cutoff |\n| `CC_REPORT_SHOW_SIGNAL_NOTE` | `false` | boolean | Reporting | Note column visibility |\n\n**Sources:** [src/config/params.ts:1-114]()\n\n---\n\n## Common Configuration Patterns\n\n### Production-Ready Configuration\n\n```typescript\nimport { setConfig } from 'backtest-kit';\n\n// Conservative production settings\nsetConfig({\n  // Higher fees for real exchange conditions\n  CC_PERCENT_FEE: 0.15,\n  CC_PERCENT_SLIPPAGE: 0.2,\n  \n  // Stricter profit requirements\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 1.0,\n  \n  // Tighter risk controls\n  CC_MAX_STOPLOSS_DISTANCE_PERCENT: 10,\n  \n  // Shorter signal lifetimes\n  CC_MAX_SIGNAL_LIFETIME_MINUTES: 720,  // 12 hours\n  \n  // More aggressive retry logic\n  CC_GET_CANDLES_RETRY_COUNT: 5,\n  CC_GET_CANDLES_RETRY_DELAY_MS: 10000,  // 10 seconds\n});\n```\n\n**Sources:** [src/config/params.ts:1-114]()\n\n---\n\n### Aggressive Backtesting Configuration\n\n```typescript\n// Optimistic backtesting (find theoretical max performance)\nsetConfig({\n  CC_PERCENT_FEE: 0.05,  // Lower fees\n  CC_PERCENT_SLIPPAGE: 0.05,  // Lower slippage\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.3,  // Allow smaller profits\n  CC_MAX_STOPLOSS_DISTANCE_PERCENT: 30,  // Allow larger stops\n  CC_MAX_SIGNAL_LIFETIME_MINUTES: 10080,  // 7 days\n});\n```\n\n**Warning:** Aggressive settings may produce unrealistic results. Always validate strategies with production settings before live trading.\n\n**Sources:** [src/config/params.ts:1-114]()\n\n---\n\n### Testing Configuration (Fast Execution)\n\n```typescript\n// Disable validations and speed up retries for tests\nsetConfig({\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0,\n  CC_MIN_STOPLOSS_DISTANCE_PERCENT: 0,\n  CC_MAX_STOPLOSS_DISTANCE_PERCENT: 100,\n  CC_MAX_SIGNAL_LIFETIME_MINUTES: 999999,\n  CC_GET_CANDLES_RETRY_COUNT: 1,  // No retries\n  CC_GET_CANDLES_RETRY_DELAY_MS: 100,  // Fast retry\n}, true);  // Reset to defaults first\n```\n\n**Sources:** [test/config/setup.mjs:89-102]()\n\n---\n\n## DEFAULT_CONFIG Constant\n\nThe `DEFAULT_CONFIG` object is a frozen (immutable) copy of `GLOBAL_CONFIG` created at initialization. Used for resetting configuration to original values.\n\n```typescript\nexport const DEFAULT_CONFIG = Object.freeze({...GLOBAL_CONFIG});\n```\n\n**Usage:**\n```typescript\n// Reset to defaults\nimport { GLOBAL_CONFIG, DEFAULT_CONFIG } from 'backtest-kit';\n\nObject.keys(DEFAULT_CONFIG).forEach(key => {\n  GLOBAL_CONFIG[key] = DEFAULT_CONFIG[key];\n});\n\n// Or use setConfig with reset flag\nsetConfig({}, true);  // Empty config + reset = full default restoration\n```\n\n**Sources:** [src/config/params.ts:116-122]()\n\n---\n\n## Validation Enforcement Points\n\n```mermaid\ngraph LR\n    subgraph \"Signal Generation\"\n        GET_SIGNAL[\"getSignal()<br/>User strategy code\"]\n        RETURN_SIGNAL[\"Return ISignalDto\"]\n    end\n    \n    subgraph \"Validation Layer (ClientStrategy)\"\n        VALIDATE_SCHEMA[\"Validate schema<br/>required fields present\"]\n        VALIDATE_PRICES[\"Validate prices<br/>positive, finite\"]\n        VALIDATE_TP_SL_LOGIC[\"Validate TP/SL logic<br/>LONG: TP>open>SL<br/>SHORT: SL>open>TP\"]\n        VALIDATE_DISTANCES[\"Validate distances<br/>CC_MIN/MAX checks\"]\n        VALIDATE_LIFETIME[\"Validate lifetime<br/>CC_MAX_SIGNAL_LIFETIME\"]\n        VALIDATE_CANDLES[\"Validate candles<br/>CC_GET_CANDLES_PRICE_ANOMALY\"]\n    end\n    \n    subgraph \"Execution Layer\"\n        SCHEDULE_OR_OPEN[\"Schedule or Open signal\"]\n        CALC_PNL[\"Calculate PNL<br/>Apply CC_PERCENT_FEE<br/>Apply CC_PERCENT_SLIPPAGE\"]\n        CLOSE[\"Close signal\"]\n    end\n    \n    subgraph \"Reporting Layer\"\n        EMIT_EVENTS[\"Emit events<br/>signalEmitter, riskSubject\"]\n        GENERATE_REPORT[\"Generate markdown<br/>Use CC_REPORT_SHOW_SIGNAL_NOTE\"]\n    end\n    \n    GET_SIGNAL --> RETURN_SIGNAL\n    RETURN_SIGNAL --> VALIDATE_SCHEMA\n    VALIDATE_SCHEMA --> VALIDATE_PRICES\n    VALIDATE_PRICES --> VALIDATE_TP_SL_LOGIC\n    VALIDATE_TP_SL_LOGIC --> VALIDATE_DISTANCES\n    VALIDATE_DISTANCES --> VALIDATE_LIFETIME\n    VALIDATE_LIFETIME --> VALIDATE_CANDLES\n    VALIDATE_CANDLES --> SCHEDULE_OR_OPEN\n    \n    SCHEDULE_OR_OPEN --> CALC_PNL\n    CALC_PNL --> CLOSE\n    \n    CLOSE --> EMIT_EVENTS\n    EMIT_EVENTS --> GENERATE_REPORT\n```\n\n**Configuration Enforcement Flow**\n\nConfiguration parameters are enforced at three primary points: (1) validation layer during signal creation, (2) execution layer during PNL calculation, (3) data fetching layer during candle retrieval. Each layer reads directly from `GLOBAL_CONFIG` at execution time.\n\n**Sources:** [src/config/params.ts:1-122]()\n\n---\n\n## Related Configuration\n\nFor additional configuration options, see:\n- **Column Configuration**: [Column Configuration](#11.2) - Customize report column visibility and formatting\n- **Logger Configuration**: [Logger Configuration](#11.3) - Configure logging output and levels\n- **Strategy Configuration**: [Strategy Schema Definition](#6.1) - Per-strategy settings (interval, callbacks, risk profiles)\n- **Risk Configuration**: [Risk Profiles & Validation](#7.1) - Custom validation rules and portfolio limits\n\n**Sources:** [src/config/params.ts:1-122]()"
                    },
                    {
                        "page_plan": {
                            "id": "11.2",
                            "title": "Column Configuration"
                        },
                        "content": "# Column Configuration\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Heat.ts](src/classes/Heat.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Partial.ts](src/classes/Partial.ts)\n- [src/classes/Performance.ts](src/classes/Performance.ts)\n- [src/classes/Risk.ts](src/classes/Risk.ts)\n- [src/classes/Schedule.ts](src/classes/Schedule.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [src/lib/services/markdown/BacktestMarkdownService.ts](src/lib/services/markdown/BacktestMarkdownService.ts)\n- [src/lib/services/markdown/HeatMarkdownService.ts](src/lib/services/markdown/HeatMarkdownService.ts)\n- [src/lib/services/markdown/LiveMarkdownService.ts](src/lib/services/markdown/LiveMarkdownService.ts)\n- [src/lib/services/markdown/PartialMarkdownService.ts](src/lib/services/markdown/PartialMarkdownService.ts)\n- [src/lib/services/markdown/PerformanceMarkdownService.ts](src/lib/services/markdown/PerformanceMarkdownService.ts)\n- [src/lib/services/markdown/RiskMarkdownService.ts](src/lib/services/markdown/RiskMarkdownService.ts)\n- [src/lib/services/markdown/ScheduleMarkdownService.ts](src/lib/services/markdown/ScheduleMarkdownService.ts)\n- [src/lib/services/markdown/WalkerMarkdownService.ts](src/lib/services/markdown/WalkerMarkdownService.ts)\n- [src/model/Column.model.ts](src/model/Column.model.ts)\n- [test/spec/columns.test.mjs](test/spec/columns.test.mjs)\n\n</details>\n\n\n\nColumn configuration in Backtest Kit provides a flexible system for customizing the markdown table output in all reporting services. This system uses a generic `ColumnModel` interface to define how data is extracted, formatted, and displayed in markdown reports across different execution modes (backtest, live, walker) and report types (performance, heatmap, risk, etc.).\n\nFor information about the markdown reporting services themselves, see [Markdown Reports](#9.2). For details on the statistics models that columns format, see [Statistics Models](#9.3).\n\n## Purpose and Scope\n\nColumn configuration serves three primary purposes:\n\n1. **Customization**: Users can define custom columns to display only relevant data\n2. **Formatting**: Each column specifies how to transform raw data into display strings\n3. **Visibility Control**: Columns can be conditionally shown/hidden based on runtime logic\n\nThis page covers the `ColumnModel` interface, column type specializations, default configurations, and integration with markdown services.\n\n---\n\n## ColumnModel Interface\n\nThe `ColumnModel<T>` interface is a generic abstraction for defining table columns in markdown reports. The type parameter `T` represents the data type being formatted (e.g., closed signals, heatmap rows, performance metrics).\n\n### Interface Structure\n\n```mermaid\nclassDiagram\n    class ColumnModel~T~ {\n        +string key\n        +string label\n        +format(data: T, index: number) string | Promise~string~\n        +isVisible() boolean | Promise~boolean~\n    }\n    \n    class BacktestColumns {\n        T = IStrategyTickResultClosed\n    }\n    \n    class LiveColumns {\n        T = TickEvent\n    }\n    \n    class WalkerStrategyColumn {\n        T = IStrategyResult\n    }\n    \n    class WalkerPnlColumn {\n        T = SignalData\n    }\n    \n    class HeatColumns {\n        T = IHeatmapRow\n    }\n    \n    class PerformanceColumns {\n        T = MetricStats\n    }\n    \n    class ScheduleColumns {\n        T = ScheduledEvent\n    }\n    \n    class PartialColumns {\n        T = PartialEvent\n    }\n    \n    class RiskColumns {\n        T = RiskEvent\n    }\n    \n    ColumnModel~T~ <|.. BacktestColumns\n    ColumnModel~T~ <|.. LiveColumns\n    ColumnModel~T~ <|.. WalkerStrategyColumn\n    ColumnModel~T~ <|.. WalkerPnlColumn\n    ColumnModel~T~ <|.. HeatColumns\n    ColumnModel~T~ <|.. PerformanceColumns\n    ColumnModel~T~ <|.. ScheduleColumns\n    ColumnModel~T~ <|.. PartialColumns\n    ColumnModel~T~ <|.. RiskColumns\n```\n\n**Sources:** [src/model/Column.model.ts:1-39]()\n\n### Property Descriptions\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `key` | `string` | Unique identifier for the column, used for tracking and debugging |\n| `label` | `string` | Display text shown in the markdown table header |\n| `format` | `(data: T, index: number) => string \\| Promise<string>` | Function to transform data into display string. Receives the data object and its index in the list |\n| `isVisible` | `() => boolean \\| Promise<boolean>` | Function to determine if column should be displayed. Enables conditional column visibility |\n\n---\n\n## Column Type Specializations\n\nEach markdown service defines its own column type alias as a specialization of `ColumnModel<T>` with a specific data type.\n\n### Backtest Columns\n\n```typescript\nexport type Columns = ColumnModel<IStrategyTickResultClosed>;\n```\n\nFormats closed signal data with PNL information, close reason, timestamps, and trade details.\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:17-48]()\n\n### Live Trading Columns\n\n```typescript\nexport type Columns = ColumnModel<TickEvent>;\n```\n\nFormats live trading events including idle, opened, active, and closed states with real-time pricing.\n\n**Sources:** [src/lib/services/markdown/LiveMarkdownService.ts:19-50]()\n\n### Walker Columns\n\nWalker mode uses two distinct column types:\n\n```typescript\nexport type StrategyColumn = ColumnModel<IStrategyResult>;\nexport type PnlColumn = ColumnModel<SignalData>;\n```\n\n- `StrategyColumn`: Formats strategy comparison metrics (win rate, Sharpe ratio, trade counts)\n- `PnlColumn`: Formats individual signal PNL data across all strategies\n\n**Sources:** [src/lib/services/markdown/WalkerMarkdownService.ts:24-88]()\n\n### Heatmap Columns\n\n```typescript\nexport type Columns = ColumnModel<IHeatmapRow>;\n```\n\nFormats per-symbol portfolio statistics (total PNL, Sharpe ratio, max drawdown, trade counts).\n\n**Sources:** [src/lib/services/markdown/HeatMarkdownService.ts:18-49]()\n\n### Performance Columns\n\n```typescript\nexport type Columns = ColumnModel<MetricStats>;\n```\n\nFormats performance metric statistics (average duration, min/max, percentiles, wait times).\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:16-47]()\n\n### Schedule Columns\n\n```typescript\nexport type Columns = ColumnModel<ScheduledEvent>;\n```\n\nFormats scheduled and cancelled signal events with timing and activation data.\n\n**Sources:** [src/lib/services/markdown/ScheduleMarkdownService.ts:19-50]()\n\n### Partial Columns\n\n```typescript\nexport type Columns = ColumnModel<PartialEvent>;\n```\n\nFormats partial profit/loss exit events with level information and symbol details.\n\n**Sources:** [src/lib/services/markdown/PartialMarkdownService.ts:20-51]()\n\n### Risk Columns\n\n```typescript\nexport type Columns = ColumnModel<RiskEvent>;\n```\n\nFormats risk rejection events with rejection reasons and context.\n\n**Sources:** [src/lib/services/markdown/RiskMarkdownService.ts:12-43]()\n\n---\n\n## Default Column Configuration\n\nAll markdown services reference default columns from `COLUMN_CONFIG`:\n\n```typescript\nimport { COLUMN_CONFIG } from \"../../../config/columns\";\n\n// Usage examples:\ncolumns: Columns[] = COLUMN_CONFIG.backtest_columns\ncolumns: Columns[] = COLUMN_CONFIG.live_columns\ncolumns: StrategyColumn[] = COLUMN_CONFIG.walker_strategy_columns\ncolumns: PnlColumn[] = COLUMN_CONFIG.walker_pnl_columns\ncolumns: Columns[] = COLUMN_CONFIG.heat_columns\ncolumns: Columns[] = COLUMN_CONFIG.performance_columns\ncolumns: Columns[] = COLUMN_CONFIG.schedule_columns\ncolumns: Columns[] = COLUMN_CONFIG.partial_columns\ncolumns: Columns[] = COLUMN_CONFIG.risk_columns\n```\n\n### COLUMN_CONFIG Structure\n\n```mermaid\ngraph TB\n    COLUMN_CONFIG[\"COLUMN_CONFIG<br/>(config/columns)\"]\n    \n    COLUMN_CONFIG --> backtest[\"backtest_columns<br/>ColumnModel&lt;IStrategyTickResultClosed&gt;[]\"]\n    COLUMN_CONFIG --> live[\"live_columns<br/>ColumnModel&lt;TickEvent&gt;[]\"]\n    COLUMN_CONFIG --> walker_strat[\"walker_strategy_columns<br/>ColumnModel&lt;IStrategyResult&gt;[]\"]\n    COLUMN_CONFIG --> walker_pnl[\"walker_pnl_columns<br/>ColumnModel&lt;SignalData&gt;[]\"]\n    COLUMN_CONFIG --> heat[\"heat_columns<br/>ColumnModel&lt;IHeatmapRow&gt;[]\"]\n    COLUMN_CONFIG --> perf[\"performance_columns<br/>ColumnModel&lt;MetricStats&gt;[]\"]\n    COLUMN_CONFIG --> sched[\"schedule_columns<br/>ColumnModel&lt;ScheduledEvent&gt;[]\"]\n    COLUMN_CONFIG --> partial[\"partial_columns<br/>ColumnModel&lt;PartialEvent&gt;[]\"]\n    COLUMN_CONFIG --> risk[\"risk_columns<br/>ColumnModel&lt;RiskEvent&gt;[]\"]\n    \n    backtest --> BacktestMarkdownService\n    live --> LiveMarkdownService\n    walker_strat --> WalkerMarkdownService\n    walker_pnl --> WalkerMarkdownService\n    heat --> HeatMarkdownService\n    perf --> PerformanceMarkdownService\n    sched --> ScheduleMarkdownService\n    partial --> PartialMarkdownService\n    risk --> RiskMarkdownService\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:15](), [src/lib/services/markdown/LiveMarkdownService.ts:17](), [src/lib/services/markdown/WalkerMarkdownService.ts:22](), [src/lib/services/markdown/HeatMarkdownService.ts:16](), [src/lib/services/markdown/PerformanceMarkdownService.ts:14](), [src/lib/services/markdown/ScheduleMarkdownService.ts:17](), [src/lib/services/markdown/PartialMarkdownService.ts:18](), [src/lib/services/markdown/RiskMarkdownService.ts:10]()\n\n---\n\n## Using Custom Columns\n\nAll reporting methods accept an optional `columns` parameter to override defaults:\n\n### Backtest.getReport / Backtest.dump\n\n```javascript\nconst customColumns = [\n  {\n    key: \"signalId\",\n    label: \"ID\",\n    format: (data) => data.signal.id,\n    isVisible: () => true,\n  },\n  {\n    key: \"position\",\n    label: \"Position\",\n    format: (data) => data.signal.position.toUpperCase(),\n    isVisible: () => true,\n  },\n  {\n    key: \"pnl\",\n    label: \"PNL\",\n    format: (data) => `${data.pnl.pnlPercentage.toFixed(2)}%`,\n    isVisible: () => true,\n  },\n];\n\nconst markdown = await Backtest.getReport(\"BTCUSDT\", \"my-strategy\", customColumns);\nawait Backtest.dump(\"BTCUSDT\", \"my-strategy\", \"./reports\", customColumns);\n```\n\n**Sources:** [test/spec/columns.test.mjs:69-95](), [test/spec/columns.test.mjs:168-190]()\n\n### Live.getReport / Live.dump\n\n```javascript\nconst liveColumns = [\n  {\n    key: \"timestamp\",\n    label: \"Time\",\n    format: (event) => new Date(event.timestamp).toISOString(),\n    isVisible: () => true\n  },\n  {\n    key: \"action\",\n    label: \"Action\",\n    format: (event) => event.action.toUpperCase(),\n    isVisible: () => true\n  }\n];\n\nconst markdown = await Live.getReport(\"BTCUSDT\", \"my-strategy\", liveColumns);\n```\n\n**Sources:** [src/classes/Live.ts:306-312](), [src/classes/Live.ts:531-542]()\n\n### Walker.getReport / Walker.dump\n\nWalker accepts two column arrays - one for strategy comparison, one for PNL table:\n\n```javascript\nconst strategyColumns = [\n  {\n    key: \"strategyName\",\n    label: \"Strategy\",\n    format: (result) => result.strategyName,\n    isVisible: () => true\n  }\n];\n\nconst pnlColumns = [\n  {\n    key: \"pnl\",\n    label: \"PNL %\",\n    format: (signal) => signal.pnl.toFixed(2) + '%',\n    isVisible: () => true\n  }\n];\n\nconst markdown = await Walker.getReport(\n  \"BTCUSDT\",\n  \"my-walker\",\n  strategyColumns,\n  pnlColumns\n);\n```\n\n**Sources:** [src/classes/Walker.ts:273-282]()\n\n### Other Reporting Classes\n\nPerformance, Heat, Schedule, Partial, and Risk classes follow the same pattern:\n\n```javascript\n// Performance\nawait Performance.dump(\"BTCUSDT\", \"my-strategy\", \"./reports\", customColumns);\n\n// Heat (strategy-wide)\nawait Heat.dump(\"my-strategy\", \"./reports\", customColumns);\n\n// Schedule\nawait Schedule.dump(\"BTCUSDT\", \"my-strategy\", \"./reports\", customColumns);\n\n// Partial\nawait Partial.dump(\"BTCUSDT\", \"my-strategy\", \"./reports\", customColumns);\n\n// Risk\nawait Risk.dump(\"BTCUSDT\", \"my-strategy\", \"./reports\", customColumns);\n```\n\n**Sources:** [src/classes/Performance.ts:108-118](), [src/classes/Heat.ts:97-108](), [src/classes/Schedule.ts:79-94](), [src/classes/Partial.ts:121-133](), [src/classes/Risk.ts:168-180]()\n\n---\n\n## Column Visibility Control\n\nThe `isVisible()` function enables conditional column display:\n\n### Implementation in Markdown Services\n\n```mermaid\nsequenceDiagram\n    participant Service as \"Markdown Service\"\n    participant Storage as \"ReportStorage\"\n    participant Column as \"ColumnModel\"\n    \n    Service->>Storage: getReport(strategyName, columns)\n    Storage->>Storage: getData()\n    \n    loop For each column\n        Storage->>Column: isVisible()\n        Column-->>Storage: boolean\n        alt isVisible === true\n            Storage->>Storage: Add to visibleColumns\n        else isVisible === false\n            Storage->>Storage: Skip column\n        end\n    end\n    \n    Storage->>Storage: Build header from visibleColumns\n    Storage->>Storage: Build separator from visibleColumns\n    \n    loop For each data row\n        loop For each visibleColumn\n            Storage->>Column: format(data, index)\n            Column-->>Storage: formattedString\n        end\n    end\n    \n    Storage-->>Service: markdown string\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:191-206]()\n\n### Example: Conditional Visibility\n\n```javascript\nconst columns = [\n  {\n    key: \"pnl\",\n    label: \"PNL %\",\n    format: (data) => `${data.pnl.pnlPercentage.toFixed(2)}%`,\n    isVisible: () => true  // Always visible\n  },\n  {\n    key: \"debug\",\n    label: \"Debug Info\",\n    format: (data) => JSON.stringify(data.signal),\n    isVisible: () => process.env.DEBUG === \"true\"  // Conditional\n  },\n  {\n    key: \"hidden\",\n    label: \"Internal\",\n    format: (data) => data.internalState,\n    isVisible: () => false  // Never visible\n  }\n];\n```\n\nThe visibility filtering happens in the `getReport` methods:\n\n```typescript\nconst visibleColumns = [];\nfor (const col of columns) {\n  if (await col.isVisible()) {\n    visibleColumns.push(col);\n  }\n}\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:191-196](), [src/lib/services/markdown/LiveMarkdownService.ts:329-334]()\n\n---\n\n## Formatting Data\n\nThe `format` function transforms raw data objects into display strings for markdown tables.\n\n### Format Function Signature\n\n```typescript\nformat: (data: T, index: number) => string | Promise<string>\n```\n\nParameters:\n- `data`: The data object being formatted (type varies by service)\n- `index`: Zero-based position in the data list\n\n### Synchronous Formatting\n\nMost formatting is synchronous:\n\n```javascript\n{\n  key: \"position\",\n  label: \"Position\",\n  format: (data) => data.signal.position.toUpperCase(),\n  isVisible: () => true\n}\n```\n\n**Sources:** [test/spec/columns.test.mjs:78-82]()\n\n### Asynchronous Formatting\n\nFormat functions can be async for complex operations:\n\n```javascript\n{\n  key: \"priceFormatted\",\n  label: \"Price\",\n  format: async (data) => {\n    const exchange = await getExchange(data.signal.exchangeName);\n    return await exchange.formatPrice(data.symbol, data.currentPrice);\n  },\n  isVisible: () => true\n}\n```\n\n### Format Execution in Services\n\nAll markdown services handle async formatting with `Promise.all`:\n\n```typescript\nconst rows = await Promise.all(\n  dataList.map(async (data, index) =>\n    Promise.all(visibleColumns.map((col) => col.format(data, index)))\n  )\n);\n```\n\nThis pattern ensures:\n1. All format functions (sync or async) execute correctly\n2. Row-level parallelism (all rows formatted simultaneously)\n3. Column-level parallelism (all columns in a row formatted simultaneously)\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:199-203](), [src/lib/services/markdown/LiveMarkdownService.ts:337-341]()\n\n---\n\n## Integration with Markdown Services\n\n### Column Flow Architecture\n\n```mermaid\ngraph TB\n    User[\"User Code\"]\n    BacktestClass[\"Backtest.getReport()<br/>Backtest.dump()\"]\n    LiveClass[\"Live.getReport()<br/>Live.dump()\"]\n    WalkerClass[\"Walker.getReport()<br/>Walker.dump()\"]\n    \n    User -->|\"customColumns?\"| BacktestClass\n    User -->|\"customColumns?\"| LiveClass\n    User -->|\"strategyColumns?, pnlColumns?\"| WalkerClass\n    \n    BacktestClass -->|\"columns || COLUMN_CONFIG.backtest_columns\"| BacktestService[\"BacktestMarkdownService\"]\n    LiveClass -->|\"columns || COLUMN_CONFIG.live_columns\"| LiveService[\"LiveMarkdownService\"]\n    WalkerClass -->|\"columns || COLUMN_CONFIG.walker_*_columns\"| WalkerService[\"WalkerMarkdownService\"]\n    \n    BacktestService --> Storage1[\"ReportStorage.getReport()\"]\n    LiveService --> Storage2[\"ReportStorage.getReport()\"]\n    WalkerService --> Storage3[\"ReportStorage.getReport()\"]\n    \n    Storage1 --> Filter1[\"Filter visible columns\"]\n    Storage2 --> Filter2[\"Filter visible columns\"]\n    Storage3 --> Filter3[\"Filter visible columns\"]\n    \n    Filter1 --> Format1[\"Format each cell\"]\n    Filter2 --> Format2[\"Format each cell\"]\n    Filter3 --> Format3[\"Format each cell\"]\n    \n    Format1 --> Table1[\"Build markdown table\"]\n    Format2 --> Table2[\"Build markdown table\"]\n    Format3 --> Table3[\"Build markdown table\"]\n    \n    Table1 --> Output[\"Markdown String\"]\n    Table2 --> Output\n    Table3 --> Output\n```\n\n**Sources:** [src/classes/Backtest.ts:299-305](), [src/classes/Live.ts:306-312](), [src/classes/Walker.ts:273-282]()\n\n### Default Column Resolution\n\nEach public API method uses default columns if not provided:\n\n```typescript\n// Backtest\npublic getReport = async (\n  symbol: string,\n  strategyName: StrategyName,\n  columns: Columns[] = COLUMN_CONFIG.backtest_columns\n): Promise<string> => {\n  // ...\n  return await backtest.backtestMarkdownService.getReport(symbol, strategyName, columns);\n};\n```\n\n```typescript\n// Live\npublic getReport = async (\n  symbol: string,\n  strategyName: StrategyName,\n  columns?: Columns[]\n): Promise<string> => {\n  // ...\n  return await backtest.liveMarkdownService.getReport(symbol, strategyName, columns);\n};\n```\n\nNote: Some methods use default parameters, others pass `undefined` to let the service apply defaults.\n\n**Sources:** [src/classes/Backtest.ts:299-305](), [src/classes/Live.ts:306-312]()\n\n### Service-Level Column Processing\n\nAll markdown services follow this pattern:\n\n```typescript\npublic async getReport(\n  strategyName: StrategyName,\n  columns: Columns[] = COLUMN_CONFIG.backtest_columns\n): Promise<string> {\n  const stats = await this.getData();\n  \n  if (stats.totalSignals === 0) {\n    return \"No data available\";\n  }\n  \n  // Filter visible columns\n  const visibleColumns = [];\n  for (const col of columns) {\n    if (await col.isVisible()) {\n      visibleColumns.push(col);\n    }\n  }\n  \n  // Build header\n  const header = visibleColumns.map((col) => col.label);\n  const separator = visibleColumns.map(() => \"---\");\n  \n  // Format rows\n  const rows = await Promise.all(\n    dataList.map(async (data, index) =>\n      Promise.all(visibleColumns.map((col) => col.format(data, index)))\n    )\n  );\n  \n  // Build table\n  const tableData = [header, separator, ...rows];\n  const table = tableData.map(row => `| ${row.join(\" | \")} |`).join(\"\\n\");\n  \n  return table;\n}\n```\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:177-224](), [src/lib/services/markdown/LiveMarkdownService.ts:315-362]()\n\n---\n\n## Complete Example\n\n### Custom Backtest Report with Conditional Columns\n\n```javascript\nimport { addExchange, addStrategy, addFrame, Backtest } from \"backtest-kit\";\n\n// Define custom columns\nconst customColumns = [\n  {\n    key: \"index\",\n    label: \"#\",\n    format: (data, index) => (index + 1).toString(),\n    isVisible: () => true\n  },\n  {\n    key: \"signalId\",\n    label: \"ID\",\n    format: (data) => data.signal.id.substring(0, 8),\n    isVisible: () => true\n  },\n  {\n    key: \"position\",\n    label: \"Pos\",\n    format: (data) => data.signal.position === \"long\" ? \"📈\" : \"📉\",\n    isVisible: () => true\n  },\n  {\n    key: \"pnl\",\n    label: \"PNL\",\n    format: (data) => {\n      const pnl = data.pnl.pnlPercentage;\n      const sign = pnl >= 0 ? \"+\" : \"\";\n      return `${sign}${pnl.toFixed(2)}%`;\n    },\n    isVisible: () => true\n  },\n  {\n    key: \"closeReason\",\n    label: \"Close\",\n    format: (data) => data.closeReason,\n    isVisible: () => true\n  },\n  {\n    key: \"duration\",\n    label: \"Time\",\n    format: (data) => {\n      const ms = data.closeTimestamp - data.signal.pendingAt;\n      const minutes = Math.round(ms / 60000);\n      return `${minutes}m`;\n    },\n    isVisible: () => true\n  },\n  {\n    key: \"debug\",\n    label: \"Note\",\n    format: (data) => data.signal.note || \"-\",\n    isVisible: () => process.env.SHOW_NOTES === \"true\"\n  }\n];\n\n// Run backtest and generate custom report\nBacktest.background(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\",\n  frameName: \"1d-backtest\"\n});\n\n// Wait for completion...\nconst markdown = await Backtest.getReport(\"BTCUSDT\", \"my-strategy\", customColumns);\nconsole.log(markdown);\n\n// Output:\n// # Backtest Report: my-strategy\n//\n// | # | ID | Pos | PNL | Close | Time |\n// | --- | --- | --- | --- | --- | --- |\n// | 1 | a1b2c3d4 | 📈 | +2.15% | take_profit | 125m |\n// | 2 | e5f6g7h8 | 📉 | -0.95% | stop_loss | 87m |\n// ...\n```\n\n**Sources:** [test/spec/columns.test.mjs:15-112]()\n\n---\n\n## Summary Table\n\n| Aspect | Details |\n|--------|---------|\n| **Core Interface** | `ColumnModel<T>` in [src/model/Column.model.ts:26-38]() |\n| **Default Config** | `COLUMN_CONFIG` from `src/config/columns` |\n| **Type Specializations** | 9 column types across markdown services |\n| **Visibility Control** | `isVisible()` with async support |\n| **Formatting** | `format(data, index)` with async support |\n| **Public API** | All reporting methods accept optional `columns` parameter |\n| **Processing Flow** | Filter visible → Format cells → Build markdown table |\n\n**Sources:** [src/model/Column.model.ts:1-39](), [src/lib/services/markdown/BacktestMarkdownService.ts:17-48](), [src/lib/services/markdown/LiveMarkdownService.ts:19-50](), [src/lib/services/markdown/WalkerMarkdownService.ts:24-88](), [src/lib/services/markdown/HeatMarkdownService.ts:18-49](), [src/lib/services/markdown/PerformanceMarkdownService.ts:16-47](), [src/lib/services/markdown/ScheduleMarkdownService.ts:19-50](), [src/lib/services/markdown/PartialMarkdownService.ts:20-51](), [src/lib/services/markdown/RiskMarkdownService.ts:12-43]()"
                    },
                    {
                        "page_plan": {
                            "id": "11.3",
                            "title": "Logger Configuration"
                        },
                        "content": "# Logger Configuration\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/function/add.ts](src/function/add.ts)\n- [src/function/list.ts](src/function/list.ts)\n- [src/lib/core/provide.ts](src/lib/core/provide.ts)\n- [src/lib/core/types.ts](src/lib/core/types.ts)\n- [src/lib/index.ts](src/lib/index.ts)\n\n</details>\n\n\n\nThis page documents the logging system in Backtest Kit, covering the `ILogger` interface, the `setLogger` function, and how logging integrates with the framework's dependency injection system. For general configuration parameters, see [GLOBAL_CONFIG Parameters](#11.1).\n\n---\n\n## Purpose and Scope\n\nThe logger configuration system provides centralized, structured logging throughout Backtest Kit. It allows developers to:\n\n- Capture execution events from all framework components\n- Route log output to custom destinations (files, monitoring services, databases)\n- Filter logs by level (log, debug, info, warn)\n- Maintain consistent log formatting across the codebase\n\nThe logger is implemented as a singleton service (`LoggerService`) injected throughout the framework via the dependency injection container. All internal operations use this service, ensuring uniform logging behavior.\n\n---\n\n## The ILogger Interface\n\nThe `ILogger` interface defines four logging methods corresponding to standard log levels:\n\n```typescript\ninterface ILogger {\n  log: (...args: any[]) => void;\n  debug: (...args: any[]) => void;\n  info: (...args: any[]) => void;\n  warn: (...args: any[]) => void;\n}\n```\n\nEach method accepts variadic arguments, allowing flexible logging of primitives, objects, and error instances. The framework does not enforce a specific log format or structure—implementations can serialize arguments as needed.\n\n**Sources:** [README.md:47-55]()\n\n---\n\n## Setting Up Logging with setLogger\n\nThe `setLogger` function configures the global logger instance. It accepts an `ILogger` implementation and replaces the default logger (typically a no-op or console logger).\n\n### Basic Console Logging\n\n```typescript\nimport { setLogger } from 'backtest-kit';\n\nsetLogger({\n  log: console.log,\n  debug: console.debug,\n  info: console.info,\n  warn: console.warn,\n});\n```\n\nThis routes all framework logs to the console using native `console` methods.\n\n### Custom Logger Implementation\n\n```typescript\nimport fs from 'fs';\nimport { setLogger } from 'backtest-kit';\n\nconst logStream = fs.createWriteStream('./backtest.log', { flags: 'a' });\n\nsetLogger({\n  log: (...args) => logStream.write(`[LOG] ${JSON.stringify(args)}\\n`),\n  debug: (...args) => logStream.write(`[DEBUG] ${JSON.stringify(args)}\\n`),\n  info: (...args) => logStream.write(`[INFO] ${JSON.stringify(args)}\\n`),\n  warn: (...args) => logStream.write(`[WARN] ${JSON.stringify(args)}\\n`),\n});\n```\n\nThis example writes structured JSON logs to a file with log level prefixes.\n\n### Integration with Third-Party Loggers\n\n```typescript\nimport winston from 'winston';\nimport { setLogger } from 'backtest-kit';\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.json(),\n  transports: [\n    new winston.transports.File({ filename: 'error.log', level: 'warn' }),\n    new winston.transports.File({ filename: 'combined.log' }),\n  ],\n});\n\nsetLogger({\n  log: (...args) => logger.log('info', ...args),\n  debug: (...args) => logger.debug(...args),\n  info: (...args) => logger.info(...args),\n  warn: (...args) => logger.warn(...args),\n});\n```\n\nThis routes framework logs to Winston, enabling features like log rotation, remote transports, and structured metadata.\n\n**Sources:** [README.md:47-55]()\n\n---\n\n## LoggerService Architecture\n\n### Dependency Injection Integration\n\nThe logger is registered in the DI container as `LoggerService` and accessed via the `TYPES.loggerService` symbol. This ensures a single logger instance is shared across all services.\n\n#### Logger Service Registration Diagram\n\n```mermaid\ngraph TB\n    subgraph \"Dependency Injection Setup\"\n        TYPES[\"TYPES.loggerService<br/>(Symbol)\"]\n        PROVIDE[\"provide()<br/>src/lib/core/provide.ts:57\"]\n        LOGGER_SERVICE[\"new LoggerService()<br/>src/services/base/LoggerService\"]\n    end\n    \n    subgraph \"Service Access\"\n        INJECT[\"inject&lt;LoggerService&gt;<br/>src/lib/index.ts:62\"]\n        BACKTEST_OBJ[\"backtest.loggerService<br/>src/lib/index.ts:225-238\"]\n    end\n    \n    subgraph \"Consumer Services\"\n        ADD_STRATEGY[\"addStrategy()<br/>src/function/add.ts:52-64\"]\n        ADD_EXCHANGE[\"addExchange()<br/>src/function/add.ts:101-113\"]\n        LIST_EXCHANGES[\"listExchanges()<br/>src/function/list.ts:43-46\"]\n    end\n    \n    TYPES --> PROVIDE\n    PROVIDE --> LOGGER_SERVICE\n    LOGGER_SERVICE --> INJECT\n    INJECT --> BACKTEST_OBJ\n    BACKTEST_OBJ --> ADD_STRATEGY\n    BACKTEST_OBJ --> ADD_EXCHANGE\n    BACKTEST_OBJ --> LIST_EXCHANGES\n```\n\n**Sources:** [src/lib/core/types.ts:1-3](), [src/lib/core/provide.ts:56-58](), [src/lib/index.ts:1-4, 61-63, 225-238]()\n\n### Logger Service Injection Pattern\n\nAll services access the logger through the `backtest` object exported from `src/lib/index.ts`:\n\n```typescript\n// Inside any service or function\nbacktest.loggerService.info(METHOD_NAME, { ...context });\n```\n\nThis pattern ensures:\n- Single source of truth for logger configuration\n- Consistent access pattern across 11 service categories\n- Easy mocking in tests\n\n**Sources:** [src/lib/index.ts:61-63, 225-238]()\n\n---\n\n## Logging Usage Patterns\n\n### Method Name Constants\n\nThe framework defines string constants for each logged method, enabling log filtering and tracing:\n\n```typescript\nconst ADD_STRATEGY_METHOD_NAME = \"add.addStrategy\";\nconst ADD_EXCHANGE_METHOD_NAME = \"add.addExchange\";\nconst LIST_EXCHANGES_METHOD_NAME = \"list.listExchanges\";\n```\n\nThese constants follow a `namespace.methodName` pattern, grouping related operations.\n\n**Sources:** [src/function/add.ts:10-16](), [src/function/list.ts:10-16]()\n\n### Logging in Configuration Functions\n\n#### addStrategy Example\n\n```typescript\nexport function addStrategy(strategySchema: IStrategySchema) {\n  backtest.loggerService.info(ADD_STRATEGY_METHOD_NAME, {\n    strategySchema,\n  });\n  backtest.strategyValidationService.addStrategy(\n    strategySchema.strategyName,\n    strategySchema\n  );\n  backtest.strategySchemaService.register(\n    strategySchema.strategyName,\n    strategySchema\n  );\n}\n```\n\n**Log Output Structure:**\n- **Method Name:** `\"add.addStrategy\"`\n- **Level:** `info`\n- **Payload:** Full `strategySchema` object with `strategyName`, `interval`, `getSignal`, callbacks, etc.\n\n**Sources:** [src/function/add.ts:52-64]()\n\n#### addExchange Example\n\n```typescript\nexport function addExchange(exchangeSchema: IExchangeSchema) {\n  backtest.loggerService.info(ADD_EXCHANGE_METHOD_NAME, {\n    exchangeSchema,\n  });\n  backtest.exchangeValidationService.addExchange(\n    exchangeSchema.exchangeName,\n    exchangeSchema\n  );\n  backtest.exchangeSchemaService.register(\n    exchangeSchema.exchangeName,\n    exchangeSchema\n  );\n}\n```\n\n**Log Output Structure:**\n- **Method Name:** `\"add.addExchange\"`\n- **Level:** `info`\n- **Payload:** Full `exchangeSchema` object with `exchangeName`, `getCandles`, `formatPrice`, callbacks, etc.\n\n**Sources:** [src/function/add.ts:101-113]()\n\n### Logging in List Functions\n\n```typescript\nexport async function listExchanges(): Promise<IExchangeSchema[]> {\n  backtest.loggerService.log(LIST_EXCHANGES_METHOD_NAME);\n  return await backtest.exchangeValidationService.list();\n}\n```\n\n**Log Output Structure:**\n- **Method Name:** `\"list.listExchanges\"`\n- **Level:** `log`\n- **Payload:** None (informational only)\n\n**Sources:** [src/function/list.ts:43-46]()\n\n### Log Level Usage Patterns\n\n| Level | Usage | Examples |\n|-------|-------|----------|\n| `log` | General execution trace | `listExchanges()`, `listStrategies()` |\n| `debug` | Detailed internal state | (Not observed in provided code) |\n| `info` | Configuration changes | `addStrategy()`, `addExchange()`, `addFrame()` |\n| `warn` | Non-fatal issues | (Not observed in provided code) |\n\n**Sources:** [src/function/add.ts:52-444](), [src/function/list.ts:43-260]()\n\n---\n\n## Logging Flow Diagram\n\n### Execution Path from User Code to Logger Output\n\n```mermaid\nsequenceDiagram\n    participant USER as \"User Code\"\n    participant ADD_FUNC as \"addStrategy()<br/>src/function/add.ts:52\"\n    participant LOGGER_SVC as \"LoggerService<br/>via backtest.loggerService\"\n    participant IMPL as \"Custom ILogger<br/>Implementation\"\n    participant OUTPUT as \"Output Destination<br/>(console/file/service)\"\n    \n    USER->>ADD_FUNC: \"addStrategy({ strategyName: 'my-strategy', ... })\"\n    ADD_FUNC->>LOGGER_SVC: \"info('add.addStrategy', { strategySchema })\"\n    LOGGER_SVC->>IMPL: \"info(...args)\"\n    IMPL->>OUTPUT: \"Write log entry\"\n    ADD_FUNC->>ADD_FUNC: \"Validate and register strategy\"\n    ADD_FUNC-->>USER: \"Strategy registered\"\n```\n\n**Sources:** [src/function/add.ts:52-64](), [src/lib/index.ts:61-63]()\n\n---\n\n## Logged Method Names Reference\n\nThe following table lists all method name constants defined in the configuration and list functions:\n\n| Constant | Value | Function | Level | File |\n|----------|-------|----------|-------|------|\n| `ADD_STRATEGY_METHOD_NAME` | `\"add.addStrategy\"` | `addStrategy()` | info | [src/function/add.ts:10, 53]() |\n| `ADD_EXCHANGE_METHOD_NAME` | `\"add.addExchange\"` | `addExchange()` | info | [src/function/add.ts:11, 102]() |\n| `ADD_FRAME_METHOD_NAME` | `\"add.addFrame\"` | `addFrame()` | info | [src/function/add.ts:12, 146]() |\n| `ADD_WALKER_METHOD_NAME` | `\"add.addWalker\"` | `addWalker()` | info | [src/function/add.ts:13, 191]() |\n| `ADD_SIZING_METHOD_NAME` | `\"add.addSizing\"` | `addSizing()` | info | [src/function/add.ts:14, 257]() |\n| `ADD_RISK_METHOD_NAME` | `\"add.addRisk\"` | `addRisk()` | info | [src/function/add.ts:15, 332]() |\n| `ADD_OPTIMIZER_METHOD_NAME` | `\"add.addOptimizer\"` | `addOptimizer()` | info | [src/function/add.ts:16, 433]() |\n| `LIST_EXCHANGES_METHOD_NAME` | `\"list.listExchanges\"` | `listExchanges()` | log | [src/function/list.ts:10, 44]() |\n| `LIST_STRATEGIES_METHOD_NAME` | `\"list.listStrategies\"` | `listStrategies()` | log | [src/function/list.ts:11, 79]() |\n| `LIST_FRAMES_METHOD_NAME` | `\"list.listFrames\"` | `listFrames()` | log | [src/function/list.ts:12, 109]() |\n| `LIST_WALKERS_METHOD_NAME` | `\"list.listWalkers\"` | `listWalkers()` | log | [src/function/list.ts:13, 140]() |\n| `LIST_SIZINGS_METHOD_NAME` | `\"list.listSizings\"` | `listSizings()` | log | [src/function/list.ts:14, 180]() |\n| `LIST_RISKS_METHOD_NAME` | `\"list.listRisks\"` | `listRisks()` | log | [src/function/list.ts:15, 217]() |\n| `LIST_OPTIMIZERS_METHOD_NAME` | `\"list.listOptimizers\"` | `listOptimizers()` | log | [src/function/list.ts:16, 258]() |\n\n**Sources:** [src/function/add.ts:10-16](), [src/function/list.ts:10-16]()\n\n---\n\n## Custom Logger Implementation Examples\n\n### Silent Logger (Production)\n\n```typescript\nimport { setLogger } from 'backtest-kit';\n\nsetLogger({\n  log: () => {},\n  debug: () => {},\n  info: () => {},\n  warn: () => {},\n});\n```\n\nDisables all logging output. Useful for production environments where logging overhead is undesirable.\n\n### Conditional Logger (Debug Mode)\n\n```typescript\nimport { setLogger } from 'backtest-kit';\n\nconst DEBUG = process.env.DEBUG === 'true';\n\nsetLogger({\n  log: (...args) => DEBUG && console.log('[LOG]', ...args),\n  debug: (...args) => DEBUG && console.debug('[DEBUG]', ...args),\n  info: (...args) => console.info('[INFO]', ...args),\n  warn: (...args) => console.warn('[WARN]', ...args),\n});\n```\n\nOnly logs `debug` and `log` entries when `DEBUG=true` environment variable is set. Always logs `info` and `warn`.\n\n### Structured Logger with Timestamps\n\n```typescript\nimport { setLogger } from 'backtest-kit';\n\nconst timestamp = () => new Date().toISOString();\n\nsetLogger({\n  log: (...args) => console.log(`[${timestamp()}] [LOG]`, ...args),\n  debug: (...args) => console.debug(`[${timestamp()}] [DEBUG]`, ...args),\n  info: (...args) => console.info(`[${timestamp()}] [INFO]`, ...args),\n  warn: (...args) => console.warn(`[${timestamp()}] [WARN]`, ...args),\n});\n```\n\nPrepends ISO 8601 timestamps to all log entries.\n\n### Logger with Remote Monitoring\n\n```typescript\nimport { setLogger } from 'backtest-kit';\nimport axios from 'axios';\n\nconst sendToMonitoring = async (level: string, data: any) => {\n  try {\n    await axios.post('https://monitoring.example.com/logs', {\n      level,\n      timestamp: Date.now(),\n      data,\n    });\n  } catch (error) {\n    console.error('Failed to send log to monitoring:', error);\n  }\n};\n\nsetLogger({\n  log: (...args) => {\n    console.log(...args);\n    sendToMonitoring('log', args);\n  },\n  debug: (...args) => {\n    console.debug(...args);\n    sendToMonitoring('debug', args);\n  },\n  info: (...args) => {\n    console.info(...args);\n    sendToMonitoring('info', args);\n  },\n  warn: (...args) => {\n    console.warn(...args);\n    sendToMonitoring('warn', args);\n  },\n});\n```\n\nDual-writes logs to console and a remote monitoring service.\n\n**Sources:** [README.md:47-55]()\n\n---\n\n## Logger Service in Backtest Object\n\nThe `backtest` object exported from `src/lib/index.ts` aggregates all services, including `loggerService`:\n\n```typescript\nexport const backtest = {\n  ...baseServices,        // Contains loggerService\n  ...contextServices,\n  ...connectionServices,\n  ...schemaServices,\n  ...coreServices,\n  ...globalServices,\n  ...commandServices,\n  ...logicPrivateServices,\n  ...logicPublicServices,\n  ...markdownServices,\n  ...validationServices,\n  ...templateServices,\n};\n```\n\nThe `baseServices` object contains the injected `LoggerService` instance:\n\n```typescript\nconst baseServices = {\n  loggerService: inject<LoggerService>(TYPES.loggerService),\n};\n```\n\nThis makes the logger accessible to all internal services via `backtest.loggerService`.\n\n**Sources:** [src/lib/index.ts:61-63, 225-238]()\n\n---\n\n## Best Practices\n\n### When to Use Each Log Level\n\n| Level | Purpose | Examples |\n|-------|---------|----------|\n| `log` | Trace function calls | List operations, queries |\n| `debug` | Internal state inspection | Variable values, loop iterations |\n| `info` | State changes | Configuration registration, mode switches |\n| `warn` | Recoverable issues | Validation warnings, retries |\n\n### Logging Sensitive Data\n\nAvoid logging sensitive information in production:\n\n```typescript\n// Bad: Logs API keys\nbacktest.loggerService.info('exchange.connect', { apiKey, apiSecret });\n\n// Good: Logs non-sensitive metadata\nbacktest.loggerService.info('exchange.connect', { exchangeName, userId });\n```\n\n### Structured Logging\n\nPass objects rather than concatenating strings:\n\n```typescript\n// Bad: String concatenation\nbacktest.loggerService.info(`Adding strategy: ${strategyName}`);\n\n// Good: Structured object\nbacktest.loggerService.info(METHOD_NAME, { strategyName, interval });\n```\n\nStructured logs are easier to parse, filter, and index in log aggregation systems.\n\n### Performance Considerations\n\nLogger calls are synchronous and block execution. For high-frequency operations:\n\n1. Use conditional logging (only log in debug mode)\n2. Implement async loggers that queue writes\n3. Disable logging entirely in production\n\n**Sources:** [src/function/add.ts:52-444](), [src/function/list.ts:43-260]()\n\n---\n\n## Integration with Other Systems\n\n### Relationship to Context Services\n\nWhile the logger does not appear to directly integrate with `ExecutionContextService` or `MethodContextService` in the provided code, custom logger implementations can access these services to enrich logs with contextual metadata (symbol, timestamp, strategy name).\n\nFor more on context propagation, see [Execution Contexts](#3.3).\n\n### Relationship to Event System\n\nThe logger operates independently of the event system (`signalEmitter`, `errorEmitter`, etc.). Events are designed for **reactive** data flow, while logging is for **observability**. Custom loggers can subscribe to event emitters to log signal lifecycle events.\n\nFor more on events, see [Event System Architecture](#4.4).\n\n**Sources:** [src/lib/index.ts:66-72]()\n\n---\n\n## Summary\n\nThe logger configuration system in Backtest Kit provides:\n\n1. **Flexible Output:** Route logs to console, files, or remote services via `setLogger()`\n2. **Structured Logging:** Pass objects with context rather than concatenated strings\n3. **Dependency Injection:** Single logger instance shared across all services via `LoggerService`\n4. **Method Name Tracing:** Consistent `namespace.methodName` constants for filtering logs\n5. **Custom Implementations:** Support for third-party loggers (Winston, Bunyan, etc.)\n\nThe logger is foundational to debugging and monitoring Backtest Kit applications, enabling visibility into framework operations without modifying internal code."
                    },
                    {
                        "page_plan": {
                            "id": "12",
                            "title": "API Reference"
                        },
                        "content": "# API Reference\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [docs/classes/StrategyConnectionService.md](docs/classes/StrategyConnectionService.md)\n- [docs/index.md](docs/index.md)\n- [docs/interfaces/IStrategy.md](docs/interfaces/IStrategy.md)\n- [docs/interfaces/IStrategySchema.md](docs/interfaces/IStrategySchema.md)\n- [docs/types/IStrategyBacktestResult.md](docs/types/IStrategyBacktestResult.md)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis document provides a comprehensive reference to all public APIs exposed by Backtest Kit. It organizes functions, classes, interfaces, and types by functional area to help you navigate the framework's capabilities.\n\nFor detailed documentation on specific API categories, see:\n- **[Global Functions](#12.1)** - Configuration and registration functions (`addExchange`, `addStrategy`, etc.)\n- **[Execution Classes API](#12.2)** - Classes for running backtests, live trading, and strategy comparison\n- **[Reporting Classes API](#12.3)** - Classes for generating reports and accessing statistics\n- **[Core Interfaces](#12.4)** - Schema interfaces for defining strategies, exchanges, and other components\n- **[Signal & Result Types](#12.5)** - Types for trading signals and execution results\n- **[Statistics & Contract Types](#12.6)** - Types for performance metrics and event payloads\n- **[Service Layer Interfaces](#12.7)** - Internal service interfaces for advanced usage\n\n**Sources:** [src/index.ts:1-199](), [types.d.ts:1-1000](), [README.md:1-255]()\n\n---\n\n## API Organization\n\nThe Backtest Kit API is organized into three layers:\n\n| Layer | Purpose | Main Exports |\n|-------|---------|--------------|\n| **Configuration Layer** | System setup and component registration | `setConfig()`, `setLogger()`, `addExchange()`, `addStrategy()`, `addFrame()`, `addRisk()`, `addWalker()`, `addSizing()`, `addOptimizer()` |\n| **Execution Layer** | Running backtests and live trading | `Backtest`, `Live`, `Walker`, `Optimizer` classes with `run()` and `background()` methods |\n| **Monitoring Layer** | Event listeners and report generation | `listenSignal*()`, `listenDone*()`, `listenPartialProfit()`, `listenRisk()`, report classes (`Performance`, `Heat`, `Schedule`, `Partial`, `Risk`) |\n\n**Sources:** [src/index.ts:1-67](), [src/function/setup.ts:1-100](), [src/function/add.ts:1-200](), [src/function/event.ts:1-500]()\n\n---\n\n## Public API Surface\n\nThe following diagram maps the public API to the main functional areas:\n\n```mermaid\ngraph TB\n    subgraph \"Configuration API\"\n        SetupFns[\"Setup Functions<br/>setLogger, setConfig, setColumns\"]\n        AddFns[\"Registration Functions<br/>addExchange, addStrategy<br/>addFrame, addRisk, addWalker<br/>addSizing, addOptimizer\"]\n        ListFns[\"Query Functions<br/>listExchanges, listStrategies<br/>listFrames, listRisks, etc.\"]\n    end\n    \n    subgraph \"Execution API\"\n        BacktestClass[\"Backtest Class<br/>run(), background(), stop()<br/>getData(), getReport(), dump()\"]\n        LiveClass[\"Live Class<br/>run(), background(), stop()<br/>getData(), getReport(), dump()\"]\n        WalkerClass[\"Walker Class<br/>run(), background(), stop()<br/>getData(), getReport(), dump()\"]\n        OptimizerClass[\"Optimizer Class<br/>getData(), getCode(), dump()\"]\n    end\n    \n    subgraph \"Monitoring API\"\n        SignalListeners[\"Signal Listeners<br/>listenSignal, listenSignalBacktest<br/>listenSignalLive, listenSignalOnce\"]\n        DoneListeners[\"Completion Listeners<br/>listenDoneBacktest, listenDoneLive<br/>listenDoneWalker\"]\n        MetricListeners[\"Metric Listeners<br/>listenPartialProfit, listenPartialLoss<br/>listenRisk, listenPerformance\"]\n        ReportClasses[\"Report Classes<br/>Performance, Heat, Schedule<br/>Partial, Risk, Constant\"]\n    end\n    \n    subgraph \"Utility API\"\n        ExchangeFns[\"Exchange Utilities<br/>getCandles, getAveragePrice<br/>formatPrice, formatQuantity<br/>getDate, getMode\"]\n        DumpFns[\"Data Export<br/>dumpSignal\"]\n    end\n    \n    AddFns --> BacktestClass\n    AddFns --> LiveClass\n    AddFns --> WalkerClass\n    AddFns --> OptimizerClass\n    \n    BacktestClass --> SignalListeners\n    LiveClass --> SignalListeners\n    WalkerClass --> SignalListeners\n    \n    BacktestClass --> DoneListeners\n    LiveClass --> DoneListeners\n    WalkerClass --> DoneListeners\n    \n    BacktestClass --> ReportClasses\n    LiveClass --> ReportClasses\n    WalkerClass --> ReportClasses\n    \n    BacktestClass --> MetricListeners\n    LiveClass --> MetricListeners\n    \n    SetupFns -.->|configures| BacktestClass\n    SetupFns -.->|configures| LiveClass\n    \n    ExchangeFns -.->|used in| AddFns\n    \n    style BacktestClass fill:#f9f9f9\n    style LiveClass fill:#f9f9f9\n    style WalkerClass fill:#f9f9f9\n    style OptimizerClass fill:#f9f9f9\n```\n\n**Sources:** [src/index.ts:1-199](), [src/classes/Backtest.ts:1-100](), [src/classes/Live.ts:1-100](), [src/classes/Walker.ts:1-100]()\n\n---\n\n## Type Hierarchy\n\nThe following diagram shows how core types relate to each other:\n\n```mermaid\ngraph TB\n    subgraph \"Schema Types (Configuration)\"\n        IExchangeSchema[\"IExchangeSchema<br/>exchangeName: ExchangeName<br/>getCandles()<br/>formatPrice(), formatQuantity()\"]\n        IStrategySchema[\"IStrategySchema<br/>strategyName: StrategyName<br/>interval: SignalInterval<br/>getSignal()<br/>riskName?, riskList?\"]\n        IFrameSchema[\"IFrameSchema<br/>frameName: FrameName<br/>interval: FrameInterval<br/>startDate, endDate\"]\n        IRiskSchema[\"IRiskSchema<br/>riskName: RiskName<br/>validations: IRiskValidationFn[]\"]\n        ISizingSchema[\"ISizingSchema<br/>sizingName: SizingName<br/>calculate()\"]\n        IWalkerSchema[\"IWalkerSchema<br/>walkerName: WalkerName<br/>strategies: StrategyName[]<br/>metric: WalkerMetric\"]\n    end\n    \n    subgraph \"Signal Types (Runtime)\"\n        ISignalDto[\"ISignalDto<br/>position: 'long' | 'short'<br/>priceOpen?, priceTakeProfit<br/>priceStopLoss, minuteEstimatedTime\"]\n        ISignalRow[\"ISignalRow extends ISignalDto<br/>id: string (UUID)<br/>strategyName, exchangeName<br/>scheduledAt, pendingAt, symbol\"]\n        IScheduledSignalRow[\"IScheduledSignalRow<br/>extends ISignalRow<br/>priceOpen: number (required)\"]\n    end\n    \n    subgraph \"Result Types (Discriminated Union)\"\n        IStrategyTickResult[\"IStrategyTickResult (union)\"]\n        ResultIdle[\"IStrategyTickResultIdle<br/>action: 'idle'<br/>signal: null\"]\n        ResultScheduled[\"IStrategyTickResultScheduled<br/>action: 'scheduled'<br/>signal: IScheduledSignalRow\"]\n        ResultOpened[\"IStrategyTickResultOpened<br/>action: 'opened'<br/>signal: ISignalRow\"]\n        ResultActive[\"IStrategyTickResultActive<br/>action: 'active'<br/>signal: ISignalRow<br/>percentTp, percentSl\"]\n        ResultClosed[\"IStrategyTickResultClosed<br/>action: 'closed'<br/>signal: ISignalRow<br/>closeReason, pnl: IStrategyPnL\"]\n        ResultCancelled[\"IStrategyTickResultCancelled<br/>action: 'cancelled'<br/>signal: IScheduledSignalRow\"]\n    end\n    \n    subgraph \"Statistics Types\"\n        BacktestStats[\"BacktestStatisticsModel<br/>signalList, totalSignals<br/>winRate, avgPnl, sharpeRatio\"]\n        LiveStats[\"LiveStatisticsModel<br/>extends BacktestStatisticsModel<br/>activeSignals, idleCount\"]\n        WalkerStats[\"WalkerStatisticsModel<br/>strategies: IWalkerStrategyResult[]<br/>bestStrategy, metric\"]\n    end\n    \n    IStrategySchema -->|generates| ISignalDto\n    ISignalDto -->|validated to| ISignalRow\n    ISignalRow -->|if priceOpen specified| IScheduledSignalRow\n    \n    IStrategyTickResult -->|discriminated union| ResultIdle\n    IStrategyTickResult -->|discriminated union| ResultScheduled\n    IStrategyTickResult -->|discriminated union| ResultOpened\n    IStrategyTickResult -->|discriminated union| ResultActive\n    IStrategyTickResult -->|discriminated union| ResultClosed\n    IStrategyTickResult -->|discriminated union| ResultCancelled\n    \n    ResultScheduled -->|contains| IScheduledSignalRow\n    ResultOpened -->|contains| ISignalRow\n    ResultActive -->|contains| ISignalRow\n    ResultClosed -->|contains| ISignalRow\n    ResultCancelled -->|contains| IScheduledSignalRow\n    \n    ResultClosed -->|aggregated to| BacktestStats\n    BacktestStats -->|extended by| LiveStats\n    BacktestStats -->|used in| WalkerStats\n    \n    style ISignalRow fill:#f9f9f9\n    style IStrategyTickResult fill:#f9f9f9\n    style BacktestStats fill:#f9f9f9\n```\n\n**Sources:** [types.d.ts:80-896](), [src/interfaces/Strategy.interface.ts:1-300](), [src/model/BacktestStatistics.model.ts:1-100]()\n\n---\n\n## API Entry Points by Category\n\n### Configuration & Setup\n\n| Function | Purpose | Returns |\n|----------|---------|---------|\n| `setLogger(logger: ILogger)` | Configure custom logger implementation | `void` |\n| `setConfig(config: Partial<GlobalConfig>)` | Set global configuration parameters | `void` |\n| `getConfig()` | Retrieve current global configuration | `GlobalConfig` |\n| `setColumns(columns: Partial<ColumnConfig>)` | Customize report column visibility | `void` |\n| `getColumns()` | Retrieve current column configuration | `ColumnConfig` |\n\n**Sources:** [src/function/setup.ts:1-200](), [src/config/params.ts:1-100](), [src/config/columns.ts:1-100]()\n\n### Component Registration\n\n| Function | Schema Type | Purpose |\n|----------|-------------|---------|\n| `addExchange(schema: IExchangeSchema)` | `IExchangeSchema` | Register data source for candles and pricing |\n| `addStrategy(schema: IStrategySchema)` | `IStrategySchema` | Register trading strategy with signal generation logic |\n| `addFrame(schema: IFrameSchema)` | `IFrameSchema` | Register timeframe for backtest period definition |\n| `addRisk(schema: IRiskSchema)` | `IRiskSchema` | Register risk management validation rules |\n| `addWalker(schema: IWalkerSchema)` | `IWalkerSchema` | Register strategy comparison configuration |\n| `addSizing(schema: ISizingSchema)` | `ISizingSchema` | Register position sizing calculator |\n| `addOptimizer(schema: IOptimizerSchema)` | `IOptimizerSchema` | Register LLM-powered strategy generator |\n\n**Sources:** [src/function/add.ts:1-200](), [types.d.ts:120-970]()\n\n### Execution Classes\n\n| Class | Methods | Purpose |\n|-------|---------|---------|\n| `Backtest` | `run()`, `background()`, `stop()`, `getData()`, `getReport()`, `dump()` | Historical simulation on defined timeframe |\n| `Live` | `run()`, `background()`, `stop()`, `getData()`, `getReport()`, `dump()` | Real-time trading with crash recovery |\n| `Walker` | `run()`, `background()`, `stop()`, `getData()`, `getReport()`, `dump()` | Multi-strategy comparison and ranking |\n| `Optimizer` | `getData()`, `getCode()`, `dump()` | LLM-powered strategy generation |\n\n**Sources:** [src/classes/Backtest.ts:1-200](), [src/classes/Live.ts:1-200](), [src/classes/Walker.ts:1-200](), [src/classes/Optimizer.ts:1-200]()\n\n### Event Listeners\n\n| Function | Event Type | Purpose |\n|----------|------------|---------|\n| `listenSignal(fn)` | `IStrategyTickResult` | All signals (backtest + live) |\n| `listenSignalBacktest(fn)` | `IStrategyTickResult` | Backtest signals only |\n| `listenSignalLive(fn)` | `IStrategyTickResult` | Live trading signals only |\n| `listenSignalOnce(filter, fn)` | `IStrategyTickResult` | Single filtered event |\n| `listenDoneBacktest(fn)` | `DoneContract` | Backtest completion |\n| `listenDoneLive(fn)` | `DoneContract` | Live trading completion |\n| `listenDoneWalker(fn)` | `DoneContract` | Walker comparison completion |\n| `listenBacktestProgress(fn)` | `ProgressBacktestContract` | Backtest progress percentage |\n| `listenWalkerProgress(fn)` | `ProgressWalkerContract` | Walker strategy iteration progress |\n| `listenPartialProfit(fn)` | `PartialProfitContract` | Profit milestone reached (10%, 20%, etc.) |\n| `listenPartialLoss(fn)` | `PartialLossContract` | Loss milestone reached (-10%, -20%, etc.) |\n| `listenRisk(fn)` | `RiskContract` | Signal rejected by risk validation |\n| `listenPerformance(fn)` | `PerformanceContract` | Execution timing metrics |\n| `listenError(fn)` | `Error` | Recoverable errors |\n| `listenExit(fn)` | `Error` | Fatal errors |\n\n**Sources:** [src/function/event.ts:1-500](), [src/config/emitters.ts:1-133]()\n\n---\n\n## Event System Architecture\n\nThe following diagram shows how events flow through the system:\n\n```mermaid\ngraph LR\n    subgraph \"Event Producers\"\n        ClientStrategy[\"ClientStrategy.tick()<br/>ClientStrategy.backtest()\"]\n        BacktestLogic[\"BacktestLogicPrivateService\"]\n        LiveLogic[\"LiveLogicPrivateService\"]\n        WalkerLogic[\"WalkerLogicPrivateService\"]\n    end\n    \n    subgraph \"Event Emitters (Subject)\"\n        signalEmitter[\"signalEmitter<br/>All signals\"]\n        signalBacktestEmitter[\"signalBacktestEmitter<br/>Backtest only\"]\n        signalLiveEmitter[\"signalLiveEmitter<br/>Live only\"]\n        doneBacktestSubject[\"doneBacktestSubject\"]\n        doneLiveSubject[\"doneLiveSubject\"]\n        doneWalkerSubject[\"doneWalkerSubject\"]\n        progressBacktestEmitter[\"progressBacktestEmitter\"]\n        progressWalkerEmitter[\"progressWalkerEmitter\"]\n        partialProfitSubject[\"partialProfitSubject\"]\n        partialLossSubject[\"partialLossSubject\"]\n        riskSubject[\"riskSubject\"]\n        performanceEmitter[\"performanceEmitter\"]\n    end\n    \n    subgraph \"Public Listeners\"\n        listenSignal[\"listenSignal()\"]\n        listenSignalBacktest[\"listenSignalBacktest()\"]\n        listenSignalLive[\"listenSignalLive()\"]\n        listenDoneBacktest[\"listenDoneBacktest()\"]\n        listenDoneLive[\"listenDoneLive()\"]\n        listenDoneWalker[\"listenDoneWalker()\"]\n        listenBacktestProgress[\"listenBacktestProgress()\"]\n        listenWalkerProgress[\"listenWalkerProgress()\"]\n        listenPartialProfit[\"listenPartialProfit()\"]\n        listenPartialLoss[\"listenPartialLoss()\"]\n        listenRisk[\"listenRisk()\"]\n        listenPerformance[\"listenPerformance()\"]\n    end\n    \n    subgraph \"Markdown Services (Subscribers)\"\n        BacktestMarkdownService[\"BacktestMarkdownService<br/>Aggregates closed signals\"]\n        LiveMarkdownService[\"LiveMarkdownService<br/>Tracks active + closed\"]\n        WalkerMarkdownService[\"WalkerMarkdownService<br/>Compares strategies\"]\n        PartialMarkdownService[\"PartialMarkdownService<br/>Profit/loss milestones\"]\n        RiskMarkdownService[\"RiskMarkdownService<br/>Rejection tracking\"]\n        PerformanceMarkdownService[\"PerformanceMarkdownService<br/>Timing metrics\"]\n    end\n    \n    ClientStrategy --> signalEmitter\n    ClientStrategy --> signalBacktestEmitter\n    ClientStrategy --> signalLiveEmitter\n    ClientStrategy --> partialProfitSubject\n    ClientStrategy --> partialLossSubject\n    ClientStrategy --> riskSubject\n    \n    BacktestLogic --> progressBacktestEmitter\n    BacktestLogic --> doneBacktestSubject\n    BacktestLogic --> performanceEmitter\n    \n    LiveLogic --> doneLiveSubject\n    LiveLogic --> performanceEmitter\n    \n    WalkerLogic --> progressWalkerEmitter\n    WalkerLogic --> doneWalkerSubject\n    \n    signalEmitter --> listenSignal\n    signalBacktestEmitter --> listenSignalBacktest\n    signalLiveEmitter --> listenSignalLive\n    doneBacktestSubject --> listenDoneBacktest\n    doneLiveSubject --> listenDoneLive\n    doneWalkerSubject --> listenDoneWalker\n    progressBacktestEmitter --> listenBacktestProgress\n    progressWalkerEmitter --> listenWalkerProgress\n    partialProfitSubject --> listenPartialProfit\n    partialLossSubject --> listenPartialLoss\n    riskSubject --> listenRisk\n    performanceEmitter --> listenPerformance\n    \n    signalBacktestEmitter --> BacktestMarkdownService\n    signalLiveEmitter --> LiveMarkdownService\n    progressWalkerEmitter --> WalkerMarkdownService\n    partialProfitSubject --> PartialMarkdownService\n    partialLossSubject --> PartialMarkdownService\n    riskSubject --> RiskMarkdownService\n    performanceEmitter --> PerformanceMarkdownService\n    \n    style signalEmitter fill:#f9f9f9\n    style BacktestMarkdownService fill:#f9f9f9\n```\n\n**Sources:** [src/config/emitters.ts:1-133](), [src/function/event.ts:1-500](), [src/lib/services/markdown/BacktestMarkdownService.ts:1-100]()\n\n---\n\n## Core Interface Relationships\n\nThe following diagram shows how schema interfaces relate to their runtime implementations:\n\n```mermaid\ngraph TB\n    subgraph \"Schema Interfaces (User-Defined)\"\n        IExchangeSchema2[\"IExchangeSchema<br/>getCandles(symbol, interval, since, limit)<br/>formatPrice(symbol, price)<br/>formatQuantity(symbol, quantity)\"]\n        IStrategySchema2[\"IStrategySchema<br/>getSignal(symbol, when)<br/>interval: SignalInterval<br/>riskName?, riskList?<br/>callbacks?\"]\n        IFrameSchema2[\"IFrameSchema<br/>interval: FrameInterval<br/>startDate, endDate<br/>callbacks?\"]\n        IRiskSchema2[\"IRiskSchema<br/>validations: IRiskValidationFn[]<br/>callbacks?\"]\n    end\n    \n    subgraph \"Internal Implementations\"\n        ClientExchange[\"ClientExchange<br/>implements IExchange<br/>getCandles(), getNextCandles()<br/>getAveragePrice() - VWAP\"]\n        ClientStrategy[\"ClientStrategy<br/>implements IStrategy<br/>tick(), backtest()<br/>getPendingSignal()\"]\n        ClientFrame[\"ClientFrame<br/>implements IFrame<br/>getTimeframe()\"]\n        ClientRisk[\"ClientRisk<br/>implements IRisk<br/>checkSignal()<br/>addSignal(), removeSignal()\"]\n    end\n    \n    subgraph \"Connection Services (Memoization)\"\n        ExchangeConnectionService2[\"ExchangeConnectionService<br/>getExchange(symbol, exchangeName)<br/>Memoizes ClientExchange instances\"]\n        StrategyConnectionService2[\"StrategyConnectionService<br/>getStrategy(symbol, strategyName)<br/>Memoizes ClientStrategy instances\"]\n        FrameConnectionService2[\"FrameConnectionService<br/>getFrame(frameName)<br/>Memoizes ClientFrame instances\"]\n        RiskConnectionService2[\"RiskConnectionService<br/>getRisk(symbol, riskName)<br/>Memoizes ClientRisk instances\"]\n    end\n    \n    subgraph \"Schema Services (Registry)\"\n        ExchangeSchemaService2[\"ExchangeSchemaService<br/>Stores IExchangeSchema by name\"]\n        StrategySchemaService2[\"StrategySchemaService<br/>Stores IStrategySchema by name\"]\n        FrameSchemaService2[\"FrameSchemaService<br/>Stores IFrameSchema by name\"]\n        RiskSchemaService2[\"RiskSchemaService<br/>Stores IRiskSchema by name\"]\n    end\n    \n    IExchangeSchema2 -->|registered to| ExchangeSchemaService2\n    IStrategySchema2 -->|registered to| StrategySchemaService2\n    IFrameSchema2 -->|registered to| FrameSchemaService2\n    IRiskSchema2 -->|registered to| RiskSchemaService2\n    \n    ExchangeSchemaService2 -->|passed to| ClientExchange\n    StrategySchemaService2 -->|passed to| ClientStrategy\n    FrameSchemaService2 -->|passed to| ClientFrame\n    RiskSchemaService2 -->|passed to| ClientRisk\n    \n    ClientExchange -->|cached by| ExchangeConnectionService2\n    ClientStrategy -->|cached by| StrategyConnectionService2\n    ClientFrame -->|cached by| FrameConnectionService2\n    ClientRisk -->|cached by| RiskConnectionService2\n    \n    style ClientStrategy fill:#f9f9f9\n    style StrategyConnectionService2 fill:#f9f9f9\n```\n\n**Sources:** [src/lib/services/connection/StrategyConnectionService.ts:1-200](), [src/lib/services/schema/StrategySchemaService.ts:1-100](), [src/lib/client/ClientStrategy.ts:1-500]()\n\n---\n\n## Method Signatures Summary\n\n### Backtest Class\n\n```typescript\nclass Backtest {\n  // Async iterator (pull-based)\n  static run(\n    symbol: string,\n    params: {\n      strategyName: StrategyName;\n      exchangeName: ExchangeName;\n      frameName: FrameName;\n    }\n  ): AsyncGenerator<IStrategyTickResult | ProgressBacktestContract>;\n\n  // Background execution (push-based)\n  static background(\n    symbol: string,\n    params: {\n      strategyName: StrategyName;\n      exchangeName: ExchangeName;\n      frameName: FrameName;\n    }\n  ): void;\n\n  // Stop backtest (if not yet complete)\n  static stop(symbol: string, strategyName: StrategyName): Promise<void>;\n\n  // Get statistics model\n  static getData(\n    symbol: string,\n    strategyName: StrategyName\n  ): Promise<BacktestStatisticsModel>;\n\n  // Get formatted markdown report\n  static getReport(\n    symbol: string,\n    strategyName: StrategyName\n  ): Promise<string>;\n\n  // Write report to file system\n  static dump(symbol: string, strategyName: StrategyName): Promise<void>;\n}\n```\n\n**Sources:** [src/classes/Backtest.ts:1-200](), [types.d.ts:1100-1200]()\n\n### Live Class\n\n```typescript\nclass Live {\n  // Async iterator (infinite, until stopped)\n  static run(\n    symbol: string,\n    params: {\n      strategyName: StrategyName;\n      exchangeName: ExchangeName;\n    }\n  ): AsyncGenerator<IStrategyTickResult>;\n\n  // Background execution (infinite loop)\n  static background(\n    symbol: string,\n    params: {\n      strategyName: StrategyName;\n      exchangeName: ExchangeName;\n    }\n  ): void;\n\n  // Stop live trading gracefully\n  static stop(symbol: string, strategyName: StrategyName): Promise<void>;\n\n  // Get statistics model (includes active signals)\n  static getData(\n    symbol: string,\n    strategyName: StrategyName\n  ): Promise<LiveStatisticsModel>;\n\n  // Get formatted markdown report\n  static getReport(\n    symbol: string,\n    strategyName: StrategyName\n  ): Promise<string>;\n\n  // Write report to file system\n  static dump(symbol: string, strategyName: StrategyName): Promise<void>;\n}\n```\n\n**Sources:** [src/classes/Live.ts:1-200](), [types.d.ts:1200-1300]()\n\n### Walker Class\n\n```typescript\nclass Walker {\n  // Async iterator (yields progress per strategy)\n  static run(\n    symbol: string,\n    params: {\n      walkerName: WalkerName;\n    }\n  ): AsyncGenerator<WalkerContract | ProgressWalkerContract>;\n\n  // Background execution\n  static background(\n    symbol: string,\n    params: {\n      walkerName: WalkerName;\n    }\n  ): void;\n\n  // Stop walker comparison\n  static stop(symbol: string, walkerName: WalkerName): Promise<void>;\n\n  // Get comparison results\n  static getData(\n    symbol: string,\n    walkerName: WalkerName\n  ): Promise<WalkerStatisticsModel>;\n\n  // Get formatted markdown report\n  static getReport(symbol: string, walkerName: WalkerName): Promise<string>;\n\n  // Write report to file system\n  static dump(symbol: string, walkerName: WalkerName): Promise<void>;\n}\n```\n\n**Sources:** [src/classes/Walker.ts:1-200](), [types.d.ts:1300-1400]()\n\n---\n\n## Discriminated Union Pattern for Results\n\nAll strategy execution methods return `IStrategyTickResult`, a discriminated union with `action` as the discriminator:\n\n```typescript\ntype IStrategyTickResult =\n  | IStrategyTickResultIdle        // action: \"idle\"\n  | IStrategyTickResultScheduled   // action: \"scheduled\"\n  | IStrategyTickResultOpened      // action: \"opened\"\n  | IStrategyTickResultActive      // action: \"active\"\n  | IStrategyTickResultClosed      // action: \"closed\"\n  | IStrategyTickResultCancelled;  // action: \"cancelled\"\n```\n\n### Type Guards Example\n\n```typescript\nlistenSignal((event) => {\n  if (event.action === \"closed\") {\n    // TypeScript knows: event is IStrategyTickResultClosed\n    console.log(event.pnl.pnlPercentage);\n    console.log(event.closeReason); // \"take_profit\" | \"stop_loss\" | \"time_expired\"\n  } else if (event.action === \"active\") {\n    // TypeScript knows: event is IStrategyTickResultActive\n    console.log(event.percentTp); // Progress towards TP\n    console.log(event.percentSl); // Progress towards SL\n  } else if (event.action === \"scheduled\") {\n    // TypeScript knows: event is IStrategyTickResultScheduled\n    console.log(event.signal.priceOpen); // Entry price waiting for activation\n  }\n});\n```\n\n**Sources:** [types.d.ts:768-893](), [src/interfaces/Strategy.interface.ts:1-300]()\n\n---\n\n## Statistics Models\n\nEach execution mode provides a statistics model with performance metrics:\n\n### BacktestStatisticsModel\n\n```typescript\ninterface BacktestStatisticsModel {\n  signalList: IStrategyTickResultClosed[];  // All closed signals\n  totalSignals: number;\n  winCount: number;\n  lossCount: number;\n  winRate: number | null;              // Percentage (0-100)\n  avgPnl: number | null;               // Average PNL per signal\n  totalPnl: number | null;             // Cumulative PNL\n  stdDev: number | null;               // Standard deviation of returns\n  sharpeRatio: number | null;          // avgPnl / stdDev\n  annualizedSharpeRatio: number | null; // sharpeRatio × √365\n  certaintyRatio: number | null;        // avgWin / |avgLoss|\n  expectedYearlyReturns: number | null; // Extrapolated annual returns\n}\n```\n\n**Sources:** [types.d.ts:918-943](), [src/model/BacktestStatistics.model.ts:1-100]()\n\n### LiveStatisticsModel\n\nExtends `BacktestStatisticsModel` with additional fields:\n\n```typescript\ninterface LiveStatisticsModel extends BacktestStatisticsModel {\n  activeSignals: ISignalRow[];        // Currently open positions\n  idleCount: number;                  // Number of idle ticks\n}\n```\n\n**Sources:** [types.d.ts:1400-1500](), [src/model/LiveStatistics.model.ts:1-100]()\n\n### WalkerStatisticsModel\n\n```typescript\ninterface WalkerStatisticsModel {\n  strategies: IWalkerStrategyResult[];  // Results for each tested strategy\n  bestStrategy: StrategyName;           // Highest metric value\n  metric: WalkerMetric;                 // Comparison metric used\n}\n\ninterface IWalkerStrategyResult {\n  strategyName: StrategyName;\n  statistics: BacktestStatisticsModel;\n  metricValue: number | null;           // Value of comparison metric\n}\n```\n\n**Sources:** [types.d.ts:1180-1250](), [src/model/WalkerStatistics.model.ts:1-100]()\n\n---\n\n## Context Services\n\nBacktest Kit uses `di-scoped` for ambient context propagation. Two context services provide implicit parameters:\n\n### ExecutionContextService\n\nPropagates runtime execution state:\n\n```typescript\ninterface IExecutionContext {\n  symbol: string;        // Trading pair (e.g., \"BTCUSDT\")\n  when: Date;           // Current timestamp\n  backtest: boolean;    // true = backtest, false = live\n}\n```\n\nFunctions like `getCandles()` automatically access this context without explicit parameters.\n\n**Sources:** [types.d.ts:6-49](), [src/lib/services/context/ExecutionContextService.ts:1-100]()\n\n### MethodContextService\n\nPropagates schema identifiers:\n\n```typescript\ninterface IMethodContext {\n  exchangeName: ExchangeName;\n  strategyName: StrategyName;\n  frameName: FrameName;\n}\n```\n\nConnection services use this to route operations to correct schema instances.\n\n**Sources:** [types.d.ts:297-336](), [src/lib/services/context/MethodContextService.ts:1-100]()\n\n---\n\n## Persistence Adapters\n\nBacktest Kit provides crash-safe persistence through abstract base class `PersistBase`:\n\n```typescript\nabstract class PersistBase<T> {\n  abstract waitForInit(entityId: EntityId): Promise<void>;\n  abstract persist(entityId: EntityId, data: T | null): Promise<void>;\n  abstract load(entityId: EntityId): Promise<T | null>;\n}\n```\n\n### Concrete Implementations\n\n| Adapter | Purpose | Storage Format |\n|---------|---------|----------------|\n| `PersistSignalAdapter` | Active signals | `Record<signalId, SignalData>` |\n| `PersistRiskAdapter` | Risk tracking state | `Record<riskKey, RiskData>` |\n| `PersistScheduleAdapter` | Scheduled signals | `Record<signalId, ScheduleData>` |\n| `PersistPartialAdapter` | Profit/loss milestones | `Record<signalId, PartialData>` |\n\nAll adapters use atomic file writes to `./persist/{entityId}.json` by default.\n\n**Sources:** [src/classes/Persist.ts:1-500](), [types.d.ts:1600-1800]()\n\n---\n\n## Custom Implementations\n\n### Custom Logger\n\nImplement `ILogger` interface:\n\n```typescript\nimport { setLogger, ILogger } from 'backtest-kit';\n\nconst myLogger: ILogger = {\n  log: (topic, ...args) => console.log(`[LOG] ${topic}`, ...args),\n  debug: (topic, ...args) => console.debug(`[DEBUG] ${topic}`, ...args),\n  info: (topic, ...args) => console.info(`[INFO] ${topic}`, ...args),\n  warn: (topic, ...args) => console.warn(`[WARN] ${topic}`, ...args),\n};\n\nsetLogger(myLogger);\n```\n\n**Sources:** [types.d.ts:52-77](), [src/function/setup.ts:1-50]()\n\n### Custom Persistence\n\nExtend `PersistBase` for custom storage backends:\n\n```typescript\nimport { PersistBase, EntityId } from 'backtest-kit';\n\nclass RedisPersistAdapter<T> extends PersistBase<T> {\n  async waitForInit(entityId: EntityId): Promise<void> {\n    // Connect to Redis\n  }\n\n  async persist(entityId: EntityId, data: T | null): Promise<void> {\n    // Write to Redis\n  }\n\n  async load(entityId: EntityId): Promise<T | null> {\n    // Read from Redis\n  }\n}\n```\n\n**Sources:** [src/classes/Persist.ts:1-200](), [types.d.ts:1600-1700]()\n\n---\n\n## Global Configuration\n\nConfigure framework defaults via `setConfig()`:\n\n```typescript\nimport { setConfig, GlobalConfig } from 'backtest-kit';\n\nsetConfig({\n  // Trading fees and slippage\n  CC_PERCENT_FEE: 0.1,              // 0.1% per trade\n  CC_PERCENT_SLIPPAGE: 0.1,         // 0.1% price impact\n\n  // Signal validation\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.3,  // TP must cover 2×fees + slippage\n  CC_MAX_STOPLOSS_DISTANCE_PERCENT: 10.0,   // SL max 10% away\n  CC_MAX_SIGNAL_LIFETIME_MINUTES: 1440,     // 24 hours max\n\n  // VWAP calculation\n  CC_AVG_PRICE_CANDLES_COUNT: 5,    // Last 5 1-minute candles\n\n  // Scheduled signal timeout\n  CC_SCHEDULE_AWAIT_MINUTES: 120,   // 2 hours to activate\n\n  // Candle data validation\n  CC_DETECT_ANOMALY_PERCENT: 10.0,  // 10% price jump = anomaly\n  CC_CHECK_LAST_N_MEDIAN_ANOMALIES: 5, // Check last 5 candles\n\n  // Retry logic\n  CC_GET_CANDLES_RETRY_COUNT: 3,\n  CC_GET_CANDLES_RETRY_DELAY_MS: 1000,\n\n  // Live trading\n  CC_TICK_TTL_MS: 60_001,           // 1 minute + 1ms sleep\n});\n```\n\n**Sources:** [src/config/params.ts:1-200](), [types.d.ts:2000-2100]()\n\n---\n\n## Report Column Configuration\n\nCustomize markdown report columns:\n\n```typescript\nimport { setColumns, ColumnConfig } from 'backtest-kit';\n\nsetColumns({\n  backtest: {\n    id: true,\n    strategyName: true,\n    symbol: true,\n    position: true,\n    priceOpen: true,\n    priceTakeProfit: true,\n    priceStopLoss: true,\n    priceClose: true,\n    closeReason: true,\n    pnlPercentage: true,\n    scheduledAt: false,      // Hide scheduled timestamp\n    pendingAt: false,        // Hide pending timestamp\n    closeTimestamp: true,\n    minuteEstimatedTime: true,\n  },\n  // Similar configuration for live, walker, schedule, performance, etc.\n});\n```\n\n**Sources:** [src/config/columns.ts:1-300](), [types.d.ts:2100-2200]()\n\n---\n\n## Advanced: Service Layer Access\n\nFor advanced use cases, the internal service layer is exposed via `lib` export:\n\n```typescript\nimport { lib } from 'backtest-kit';\n\n// Access service instances\nlib.loggerService;\nlib.strategyConnectionService;\nlib.exchangeConnectionService;\nlib.strategyCoreService;\nlib.backtestLogicPrivateService;\n// ... etc.\n```\n\nSee **[Service Layer Interfaces](#12.7)** for detailed service documentation.\n\n**Sources:** [src/lib/index.ts:1-500](), [types.d.ts:2200-2500]()"
                    },
                    {
                        "page_plan": {
                            "id": "12.1",
                            "title": "Global Functions"
                        },
                        "content": "# Global Functions\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [README.md](README.md)\n- [demo/backtest/package-lock.json](demo/backtest/package-lock.json)\n- [demo/backtest/package.json](demo/backtest/package.json)\n- [demo/live/package-lock.json](demo/live/package-lock.json)\n- [demo/live/package.json](demo/live/package.json)\n- [demo/optimization/package-lock.json](demo/optimization/package-lock.json)\n- [demo/optimization/package.json](demo/optimization/package.json)\n- [docs/classes/StrategyConnectionService.md](docs/classes/StrategyConnectionService.md)\n- [docs/index.md](docs/index.md)\n- [docs/interfaces/IStrategy.md](docs/interfaces/IStrategy.md)\n- [docs/interfaces/IStrategySchema.md](docs/interfaces/IStrategySchema.md)\n- [docs/types/IStrategyBacktestResult.md](docs/types/IStrategyBacktestResult.md)\n- [package-lock.json](package-lock.json)\n- [package.json](package.json)\n- [src/function/add.ts](src/function/add.ts)\n- [src/function/list.ts](src/function/list.ts)\n- [src/lib/core/provide.ts](src/lib/core/provide.ts)\n- [src/lib/core/types.ts](src/lib/core/types.ts)\n- [src/lib/index.ts](src/lib/index.ts)\n\n</details>\n\n\n\nGlobal functions are the primary user-facing API for configuring and interacting with Backtest Kit. These functions provide a declarative interface for registering components, configuring system behavior, subscribing to events, and accessing framework utilities. All global functions are exported from the main package entry point and operate on the singleton service layer.\n\nFor information about class-based execution APIs (Backtest, Live, Walker, Optimizer), see [Execution Classes API](#12.2). For data structure definitions used in function parameters and return values, see [Core Interfaces](#12.4) and [Signal & Result Types](#12.5).\n\n---\n\n## Function Categories\n\nGlobal functions are organized into six functional categories:\n\n| Category | Functions | Purpose |\n|----------|-----------|---------|\n| **Configuration** | `setLogger`, `setConfig`, `getConfig`, `getDefaultConfig`, `setColumns`, `getColumns`, `getDefaultColumns` | System-wide settings and logging |\n| **Registration** | `addExchange`, `addStrategy`, `addFrame`, `addRisk`, `addWalker`, `addSizing`, `addOptimizer` | Register trading components |\n| **Query** | `listExchanges`, `listStrategies`, `listFrames`, `listRisks`, `listWalkers`, `listSizings`, `listOptimizers` | Retrieve registered components |\n| **Event Subscription** | `listenSignal*`, `listenDone*`, `listenPartial*`, `listenRisk`, `listenPerformance`, `listenError`, `listenExit` | Subscribe to framework events |\n| **Context Access** | `getDate`, `getMode` | Access execution context |\n| **Exchange Utilities** | `getCandles`, `getAveragePrice`, `formatPrice`, `formatQuantity` | Data fetching and formatting |\n| **Debugging** | `dumpSignal` | Logging and analysis |\n\n**Sources:** [README.md:36-176](), [docs/index.md:84-141](), [src/function/add.ts:1-500](), [src/function/list.ts:1-261]()\n\n---\n\n## Architecture: Global Functions to Service Layer\n\n```mermaid\ngraph TB\n    subgraph \"User Code\"\n        USER[\"User Application\"]\n    end\n    \n    subgraph \"Global Functions (src/function/)\"\n        CONFIG_FN[\"setLogger()<br/>setConfig()<br/>setColumns()\"]\n        ADD_FN[\"addExchange()<br/>addStrategy()<br/>addFrame()<br/>addRisk()<br/>addWalker()<br/>addSizing()<br/>addOptimizer()\"]\n        LIST_FN[\"listExchanges()<br/>listStrategies()<br/>listFrames()<br/>etc.\"]\n        LISTEN_FN[\"listenSignal*()<br/>listenDone*()<br/>listenPartial*()\"]\n        UTIL_FN[\"getCandles()<br/>getAveragePrice()<br/>formatPrice()\"]\n        CTX_FN[\"getDate()<br/>getMode()\"]\n    end\n    \n    subgraph \"Service Layer Access (src/lib/index.ts)\"\n        BACKTEST_OBJ[\"backtest object<br/>Singleton service container\"]\n    end\n    \n    subgraph \"Validation Services\"\n        VAL_EXCHANGE[\"ExchangeValidationService\"]\n        VAL_STRATEGY[\"StrategyValidationService\"]\n        VAL_FRAME[\"FrameValidationService\"]\n        VAL_RISK[\"RiskValidationService\"]\n        VAL_WALKER[\"WalkerValidationService\"]\n        VAL_SIZING[\"SizingValidationService\"]\n        VAL_OPTIMIZER[\"OptimizerValidationService\"]\n        VAL_CONFIG[\"ConfigValidationService\"]\n        VAL_COLUMN[\"ColumnValidationService\"]\n    end\n    \n    subgraph \"Schema Services (ToolRegistry pattern)\"\n        SCHEMA_EXCHANGE[\"ExchangeSchemaService\"]\n        SCHEMA_STRATEGY[\"StrategySchemaService\"]\n        SCHEMA_FRAME[\"FrameSchemaService\"]\n        SCHEMA_RISK[\"RiskSchemaService\"]\n        SCHEMA_WALKER[\"WalkerSchemaService\"]\n        SCHEMA_SIZING[\"SizingSchemaService\"]\n        SCHEMA_OPTIMIZER[\"OptimizerSchemaService\"]\n    end\n    \n    subgraph \"Context Services\"\n        CTX_EXEC[\"ExecutionContextService<br/>symbol, when, backtest flag\"]\n        CTX_METHOD[\"MethodContextService<br/>strategyName, exchangeName\"]\n    end\n    \n    subgraph \"Connection Services\"\n        CONN_EXCHANGE[\"ExchangeConnectionService<br/>ClientExchange instances\"]\n    end\n    \n    subgraph \"Event System\"\n        EMITTERS[\"signalEmitter<br/>doneBacktestSubject<br/>doneLiveSubject<br/>partialProfitSubject<br/>etc.\"]\n    end\n    \n    USER --> CONFIG_FN\n    USER --> ADD_FN\n    USER --> LIST_FN\n    USER --> LISTEN_FN\n    USER --> UTIL_FN\n    USER --> CTX_FN\n    \n    CONFIG_FN --> BACKTEST_OBJ\n    ADD_FN --> BACKTEST_OBJ\n    LIST_FN --> BACKTEST_OBJ\n    LISTEN_FN --> EMITTERS\n    UTIL_FN --> BACKTEST_OBJ\n    CTX_FN --> BACKTEST_OBJ\n    \n    BACKTEST_OBJ --> VAL_EXCHANGE\n    BACKTEST_OBJ --> VAL_STRATEGY\n    BACKTEST_OBJ --> VAL_FRAME\n    BACKTEST_OBJ --> VAL_RISK\n    BACKTEST_OBJ --> VAL_WALKER\n    BACKTEST_OBJ --> VAL_SIZING\n    BACKTEST_OBJ --> VAL_OPTIMIZER\n    BACKTEST_OBJ --> VAL_CONFIG\n    BACKTEST_OBJ --> VAL_COLUMN\n    BACKTEST_OBJ --> SCHEMA_EXCHANGE\n    BACKTEST_OBJ --> SCHEMA_STRATEGY\n    BACKTEST_OBJ --> SCHEMA_FRAME\n    BACKTEST_OBJ --> SCHEMA_RISK\n    BACKTEST_OBJ --> SCHEMA_WALKER\n    BACKTEST_OBJ --> SCHEMA_SIZING\n    BACKTEST_OBJ --> SCHEMA_OPTIMIZER\n    BACKTEST_OBJ --> CTX_EXEC\n    BACKTEST_OBJ --> CTX_METHOD\n    BACKTEST_OBJ --> CONN_EXCHANGE\n    \n    ADD_FN --> VAL_EXCHANGE\n    ADD_FN --> VAL_STRATEGY\n    ADD_FN --> VAL_FRAME\n    ADD_FN --> VAL_RISK\n    ADD_FN --> VAL_WALKER\n    ADD_FN --> VAL_SIZING\n    ADD_FN --> VAL_OPTIMIZER\n    \n    VAL_EXCHANGE --> SCHEMA_EXCHANGE\n    VAL_STRATEGY --> SCHEMA_STRATEGY\n    VAL_FRAME --> SCHEMA_FRAME\n    VAL_RISK --> SCHEMA_RISK\n    VAL_WALKER --> SCHEMA_WALKER\n    VAL_SIZING --> SCHEMA_SIZING\n    VAL_OPTIMIZER --> SCHEMA_OPTIMIZER\n    \n    LIST_FN --> VAL_EXCHANGE\n    LIST_FN --> VAL_STRATEGY\n    LIST_FN --> VAL_FRAME\n    LIST_FN --> VAL_RISK\n    LIST_FN --> VAL_WALKER\n    LIST_FN --> VAL_SIZING\n    LIST_FN --> VAL_OPTIMIZER\n    \n    UTIL_FN --> CTX_EXEC\n    UTIL_FN --> CTX_METHOD\n    UTIL_FN --> CONN_EXCHANGE\n```\n\n**Architectural Flow:**\n\n1. **User Code** calls global functions from the public API\n2. **Global Functions** delegate to the `backtest` singleton object (dependency injection container)\n3. **Validation Services** perform shallow validation and duplicate checks\n4. **Schema Services** store validated configurations in `ToolRegistry` instances\n5. **Context Services** propagate ambient execution state via `AsyncLocalStorage`\n6. **Connection Services** create and cache client instances (memoized factories)\n7. **Event System** broadcasts events to registered listeners via Subject pattern\n\n**Sources:** [src/function/add.ts:1-500](), [src/lib/index.ts:1-246](), [src/lib/core/types.ts:1-105](), [src/lib/core/provide.ts:1-143]()\n\n---\n\n## Configuration Functions\n\n### setLogger\n\n```typescript\nsetLogger(logger: ILogger): void\n```\n\nRegisters a custom logger implementation for framework-wide logging. The logger receives contextual information about operations including method names and parameters.\n\n**Parameters:**\n- `logger: ILogger` - Logger implementation with `log`, `debug`, `info`, `warn` methods\n\n**Logger Interface:**\n```typescript\ninterface ILogger {\n  log: (...args: any[]) => void;\n  debug: (...args: any[]) => void;\n  info: (...args: any[]) => void;\n  warn: (...args: any[]) => void;\n}\n```\n\n**Example:**\n```typescript\nimport { setLogger } from 'backtest-kit';\n\nsetLogger({\n  log: console.log,\n  debug: console.debug,\n  info: console.info,\n  warn: console.warn,\n});\n```\n\n**Internal Flow:**\nThe logger is stored in `LoggerService` ([src/services/base/LoggerService]()), which is injected as a dependency throughout the service layer. All services access logging via `backtest.loggerService`.\n\n**Sources:** [README.md:46-55](), [docs/index.md:86]()\n\n---\n\n### setConfig\n\n```typescript\nsetConfig(config: Partial<GlobalConfig>): void\n```\n\nUpdates global configuration parameters that control validation thresholds, fees, slippage, retry logic, and anomaly detection. Configuration is merged with existing values, allowing partial updates.\n\n**Key Configuration Parameters:**\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| `CC_PERCENT_FEE` | `0.1` | Fee percentage per trade (0.1 = 0.1%) |\n| `CC_PERCENT_SLIPPAGE` | `0.1` | Slippage percentage per trade (0.1 = 0.1%) |\n| `CC_MIN_TAKEPROFIT_DISTANCE_PERCENT` | `0.22` | Min TP distance to cover fees+slippage (0.1% + 0.1% + buffer) |\n| `CC_MAX_STOPLOSS_DISTANCE_PERCENT` | `100` | Max SL distance as percentage |\n| `CC_MAX_SIGNAL_LIFETIME_MINUTES` | `10080` | Max signal lifetime (default: 7 days) |\n| `CC_SCHEDULE_AWAIT_MINUTES` | `120` | Timeout for scheduled signal activation |\n| `CC_AVG_PRICE_CANDLES_COUNT` | `5` | Number of 1m candles for VWAP calculation |\n| `CC_CANDLES_RETRY_COUNT` | `3` | Retry attempts for candle fetching |\n| `CC_CANDLES_RETRY_DELAY_MS` | `1000` | Delay between retry attempts |\n| `CC_MEDIAN_CANDLES_LOOKBACK` | `20` | Candles for median price calculation |\n| `CC_PRICE_ANOMALY_THRESHOLD` | `0.5` | Threshold for price anomaly detection (50% deviation) |\n\n**Example:**\n```typescript\nimport { setConfig } from 'backtest-kit';\n\nsetConfig({\n  CC_PERCENT_FEE: 0.1,\n  CC_PERCENT_SLIPPAGE: 0.1,\n  CC_MIN_TAKEPROFIT_DISTANCE_PERCENT: 0.3,\n  CC_SCHEDULE_AWAIT_MINUTES: 120,\n});\n```\n\n**Internal Validation:**\nConfiguration is validated by `ConfigValidationService` ([src/services/validation/ConfigValidationService]()) which ensures:\n- All percentages are finite positive numbers\n- Retry counts are positive integers\n- Lookback periods are positive integers\n- Thresholds are within valid ranges\n\n**Sources:** [README.md:57-63](), [docs/types/GlobalConfig.md:1-10]()\n\n---\n\n### getConfig\n\n```typescript\ngetConfig(): GlobalConfig\n```\n\nReturns the current global configuration object with all parameters. Useful for debugging or displaying configuration in UIs.\n\n**Returns:** Complete `GlobalConfig` object with all parameters\n\n**Sources:** [docs/index.md:88]()\n\n---\n\n### getDefaultConfig\n\n```typescript\ngetDefaultConfig(): GlobalConfig\n```\n\nReturns the default global configuration object. Useful for resetting configuration or comparing against defaults.\n\n**Returns:** Default `GlobalConfig` object with framework defaults\n\n**Sources:** [docs/index.md:89]()\n\n---\n\n### setColumns\n\n```typescript\nsetColumns(columns: Partial<ColumnConfig>): void\n```\n\nConfigures which columns are visible in markdown reports. Allows customization of report output format by showing/hiding specific columns.\n\n**Column Categories:**\n\n| Category | Columns | Description |\n|----------|---------|-------------|\n| **Signal Identification** | `id`, `symbol`, `strategyName`, `exchangeName` | Core identifiers |\n| **Pricing** | `priceOpen`, `priceClose`, `priceTakeProfit`, `priceStopLoss`, `averageEntryPrice` | Entry/exit prices |\n| **Position** | `position`, `quantity` | Trade direction and size |\n| **Timing** | `timestamp`, `timestampOpen`, `timestampClose`, `minuteEstimatedTime` | Temporal data |\n| **Performance** | `pnl`, `pnlPercentage`, `feePercentage`, `slippagePercentage` | Financial results |\n| **Status** | `closeReason` | Trade closure reason |\n\n**Example:**\n```typescript\nimport { setColumns } from 'backtest-kit';\n\nsetColumns({\n  id: false,                    // Hide signal IDs\n  exchangeName: false,          // Hide exchange names\n  quantity: true,               // Show quantities\n  pnl: true,                    // Show PNL\n  pnlPercentage: true,         // Show PNL %\n});\n```\n\n**Internal Validation:**\nColumn configuration is validated by `ColumnValidationService` ([src/services/validation/ColumnValidationService]()) which ensures all keys are valid column names.\n\n**Sources:** [docs/index.md:90](), [docs/types/ColumnConfig.md:1-10]()\n\n---\n\n### getColumns\n\n```typescript\ngetColumns(): ColumnConfig\n```\n\nReturns the current column visibility configuration.\n\n**Returns:** Complete `ColumnConfig` object\n\n**Sources:** [docs/index.md:91]()\n\n---\n\n### getDefaultColumns\n\n```typescript\ngetDefaultColumns(): ColumnConfig\n```\n\nReturns the default column visibility configuration.\n\n**Returns:** Default `ColumnConfig` object\n\n**Sources:** [docs/index.md:92]()\n\n---\n\n## Registration Functions\n\nRegistration functions validate and store component schemas in the service layer. Each function performs two operations:\n\n1. **Validation** via dedicated ValidationService (shallow validation, duplicate checking)\n2. **Storage** via dedicated SchemaService (ToolRegistry pattern for immutable storage)\n\n```mermaid\ngraph TB\n    ADD[\"addStrategy()<br/>addExchange()<br/>addFrame()<br/>addRisk()<br/>addWalker()<br/>addSizing()<br/>addOptimizer()\"]\n    \n    LOG[\"LoggerService.info()<br/>Log registration attempt\"]\n    \n    VALIDATE[\"ValidationService<br/>addStrategy() / addExchange() / etc.<br/>Check for duplicates<br/>Validate schema shape\"]\n    \n    REGISTER[\"SchemaService<br/>register(name, schema)<br/>Store in ToolRegistry\"]\n    \n    TOOLREG[\"ToolRegistry<br/>Map<name, schema><br/>Immutable storage\"]\n    \n    CONNECTION[\"ConnectionService<br/>Memoized factory<br/>Creates client instances\"]\n    \n    CLIENT[\"ClientStrategy<br/>ClientExchange<br/>ClientFrame<br/>ClientRisk<br/>ClientSizing\"]\n    \n    ADD --> LOG\n    LOG --> VALIDATE\n    VALIDATE --> REGISTER\n    REGISTER --> TOOLREG\n    \n    TOOLREG -.->|\"Lazy loading\"| CONNECTION\n    CONNECTION -.->|\"First access\"| CLIENT\n```\n\n**Registration Flow:**\n\n1. User calls `add*()` function with schema object\n2. `LoggerService` logs registration attempt with method name and schema\n3. `ValidationService` validates schema and checks for duplicate names\n4. `SchemaService` stores validated schema in `ToolRegistry` instance\n5. Later, `ConnectionService` retrieves schema and creates client instances on-demand (memoized)\n\n**Sources:** [src/function/add.ts:52-343]()\n\n---\n\n### addStrategy\n\n```typescript\naddStrategy(strategySchema: IStrategySchema): void\n```\n\nRegisters a trading strategy with signal generation logic, lifecycle callbacks, and risk profile association.\n\n**Schema Structure (IStrategySchema):**\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `strategyName` | `string` | ✓ | Unique strategy identifier |\n| `interval` | `SignalInterval` | ✓ | Throttling interval: `\"1m\"` \\| `\"3m\"` \\| `\"5m\"` \\| `\"15m\"` \\| `\"30m\"` \\| `\"1h\"` |\n| `getSignal` | `(symbol: string, when: Date) => Promise<ISignalDto \\| null>` | ✓ | Signal generation function |\n| `callbacks` | `Partial<IStrategyCallbacks>` | | Lifecycle hooks: `onOpen`, `onClose`, `onSchedule`, `onCancel`, `onPartialProfit`, `onPartialLoss` |\n| `riskName` | `string` | | Single risk profile name |\n| `riskList` | `string[]` | | Multiple risk profile names (if multiple required) |\n| `note` | `string` | | Developer documentation |\n\n**Signal DTO (ISignalDto):**\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `position` | `\"long\"` \\| `\"short\"` | ✓ | Trade direction |\n| `priceOpen` | `number` | | Entry price (if omitted, opens immediately at current price) |\n| `priceTakeProfit` | `number` | ✓ | Take profit price |\n| `priceStopLoss` | `number` | ✓ | Stop loss price |\n| `minuteEstimatedTime` | `number` | ✓ | Expected signal lifetime in minutes |\n| `timestamp` | `number` | ✓ | Signal generation timestamp (Unix milliseconds) |\n| `id` | `string` | | Optional unique signal identifier |\n| `quantity` | `number` | | Optional position size override |\n\n**Example:**\n```typescript\nimport { addStrategy, getCandles } from 'backtest-kit';\n\naddStrategy({\n  strategyName: \"sma-crossover\",\n  interval: \"5m\",\n  riskName: \"conservative\",\n  getSignal: async (symbol, when) => {\n    const candles = await getCandles(symbol, \"1h\", 50);\n    const sma20 = calculateSMA(candles, 20);\n    const sma50 = calculateSMA(candles, 50);\n    \n    if (sma20 > sma50 && previousSma20 <= previousSma50) {\n      return {\n        position: \"long\",\n        priceTakeProfit: currentPrice * 1.02,\n        priceStopLoss: currentPrice * 0.99,\n        minuteEstimatedTime: 60,\n        timestamp: when.getTime(),\n      };\n    }\n    \n    return null;\n  },\n  callbacks: {\n    onOpen: (symbol, signal, currentPrice, backtest) => {\n      console.log(`[OPEN] ${symbol} at ${currentPrice}`);\n    },\n    onClose: (symbol, signal, priceClose, backtest) => {\n      console.log(`[CLOSE] ${symbol} at ${priceClose} - PNL: ${signal.pnl}`);\n    },\n  },\n});\n```\n\n**Validation:**\n`StrategyValidationService` ([src/services/validation/StrategyValidationService]()) validates:\n- `strategyName` is unique and non-empty string\n- `interval` is valid `SignalInterval` enum value\n- `getSignal` is a function\n- If `callbacks` provided, each callback is a function\n- If `riskName` or `riskList` provided, references valid risk profiles (deferred check)\n\n**Storage:**\n`StrategySchemaService` ([src/services/schema/StrategySchemaService]()) stores schema in `ToolRegistry` instance, enabling later retrieval by `StrategyConnectionService`.\n\n**Sources:** [src/function/add.ts:52-64](), [README.md:111-143](), [docs/interfaces/IStrategySchema.md:1-70]()\n\n---\n\n### addExchange\n\n```typescript\naddExchange(exchangeSchema: IExchangeSchema): void\n```\n\nRegisters an exchange data source with candle fetching, price formatting, and optional callbacks.\n\n**Schema Structure (IExchangeSchema):**\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `exchangeName` | `string` | ✓ | Unique exchange identifier |\n| `getCandles` | `(symbol, interval, since, limit) => Promise<ICandleData[]>` | ✓ | Candle data fetching function |\n| `formatPrice` | `(symbol, price) => Promise<string>` | ✓ | Price formatting for exchange |\n| `formatQuantity` | `(symbol, quantity) => Promise<string>` | ✓ | Quantity formatting for exchange |\n| `getAveragePrice` | `(symbol) => Promise<number>` | | Optional VWAP override (default: last 5 1m candles) |\n| `callbacks` | `Partial<IExchangeCallbacks>` | | Optional `onCandles` callback |\n| `note` | `string` | | Developer documentation |\n\n**Candle Data Structure (ICandleData):**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `timestamp` | `number` | Unix milliseconds |\n| `open` | `number` | Opening price |\n| `high` | `number` | Highest price |\n| `low` | `number` | Lowest price |\n| `close` | `number` | Closing price |\n| `volume` | `number` | Trading volume |\n\n**Example:**\n```typescript\nimport { addExchange } from 'backtest-kit';\nimport ccxt from 'ccxt';\n\naddExchange({\n  exchangeName: \"binance\",\n  getCandles: async (symbol, interval, since, limit) => {\n    const exchange = new ccxt.binance();\n    const ohlcv = await exchange.fetchOHLCV(\n      symbol,\n      interval,\n      since.getTime(),\n      limit\n    );\n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n      timestamp,\n      open,\n      high,\n      low,\n      close,\n      volume,\n    }));\n  },\n  formatPrice: async (symbol, price) => price.toFixed(2),\n  formatQuantity: async (symbol, quantity) => quantity.toFixed(8),\n});\n```\n\n**Validation:**\n`ExchangeValidationService` ([src/services/validation/ExchangeValidationService]()) validates:\n- `exchangeName` is unique and non-empty string\n- `getCandles` is a function\n- `formatPrice` is a function\n- `formatQuantity` is a function\n\n**Storage:**\n`ExchangeSchemaService` ([src/services/schema/ExchangeSchemaService]()) stores schema in `ToolRegistry` instance.\n\n**Sources:** [src/function/add.ts:101-113](), [README.md:70-80](), [docs/interfaces/IExchangeSchema.md:1-50]()\n\n---\n\n### addFrame\n\n```typescript\naddFrame(frameSchema: IFrameSchema): void\n```\n\nRegisters a timeframe generator for backtesting with start/end dates and interval configuration.\n\n**Schema Structure (IFrameSchema):**\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `frameName` | `string` | ✓ | Unique frame identifier |\n| `interval` | `FrameInterval` | ✓ | Timeframe interval |\n| `startDate` | `Date` | ✓ | Backtest start date |\n| `endDate` | `Date` | ✓ | Backtest end date |\n| `callbacks` | `Partial<IFrameCallbacks>` | | Optional `onTimeframe` callback |\n| `note` | `string` | | Developer documentation |\n\n**Frame Intervals:**\n`\"1m\"` \\| `\"3m\"` \\| `\"5m\"` \\| `\"15m\"` \\| `\"30m\"` \\| `\"1h\"` \\| `\"2h\"` \\| `\"4h\"` \\| `\"6h\"` \\| `\"8h\"` \\| `\"12h\"` \\| `\"1d\"` \\| `\"3d\"`\n\n**Example:**\n```typescript\nimport { addFrame } from 'backtest-kit';\n\naddFrame({\n  frameName: \"1d-test\",\n  interval: \"1m\",\n  startDate: new Date(\"2024-01-01T00:00:00Z\"),\n  endDate: new Date(\"2024-01-02T00:00:00Z\"),\n  callbacks: {\n    onTimeframe: (timeframe, startDate, endDate, interval) => {\n      console.log(`Generated ${timeframe.length} timeframes`);\n    },\n  },\n});\n```\n\n**Validation:**\n`FrameValidationService` ([src/services/validation/FrameValidationService]()) validates:\n- `frameName` is unique and non-empty string\n- `interval` is valid `FrameInterval` enum value\n- `startDate` and `endDate` are valid Date objects\n- `endDate` is after `startDate`\n\n**Storage:**\n`FrameSchemaService` ([src/services/schema/FrameSchemaService]()) stores schema in `ToolRegistry` instance.\n\n**Sources:** [src/function/add.ts:145-151](), [README.md:102-108](), [docs/interfaces/IFrameSchema.md:1-40]()\n\n---\n\n### addWalker\n\n```typescript\naddWalker(walkerSchema: IWalkerSchema): void\n```\n\nRegisters a walker for multi-strategy comparison with metric-based ranking.\n\n**Schema Structure (IWalkerSchema):**\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `walkerName` | `string` | ✓ | Unique walker identifier |\n| `exchangeName` | `string` | ✓ | Exchange for all strategies |\n| `frameName` | `string` | ✓ | Timeframe for all strategies |\n| `strategies` | `string[]` | ✓ | Strategy names to compare |\n| `metric` | `WalkerMetric` | | Ranking metric (default: `\"sharpeRatio\"`) |\n| `context` | `any` | | User-defined context passed to callbacks |\n| `callbacks` | `Partial<IWalkerCallbacks>` | | Optional lifecycle hooks |\n| `note` | `string` | | Developer documentation |\n\n**Walker Metrics:**\n`\"sharpeRatio\"` \\| `\"winRate\"` \\| `\"pnl\"` \\| `\"totalTrades\"` \\| `\"avgPnl\"` \\| `\"maxDrawdown\"`\n\n**Example:**\n```typescript\nimport { addWalker } from 'backtest-kit';\n\naddWalker({\n  walkerName: \"llm-prompt-optimizer\",\n  exchangeName: \"binance\",\n  frameName: \"1d-test\",\n  strategies: [\"strategy-v1\", \"strategy-v2\", \"strategy-v3\"],\n  metric: \"sharpeRatio\",\n  callbacks: {\n    onStrategyComplete: (strategyName, symbol, stats, metric) => {\n      console.log(`${strategyName}: Sharpe=${stats.sharpeRatio}`);\n    },\n    onComplete: (results) => {\n      console.log(`Best: ${results.bestStrategy}`);\n    },\n  },\n});\n```\n\n**Validation:**\n`WalkerValidationService` ([src/services/validation/WalkerValidationService]()) validates:\n- `walkerName` is unique and non-empty string\n- `exchangeName` references valid exchange (deferred check)\n- `frameName` references valid frame (deferred check)\n- `strategies` is non-empty array of strings\n- `metric` is valid `WalkerMetric` enum value\n\n**Storage:**\n`WalkerSchemaService` ([src/services/schema/WalkerSchemaService]()) stores schema in `ToolRegistry` instance.\n\n**Sources:** [src/function/add.ts:190-202](), [docs/interfaces/IWalkerSchema.md:1-50]()\n\n---\n\n### addSizing\n\n```typescript\naddSizing(sizingSchema: ISizingSchema): void\n```\n\nRegisters a position sizing configuration using one of three methods: fixed-percentage, Kelly criterion, or ATR-based.\n\n**Schema Structure (ISizingSchema - Discriminated Union):**\n\n**Fixed Percentage:**\n```typescript\n{\n  sizingName: string;\n  method: \"fixed-percentage\";\n  riskPercentage: number;              // % of account to risk per trade\n  maxPositionPercentage?: number;      // Max position size as % of account\n  minPositionSize?: number;            // Min position size\n  maxPositionSize?: number;            // Max position size\n  callbacks?: Partial<ISizingCallbacks>;\n  note?: string;\n}\n```\n\n**Kelly Criterion:**\n```typescript\n{\n  sizingName: string;\n  method: \"kelly-criterion\";\n  kellyMultiplier?: number;            // Multiplier for Kelly % (default: 0.25)\n  maxPositionPercentage?: number;\n  minPositionSize?: number;\n  maxPositionSize?: number;\n  callbacks?: Partial<ISizingCallbacks>;\n  note?: string;\n}\n```\n\n**ATR-Based:**\n```typescript\n{\n  sizingName: string;\n  method: \"atr-based\";\n  riskPercentage: number;              // % of account to risk\n  atrMultiplier?: number;              // ATR multiplier for stop distance (default: 2)\n  maxPositionPercentage?: number;\n  minPositionSize?: number;\n  maxPositionSize?: number;\n  callbacks?: Partial<ISizingCallbacks>;\n  note?: string;\n}\n```\n\n**Example:**\n```typescript\nimport { addSizing } from 'backtest-kit';\n\n// Fixed percentage\naddSizing({\n  sizingName: \"conservative\",\n  method: \"fixed-percentage\",\n  riskPercentage: 1,\n  maxPositionPercentage: 10,\n});\n\n// Kelly criterion\naddSizing({\n  sizingName: \"kelly\",\n  method: \"kelly-criterion\",\n  kellyMultiplier: 0.25,\n  maxPositionPercentage: 20,\n});\n\n// ATR-based\naddSizing({\n  sizingName: \"atr-dynamic\",\n  method: \"atr-based\",\n  riskPercentage: 2,\n  atrMultiplier: 2,\n});\n```\n\n**Validation:**\n`SizingValidationService` ([src/services/validation/SizingValidationService]()) validates:\n- `sizingName` is unique and non-empty string\n- `method` is valid sizing method\n- Method-specific fields are present and valid\n- Percentages are positive numbers\n\n**Storage:**\n`SizingSchemaService` ([src/services/schema/SizingSchemaService]()) stores schema in `ToolRegistry` instance.\n\n**Sources:** [src/function/add.ts:256-268](), [docs/interfaces/ISizingSchema.md:1-100]()\n\n---\n\n### addRisk\n\n```typescript\naddRisk(riskSchema: IRiskSchema): void\n```\n\nRegisters a risk management profile with position limits and custom validations.\n\n**Schema Structure (IRiskSchema):**\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `riskName` | `string` | ✓ | Unique risk profile identifier |\n| `maxConcurrentPositions` | `number` | | Max open positions across all strategies |\n| `validations` | `IRiskValidation[]` | | Custom validation functions |\n| `callbacks` | `Partial<IRiskCallbacks>` | | Optional `onRejected`, `onAllowed` callbacks |\n| `note` | `string` | | Developer documentation |\n\n**Risk Validation Function:**\n```typescript\ntype IRiskValidationFn = (args: {\n  params: IRiskCheckArgs;\n}) => void | Promise<void>;\n\ninterface IRiskCheckArgs {\n  symbol: string;\n  strategyName: string;\n  exchangeName: string;\n  signal: ISignalDto;\n  currentPrice: number;\n  timestamp: Date;\n}\n```\n\nValidation functions throw errors to reject signals. Async validations are supported for external data fetching.\n\n**Example:**\n```typescript\nimport { addRisk } from 'backtest-kit';\n\naddRisk({\n  riskName: \"advanced\",\n  maxConcurrentPositions: 10,\n  validations: [\n    {\n      validate: async ({ params }) => {\n        const portfolio = await getPortfolioState();\n        if (portfolio.drawdown > 20) {\n          throw new Error(\"Portfolio drawdown exceeds 20%\");\n        }\n      },\n      docDescription: \"Prevents trading during high drawdown\",\n    },\n    ({ params }) => {\n      const riskRewardRatio = \n        Math.abs(params.signal.priceTakeProfit - params.currentPrice) /\n        Math.abs(params.currentPrice - params.signal.priceStopLoss);\n      \n      if (riskRewardRatio < 2) {\n        throw new Error(\"Risk/reward ratio below 2:1\");\n      }\n    },\n  ],\n  callbacks: {\n    onRejected: (symbol, reason) => {\n      console.log(`[RISK] Signal rejected: ${reason}`);\n    },\n    onAllowed: (symbol) => {\n      console.log(`[RISK] Signal allowed for ${symbol}`);\n    },\n  },\n});\n```\n\n**Validation:**\n`RiskValidationService` ([src/services/validation/RiskValidationService]()) validates:\n- `riskName` is unique and non-empty string\n- `maxConcurrentPositions` (if provided) is positive integer\n- Each validation in `validations` array has `validate` function\n\n**Storage:**\n`RiskSchemaService` ([src/services/schema/RiskSchemaService]()) stores schema in `ToolRegistry` instance.\n\n**Sources:** [src/function/add.ts:331-343](), [README.md:82-100](), [docs/interfaces/IRiskSchema.md:1-70]()\n\n---\n\n### addOptimizer\n\n```typescript\naddOptimizer(optimizerSchema: IOptimizerSchema): void\n```\n\nRegisters an optimizer for LLM-powered strategy generation with data collection, prompt engineering, and code generation.\n\n**Schema Structure (IOptimizerSchema):**\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `optimizerName` | `string` | ✓ | Unique optimizer identifier |\n| `rangeTrain` | `IOptimizerRange[]` | ✓ | Training period date ranges |\n| `rangeTest` | `IOptimizerRange` | ✓ | Testing period date range |\n| `source` | `IOptimizerSource[]` | ✓ | Data sources for LLM context |\n| `getPrompt` | `(symbol, messages) => Promise<string>` | ✓ | Prompt generation function |\n| `template` | `IOptimizerTemplate` | | Custom code generation template |\n| `callbacks` | `Partial<IOptimizerCallbacks>` | | Optional lifecycle hooks |\n| `note` | `string` | | Developer documentation |\n\n**Date Range Structure:**\n```typescript\ninterface IOptimizerRange {\n  startDate: Date;\n  endDate: Date;\n  note?: string;\n}\n```\n\n**Data Source Structure:**\n```typescript\ninterface IOptimizerSource {\n  exchangeName: string;\n  interval: CandleInterval;\n  strategies: IOptimizerStrategy[];\n}\n\ninterface IOptimizerStrategy {\n  strategyName: string;\n  frameName: string;\n}\n```\n\n**Example:**\n```typescript\nimport { addOptimizer } from 'backtest-kit';\nimport { Ollama } from 'ollama';\n\nconst ollama = new Ollama({ host: 'http://localhost:11434' });\n\naddOptimizer({\n  optimizerName: \"llm-strategy-generator\",\n  rangeTrain: [\n    {\n      startDate: new Date(\"2024-01-01\"),\n      endDate: new Date(\"2024-01-31\"),\n      note: \"Training period 1\",\n    },\n  ],\n  rangeTest: {\n    startDate: new Date(\"2024-02-01\"),\n    endDate: new Date(\"2024-02-28\"),\n    note: \"Testing period\",\n  },\n  source: [\n    {\n      exchangeName: \"binance\",\n      interval: \"1h\",\n      strategies: [\n        { strategyName: \"baseline\", frameName: \"train-frame-1\" },\n      ],\n    },\n  ],\n  getPrompt: async (symbol, messages) => {\n    const response = await ollama.chat({\n      model: \"deepseek-v3.1:671b\",\n      messages,\n    });\n    return response.message.content;\n  },\n});\n```\n\n**Validation:**\n`OptimizerValidationService` ([src/services/validation/OptimizerValidationService]()) validates:\n- `optimizerName` is unique and non-empty string\n- `rangeTrain` is non-empty array\n- `rangeTest` is valid date range\n- `source` array structure is valid\n- `getPrompt` is a function\n\n**Storage:**\n`OptimizerSchemaService` ([src/services/schema/OptimizerSchemaService]()) stores schema in `ToolRegistry` instance.\n\n**Sources:** [src/function/add.ts:345-500](), [docs/interfaces/IOptimizerSchema.md:1-100]()\n\n---\n\n## Query Functions\n\nQuery functions retrieve lists of registered schemas from validation services. All functions return arrays of schema objects.\n\n```mermaid\ngraph LR\n    LIST[\"listExchanges()<br/>listStrategies()<br/>listFrames()<br/>listRisks()<br/>listWalkers()<br/>listSizings()<br/>listOptimizers()\"]\n    \n    LOG[\"LoggerService.log()<br/>Log list request\"]\n    \n    VALIDATE[\"ValidationService<br/>list()<br/>Returns array of schemas\"]\n    \n    SCHEMA[\"SchemaService<br/>ToolRegistry.getItems()<br/>Retrieves all entries\"]\n    \n    RETURN[\"Returns:<br/>IExchangeSchema[]<br/>IStrategySchema[]<br/>IFrameSchema[]<br/>etc.\"]\n    \n    LIST --> LOG\n    LOG --> VALIDATE\n    VALIDATE --> SCHEMA\n    SCHEMA --> RETURN\n```\n\nAll list functions share the same pattern:\n1. Log the request via `LoggerService`\n2. Delegate to appropriate `ValidationService.list()`\n3. ValidationService retrieves schemas from SchemaService\n4. Returns array of schema objects\n\n**Sources:** [src/function/list.ts:1-261]()\n\n---\n\n### listExchanges\n\n```typescript\nlistExchanges(): Promise<IExchangeSchema[]>\n```\n\nReturns array of all registered exchange schemas.\n\n**Example:**\n```typescript\nconst exchanges = await listExchanges();\nconsole.log(exchanges.map(e => e.exchangeName));\n// [\"binance\", \"coinbase\", ...]\n```\n\n**Sources:** [src/function/list.ts:43-46]()\n\n---\n\n### listStrategies\n\n```typescript\nlistStrategies(): Promise<IStrategySchema[]>\n```\n\nReturns array of all registered strategy schemas.\n\n**Example:**\n```typescript\nconst strategies = await listStrategies();\nconsole.log(strategies.map(s => s.strategyName));\n// [\"sma-crossover\", \"rsi-divergence\", ...]\n```\n\n**Sources:** [src/function/list.ts:78-81]()\n\n---\n\n### listFrames\n\n```typescript\nlistFrames(): Promise<IFrameSchema[]>\n```\n\nReturns array of all registered frame schemas.\n\n**Example:**\n```typescript\nconst frames = await listFrames();\nconsole.log(frames.map(f => ({ \n  name: f.frameName, \n  interval: f.interval,\n  start: f.startDate,\n  end: f.endDate \n})));\n```\n\n**Sources:** [src/function/list.ts:108-111]()\n\n---\n\n### listWalkers\n\n```typescript\nlistWalkers(): Promise<IWalkerSchema[]>\n```\n\nReturns array of all registered walker schemas.\n\n**Example:**\n```typescript\nconst walkers = await listWalkers();\nconsole.log(walkers.map(w => ({ \n  name: w.walkerName,\n  strategies: w.strategies,\n  metric: w.metric \n})));\n```\n\n**Sources:** [src/function/list.ts:139-142]()\n\n---\n\n### listSizings\n\n```typescript\nlistSizings(): Promise<ISizingSchema[]>\n```\n\nReturns array of all registered sizing schemas.\n\n**Example:**\n```typescript\nconst sizings = await listSizings();\nconsole.log(sizings.map(s => ({ \n  name: s.sizingName,\n  method: s.method \n})));\n```\n\n**Sources:** [src/function/list.ts:179-182]()\n\n---\n\n### listRisks\n\n```typescript\nlistRisks(): Promise<IRiskSchema[]>\n```\n\nReturns array of all registered risk schemas.\n\n**Example:**\n```typescript\nconst risks = await listRisks();\nconsole.log(risks.map(r => ({ \n  name: r.riskName,\n  maxPositions: r.maxConcurrentPositions \n})));\n```\n\n**Sources:** [src/function/list.ts:216-219]()\n\n---\n\n### listOptimizers\n\n```typescript\nlistOptimizers(): Promise<IOptimizerSchema[]>\n```\n\nReturns array of all registered optimizer schemas.\n\n**Example:**\n```typescript\nconst optimizers = await listOptimizers();\nconsole.log(optimizers.map(o => o.optimizerName));\n```\n\n**Sources:** [src/function/list.ts:257-260]()\n\n---\n\n## Event Subscription Functions\n\nEvent subscription functions register callbacks for framework events. The framework uses a Subject pattern for event emission with support for both persistent and one-time listeners.\n\n```mermaid\ngraph TB\n    subgraph \"Event Producers\"\n        STRAT[\"ClientStrategy<br/>Strategy execution\"]\n        BT[\"BacktestLogicPrivateService<br/>Backtest orchestration\"]\n        LIVE[\"LiveLogicPrivateService<br/>Live trading\"]\n        WALK[\"WalkerLogicPrivateService<br/>Walker comparison\"]\n        RISK[\"ClientRisk<br/>Risk validation\"]\n        PARTIAL[\"ClientPartial<br/>Partial monitoring\"]\n    end\n    \n    subgraph \"Event Emitters (Subject Pattern)\"\n        SIG_EMIT[\"signalEmitter<br/>All signals\"]\n        SIG_BT[\"signalBacktestEmitter<br/>Backtest signals\"]\n        SIG_LIVE[\"signalLiveEmitter<br/>Live signals\"]\n        DONE_BT[\"doneBacktestSubject<br/>Backtest complete\"]\n        DONE_LIVE[\"doneLiveSubject<br/>Live complete\"]\n        DONE_WALK[\"doneWalkerSubject<br/>Walker complete\"]\n        PROG_BT[\"progressBacktestEmitter<br/>Frame progress\"]\n        PROG_WALK[\"walkerEmitter<br/>Strategy progress\"]\n        WALK_COMP[\"walkerCompleteSubject<br/>Final results\"]\n        RISK_EMIT[\"riskSubject<br/>Rejected signals\"]\n        PERF[\"performanceEmitter<br/>Timing metrics\"]\n        PP[\"partialProfitSubject<br/>Profit milestones\"]\n        PL[\"partialLossSubject<br/>Loss milestones\"]\n        ERR[\"errorEmitter<br/>Recoverable errors\"]\n        EXIT[\"exitEmitter<br/>Fatal errors\"]\n    end\n    \n    subgraph \"Listen Functions\"\n        LISTEN[\"listenSignal()<br/>listenSignalBacktest()<br/>listenSignalLive()<br/>listenDone*()<br/>listenBacktestProgress()<br/>listenWalkerProgress()<br/>listenRisk()<br/>listenPerformance()<br/>listenPartialProfit()<br/>listenPartialLoss()<br/>listenError()<br/>listenExit()\"]\n        \n        QUEUED[\"functools-kit queued()<br/>Sequential async execution<br/>Prevents concurrent callbacks\"]\n    end\n    \n    STRAT --> SIG_EMIT\n    STRAT --> SIG_BT\n    STRAT --> SIG_LIVE\n    \n    BT --> DONE_BT\n    BT --> PROG_BT\n    BT --> PERF\n    \n    LIVE --> DONE_LIVE\n    LIVE --> PERF\n    \n    WALK --> DONE_WALK\n    WALK --> PROG_WALK\n    WALK --> WALK_COMP\n    \n    RISK --> RISK_EMIT\n    PARTIAL --> PP\n    PARTIAL --> PL\n    \n    STRAT --> ERR\n    BT --> ERR\n    LIVE --> ERR\n    WALK --> EXIT\n    \n    SIG_EMIT --> LISTEN\n    SIG_BT --> LISTEN\n    SIG_LIVE --> LISTEN\n    DONE_BT --> LISTEN\n    DONE_LIVE --> LISTEN\n    DONE_WALK --> LISTEN\n    PROG_BT --> LISTEN\n    PROG_WALK --> LISTEN\n    WALK_COMP --> LISTEN\n    RISK_EMIT --> LISTEN\n    PERF --> LISTEN\n    PP --> LISTEN\n    PL --> LISTEN\n    ERR --> LISTEN\n    EXIT --> LISTEN\n    \n    LISTEN --> QUEUED\n```\n\n**Event Subscription Pattern:**\n\n1. **Event Producers** emit events during execution (strategies, backtests, live trading, walkers)\n2. **Event Emitters** broadcast events to registered listeners using Subject pattern\n3. **Listen Functions** register callbacks with emitters\n4. **Queued Wrapper** ensures sequential async callback execution (prevents race conditions)\n\nAll listener callbacks are wrapped with `functools-kit` `queued()` to ensure sequential execution even when multiple events fire rapidly.\n\n**Sources:** [README.md:173-176](), [docs/index.md:107-134]()\n\n---\n\n### Signal Event Listeners\n\n**listenSignal / listenSignalOnce:**\n```typescript\nlistenSignal(callback: (signal: ISignalRow) => void | Promise<void>): void\nlistenSignalOnce(callback: (signal: ISignalRow) => void | Promise<void>): void\n```\n\nListens to all signal events (backtest and live). `listenSignalOnce` unsubscribes after first event.\n\n**listenSignalBacktest / listenSignalBacktestOnce:**\n```typescript\nlistenSignalBacktest(callback: (signal: ISignalRow) => void | Promise<void>): void\nlistenSignalBacktestOnce(callback: (signal: ISignalRow) => void | Promise<void>): void\n```\n\nListens to backtest signal events only.\n\n**listenSignalLive / listenSignalLiveOnce:**\n```typescript\nlistenSignalLive(callback: (signal: ISignalRow) => void | Promise<void>): void\nlistenSignalLiveOnce(callback: (signal: ISignalRow) => void | Promise<void>): void\n```\n\nListens to live trading signal events only.\n\n**Example:**\n```typescript\nimport { listenSignal, listenSignalBacktest, Backtest } from 'backtest-kit';\n\nlistenSignal((signal) => {\n  console.log(`[${signal.symbol}] ${signal.position} at ${signal.priceOpen}`);\n});\n\nlistenSignalBacktest((signal) => {\n  if (signal.closeReason === 'take_profit') {\n    console.log(`TP hit: ${signal.pnl}`);\n  }\n});\n\nBacktest.background('BTCUSDT', {\n  strategyName: 'my-strategy',\n  exchangeName: 'binance',\n  frameName: '1d-test',\n});\n```\n\n**Sources:** [docs/index.md:107-112]()\n\n---\n\n### Completion Event Listeners\n\n**listenDoneBacktest / listenDoneBacktestOnce:**\n```typescript\nlistenDoneBacktest(callback: (event: DoneContract) => void | Promise<void>): void\nlistenDoneBacktestOnce(callback: (event: DoneContract) => void | Promise<void>): void\n```\n\nListens to backtest completion events.\n\n**listenDoneLive / listenDoneLiveOnce:**\n```typescript\nlistenDoneLive(callback: (event: DoneContract) => void | Promise<void>): void\nlistenDoneLiveOnce(callback: (event: DoneContract) => void | Promise<void>): void\n```\n\nListens to live trading completion events (graceful shutdown).\n\n**listenDoneWalker / listenDoneWalkerOnce:**\n```typescript\nlistenDoneWalker(callback: (event: DoneContract) => void | Promise<void>): void\nlistenDoneWalkerOnce(callback: (event: DoneContract) => void | Promise<void>): void\n```\n\nListens to walker completion events.\n\n**DoneContract Structure:**\n```typescript\ninterface DoneContract {\n  symbol: string;\n  strategyName: string;\n  exchangeName?: string;\n  frameName?: string;\n  backtest: boolean;\n}\n```\n\n**Example:**\n```typescript\nimport { listenDoneBacktest, Backtest } from 'backtest-kit';\n\nlistenDoneBacktest(async (event) => {\n  console.log(`Backtest complete: ${event.symbol} - ${event.strategyName}`);\n  await Backtest.dump(event.symbol, event.strategyName);\n});\n```\n\n**Sources:** [docs/index.md:115-120](), [README.md:156-159]()\n\n---\n\n### Progress Event Listeners\n\n**listenBacktestProgress:**\n```typescript\nlistenBacktestProgress(callback: (event: ProgressBacktestContract) => void | Promise<void>): void\n```\n\nListens to backtest frame completion progress.\n\n**ProgressBacktestContract:**\n```typescript\ninterface ProgressBacktestContract {\n  symbol: string;\n  strategyName: string;\n  exchangeName: string;\n  frameName: string;\n  currentFrame: number;\n  totalFrames: number;\n  percentage: number;\n}\n```\n\n**listenWalkerProgress:**\n```typescript\nlistenWalkerProgress(callback: (event: ProgressWalkerContract) => void | Promise<void>): void\n```\n\nListens to walker strategy comparison progress.\n\n**ProgressWalkerContract:**\n```typescript\ninterface ProgressWalkerContract {\n  walkerName: string;\n  symbol: string;\n  currentStrategy: string;\n  currentStrategyIndex: number;\n  totalStrategies: number;\n  percentage: number;\n}\n```\n\n**listenOptimizerProgress:**\n```typescript\nlistenOptimizerProgress(callback: (event: ProgressOptimizerContract) => void | Promise<void>): void\n```\n\nListens to optimizer data collection progress.\n\n**Example:**\n```typescript\nimport { listenBacktestProgress, Backtest } from 'backtest-kit';\n\nlistenBacktestProgress((event) => {\n  console.log(`Progress: ${event.percentage.toFixed(2)}% (${event.currentFrame}/${event.totalFrames})`);\n});\n```\n\n**Sources:** [docs/index.md:121-123]()\n\n---\n\n### Risk Event Listeners\n\n**listenRisk / listenRiskOnce:**\n```typescript\nlistenRisk(callback: (event: RiskContract) => void | Promise<void>): void\nlistenRiskOnce(callback: (event: RiskContract) => void | Promise<void>): void\n```\n\nListens to risk validation rejection events.\n\n**RiskContract:**\n```typescript\ninterface RiskContract {\n  symbol: string;\n  strategyName: string;\n  reason: string;\n  timestamp: Date;\n}\n```\n\n**Example:**\n```typescript\nimport { listenRisk } from 'backtest-kit';\n\nlistenRisk((event) => {\n  console.log(`[RISK] ${event.symbol}: ${event.reason}`);\n});\n```\n\n**Sources:** [docs/index.md:133-134]()\n\n---\n\n### Partial Event Listeners\n\n**listenPartialProfit / listenPartialProfitOnce:**\n```typescript\nlistenPartialProfit(callback: (event: PartialProfitContract) => void | Promise<void>): void\nlistenPartialProfitOnce(callback: (event: PartialProfitContract) => void | Promise<void>): void\n```\n\nListens to profit milestone events (10%, 20%, 30%, etc.).\n\n**listenPartialLoss / listenPartialLossOnce:**\n```typescript\nlistenPartialLoss(callback: (event: PartialLossContract) => void | Promise<void>): void\nlistenPartialLossOnce(callback: (event: PartialLossContract) => void | Promise<void>): void\n```\n\nListens to loss milestone events (-10%, -20%, -30%, etc.).\n\n**PartialProfitContract / PartialLossContract:**\n```typescript\ninterface PartialProfitContract {\n  symbol: string;\n  strategyName: string;\n  level: number;           // Milestone level (10, 20, 30, ...)\n  currentPnlPercentage: number;\n  signal: ISignalRow;\n  timestamp: Date;\n}\n```\n\n**Example:**\n```typescript\nimport { listenPartialProfit, listenPartialLoss } from 'backtest-kit';\n\nlistenPartialProfit((event) => {\n  console.log(`[PROFIT] ${event.symbol}: +${event.currentPnlPercentage.toFixed(2)}%`);\n});\n\nlistenPartialLoss((event) => {\n  console.log(`[LOSS] ${event.symbol}: ${event.currentPnlPercentage.toFixed(2)}%`);\n});\n```\n\n**Sources:** [docs/index.md:129-132]()\n\n---\n\n### Performance Event Listeners\n\n**listenPerformance:**\n```typescript\nlistenPerformance(callback: (event: PerformanceContract) => void | Promise<void>): void\n```\n\nListens to execution timing metrics for profiling.\n\n**PerformanceContract:**\n```typescript\ninterface PerformanceContract {\n  metricType: PerformanceMetricType;\n  symbol: string;\n  strategyName: string;\n  duration: number;\n  timestamp: Date;\n}\n\ntype PerformanceMetricType = 'tick' | 'backtest' | 'getSignal' | 'getCandles';\n```\n\n**Example:**\n```typescript\nimport { listenPerformance } from 'backtest-kit';\n\nlistenPerformance((event) => {\n  if (event.duration > 1000) {\n    console.warn(`[PERF] Slow ${event.metricType}: ${event.duration}ms`);\n  }\n});\n```\n\n**Sources:** [docs/index.md:124]()\n\n---\n\n### Error Event Listeners\n\n**listenError:**\n```typescript\nlistenError(callback: (error: Error) => void | Promise<void>): void\n```\n\nListens to recoverable errors (execution continues).\n\n**listenExit:**\n```typescript\nlistenExit(callback: (error: Error) => void | Promise<void>): void\n```\n\nListens to fatal errors (execution terminates).\n\n**Example:**\n```typescript\nimport { listenError, listenExit } from 'backtest-kit';\n\nlistenError((error) => {\n  console.error('[ERROR] Recoverable:', error.message);\n});\n\nlistenExit((error) => {\n  console.error('[FATAL] Terminating:', error.message);\n  process.exit(1);\n});\n```\n\n**Sources:** [docs/index.md:113-114]()\n\n---\n\n### Walker Event Listeners\n\n**listenWalker / listenWalkerOnce:**\n```typescript\nlistenWalker(callback: (event: WalkerContract) => void | Promise<void>): void\nlistenWalkerOnce(callback: (event: WalkerContract) => void | Promise<void>): void\n```\n\nListens to walker strategy comparison events.\n\n**listenWalkerComplete:**\n```typescript\nlistenWalkerComplete(callback: (event: WalkerCompleteContract) => void | Promise<void>): void\n```\n\nListens to walker final results with ranked strategies.\n\n**WalkerCompleteContract:**\n```typescript\ninterface WalkerCompleteContract {\n  walkerName: string;\n  symbol: string;\n  bestStrategy: string;\n  bestMetricValue: number;\n  results: IWalkerResults[];\n}\n```\n\n**Example:**\n```typescript\nimport { listenWalkerComplete, Walker } from 'backtest-kit';\n\nlistenWalkerComplete((event) => {\n  console.log(`Best strategy: ${event.bestStrategy}`);\n  console.log(`Metric value: ${event.bestMetricValue}`);\n  \n  event.results.forEach((result, index) => {\n    console.log(`${index + 1}. ${result.strategyName}: ${result.metricValue}`);\n  });\n});\n\nWalker.background('BTCUSDT', { walkerName: 'llm-optimizer' });\n```\n\n**Sources:** [docs/index.md:125-127]()\n\n---\n\n## Context Access Functions\n\nContext access functions retrieve ambient execution state propagated via `AsyncLocalStorage`. These functions work within strategy code and callbacks.\n\n```mermaid\ngraph TB\n    subgraph \"Execution Entry Points\"\n        BT_RUN[\"Backtest.run()<br/>Backtest.background()\"]\n        LIVE_RUN[\"Live.run()<br/>Live.background()\"]\n    end\n    \n    subgraph \"Context Setup\"\n        SET_EXEC[\"ExecutionContextService.run()<br/>Set: symbol, when, backtest\"]\n        SET_METHOD[\"MethodContextService.run()<br/>Set: strategyName, exchangeName, frameName\"]\n    end\n    \n    subgraph \"Strategy Execution\"\n        GET_SIGNAL[\"getSignal(symbol, when)\"]\n        CALLBACKS[\"Strategy callbacks<br/>onOpen, onClose, etc.\"]\n    end\n    \n    subgraph \"Context Access Functions\"\n        GET_DATE[\"getDate()<br/>Returns: Date\"]\n        GET_MODE[\"getMode()<br/>Returns: boolean\"]\n    end\n    \n    subgraph \"Context Services (AsyncLocalStorage)\"\n        EXEC_CTX[\"ExecutionContextService<br/>{ symbol, when, backtest }\"]\n        METHOD_CTX[\"MethodContextService<br/>{ strategyName, exchangeName, frameName }\"]\n    end\n    \n    BT_RUN --> SET_EXEC\n    LIVE_RUN --> SET_EXEC\n    \n    SET_EXEC --> SET_METHOD\n    SET_METHOD --> GET_SIGNAL\n    SET_METHOD --> CALLBACKS\n    \n    GET_SIGNAL --> GET_DATE\n    GET_SIGNAL --> GET_MODE\n    CALLBACKS --> GET_DATE\n    CALLBACKS --> GET_MODE\n    \n    GET_DATE --> EXEC_CTX\n    GET_MODE --> EXEC_CTX\n```\n\n**Context Propagation:**\n\n1. **Execution Entry** (Backtest/Live) initializes execution context\n2. **Context Services** store ambient state in `AsyncLocalStorage`\n3. **Strategy Code** accesses context via global functions\n4. **No Parameters Required** - context is automatically available\n\n**Sources:** [docs/index.md:139-140]()\n\n---\n\n### getDate\n\n```typescript\ngetDate(): Date\n```\n\nReturns the current execution timestamp from `ExecutionContextService`. In backtest mode, this is the current frame timestamp. In live mode, this is `new Date()`.\n\n**Example:**\n```typescript\nimport { addStrategy, getDate } from 'backtest-kit';\n\naddStrategy({\n  strategyName: \"time-aware\",\n  interval: \"5m\",\n  getSignal: async (symbol) => {\n    const when = getDate();\n    const hour = when.getHours();\n    \n    if (hour < 8 || hour > 20) {\n      return null;  // Don't trade outside market hours\n    }\n    \n    // Generate signal...\n  },\n});\n```\n\n**Internal Access:**\n`getDate()` retrieves `when` from `ExecutionContextService.context.when` ([src/services/context/ExecutionContextService]()).\n\n**Sources:** [docs/index.md:139]()\n\n---\n\n### getMode\n\n```typescript\ngetMode(): boolean\n```\n\nReturns the execution mode flag from `ExecutionContextService`. Returns `true` for backtest mode, `false` for live mode.\n\n**Example:**\n```typescript\nimport { addStrategy, getMode } from 'backtest-kit';\n\naddStrategy({\n  strategyName: \"mode-aware\",\n  interval: \"5m\",\n  callbacks: {\n    onOpen: (symbol, signal, currentPrice, backtest) => {\n      const isBacktest = getMode();\n      \n      if (isBacktest) {\n        console.log('[BACKTEST] Signal opened');\n      } else {\n        // Send notification to live trading system\n        sendNotification(`[LIVE] ${symbol} opened at ${currentPrice}`);\n      }\n    },\n  },\n  getSignal: async (symbol) => {\n    // Generate signal...\n  },\n});\n```\n\n**Internal Access:**\n`getMode()` retrieves `backtest` from `ExecutionContextService.context.backtest` ([src/services/context/ExecutionContextService]()).\n\n**Sources:** [docs/index.md:140]()\n\n---\n\n## Exchange Utility Functions\n\nExchange utility functions provide access to candle data and formatting methods. These functions retrieve the exchange from context and delegate to `ClientExchange` methods.\n\n```mermaid\ngraph TB\n    subgraph \"Utility Functions\"\n        GET_CANDLES[\"getCandles(symbol, interval, limit)\"]\n        GET_AVG[\"getAveragePrice(symbol)\"]\n        FMT_PRICE[\"formatPrice(symbol, price)\"]\n        FMT_QTY[\"formatQuantity(symbol, quantity)\"]\n    end\n    \n    subgraph \"Context Resolution\"\n        METHOD_CTX[\"MethodContextService<br/>Get: exchangeName\"]\n    end\n    \n    subgraph \"Connection Service\"\n        EXCH_CONN[\"ExchangeConnectionService<br/>Memoized factory\"]\n    end\n    \n    subgraph \"Client Layer\"\n        CLIENT_EXCH[\"ClientExchange<br/>CCXT integration<br/>VWAP calculation\"]\n    end\n    \n    subgraph \"Exchange Schema\"\n        SCHEMA[\"IExchangeSchema<br/>User-defined functions\"]\n    end\n    \n    subgraph \"External API\"\n        CCXT[\"CCXT Library<br/>fetchOHLCV()\"]\n        DB[\"Database<br/>Custom data source\"]\n    end\n    \n    GET_CANDLES --> METHOD_CTX\n    GET_AVG --> METHOD_CTX\n    FMT_PRICE --> METHOD_CTX\n    FMT_QTY --> METHOD_CTX\n    \n    METHOD_CTX --> EXCH_CONN\n    EXCH_CONN --> CLIENT_EXCH\n    \n    CLIENT_EXCH --> SCHEMA\n    SCHEMA --> CCXT\n    SCHEMA --> DB\n```\n\n**Utility Function Flow:**\n\n1. **Utility Function** called from strategy code\n2. **MethodContext** provides current `exchangeName`\n3. **ExchangeConnectionService** retrieves cached `ClientExchange` instance\n4. **ClientExchange** delegates to user-defined schema functions\n5. **Schema Functions** fetch data from CCXT or custom sources\n\n**Sources:** [docs/index.md:135-138]()\n\n---\n\n### getCandles\n\n```typescript\ngetCandles(\n  symbol: string,\n  interval: CandleInterval,\n  limit: number\n): Promise<ICandleData[]>\n```\n\nFetches historical candle data for the specified symbol and interval. In backtest mode, returns candles up to the current frame timestamp (prevents look-ahead bias). In live mode, returns the most recent candles.\n\n**Parameters:**\n- `symbol: string` - Trading pair symbol (e.g., \"BTCUSDT\")\n- `interval: CandleInterval` - Candle interval (e.g., \"1h\", \"15m\")\n- `limit: number` - Maximum number of candles to fetch\n\n**CandleInterval:**\n`\"1m\"` | `\"3m\"` | `\"5m\"` | `\"15m\"` | `\"30m\"` | `\"1h\"` | `\"2h\"` | `\"4h\"` | `\"6h\"` | `\"8h\"` | `\"12h\"` | `\"1d\"` | `\"3d\"`\n\n**Returns:**\nArray of `ICandleData` objects sorted by timestamp ascending.\n\n**Example:**\n```typescript\nimport { addStrategy, getCandles } from 'backtest-kit';\n\naddStrategy({\n  strategyName: \"sma-crossover\",\n  interval: \"5m\",\n  getSignal: async (symbol) => {\n    const candles1h = await getCandles(symbol, \"1h\", 50);\n    const candles15m = await getCandles(symbol, \"15m\", 100);\n    \n    const sma20 = calculateSMA(candles1h, 20);\n    const sma50 = calculateSMA(candles1h, 50);\n    \n    if (sma20 > sma50) {\n      return {\n        position: \"long\",\n        priceTakeProfit: candles1h[candles1h.length - 1].close * 1.02,\n        priceStopLoss: candles1h[candles1h.length - 1].close * 0.99,\n        minuteEstimatedTime: 60,\n        timestamp: Date.now(),\n      };\n    }\n    \n    return null;\n  },\n});\n```\n\n**Temporal Context Guarantee:**\nIn backtest mode, `getCandles()` automatically enforces temporal context by only returning candles with `timestamp <= currentFrameTimestamp`. This architecturally prevents look-ahead bias - strategies cannot access future data.\n\n**Internal Flow:**\n1. Retrieves `exchangeName` from `MethodContextService`\n2. Gets cached `ClientExchange` via `ExchangeConnectionService`\n3. Calls `ClientExchange.getCandles()` which delegates to user-defined `IExchangeSchema.getCandles()`\n4. Applies temporal filtering in backtest mode\n5. Validates candle data (anomaly detection, completeness checks)\n6. Returns filtered candles\n\n**Sources:** [docs/index.md:135](), [README.md:189-198](), [README.md:123-127]()\n\n---\n\n### getAveragePrice\n\n```typescript\ngetAveragePrice(symbol: string): Promise<number>\n```\n\nReturns the current VWAP (Volume Weighted Average Price) for the symbol. By default, calculates VWAP from the last 5 1-minute candles. Can be overridden via `IExchangeSchema.getAveragePrice()`.\n\n**Parameters:**\n- `symbol: string` - Trading pair symbol\n\n**Returns:**\nVWAP price as a number.\n\n**VWAP Calculation:**\n```\nVWAP = Σ(price * volume) / Σ(volume)\nwhere price = (high + low + close) / 3\n```\n\n**Example:**\n```typescript\nimport { addStrategy, getAveragePrice } from 'backtest-kit';\n\naddStrategy({\n  strategyName: \"vwap-entry\",\n  interval: \"5m\",\n  getSignal: async (symbol) => {\n    const vwap = await getAveragePrice(symbol);\n    const lastPrice = await getLastPrice(symbol);\n    \n    if (lastPrice < vwap * 0.99) {\n      return {\n        position: \"long\",\n        priceTakeProfit: vwap * 1.01,\n        priceStopLoss: lastPrice * 0.98,\n        minuteEstimatedTime: 30,\n        timestamp: Date.now(),\n      };\n    }\n    \n    return null;\n  },\n});\n```\n\n**Internal Flow:**\n1. Retrieves `exchangeName` from `MethodContextService`\n2. Gets cached `ClientExchange` via `ExchangeConnectionService`\n3. If `IExchangeSchema.getAveragePrice()` defined, calls it\n4. Otherwise, fetches last 5 1m candles and calculates VWAP\n5. Returns VWAP price\n\n**Sources:** [docs/index.md:136]()\n\n---\n\n### formatPrice\n\n```typescript\nformatPrice(symbol: string, price: number): Promise<string>\n```\n\nFormats price according to exchange-specific precision rules.\n\n**Parameters:**\n- `symbol: string` - Trading pair symbol\n- `price: number` - Price to format\n\n**Returns:**\nFormatted price string.\n\n**Example:**\n```typescript\nimport { addStrategy, formatPrice } from 'backtest-kit';\n\naddStrategy({\n  strategyName: \"order-placer\",\n  interval: \"5m\",\n  callbacks: {\n    onOpen: async (symbol, signal, currentPrice) => {\n      const formattedPrice = await formatPrice(symbol, currentPrice);\n      console.log(`Order placed at ${formattedPrice}`);\n    },\n  },\n  getSignal: async (symbol) => {\n    // Generate signal...\n  },\n});\n```\n\n**Internal Flow:**\n1. Retrieves `exchangeName` from `MethodContextService`\n2. Gets cached `ClientExchange` via `ExchangeConnectionService`\n3. Calls `ClientExchange.formatPrice()` which delegates to `IExchangeSchema.formatPrice()`\n4. Returns formatted string\n\n**Sources:** [docs/index.md:137]()\n\n---\n\n### formatQuantity\n\n```typescript\nformatQuantity(symbol: string, quantity: number): Promise<string>\n```\n\nFormats quantity according to exchange-specific precision rules.\n\n**Parameters:**\n- `symbol: string` - Trading pair symbol\n- `quantity: number` - Quantity to format\n\n**Returns:**\nFormatted quantity string.\n\n**Example:**\n```typescript\nimport { addStrategy, formatQuantity } from 'backtest-kit';\n\naddStrategy({\n  strategyName: \"order-placer\",\n  interval: \"5m\",\n  callbacks: {\n    onOpen: async (symbol, signal) => {\n      const formattedQty = await formatQuantity(symbol, signal.quantity);\n      console.log(`Quantity: ${formattedQty}`);\n    },\n  },\n  getSignal: async (symbol) => {\n    // Generate signal...\n  },\n});\n```\n\n**Internal Flow:**\n1. Retrieves `exchangeName` from `MethodContextService`\n2. Gets cached `ClientExchange` via `ExchangeConnectionService`\n3. Calls `ClientExchange.formatQuantity()` which delegates to `IExchangeSchema.formatQuantity()`\n4. Returns formatted string\n\n**Sources:** [docs/index.md:138]()\n\n---\n\n## Debugging Functions\n\n### dumpSignal\n\n```typescript\ndumpSignal(\n  id: string,\n  messages: any,\n  signal: any\n): Promise<void>\n```\n\nLogs LLM conversation history and generated signal to file system for analysis and debugging. Creates structured JSON files in `./dump/signals/` directory.\n\n**Parameters:**\n- `id: string` - Unique identifier for the dump file\n- `messages: any` - LLM conversation messages (OpenAI format)\n- `signal: any` - Generated signal object\n\n**Output File Structure:**\n```\n./dump/signals/{id}.json\n{\n  \"id\": \"uuid-v4\",\n  \"timestamp\": \"2024-01-01T12:00:00.000Z\",\n  \"messages\": [...],\n  \"signal\": {...}\n}\n```\n\n**Example:**\n```typescript\nimport { addStrategy, dumpSignal, getCandles } from 'backtest-kit';\nimport { v4 as uuid } from 'uuid';\nimport { Ollama } from 'ollama';\n\nconst ollama = new Ollama({ host: 'http://localhost:11434' });\n\naddStrategy({\n  strategyName: \"llm-strategy\",\n  interval: \"5m\",\n  getSignal: async (symbol) => {\n    const candles = await getCandles(symbol, \"1h\", 24);\n    \n    const messages = [\n      { role: 'system', content: 'You are a trading strategy generator.' },\n      { role: 'user', content: JSON.stringify(candles) },\n    ];\n    \n    const response = await ollama.chat({\n      model: 'deepseek-v3.1:671b',\n      messages,\n    });\n    \n    const signal = JSON.parse(response.message.content);\n    const resultId = uuid();\n    \n    await dumpSignal(resultId, messages, signal);\n    \n    return { ...signal, id: resultId };\n  },\n});\n```\n\n**Use Cases:**\n- Debugging LLM-generated strategies\n- Analyzing conversation context and outputs\n- Auditing signal generation decisions\n- Training data collection\n\n**Sources:** [docs/index.md:141](), [README.md:136-140]()\n\n---\n\n## Summary Tables\n\n### Function Categories Summary\n\n| Category | Count | Primary Use Cases |\n|----------|-------|-------------------|\n| Configuration | 7 | System setup, logging, validation thresholds |\n| Registration | 7 | Component definition and storage |\n| Query | 7 | Listing registered components |\n| Event Subscription | 20+ | Real-time monitoring, callbacks |\n| Context Access | 2 | Ambient state retrieval |\n| Exchange Utilities | 4 | Data fetching, formatting |\n| Debugging | 1 | LLM conversation logging |\n\n---\n\n### Service Layer Mapping\n\n| Global Function | Service Layer Access Path | Purpose |\n|----------------|---------------------------|---------|\n| `addStrategy()` | `backtest.strategyValidationService` → `backtest.strategySchemaService` | Validate and store strategy schema |\n| `addExchange()` | `backtest.exchangeValidationService` → `backtest.exchangeSchemaService` | Validate and store exchange schema |\n| `addFrame()` | `backtest.frameValidationService` → `backtest.frameSchemaService` | Validate and store frame schema |\n| `addRisk()` | `backtest.riskValidationService` → `backtest.riskSchemaService` | Validate and store risk schema |\n| `addWalker()` | `backtest.walkerValidationService` → `backtest.walkerSchemaService` | Validate and store walker schema |\n| `addSizing()` | `backtest.sizingValidationService` → `backtest.sizingSchemaService` | Validate and store sizing schema |\n| `addOptimizer()` | `backtest.optimizerValidationService` → `backtest.optimizerSchemaService` | Validate and store optimizer schema |\n| `listExchanges()` | `backtest.exchangeValidationService.list()` | Query exchange schemas |\n| `listStrategies()` | `backtest.strategyValidationService.list()` | Query strategy schemas |\n| `getCandles()` | `backtest.methodContextService` → `backtest.exchangeConnectionService` → `ClientExchange` | Fetch candle data |\n| `getDate()` | `backtest.executionContextService.context.when` | Retrieve execution timestamp |\n| `getMode()` | `backtest.executionContextService.context.backtest` | Retrieve execution mode flag |\n\n**Sources:** [src/lib/index.ts:225-246](), [src/lib/core/types.ts:1-105](), [src/lib/core/provide.ts:1-143]()"
                    },
                    {
                        "page_plan": {
                            "id": "12.2",
                            "title": "Execution Classes API"
                        },
                        "content": "# Execution Classes API\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [docs/classes/StrategyConnectionService.md](docs/classes/StrategyConnectionService.md)\n- [docs/index.md](docs/index.md)\n- [docs/interfaces/IStrategy.md](docs/interfaces/IStrategy.md)\n- [docs/interfaces/IStrategySchema.md](docs/interfaces/IStrategySchema.md)\n- [docs/types/IStrategyBacktestResult.md](docs/types/IStrategyBacktestResult.md)\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Heat.ts](src/classes/Heat.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Partial.ts](src/classes/Partial.ts)\n- [src/classes/Performance.ts](src/classes/Performance.ts)\n- [src/classes/Risk.ts](src/classes/Risk.ts)\n- [src/classes/Schedule.ts](src/classes/Schedule.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [test/spec/columns.test.mjs](test/spec/columns.test.mjs)\n\n</details>\n\n\n\nThis page documents the public execution classes that orchestrate backtest, live trading, and strategy comparison operations. These are the primary entry points for running trading strategies after configuration via global functions (see [Global Functions](#12.1)).\n\nFor specialized reporting and monitoring classes (Performance, Heat, Risk, Schedule, Partial), see [Reporting Classes API](#12.3).\n\n---\n\n## Architecture: Instance-Utils Pattern\n\nThe framework uses a dual-class pattern for each execution mode. Every execution class consists of:\n\n1. **Instance class** (`BacktestInstance`, `LiveInstance`, `WalkerInstance`) - Manages execution for a specific symbol-strategy pair with isolated state\n2. **Utils class** (`BacktestUtils`, `LiveUtils`, `WalkerUtils`) - Singleton wrapper providing validation, instance memoization, and convenient API surface\n3. **Exported singleton** (`Backtest`, `Live`, `Walker`) - Single instance of Utils class for application-wide use\n\n```mermaid\ngraph TB\n    subgraph \"Public API\"\n        BacktestSingleton[\"Backtest (singleton)<br/>BacktestUtils instance\"]\n        LiveSingleton[\"Live (singleton)<br/>LiveUtils instance\"]\n        WalkerSingleton[\"Walker (singleton)<br/>WalkerUtils instance\"]\n    end\n    \n    subgraph \"Utils Layer - Validation & Routing\"\n        BacktestUtils[\"BacktestUtils<br/>- Schema validation<br/>- Risk validation<br/>- Instance memoization\"]\n        LiveUtils[\"LiveUtils<br/>- Schema validation<br/>- Risk validation<br/>- Instance memoization\"]\n        WalkerUtils[\"WalkerUtils<br/>- Schema validation<br/>- Multi-strategy validation<br/>- Instance memoization\"]\n    end\n    \n    subgraph \"Instance Layer - Execution State\"\n        BacktestInstance[\"BacktestInstance<br/>- _isStopped flag<br/>- _isDone flag<br/>- task (singlerun)<br/>- id (random string)\"]\n        LiveInstance[\"LiveInstance<br/>- _isStopped flag<br/>- _isDone flag<br/>- task (singlerun)<br/>- id (random string)\"]\n        WalkerInstance[\"WalkerInstance<br/>- _isStopped flag<br/>- _isDone flag<br/>- task (singlerun)<br/>- id (random string)\"]\n    end\n    \n    subgraph \"Command Services\"\n        BacktestCommand[\"BacktestCommandService.run()<br/>Async generator\"]\n        LiveCommand[\"LiveCommandService.run()<br/>Infinite async generator\"]\n        WalkerCommand[\"WalkerCommandService.run()<br/>Async generator\"]\n    end\n    \n    BacktestSingleton --> BacktestUtils\n    LiveSingleton --> LiveUtils\n    WalkerSingleton --> WalkerUtils\n    \n    BacktestUtils -->|\"_getInstance(symbol, strategyName)\"| BacktestInstance\n    LiveUtils -->|\"_getInstance(symbol, strategyName)\"| LiveInstance\n    WalkerUtils -->|\"_getInstance(symbol, walkerName)\"| WalkerInstance\n    \n    BacktestInstance --> BacktestCommand\n    LiveInstance --> LiveCommand\n    WalkerInstance --> WalkerCommand\n```\n\n**Instance Memoization**\n\nEach Utils class maintains a memoized factory that caches Instance objects by key:\n- **Backtest/Live**: Key is `\"${symbol}:${strategyName}\"` (e.g., `\"BTCUSDT:my-strategy\"`)\n- **Walker**: Key is `\"${symbol}:${walkerName}\"` (e.g., `\"BTCUSDT:my-walker\"`)\n\nThis ensures that multiple calls to `run()` or `background()` for the same symbol-strategy pair reuse the same Instance object, preserving execution state across calls.\n\nSources: [src/classes/Backtest.ts:359-399](), [src/classes/Live.ts:376-417](), [src/classes/Walker.ts:431-471]()\n\n---\n\n## Common Patterns\n\nAll execution classes share these common patterns:\n\n### Method Signatures\n\n| Method | Returns | Description |\n|--------|---------|-------------|\n| `run(symbol, context)` | `AsyncGenerator` | Executes and yields results incrementally |\n| `background(symbol, context)` | `() => void` | Executes without yielding, returns cancellation function |\n| `stop(symbol, identifier)` | `Promise<void>` | Stops strategy from opening new signals |\n| `getData(symbol, identifier)` | `Promise<Statistics>` | Retrieves aggregated statistics |\n| `getReport(symbol, identifier, columns?)` | `Promise<string>` | Generates markdown report |\n| `dump(symbol, identifier, path?, columns?)` | `Promise<void>` | Saves report to disk |\n| `list()` | `Promise<StatusObject[]>` | Lists all active instances |\n\n**Context Variations:**\n- **Backtest**: `{ strategyName, exchangeName, frameName }`\n- **Live**: `{ strategyName, exchangeName }`\n- **Walker**: `{ walkerName }` (exchange/frame pulled from walker schema)\n\n### State Management\n\n```mermaid\nstateDiagram-v2\n    [*] --> Idle: Instance created\n    \n    Idle --> Running: run() or background() called\n    \n    Running --> Stopped: stop() called\n    Running --> Done: Execution completes naturally\n    \n    Stopped --> Done: Active signal closes\n    \n    Done --> [*]\n    \n    note right of Running\n        _isStopped = false\n        _isDone = false\n        task.getStatus() = \"running\"\n    end note\n    \n    note right of Stopped\n        _isStopped = true\n        _isDone = false\n        Prevents new signals\n        Active signal continues\n    end note\n    \n    note right of Done\n        _isStopped = true or false\n        _isDone = true\n        task.getStatus() = \"done\"\n        doneSubject emitted\n    end note\n```\n\nEach Instance maintains:\n- `id`: Randomly generated string for tracking\n- `_isStopped`: Manual stop flag preventing new signals\n- `_isDone`: Completion flag indicating execution finished\n- `task`: Singlerun-wrapped function ensuring single concurrent execution\n\nSources: [src/classes/Backtest.ts:74-93](), [src/classes/Live.ts:79-98](), [src/classes/Walker.ts:72-91]()\n\n### Task Execution Flow\n\n```mermaid\ngraph TD\n    UtilsMethod[\"Utils.run() or Utils.background()\"]\n    Validation[\"Schema Validation<br/>- strategyValidationService<br/>- exchangeValidationService<br/>- frameValidationService<br/>- riskValidationService\"]\n    GetInstance[\"_getInstance(symbol, identifier)<br/>Memoized factory returns<br/>cached or new Instance\"]\n    InstanceMethod[\"Instance.run() or Instance.background()\"]\n    ClearServices[\"Clear Services<br/>- backtestMarkdownService.clear()<br/>- scheduleMarkdownService.clear()<br/>- strategyCoreService.clear()<br/>- riskGlobalService.clear()\"]\n    CommandService[\"CommandService.run()<br/>Returns AsyncGenerator\"]\n    TaskWrapper[\"task = singlerun(INSTANCE_TASK_FN)<br/>Prevents concurrent execution\"]\n    ConsumeGenerator[\"Consume generator<br/>Check _isStopped flag<br/>on each iteration\"]\n    EmitDone[\"Emit doneSubject<br/>if not already done\"]\n    SetDone[\"Set _isDone = true\"]\n    \n    UtilsMethod --> Validation\n    Validation --> GetInstance\n    GetInstance --> InstanceMethod\n    InstanceMethod --> ClearServices\n    ClearServices --> CommandService\n    \n    CommandService --> TaskWrapper\n    TaskWrapper --> ConsumeGenerator\n    ConsumeGenerator --> EmitDone\n    EmitDone --> SetDone\n```\n\nSources: [src/classes/Backtest.ts:26-53](), [src/classes/Live.ts:31-57](), [src/classes/Walker.ts:27-53]()\n\n---\n\n## Backtest Class\n\nThe `Backtest` class provides historical simulation with deterministic time progression.\n\n### Core Methods\n\n#### run()\n\nExecutes backtest and yields closed signals as they occur.\n\n```typescript\nBacktest.run(\n  symbol: string,\n  context: {\n    strategyName: string;\n    exchangeName: string;\n    frameName: string;\n  }\n): AsyncGenerator<IStrategyTickResultClosed>\n```\n\n**Usage:**\n```typescript\nfor await (const result of Backtest.run(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\",\n  frameName: \"1d-backtest\"\n})) {\n  console.log(`Signal closed: ${result.pnl.pnlPercentage}%`);\n}\n```\n\n**Behavior:**\n- Iterates through timeframes defined by `frameName`\n- Yields only `IStrategyTickResultClosed` results (action: \"closed\")\n- Uses fast-backtest optimization to skip frames while signal is active\n- Stops when frame iteration completes or `stop()` is called\n\nSources: [src/classes/Backtest.ts:378-400](), [src/classes/Backtest.ts:149-178]()\n\n#### background()\n\nRuns backtest silently, consuming all results internally. Useful for side-effect-only execution (callbacks, logging).\n\n```typescript\nBacktest.background(\n  symbol: string,\n  context: {\n    strategyName: string;\n    exchangeName: string;\n    frameName: string;\n  }\n): () => void  // Returns cancellation function\n```\n\n**Usage:**\n```typescript\nconst cancel = Backtest.background(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\",\n  frameName: \"1d-backtest\"\n});\n\n// Later: cancel execution gracefully\ncancel();\n```\n\n**Behavior:**\n- Spawns async task via `task(symbol, context)`\n- Returns cancellation closure immediately\n- Cancellation checks for pending signal before emitting done event\n- Errors are caught and emitted to `exitEmitter`\n\nSources: [src/classes/Backtest.ts:423-443](), [src/classes/Backtest.ts:200-235]()\n\n#### stop()\n\nPrevents strategy from opening new signals. Active signal (if any) completes normally.\n\n```typescript\nBacktest.stop(\n  symbol: string,\n  strategyName: string\n): Promise<void>\n```\n\n**Usage:**\n```typescript\nawait Backtest.stop(\"BTCUSDT\", \"my-strategy\");\n```\n\n**Behavior:**\n- Calls `strategyCoreService.stop({ symbol, strategyName }, true)`\n- Sets internal flag in `ClientStrategy` instance\n- Does NOT force-close active signals\n- Backtest loop checks `_isStopped` after each frame and exits at next idle state\n\nSources: [src/classes/Backtest.ts:462-473](), [src/classes/Backtest.ts:254-260]()\n\n#### getData()\n\nRetrieves aggregated statistics from all closed signals.\n\n```typescript\nBacktest.getData(\n  symbol: string,\n  strategyName: string\n): Promise<BacktestStatisticsModel>\n```\n\n**Returns:**\n- `sharpeRatio`: Risk-adjusted return metric\n- `winRate`: Percentage of profitable trades\n- `totalPnl`: Cumulative profit/loss percentage\n- `maxDrawdown`: Largest peak-to-trough decline\n- `totalTrades`: Number of closed signals\n- Additional metrics (avg trade duration, profit factor, etc.)\n\nSources: [src/classes/Backtest.ts:488-499](), [src/classes/Backtest.ts:276-282]()\n\n#### getReport()\n\nGenerates markdown report with signal table and statistics summary.\n\n```typescript\nBacktest.getReport(\n  symbol: string,\n  strategyName: string,\n  columns?: Columns[]\n): Promise<string>\n```\n\n**Columns Parameter:**\nOptional array of `ColumnModel` objects to customize report columns. Each column specifies:\n- `key`: Unique column identifier\n- `label`: Column header text\n- `format`: Function to format cell value from signal data\n- `isVisible`: Function returning boolean for conditional visibility\n\n**Default Columns:** Signal ID, Symbol, Position, Open Price, Take Profit, Stop Loss, Close Price, PNL %, Close Reason, Open Time, Close Time, Duration, Note\n\nSources: [src/classes/Backtest.ts:515-526](), [src/classes/Backtest.ts:299-305](), [test/spec/columns.test.mjs:15-112]()\n\n#### dump()\n\nSaves markdown report to file.\n\n```typescript\nBacktest.dump(\n  symbol: string,\n  strategyName: string,\n  path?: string,\n  columns?: Columns[]\n): Promise<void>\n```\n\n**Default Path:** `./dump/backtest/{strategyName}.md`\n\nSources: [src/classes/Backtest.ts:545-561](), [src/classes/Backtest.ts:325-337]()\n\n#### list()\n\nLists all active backtest instances with their status.\n\n```typescript\nBacktest.list(): Promise<Array<{\n  id: string;\n  symbol: string;\n  strategyName: string;\n  status: \"idle\" | \"running\" | \"done\";\n}>>\n```\n\n**Usage:**\n```typescript\nconst instances = await Backtest.list();\ninstances.forEach(inst => {\n  console.log(`${inst.symbol}:${inst.strategyName} - ${inst.status}`);\n});\n```\n\nSources: [src/classes/Backtest.ts:576-579]()\n\n### Backtest Execution Flow\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant BacktestUtils\n    participant BacktestInstance\n    participant CommandService\n    participant MarkdownService\n    \n    User->>BacktestUtils: run(symbol, context)\n    BacktestUtils->>BacktestUtils: Validate schemas\n    BacktestUtils->>BacktestUtils: _getInstance(symbol, strategyName)\n    BacktestUtils->>BacktestInstance: run(symbol, context)\n    \n    BacktestInstance->>MarkdownService: clear(symbol, strategyName)\n    BacktestInstance->>CommandService: run(symbol, context)\n    CommandService-->>BacktestInstance: AsyncGenerator\n    \n    loop For each frame in timeframe\n        CommandService->>CommandService: tick(when, backtest=true)\n        CommandService->>MarkdownService: Emit signal events\n        CommandService-->>BacktestInstance: Yield closed signal\n        BacktestInstance-->>User: Yield closed signal\n    end\n    \n    CommandService->>CommandService: Emit doneBacktestSubject\n    CommandService-->>BacktestInstance: Generator completes\n    BacktestInstance->>BacktestInstance: Set _isDone = true\n```\n\nSources: [src/classes/Backtest.ts:149-178](), [src/classes/Backtest.ts:378-400]()\n\n---\n\n## Live Class\n\nThe `Live` class provides real-time trading execution with crash recovery support.\n\n### Core Methods\n\n#### run()\n\nExecutes live trading with infinite loop, yielding opened and closed signals.\n\n```typescript\nLive.run(\n  symbol: string,\n  context: {\n    strategyName: string;\n    exchangeName: string;\n  }\n): AsyncGenerator<IStrategyTickResultOpened | IStrategyTickResultClosed>\n```\n\n**Usage:**\n```typescript\nfor await (const result of Live.run(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\"\n})) {\n  if (result.action === \"opened\") {\n    console.log(`Signal opened: ${result.signal.position}`);\n  } else if (result.action === \"closed\") {\n    console.log(`Signal closed: PNL ${result.pnl.pnlPercentage}%`);\n  }\n}\n```\n\n**Behavior:**\n- Infinite async generator (never completes naturally)\n- Polls every `TICK_TTL` (1 minute + 1ms) with `Date.now()`\n- Yields both opened and closed signals\n- Persists opened signals to disk for crash recovery\n- Restores persisted signal on startup\n\nSources: [src/classes/Live.ts:398-417](), [src/classes/Live.ts:156-186]()\n\n#### background()\n\nRuns live trading silently in background. Returns cancellation function.\n\n```typescript\nLive.background(\n  symbol: string,\n  context: {\n    strategyName: string;\n    exchangeName: string;\n  }\n): () => void\n```\n\n**Usage:**\n```typescript\nconst cancel = Live.background(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\"\n});\n\n// Graceful shutdown after receiving SIGINT\nprocess.on(\"SIGINT\", () => {\n  cancel();\n});\n```\n\n**Behavior:**\n- Returns cancellation closure immediately\n- Live loop continues until `stop()` called or process crashes\n- Cancellation waits for active signal to close before emitting done event\n- Crash recovery: persisted signals restored on next startup\n\nSources: [src/classes/Live.ts:441-459](), [src/classes/Live.ts:208-242]()\n\n#### stop()\n\nInitiates graceful shutdown. Waits for active signal to close before completing.\n\n```typescript\nLive.stop(\n  symbol: string,\n  strategyName: string\n): Promise<void>\n```\n\n**Usage:**\n```typescript\nawait Live.stop(\"BTCUSDT\", \"my-strategy\");\n// Active signal will continue monitoring until TP/SL/time_expired\n```\n\n**Behavior:**\n- Sets `_isStopped = true` flag\n- Prevents new signals from opening\n- Active signal continues monitoring until natural closure\n- Loop exits after signal closes (checked in `INSTANCE_TASK_FN`)\n\nSources: [src/classes/Live.ts:478-489](), [src/classes/Live.ts:261-267]()\n\n#### getData()\n\nRetrieves live trading statistics including all event types (opened, closed, scheduled, cancelled).\n\n```typescript\nLive.getData(\n  symbol: string,\n  strategyName: string\n): Promise<LiveStatisticsModel>\n```\n\n**Returns:**\nStatistics covering all signal lifecycle events, not just closed signals like backtest.\n\nSources: [src/classes/Live.ts:504-515](), [src/classes/Live.ts:283-289]()\n\n#### getReport()\n\nGenerates markdown report with all live trading events.\n\n```typescript\nLive.getReport(\n  symbol: string,\n  strategyName: string,\n  columns?: Columns[]\n): Promise<string>\n```\n\n**Report Differences from Backtest:**\n- Includes \"opened\" events (signals currently active)\n- Includes \"scheduled\" events (waiting for activation)\n- Includes \"cancelled\" events (scheduled signals that never activated)\n- Real-time data with current timestamps\n\nSources: [src/classes/Live.ts:531-542](), [src/classes/Live.ts:306-312]()\n\n#### dump()\n\nSaves live trading report to file.\n\n```typescript\nLive.dump(\n  symbol: string,\n  strategyName: string,\n  path?: string,\n  columns?: Columns[]\n): Promise<void>\n```\n\n**Default Path:** `./dump/live/{strategyName}.md`\n\nSources: [src/classes/Live.ts:561-577](), [src/classes/Live.ts:332-344]()\n\n### Live Execution Flow\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant LiveUtils\n    participant LiveInstance\n    participant CommandService\n    participant PersistAdapter\n    participant MarkdownService\n    \n    User->>LiveUtils: run(symbol, context)\n    LiveUtils->>LiveUtils: Validate schemas\n    LiveUtils->>LiveUtils: _getInstance(symbol, strategyName)\n    LiveUtils->>LiveInstance: run(symbol, context)\n    \n    LiveInstance->>PersistAdapter: Load persisted signal (crash recovery)\n    LiveInstance->>CommandService: run(symbol, context)\n    CommandService-->>LiveInstance: Infinite AsyncGenerator\n    \n    loop Every TICK_TTL (1 minute)\n        CommandService->>CommandService: tick(Date.now(), backtest=false)\n        \n        alt Signal opens\n            CommandService->>PersistAdapter: Persist signal\n            CommandService->>MarkdownService: Emit opened event\n            CommandService-->>LiveInstance: Yield opened signal\n            LiveInstance-->>User: Yield opened signal\n        end\n        \n        alt Signal closes\n            CommandService->>PersistAdapter: Delete persisted signal\n            CommandService->>MarkdownService: Emit closed event\n            CommandService-->>LiveInstance: Yield closed signal\n            LiveInstance-->>User: Yield closed signal\n        end\n        \n        CommandService->>CommandService: Check _isStopped flag\n        \n        alt _isStopped and signal closed\n            CommandService->>CommandService: Break loop\n        end\n        \n        CommandService->>CommandService: sleep(TICK_TTL)\n    end\n    \n    Note over CommandService: Loop exits only on stop() + closed signal\n```\n\nSources: [src/classes/Live.ts:156-186]()\n\n---\n\n## Walker Class\n\nThe `Walker` class orchestrates sequential backtests across multiple strategies for comparison.\n\n### Core Methods\n\n#### run()\n\nRuns all strategies defined in walker schema and yields progress after each strategy completes.\n\n```typescript\nWalker.run(\n  symbol: string,\n  context: {\n    walkerName: string;\n  }\n): AsyncGenerator<WalkerContract>\n```\n\n**WalkerContract Structure:**\n```typescript\n{\n  strategiesTested: number;\n  totalStrategies: number;\n  currentStrategy: string;\n  bestStrategy: string;\n  bestMetric: number;\n  metric: WalkerMetric;  // \"sharpeRatio\" | \"winRate\" | \"totalPnl\" | etc.\n}\n```\n\n**Usage:**\n```typescript\nfor await (const progress of Walker.run(\"BTCUSDT\", {\n  walkerName: \"my-walker\"\n})) {\n  console.log(`Testing ${progress.currentStrategy} (${progress.strategiesTested}/${progress.totalStrategies})`);\n  console.log(`Best so far: ${progress.bestStrategy} with ${progress.metric}=${progress.bestMetric}`);\n}\n```\n\n**Behavior:**\n- Pulls `strategies`, `exchangeName`, `frameName`, `metric` from walker schema\n- Validates all strategy schemas before starting\n- Executes `Backtest.run()` for each strategy sequentially\n- Collects statistics from `BacktestMarkdownService` after each strategy\n- Compares strategies using specified metric (default: `sharpeRatio`)\n- Yields progress event after each strategy completes\n\nSources: [src/classes/Walker.ts:450-472](), [src/classes/Walker.ts:145-194]()\n\n#### background()\n\nRuns walker comparison silently. Returns cancellation function.\n\n```typescript\nWalker.background(\n  symbol: string,\n  context: {\n    walkerName: string;\n  }\n): () => void\n```\n\n**Usage:**\n```typescript\nconst cancel = Walker.background(\"BTCUSDT\", {\n  walkerName: \"my-walker\"\n});\n\n// Cancel all strategies\ncancel();\n```\n\n**Behavior:**\n- Executes all strategy backtests in background\n- Cancellation sends stop signal to all strategies via `walkerStopSubject`\n- Prevents interference when multiple walkers run on same symbol simultaneously\n\nSources: [src/classes/Walker.ts:493-515](), [src/classes/Walker.ts:214-246]()\n\n#### stop()\n\nStops all strategies in walker from generating new signals.\n\n```typescript\nWalker.stop(\n  symbol: string,\n  walkerName: string\n): Promise<void>\n```\n\n**Behavior:**\n- Iterates through all strategies in walker schema\n- Sends stop signal via `walkerStopSubject` (interrupts current running strategy)\n- Calls `strategyCoreService.stop()` for each strategy\n- Supports multiple concurrent walkers on same symbol (filtered by `walkerName`)\n\nSources: [src/classes/Walker.ts:540-554](), [src/classes/Walker.ts:271-283]()\n\n#### getData()\n\nRetrieves walker comparison results with ranked strategies.\n\n```typescript\nWalker.getData(\n  symbol: string,\n  walkerName: string\n): Promise<WalkerStatisticsModel>\n```\n\n**Returns:**\n- `strategies`: Array of strategy results with metrics\n- `bestStrategy`: Name of winning strategy\n- `bestMetric`: Winning metric value\n- `metric`: Metric used for comparison\n- Per-strategy statistics (Sharpe ratio, win rate, total PNL, etc.)\n\nSources: [src/classes/Walker.ts:569-586](), [src/classes/Walker.ts:299-319]()\n\n#### getReport()\n\nGenerates markdown report with strategy comparison table.\n\n```typescript\nWalker.getReport(\n  symbol: string,\n  walkerName: string,\n  strategyColumns?: StrategyColumn[],\n  pnlColumns?: PnlColumn[]\n): Promise<string>\n```\n\n**Custom Columns:**\n- `strategyColumns`: Customize strategy metadata columns\n- `pnlColumns`: Customize PNL/metrics columns\n\n**Default Report Structure:**\n1. Walker metadata (symbol, metric, date range)\n2. Strategy comparison table sorted by metric\n3. Winner highlighted\n4. Per-strategy PNL breakdown tables\n\nSources: [src/classes/Walker.ts:603-622](), [src/classes/Walker.ts:337-361]()\n\n#### dump()\n\nSaves walker comparison report to file.\n\n```typescript\nWalker.dump(\n  symbol: string,\n  walkerName: string,\n  path?: string,\n  strategyColumns?: StrategyColumn[],\n  pnlColumns?: PnlColumn[]\n): Promise<void>\n```\n\n**Default Path:** `./dump/walker/{walkerName}.md`\n\nSources: [src/classes/Walker.ts:642-662](), [src/classes/Walker.ts:382-409]()\n\n### Walker Execution Flow\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant WalkerUtils\n    participant WalkerInstance\n    participant WalkerCommand\n    participant BacktestCommand\n    participant MarkdownService\n    \n    User->>WalkerUtils: run(symbol, { walkerName })\n    WalkerUtils->>WalkerUtils: Validate walker schema\n    WalkerUtils->>WalkerUtils: Validate all strategy schemas\n    WalkerUtils->>WalkerUtils: _getInstance(symbol, walkerName)\n    WalkerUtils->>WalkerInstance: run(symbol, { walkerName })\n    \n    WalkerInstance->>MarkdownService: clear(walkerName)\n    WalkerInstance->>WalkerCommand: run(symbol, context)\n    WalkerCommand-->>WalkerInstance: AsyncGenerator\n    \n    loop For each strategy in walker.strategies\n        WalkerCommand->>BacktestCommand: run(symbol, { strategyName, exchangeName, frameName })\n        \n        loop For each frame\n            BacktestCommand->>BacktestCommand: Execute strategy tick\n        end\n        \n        BacktestCommand->>MarkdownService: Collect closed signals\n        BacktestCommand-->>WalkerCommand: Backtest complete\n        \n        WalkerCommand->>MarkdownService: Calculate statistics\n        WalkerCommand->>WalkerCommand: Compare with best metric\n        WalkerCommand->>WalkerCommand: Emit walkerEmitter\n        WalkerCommand-->>WalkerInstance: Yield progress\n        WalkerInstance-->>User: Yield progress\n    end\n    \n    WalkerCommand->>WalkerCommand: Emit walkerCompleteSubject\n    WalkerCommand-->>WalkerInstance: Generator completes\n    WalkerInstance->>WalkerInstance: Set _isDone = true\n```\n\nSources: [src/classes/Walker.ts:145-194]()\n\n---\n\n## Method Signature Reference\n\n### Backtest Class\n\n| Method | Parameters | Return Type | Description |\n|--------|-----------|-------------|-------------|\n| `run` | `symbol: string`<br/>`context: { strategyName, exchangeName, frameName }` | `AsyncGenerator<IStrategyTickResultClosed>` | Execute backtest, yield closed signals |\n| `background` | `symbol: string`<br/>`context: { strategyName, exchangeName, frameName }` | `() => void` | Execute backtest silently, return cancel function |\n| `stop` | `symbol: string`<br/>`strategyName: string` | `Promise<void>` | Stop strategy from opening new signals |\n| `getData` | `symbol: string`<br/>`strategyName: string` | `Promise<BacktestStatisticsModel>` | Get aggregated statistics |\n| `getReport` | `symbol: string`<br/>`strategyName: string`<br/>`columns?: Columns[]` | `Promise<string>` | Generate markdown report |\n| `dump` | `symbol: string`<br/>`strategyName: string`<br/>`path?: string`<br/>`columns?: Columns[]` | `Promise<void>` | Save report to disk |\n| `list` | None | `Promise<Array<StatusObject>>` | List all backtest instances |\n\nSources: [src/classes/Backtest.ts:359-580]()\n\n### Live Class\n\n| Method | Parameters | Return Type | Description |\n|--------|-----------|-------------|-------------|\n| `run` | `symbol: string`<br/>`context: { strategyName, exchangeName }` | `AsyncGenerator<IStrategyTickResultOpened \\| IStrategyTickResultClosed>` | Execute live trading, yield all signals |\n| `background` | `symbol: string`<br/>`context: { strategyName, exchangeName }` | `() => void` | Execute live trading silently |\n| `stop` | `symbol: string`<br/>`strategyName: string` | `Promise<void>` | Initiate graceful shutdown |\n| `getData` | `symbol: string`<br/>`strategyName: string` | `Promise<LiveStatisticsModel>` | Get live trading statistics |\n| `getReport` | `symbol: string`<br/>`strategyName: string`<br/>`columns?: Columns[]` | `Promise<string>` | Generate live trading report |\n| `dump` | `symbol: string`<br/>`strategyName: string`<br/>`path?: string`<br/>`columns?: Columns[]` | `Promise<void>` | Save report to disk |\n| `list` | None | `Promise<Array<StatusObject>>` | List all live instances |\n\nSources: [src/classes/Live.ts:376-595]()\n\n### Walker Class\n\n| Method | Parameters | Return Type | Description |\n|--------|-----------|-------------|-------------|\n| `run` | `symbol: string`<br/>`context: { walkerName }` | `AsyncGenerator<WalkerContract>` | Execute strategy comparison, yield progress |\n| `background` | `symbol: string`<br/>`context: { walkerName }` | `() => void` | Execute comparison silently |\n| `stop` | `symbol: string`<br/>`walkerName: string` | `Promise<void>` | Stop all walker strategies |\n| `getData` | `symbol: string`<br/>`walkerName: string` | `Promise<WalkerStatisticsModel>` | Get comparison results |\n| `getReport` | `symbol: string`<br/>`walkerName: string`<br/>`strategyColumns?: StrategyColumn[]`<br/>`pnlColumns?: PnlColumn[]` | `Promise<string>` | Generate comparison report |\n| `dump` | `symbol: string`<br/>`walkerName: string`<br/>`path?: string`<br/>`strategyColumns?: StrategyColumn[]`<br/>`pnlColumns?: PnlColumn[]` | `Promise<void>` | Save report to disk |\n| `list` | None | `Promise<Array<StatusObject>>` | List all walker instances |\n\nSources: [src/classes/Walker.ts:431-680]()\n\n---\n\n## Instance State Management\n\n### State Flags\n\nEach Instance class maintains three state indicators:\n\n| Property | Type | Purpose |\n|----------|------|---------|\n| `id` | `string` | Randomly generated identifier for tracking |\n| `_isStopped` | `boolean` | Manual stop flag preventing new signals |\n| `_isDone` | `boolean` | Completion flag indicating execution finished |\n\n**Lifecycle:**\n\n```mermaid\ngraph LR\n    Init[\"id generated<br/>_isStopped = false<br/>_isDone = false\"]\n    Running[\"task executing<br/>_isStopped = false<br/>_isDone = false\"]\n    Stopped[\"stop() called<br/>_isStopped = true<br/>_isDone = false\"]\n    Done[\"Execution complete<br/>_isStopped = true/false<br/>_isDone = true\"]\n    \n    Init --> Running\n    Running --> Stopped\n    Running --> Done\n    Stopped --> Done\n```\n\nSources: [src/classes/Backtest.ts:74-82](), [src/classes/Live.ts:79-87](), [src/classes/Walker.ts:72-80]()\n\n### Task Singlerun Wrapper\n\nAll Instance classes wrap their execution logic in `singlerun()` from `functools-kit`:\n\n```typescript\nprivate task = singlerun(async (symbol, context) => {\n  // Execution logic\n  return await INSTANCE_TASK_FN(symbol, context, this);\n});\n```\n\n**Purpose:**\n- Prevents concurrent execution of same instance\n- Returns existing promise if task already running\n- Provides status via `task.getStatus()`: `\"idle\" | \"running\" | \"done\"`\n\nSources: [src/classes/Backtest.ts:105-118](), [src/classes/Live.ts:110-122](), [src/classes/Walker.ts:103-114]()\n\n### getStatus() Method\n\nReturns current execution status for monitoring:\n\n```typescript\nconst status = await instance.getStatus();\n// {\n//   id: \"abc123\",\n//   symbol: \"BTCUSDT\",\n//   strategyName: \"my-strategy\",\n//   status: \"running\"\n// }\n```\n\n**Status Values:**\n- `\"idle\"`: Instance created but not started\n- `\"running\"`: Execution in progress\n- `\"done\"`: Execution completed\n\nSources: [src/classes/Backtest.ts:132-140](), [src/classes/Live.ts:136-144](), [src/classes/Walker.ts:128-136]()\n\n---\n\n## Validation & Error Handling\n\n### Schema Validation\n\nAll execution methods validate required schemas before execution:\n\n```mermaid\ngraph TD\n    MethodCall[\"Method called\"]\n    ValidateStrategy[\"strategyValidationService.validate()\"]\n    ValidateExchange[\"exchangeValidationService.validate()\"]\n    ValidateFrame[\"frameValidationService.validate()\"]\n    ValidateRisk[\"riskValidationService.validate()<br/>for riskName and riskList\"]\n    GetInstance[\"Get or create Instance\"]\n    Execute[\"Execute operation\"]\n    \n    MethodCall --> ValidateStrategy\n    ValidateStrategy --> ValidateExchange\n    ValidateExchange --> ValidateFrame\n    ValidateFrame --> ValidateRisk\n    ValidateRisk --> GetInstance\n    GetInstance --> Execute\n```\n\n**Validation Failures:**\nIf any schema is not registered, validation throws error with helpful message indicating which schema is missing and which method was called.\n\nSources: [src/classes/Backtest.ts:387-396](), [src/classes/Live.ts:406-414](), [src/classes/Walker.ts:456-468]()\n\n### Error Emission\n\n```mermaid\ngraph LR\n    TaskExecution[\"task(symbol, context)\"]\n    Error[\"Exception thrown\"]\n    ExitEmitter[\"exitEmitter.next(error)\"]\n    Subscribers[\"Error subscribers notified\"]\n    \n    TaskExecution --> Error\n    Error --> ExitEmitter\n    ExitEmitter --> Subscribers\n```\n\n**Error Handling Strategy:**\n- Background tasks catch all errors and emit to `exitEmitter`\n- `run()` method errors propagate to caller (no catch)\n- Users can subscribe to errors via `listenError()` and `listenExit()`\n- Distinguishes between recoverable errors (`errorEmitter`) and fatal errors (`exitEmitter`)\n\nSources: [src/classes/Backtest.ts:212-214](), [src/classes/Live.ts:219-221](), [src/classes/Walker.ts:227-229]()\n\n---\n\n## Integration with Service Layer\n\nExecution classes coordinate multiple service layers:\n\n```mermaid\ngraph TB\n    subgraph \"Execution Classes\"\n        Backtest[\"Backtest\"]\n        Live[\"Live\"]\n        Walker[\"Walker\"]\n    end\n    \n    subgraph \"Validation Services\"\n        StrategyVal[\"strategyValidationService\"]\n        ExchangeVal[\"exchangeValidationService\"]\n        FrameVal[\"frameValidationService\"]\n        RiskVal[\"riskValidationService\"]\n    end\n    \n    subgraph \"Schema Services\"\n        StrategySchema[\"strategySchemaService\"]\n        WalkerSchema[\"walkerSchemaService\"]\n    end\n    \n    subgraph \"Command Services\"\n        BacktestCmd[\"backtestCommandService\"]\n        LiveCmd[\"liveCommandService\"]\n        WalkerCmd[\"walkerCommandService\"]\n    end\n    \n    subgraph \"Markdown Services\"\n        BacktestMd[\"backtestMarkdownService\"]\n        LiveMd[\"liveMarkdownService\"]\n        WalkerMd[\"walkerMarkdownService\"]\n        ScheduleMd[\"scheduleMarkdownService\"]\n    end\n    \n    subgraph \"Core Services\"\n        StrategyCore[\"strategyCoreService\"]\n        RiskGlobal[\"riskGlobalService\"]\n    end\n    \n    Backtest --> StrategyVal\n    Backtest --> ExchangeVal\n    Backtest --> FrameVal\n    Backtest --> RiskVal\n    Backtest --> StrategySchema\n    Backtest --> BacktestCmd\n    Backtest --> BacktestMd\n    Backtest --> ScheduleMd\n    Backtest --> StrategyCore\n    Backtest --> RiskGlobal\n    \n    Live --> StrategyVal\n    Live --> ExchangeVal\n    Live --> RiskVal\n    Live --> StrategySchema\n    Live --> LiveCmd\n    Live --> LiveMd\n    Live --> ScheduleMd\n    Live --> StrategyCore\n    Live --> RiskGlobal\n    \n    Walker --> StrategyVal\n    Walker --> ExchangeVal\n    Walker --> FrameVal\n    Walker --> RiskVal\n    Walker --> WalkerSchema\n    Walker --> WalkerCmd\n    Walker --> WalkerMd\n    Walker --> BacktestMd\n    Walker --> StrategyCore\n    Walker --> RiskGlobal\n```\n\n**Key Integration Points:**\n\n1. **Validation**: All schemas validated before execution\n2. **Schema Retrieval**: Pull configuration from schema services\n3. **Command Execution**: Delegate to command services for async generator logic\n4. **Reporting**: Markdown services collect events and generate reports\n5. **State Management**: Core services manage strategy/risk state\n6. **Cleanup**: Clear services before each new execution\n\nSources: [src/classes/Backtest.ts:163-176](), [src/classes/Live.ts:169-183](), [src/classes/Walker.ts:163-187]()"
                    },
                    {
                        "page_plan": {
                            "id": "12.3",
                            "title": "Reporting Classes API"
                        },
                        "content": "# Reporting Classes API\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/classes/Backtest.ts](src/classes/Backtest.ts)\n- [src/classes/Heat.ts](src/classes/Heat.ts)\n- [src/classes/Live.ts](src/classes/Live.ts)\n- [src/classes/Partial.ts](src/classes/Partial.ts)\n- [src/classes/Performance.ts](src/classes/Performance.ts)\n- [src/classes/Risk.ts](src/classes/Risk.ts)\n- [src/classes/Schedule.ts](src/classes/Schedule.ts)\n- [src/classes/Walker.ts](src/classes/Walker.ts)\n- [src/lib/services/markdown/BacktestMarkdownService.ts](src/lib/services/markdown/BacktestMarkdownService.ts)\n- [src/lib/services/markdown/HeatMarkdownService.ts](src/lib/services/markdown/HeatMarkdownService.ts)\n- [src/lib/services/markdown/LiveMarkdownService.ts](src/lib/services/markdown/LiveMarkdownService.ts)\n- [src/lib/services/markdown/PartialMarkdownService.ts](src/lib/services/markdown/PartialMarkdownService.ts)\n- [src/lib/services/markdown/PerformanceMarkdownService.ts](src/lib/services/markdown/PerformanceMarkdownService.ts)\n- [src/lib/services/markdown/RiskMarkdownService.ts](src/lib/services/markdown/RiskMarkdownService.ts)\n- [src/lib/services/markdown/ScheduleMarkdownService.ts](src/lib/services/markdown/ScheduleMarkdownService.ts)\n- [src/lib/services/markdown/WalkerMarkdownService.ts](src/lib/services/markdown/WalkerMarkdownService.ts)\n- [src/model/Column.model.ts](src/model/Column.model.ts)\n- [test/spec/columns.test.mjs](test/spec/columns.test.mjs)\n\n</details>\n\n\n\nThis page documents the specialized reporting classes that provide access to trading statistics and analysis reports. These classes are wrappers around markdown services and offer three primary methods: `getData()`, `getReport()`, and `dump()`.\n\nFor execution control classes like `Backtest`, `Live`, and `Walker`, see [Execution Classes API](#12.2). For the complete list of global configuration functions, see [Global Functions](#12.1).\n\n## Overview\n\nThe framework provides five reporting classes for analyzing different aspects of trading activity:\n\n| Class | Purpose | Data Source |\n|-------|---------|-------------|\n| `Performance` | Execution timing and bottleneck analysis | `PerformanceMarkdownService` |\n| `Heat` | Portfolio-wide symbol aggregation (heatmap) | `HeatMarkdownService` |\n| `Risk` | Risk rejection tracking | `RiskMarkdownService` |\n| `Schedule` | Scheduled signal monitoring | `ScheduleMarkdownService` |\n| `Partial` | Partial profit/loss milestone tracking | `PartialMarkdownService` |\n\nEach class is a singleton utility that delegates to its corresponding markdown service, which automatically accumulates events via event emitter subscriptions.\n\n**Sources:** [src/classes/Performance.ts:1-159](), [src/classes/Heat.ts:1-148](), [src/classes/Risk.ts:1-202](), [src/classes/Schedule.ts:1-149](), [src/classes/Partial.ts:1-186]()\n\n## Common API Pattern\n\nAll reporting classes follow the same three-method API pattern:\n\n```typescript\n// Get statistical data object\nconst stats = await ReportingClass.getData(...args);\n\n// Generate markdown report string\nconst markdown = await ReportingClass.getReport(...args, columns?);\n\n// Save report to file system\nawait ReportingClass.dump(...args, path?, columns?);\n```\n\nEach method performs strategy validation before delegating to its markdown service. The `columns` parameter allows customization of report table structure.\n\n**Sources:** [src/classes/Performance.ts:70-155](), [src/classes/Heat.ts:57-139]()\n\n## Class Hierarchy and Data Flow\n\n```mermaid\ngraph TD\n    User[\"User Code\"]\n    \n    subgraph \"Public API Classes\"\n        Perf[\"Performance<br/>(static methods)\"]\n        Heat[\"Heat<br/>(singleton)\"]\n        Risk[\"Risk<br/>(singleton)\"]\n        Schedule[\"Schedule<br/>(singleton)\"]\n        Partial[\"Partial<br/>(singleton)\"]\n    end\n    \n    subgraph \"Markdown Services\"\n        PerfMD[\"PerformanceMarkdownService\"]\n        HeatMD[\"HeatMarkdownService\"]\n        RiskMD[\"RiskMarkdownService\"]\n        ScheduleMD[\"ScheduleMarkdownService\"]\n        PartialMD[\"PartialMarkdownService\"]\n    end\n    \n    subgraph \"Storage Layer\"\n        PerfStorage[\"PerformanceStorage<br/>(per symbol-strategy)\"]\n        HeatStorage[\"HeatmapStorage<br/>(per strategy)\"]\n        RiskStorage[\"ReportStorage<br/>(per symbol-strategy)\"]\n        ScheduleStorage[\"ReportStorage<br/>(per symbol-strategy)\"]\n        PartialStorage[\"ReportStorage<br/>(per symbol-strategy)\"]\n    end\n    \n    subgraph \"Event System\"\n        PerfEmit[\"performanceEmitter\"]\n        SigEmit[\"signalEmitter\"]\n        RiskEmit[\"riskSubject\"]\n        PPEmit[\"partialProfitSubject\"]\n        PLEmit[\"partialLossSubject\"]\n    end\n    \n    User --> Perf\n    User --> Heat\n    User --> Risk\n    User --> Schedule\n    User --> Partial\n    \n    Perf --> PerfMD\n    Heat --> HeatMD\n    Risk --> RiskMD\n    Schedule --> ScheduleMD\n    Partial --> PartialMD\n    \n    PerfMD --> PerfStorage\n    HeatMD --> HeatStorage\n    RiskMD --> RiskStorage\n    ScheduleMD --> ScheduleStorage\n    PartialMD --> PartialStorage\n    \n    PerfEmit --> PerfMD\n    SigEmit --> HeatMD\n    SigEmit --> ScheduleMD\n    RiskEmit --> RiskMD\n    PPEmit --> PartialMD\n    PLEmit --> PartialMD\n```\n\n**Sources:** [src/classes/Performance.ts:40-156](), [src/lib/services/markdown/PerformanceMarkdownService.ts:312-459](), [src/lib/services/markdown/HeatMarkdownService.ts:434-587]()\n\n## Performance Class\n\nThe `Performance` class provides static methods for analyzing execution timing metrics and identifying bottlenecks.\n\n### Methods\n\n#### `Performance.getData(symbol, strategyName): Promise<PerformanceStatisticsModel>`\n\nReturns aggregated performance statistics grouped by metric type. Each metric includes:\n- Count, total duration, average, min, max\n- Standard deviation for volatility analysis\n- Percentiles (median, P95, P99) for outlier detection\n- Wait time statistics (time between consecutive events)\n\n**Parameters:**\n- `symbol: string` - Trading pair symbol\n- `strategyName: string` - Strategy name\n\n**Returns:** `PerformanceStatisticsModel` containing:\n- `strategyName: string`\n- `totalEvents: number`\n- `totalDuration: number`\n- `metricStats: Record<PerformanceMetricType, MetricStats>`\n- `events: PerformanceContract[]`\n\n**Sources:** [src/classes/Performance.ts:70-83]()\n\n#### `Performance.getReport(symbol, strategyName, columns?): Promise<string>`\n\nGenerates markdown report with:\n- Time distribution across operation types (percentage breakdown)\n- Detailed metrics table sorted by total duration (bottlenecks first)\n- Percentile analysis with P95/P99 values\n\n**Parameters:**\n- `symbol: string`\n- `strategyName: string`\n- `columns?: Columns[]` - Optional custom column configuration\n\n**Returns:** Markdown formatted report string\n\n**Sources:** [src/classes/Performance.ts:108-118]()\n\n#### `Performance.dump(symbol, strategyName, path?, columns?): Promise<void>`\n\nSaves performance report to disk. Default path: `./dump/performance/{strategyName}.md`\n\n**Parameters:**\n- `symbol: string`\n- `strategyName: string`\n- `path?: string` - Custom directory path\n- `columns?: Columns[]` - Optional custom column configuration\n\n**Sources:** [src/classes/Performance.ts:140-155]()\n\n### Data Collection\n\nPerformance metrics are collected via `performanceEmitter` which broadcasts `PerformanceContract` events containing:\n- `metricType: PerformanceMetricType` - Operation identifier\n- `duration: number` - Execution time in milliseconds\n- `timestamp: number` - Event timestamp\n- `previousTimestamp: number | null` - Previous event timestamp for wait time calculation\n\nMaximum 10,000 events stored per symbol-strategy pair.\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:74-97](), [src/lib/services/markdown/PerformanceMarkdownService.ts:331-340]()\n\n## Heat Class\n\nThe `Heat` class provides portfolio-wide symbol aggregation, generating heatmaps that show performance across all symbols for a given strategy.\n\n### Methods\n\n#### `Heat.getData(strategyName): Promise<HeatmapStatisticsModel>`\n\nReturns per-symbol statistics and portfolio-wide aggregates:\n- Per-symbol: Total PNL, Sharpe Ratio, Max Drawdown, trades, win rate, profit factor, etc.\n- Portfolio: Total PNL, weighted Sharpe Ratio, total trades across all symbols\n\nSymbols are sorted by Sharpe Ratio (best performers first).\n\n**Parameters:**\n- `strategyName: string` - Strategy name\n\n**Returns:** `HeatmapStatisticsModel` containing:\n- `symbols: IHeatmapRow[]` - Per-symbol statistics\n- `totalSymbols: number`\n- `portfolioTotalPnl: number | null`\n- `portfolioSharpeRatio: number | null`\n- `portfolioTotalTrades: number`\n\n**Sources:** [src/classes/Heat.ts:57-69](), [src/lib/services/markdown/HeatMarkdownService.ts:278-330]()\n\n#### `Heat.getReport(strategyName, columns?): Promise<string>`\n\nGenerates markdown heatmap table with portfolio summary header.\n\n**Parameters:**\n- `strategyName: string`\n- `columns?: Columns[]` - Optional custom column configuration\n\n**Returns:** Markdown formatted heatmap report\n\n**Sources:** [src/classes/Heat.ts:97-109]()\n\n#### `Heat.dump(strategyName, path?, columns?): Promise<void>`\n\nSaves heatmap report to disk. Default path: `./dump/heatmap/{strategyName}.md`\n\n**Parameters:**\n- `strategyName: string`\n- `path?: string` - Custom directory path\n- `columns?: Columns[]` - Optional custom column configuration\n\n**Sources:** [src/classes/Heat.ts:130-139]()\n\n### Data Collection\n\nHeat data is collected via `signalEmitter` which broadcasts all closed signals. The service automatically groups signals by symbol and calculates comprehensive statistics per symbol including Sharpe Ratio, Max Drawdown, Profit Factor, Win/Loss Streaks, and Expectancy.\n\nMaximum 250 signals stored per symbol.\n\n**Sources:** [src/lib/services/markdown/HeatMarkdownService.ts:455-466](), [src/lib/services/markdown/HeatMarkdownService.ts:82-105]()\n\n## Risk Class\n\nThe `Risk` class provides access to risk rejection event tracking and includes the `MergeRisk` composite implementation.\n\n### RiskUtils Methods\n\n#### `Risk.getData(symbol, strategyName): Promise<RiskStatisticsModel>`\n\nReturns risk rejection statistics with aggregations by symbol and by strategy.\n\n**Parameters:**\n- `symbol: string` - Trading pair symbol\n- `strategyName: string` - Strategy name\n\n**Returns:** `RiskStatisticsModel` containing:\n- `eventList: RiskEvent[]` - All rejection events\n- `totalRejections: number`\n- `bySymbol: Record<string, number>` - Rejection count per symbol\n- `byStrategy: Record<string, number>` - Rejection count per strategy\n\n**Sources:** [src/classes/Risk.ts:156-171](), [src/lib/services/markdown/RiskMarkdownService.ts:75-99]()\n\n#### `Risk.getReport(symbol, strategyName, columns?): Promise<string>`\n\nGenerates markdown report with rejection event table and summary statistics broken down by symbol and strategy.\n\n**Parameters:**\n- `symbol: string`\n- `strategyName: string`\n- `columns?: Columns[]` - Optional custom column configuration\n\n**Returns:** Markdown formatted report string\n\n**Sources:** [src/classes/Risk.ts:185-197]()\n\n#### `Risk.dump(symbol, strategyName, path?, columns?): Promise<void>`\n\nSaves risk rejection report to disk. Default filename: `{symbol}_{strategyName}.md`\n\n**Parameters:**\n- `symbol: string`\n- `strategyName: string`\n- `path?: string` - Custom directory path (default: `./dump/risk`)\n- `columns?: Columns[]` - Optional custom column configuration\n\n**Sources:** [src/classes/Risk.ts:211-223]()\n\n### MergeRisk Class\n\nThe `MergeRisk` class implements the Composite pattern to combine multiple risk profiles. Used internally when a strategy specifies both `riskName` and `riskList`.\n\n#### Constructor\n\n```typescript\nnew MergeRisk(riskList: IRisk[])\n```\n\nCreates a merged risk profile from multiple `IRisk` instances.\n\n**Sources:** [src/classes/Risk.ts:42-48]()\n\n#### `checkSignal(params): Promise<boolean>`\n\nReturns `true` only if ALL child risk profiles approve the signal (logical AND). Executes all checks in parallel.\n\n**Parameters:**\n- `params: IRiskCheckArgs` - Contains symbol, strategyName, position, exchangeName\n\n**Returns:** `true` if all risks pass, `false` if any risk rejects\n\n**Sources:** [src/classes/Risk.ts:59-67]()\n\n#### `addSignal(symbol, context): Promise<void>`\n\nPropagates signal registration to all child risk profiles in parallel.\n\n**Sources:** [src/classes/Risk.ts:79-90]()\n\n#### `removeSignal(symbol, context): Promise<void>`\n\nPropagates signal removal to all child risk profiles in parallel.\n\n**Sources:** [src/classes/Risk.ts:102-116]()\n\n### Data Collection\n\nRisk rejection events are collected via `riskSubject` which emits `RiskEvent` objects containing:\n- `timestamp: number`\n- `symbol: string`\n- `strategyName: string`\n- `position: PositionEnum`\n- `exchangeName: string`\n- `currentPrice: number`\n- `activePositionCount: number`\n- `comment: string` - Rejection reason\n\nMaximum 250 events stored per symbol-strategy pair.\n\n**Sources:** [src/lib/services/markdown/RiskMarkdownService.ts:52-68](), [src/lib/services/markdown/RiskMarkdownService.ts:233-240]()\n\n## Schedule Class\n\nThe `Schedule` class tracks scheduled signals, their activation status, and cancellation metrics.\n\n### Methods\n\n#### `Schedule.getData(symbol, strategyName): Promise<ScheduleStatisticsModel>`\n\nReturns scheduled signal statistics including cancellation rate and average wait times.\n\n**Parameters:**\n- `symbol: string` - Trading pair symbol\n- `strategyName: string` - Strategy name\n\n**Returns:** `ScheduleStatisticsModel` containing:\n- `eventList: ScheduledEvent[]`\n- `totalEvents: number`\n- `totalScheduled: number`\n- `totalOpened: number`\n- `totalCancelled: number`\n- `cancellationRate: number | null` - Percentage\n- `activationRate: number | null` - Percentage\n- `avgWaitTime: number | null` - Minutes until cancellation\n- `avgActivationTime: number | null` - Minutes until activation\n\n**Sources:** [src/classes/Schedule.ts:48-63](), [src/lib/services/markdown/ScheduleMarkdownService.ts:156-218]()\n\n#### `Schedule.getReport(symbol, strategyName, columns?): Promise<string>`\n\nGenerates markdown report with scheduled event table and summary statistics showing cancellation/activation rates and timing metrics.\n\n**Parameters:**\n- `symbol: string`\n- `strategyName: string`\n- `columns?: Columns[]` - Optional custom column configuration\n\n**Returns:** Markdown formatted report string\n\n**Sources:** [src/classes/Schedule.ts:79-94]()\n\n#### `Schedule.dump(symbol, strategyName, path?, columns?): Promise<void>`\n\nSaves schedule report to disk. Default path: `./dump/schedule/{strategyName}.md`\n\n**Parameters:**\n- `symbol: string`\n- `strategyName: string`\n- `path?: string` - Custom directory path\n- `columns?: Columns[]` - Optional custom column configuration\n\n**Sources:** [src/classes/Schedule.ts:113-134]()\n\n### Data Collection\n\nSchedule data is collected via `signalEmitter` which broadcasts all signal events. The service tracks three event types:\n1. **Scheduled** - Signal created but `priceOpen` not yet reached\n2. **Opened** - Scheduled signal activated (only if `scheduledAt !== pendingAt`)\n3. **Cancelled** - Scheduled signal cancelled before activation\n\nMaximum 250 events stored per symbol-strategy pair.\n\n**Sources:** [src/lib/services/markdown/ScheduleMarkdownService.ts:351-369](), [src/lib/services/markdown/ScheduleMarkdownService.ts:52-149]()\n\n## Partial Class\n\nThe `Partial` class tracks partial profit/loss milestone events as positions move through predefined levels (±10%, ±20%, ±30%, etc.).\n\n### Methods\n\n#### `Partial.getData(symbol, strategyName): Promise<PartialStatisticsModel>`\n\nReturns partial profit/loss event statistics.\n\n**Parameters:**\n- `symbol: string` - Trading pair symbol\n- `strategyName: string` - Strategy name\n\n**Returns:** `PartialStatisticsModel` containing:\n- `eventList: PartialEvent[]`\n- `totalEvents: number`\n- `totalProfit: number` - Count of profit milestone events\n- `totalLoss: number` - Count of loss milestone events\n\n**Sources:** [src/classes/Partial.ts:68-80](), [src/lib/services/markdown/PartialMarkdownService.ts:135-154]()\n\n#### `Partial.getReport(symbol, strategyName, columns?): Promise<string>`\n\nGenerates markdown report with partial event table showing:\n- Action (PROFIT/LOSS)\n- Symbol, Strategy, Signal ID, Position\n- Level percentage (±10%, ±20%, etc.)\n- Current price at milestone\n- Timestamp and mode (Backtest/Live)\n\n**Parameters:**\n- `symbol: string`\n- `strategyName: string`\n- `columns?: Columns[]` - Optional custom column configuration\n\n**Returns:** Markdown formatted report string\n\n**Sources:** [src/classes/Partial.ts:121-133]()\n\n#### `Partial.dump(symbol, strategyName, path?, columns?): Promise<void>`\n\nSaves partial report to disk. Default filename: `{symbol}_{strategyName}.md`\n\n**Parameters:**\n- `symbol: string`\n- `strategyName: string`\n- `path?: string` - Custom directory path (default: `./dump/partial`)\n- `columns?: Columns[]` - Optional custom column configuration\n\n**Sources:** [src/classes/Partial.ts:148-159]()\n\n### Data Collection\n\nPartial data is collected via two subjects:\n- `partialProfitSubject` - Emits when position reaches profit milestones (10%, 20%, 30%, etc.)\n- `partialLossSubject` - Emits when position reaches loss milestones (-10%, -20%, -30%, etc.)\n\nEach event contains:\n- `timestamp: number`\n- `action: \"profit\" | \"loss\"`\n- `symbol: string`\n- `strategyName: string`\n- `signalId: string`\n- `position: PositionEnum`\n- `currentPrice: number`\n- `level: PartialLevel` - Milestone percentage\n- `backtest: boolean`\n\nMaximum 250 events stored per symbol-strategy pair.\n\n**Sources:** [src/lib/services/markdown/PartialMarkdownService.ts:284-338](), [src/lib/services/markdown/PartialMarkdownService.ts:60-128]()\n\n## Column Configuration\n\nAll reporting classes support custom column configuration via the optional `columns` parameter in `getReport()` and `dump()` methods.\n\n### ColumnModel Interface\n\n```typescript\ninterface ColumnModel<T extends object = any> {\n  key: string;              // Unique column identifier\n  label: string;            // Display label for column header\n  format: (data: T, index: number) => string | Promise<string>;\n  isVisible: () => boolean | Promise<boolean>;\n}\n```\n\n**Sources:** [src/model/Column.model.ts:26-38]()\n\n### Column Type Aliases\n\nEach markdown service defines a type alias for its column configuration:\n\n| Service | Type Alias | Data Type |\n|---------|------------|-----------|\n| `BacktestMarkdownService` | `Columns` | `IStrategyTickResultClosed` |\n| `LiveMarkdownService` | `Columns` | `TickEvent` |\n| `WalkerMarkdownService` | `StrategyColumn` | `IStrategyResult` |\n| `WalkerMarkdownService` | `PnlColumn` | `SignalData` |\n| `PerformanceMarkdownService` | `Columns` | `MetricStats` |\n| `HeatMarkdownService` | `Columns` | `IHeatmapRow` |\n| `RiskMarkdownService` | `Columns` | `RiskEvent` |\n| `ScheduleMarkdownService` | `Columns` | `ScheduledEvent` |\n| `PartialMarkdownService` | `Columns` | `PartialEvent` |\n\n**Sources:** [src/lib/services/markdown/BacktestMarkdownService.ts:48](), [src/lib/services/markdown/LiveMarkdownService.ts:50](), [src/lib/services/markdown/PerformanceMarkdownService.ts:47]()\n\n### Default Column Configuration\n\nDefault columns are defined in `COLUMN_CONFIG` object:\n\n```typescript\nimport { COLUMN_CONFIG } from \"backtest-kit\";\n\n// Access default column configurations\nconst backtestColumns = COLUMN_CONFIG.backtest_columns;\nconst liveColumns = COLUMN_CONFIG.live_columns;\nconst performanceColumns = COLUMN_CONFIG.performance_columns;\nconst heatColumns = COLUMN_CONFIG.heat_columns;\nconst riskColumns = COLUMN_CONFIG.risk_columns;\nconst scheduleColumns = COLUMN_CONFIG.schedule_columns;\nconst partialColumns = COLUMN_CONFIG.partial_columns;\nconst walkerStrategyColumns = COLUMN_CONFIG.walker_strategy_columns;\nconst walkerPnlColumns = COLUMN_CONFIG.walker_pnl_columns;\n```\n\n**Sources:** [src/config/columns.ts]() (referenced in multiple markdown services)\n\n### Custom Column Example\n\n```typescript\nimport { Performance } from \"backtest-kit\";\n\n// Define custom columns showing only metric type and average duration\nconst customColumns = [\n  {\n    key: \"metric\",\n    label: \"Operation\",\n    format: (stat) => stat.metricType,\n    isVisible: () => true\n  },\n  {\n    key: \"avg\",\n    label: \"Avg Time (ms)\",\n    format: (stat) => stat.avgDuration.toFixed(2),\n    isVisible: () => true\n  },\n  {\n    key: \"p99\",\n    label: \"P99 (ms)\",\n    format: (stat) => stat.p99.toFixed(2),\n    isVisible: () => true\n  }\n];\n\n// Use custom columns in report\nconst markdown = await Performance.getReport(\n  \"BTCUSDT\",\n  \"my-strategy\",\n  customColumns\n);\n```\n\n**Sources:** [test/spec/columns.test.mjs:69-112]()\n\n## API Method Signature Patterns\n\nAll reporting classes follow consistent method signature patterns for easy memorization:\n\n### Symbol-Strategy Scope\n\nClasses that operate on symbol-strategy pairs (Performance, Risk, Schedule, Partial):\n\n```typescript\n// getData pattern\ngetData(symbol: string, strategyName: string): Promise<StatisticsModel>\n\n// getReport pattern\ngetReport(\n  symbol: string,\n  strategyName: string,\n  columns?: Columns[]\n): Promise<string>\n\n// dump pattern\ndump(\n  symbol: string,\n  strategyName: string,\n  path?: string,\n  columns?: Columns[]\n): Promise<void>\n```\n\n**Sources:** [src/classes/Performance.ts:70-155](), [src/classes/Risk.ts:156-223]()\n\n### Strategy Scope\n\nClasses that operate on strategy level only (Heat):\n\n```typescript\n// getData pattern\ngetData(strategyName: string): Promise<StatisticsModel>\n\n// getReport pattern\ngetReport(\n  strategyName: string,\n  columns?: Columns[]\n): Promise<string>\n\n// dump pattern\ndump(\n  strategyName: string,\n  path?: string,\n  columns?: Columns[]\n): Promise<void>\n```\n\n**Sources:** [src/classes/Heat.ts:57-139]()\n\n## Statistics Models Reference\n\nEach reporting class returns a specific statistics model from its `getData()` method:\n\n### PerformanceStatisticsModel\n\n```typescript\n{\n  strategyName: string;\n  totalEvents: number;\n  totalDuration: number;\n  metricStats: Record<string, MetricStats>;\n  events: PerformanceContract[];\n}\n\n// MetricStats structure\n{\n  metricType: PerformanceMetricType;\n  count: number;\n  totalDuration: number;\n  avgDuration: number;\n  minDuration: number;\n  maxDuration: number;\n  stdDev: number;\n  median: number;\n  p95: number;\n  p99: number;\n  avgWaitTime: number;\n  minWaitTime: number;\n  maxWaitTime: number;\n}\n```\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:104-185]()\n\n### HeatmapStatisticsModel\n\n```typescript\n{\n  symbols: IHeatmapRow[];\n  totalSymbols: number;\n  portfolioTotalPnl: number | null;\n  portfolioSharpeRatio: number | null;\n  portfolioTotalTrades: number;\n}\n\n// IHeatmapRow structure\n{\n  symbol: string;\n  totalPnl: number | null;\n  sharpeRatio: number | null;\n  maxDrawdown: number | null;\n  totalTrades: number;\n  winCount: number;\n  lossCount: number;\n  winRate: number | null;\n  avgPnl: number | null;\n  stdDev: number | null;\n  profitFactor: number | null;\n  avgWin: number | null;\n  avgLoss: number | null;\n  maxWinStreak: number;\n  maxLossStreak: number;\n  expectancy: number | null;\n}\n```\n\n**Sources:** [src/lib/services/markdown/HeatMarkdownService.ts:278-330](), [src/lib/services/markdown/HeatMarkdownService.ts:108-271]()\n\n### RiskStatisticsModel\n\n```typescript\n{\n  eventList: RiskEvent[];\n  totalRejections: number;\n  bySymbol: Record<string, number>;\n  byStrategy: Record<string, number>;\n}\n\n// RiskEvent structure\n{\n  timestamp: number;\n  symbol: string;\n  strategyName: string;\n  position: PositionEnum;\n  exchangeName: string;\n  currentPrice: number;\n  activePositionCount: number;\n  comment: string;\n}\n```\n\n**Sources:** [src/lib/services/markdown/RiskMarkdownService.ts:75-99]()\n\n### ScheduleStatisticsModel\n\n```typescript\n{\n  eventList: ScheduledEvent[];\n  totalEvents: number;\n  totalScheduled: number;\n  totalOpened: number;\n  totalCancelled: number;\n  cancellationRate: number | null;\n  activationRate: number | null;\n  avgWaitTime: number | null;\n  avgActivationTime: number | null;\n}\n\n// ScheduledEvent structure\n{\n  timestamp: number;\n  action: \"scheduled\" | \"opened\" | \"cancelled\";\n  symbol: string;\n  signalId: string;\n  position: PositionEnum;\n  note: string;\n  currentPrice: number;\n  priceOpen: number;\n  takeProfit: number;\n  stopLoss: number;\n  closeTimestamp?: number;\n  duration?: number;\n}\n```\n\n**Sources:** [src/lib/services/markdown/ScheduleMarkdownService.ts:156-218]()\n\n### PartialStatisticsModel\n\n```typescript\n{\n  eventList: PartialEvent[];\n  totalEvents: number;\n  totalProfit: number;\n  totalLoss: number;\n}\n\n// PartialEvent structure\n{\n  timestamp: number;\n  action: \"profit\" | \"loss\";\n  symbol: string;\n  strategyName: string;\n  signalId: string;\n  position: PositionEnum;\n  currentPrice: number;\n  level: PartialLevel;\n  backtest: boolean;\n}\n```\n\n**Sources:** [src/lib/services/markdown/PartialMarkdownService.ts:135-154]()\n\n## Storage and Memory Management\n\nAll markdown services implement a consistent storage pattern with memory limits:\n\n| Service | Storage Class | Max Events | Scope |\n|---------|--------------|------------|-------|\n| `PerformanceMarkdownService` | `PerformanceStorage` | 10,000 | Per symbol-strategy |\n| `HeatMarkdownService` | `HeatmapStorage` | 250 per symbol | Per strategy |\n| `RiskMarkdownService` | `ReportStorage` | 250 | Per symbol-strategy |\n| `ScheduleMarkdownService` | `ReportStorage` | 250 | Per symbol-strategy |\n| `PartialMarkdownService` | `ReportStorage` | 250 | Per symbol-strategy |\n\nStorage instances are created and cached using `memoize` pattern from `functools-kit`. When the event limit is exceeded, the oldest events are removed (FIFO queue).\n\n**Sources:** [src/lib/services/markdown/PerformanceMarkdownService.ts:75-97](), [src/lib/services/markdown/HeatMarkdownService.ts:76-105](), [src/lib/services/markdown/RiskMarkdownService.ts:46-68]()\n\n## Complete Usage Example\n\n```typescript\nimport {\n  Performance,\n  Heat,\n  Risk,\n  Schedule,\n  Partial,\n  Backtest,\n  listenDoneBacktest\n} from \"backtest-kit\";\n\n// Run backtest\nconst cancel = Backtest.background(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\",\n  frameName: \"30d-backtest\"\n});\n\n// Wait for completion\nawait new Promise(resolve => {\n  const unsub = listenDoneBacktest((event) => {\n    if (event.strategyName === \"my-strategy\") {\n      unsub();\n      resolve();\n    }\n  });\n});\n\n// Generate all reports\nconst perfStats = await Performance.getData(\"BTCUSDT\", \"my-strategy\");\nconsole.log(`Slowest operation: ${Object.values(perfStats.metricStats)\n  .sort((a, b) => b.avgDuration - a.avgDuration)[0].metricType}`);\n\nconst heatStats = await Heat.getData(\"my-strategy\");\nconsole.log(`Portfolio PNL: ${heatStats.portfolioTotalPnl}%`);\n\nconst riskStats = await Risk.getData(\"BTCUSDT\", \"my-strategy\");\nconsole.log(`Total rejections: ${riskStats.totalRejections}`);\n\nconst schedStats = await Schedule.getData(\"BTCUSDT\", \"my-strategy\");\nconsole.log(`Cancellation rate: ${schedStats.cancellationRate}%`);\n\nconst partialStats = await Partial.getData(\"BTCUSDT\", \"my-strategy\");\nconsole.log(`Profit milestones: ${partialStats.totalProfit}`);\n\n// Save all reports to disk\nawait Performance.dump(\"BTCUSDT\", \"my-strategy\");\nawait Heat.dump(\"my-strategy\");\nawait Risk.dump(\"BTCUSDT\", \"my-strategy\");\nawait Schedule.dump(\"BTCUSDT\", \"my-strategy\");\nawait Partial.dump(\"BTCUSDT\", \"my-strategy\");\n```\n\n**Sources:** [src/classes/Performance.ts:18-38](), [src/classes/Heat.ts:18-31]()"
                    },
                    {
                        "page_plan": {
                            "id": "12.4",
                            "title": "Core Interfaces"
                        },
                        "content": "# Core Interfaces\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [docs/classes/StrategyConnectionService.md](docs/classes/StrategyConnectionService.md)\n- [docs/index.md](docs/index.md)\n- [docs/interfaces/IStrategy.md](docs/interfaces/IStrategy.md)\n- [docs/interfaces/IStrategySchema.md](docs/interfaces/IStrategySchema.md)\n- [docs/types/IStrategyBacktestResult.md](docs/types/IStrategyBacktestResult.md)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis page documents the schema interfaces that define the core configuration contracts for Backtest Kit. These interfaces are used to register strategies, exchanges, timeframes, risk profiles, walkers, position sizing rules, and optimizer configurations via the `add*` family of functions (see [Global Functions](#12.1)).\n\nFor information about runtime result types (signals, statistics, contracts), see [Signal & Result Types](#12.5) and [Statistics & Contract Types](#12.6). For internal service interfaces, see [Service Layer Interfaces](#12.7).\n\n---\n\n## Schema Registration Overview\n\nAll schema interfaces follow a consistent registration pattern: define a configuration object implementing the schema interface, then register it using the corresponding `add*` function.\n\n**Schema Registration Flow**\n\n```mermaid\ngraph LR\n    User[\"User Code\"]\n    \n    subgraph \"Public API\"\n        AddStrategy[\"addStrategy()\"]\n        AddExchange[\"addExchange()\"]\n        AddFrame[\"addFrame()\"]\n        AddRisk[\"addRisk()\"]\n        AddWalker[\"addWalker()\"]\n        AddSizing[\"addSizing()\"]\n        AddOptimizer[\"addOptimizer()\"]\n    end\n    \n    subgraph \"Schema Services\"\n        StrategySchema[\"StrategySchemaService<br/>ToolRegistry\"]\n        ExchangeSchema[\"ExchangeSchemaService<br/>ToolRegistry\"]\n        FrameSchema[\"FrameSchemaService<br/>ToolRegistry\"]\n        RiskSchema[\"RiskSchemaService<br/>ToolRegistry\"]\n        WalkerSchema[\"WalkerSchemaService<br/>ToolRegistry\"]\n        SizingSchema[\"SizingSchemaService<br/>ToolRegistry\"]\n        OptimizerSchema[\"OptimizerSchemaService<br/>ToolRegistry\"]\n    end\n    \n    subgraph \"Connection Services\"\n        StrategyConn[\"StrategyConnectionService<br/>Memoized ClientStrategy\"]\n        ExchangeConn[\"ExchangeConnectionService<br/>Memoized ClientExchange\"]\n        FrameConn[\"FrameConnectionService<br/>Memoized ClientFrame\"]\n        RiskConn[\"RiskConnectionService<br/>Memoized ClientRisk\"]\n        SizingConn[\"SizingConnectionService<br/>Memoized ClientSizing\"]\n        OptimizerConn[\"OptimizerConnectionService<br/>Memoized ClientOptimizer\"]\n    end\n    \n    User -->|\"IStrategySchema\"| AddStrategy\n    User -->|\"IExchangeSchema\"| AddExchange\n    User -->|\"IFrameSchema\"| AddFrame\n    User -->|\"IRiskSchema\"| AddRisk\n    User -->|\"IWalkerSchema\"| AddWalker\n    User -->|\"ISizingSchema\"| AddSizing\n    User -->|\"IOptimizerSchema\"| AddOptimizer\n    \n    AddStrategy --> StrategySchema\n    AddExchange --> ExchangeSchema\n    AddFrame --> FrameSchema\n    AddRisk --> RiskSchema\n    AddWalker --> WalkerSchema\n    AddSizing --> SizingSchema\n    AddOptimizer --> OptimizerSchema\n    \n    StrategyConn -.->|\"reads\"| StrategySchema\n    ExchangeConn -.->|\"reads\"| ExchangeSchema\n    FrameConn -.->|\"reads\"| FrameSchema\n    RiskConn -.->|\"reads\"| RiskSchema\n    SizingConn -.->|\"reads\"| SizingSchema\n    OptimizerConn -.->|\"reads\"| OptimizerSchema\n```\n\nSources: [types.d.ts:728-969](), [src/index.ts:10-18]()\n\n**Schema Interface Categories**\n\n| Category | Interface | Registered Via | Purpose |\n|----------|-----------|----------------|---------|\n| **Strategy** | `IStrategySchema` | `addStrategy()` | Defines signal generation logic and interval throttling |\n| **Exchange** | `IExchangeSchema` | `addExchange()` | Defines candle data source and price/quantity formatting |\n| **Frame** | `IFrameSchema` | `addFrame()` | Defines backtest time period and iteration interval |\n| **Risk** | `IRiskSchema` | `addRisk()` | Defines portfolio-level risk validations |\n| **Walker** | `IWalkerSchema` | `addWalker()` | Defines strategy comparison configuration |\n| **Sizing** | `ISizingSchema` | `addSizing()` | Defines position sizing calculation method |\n| **Optimizer** | `IOptimizerSchema` | `addOptimizer()` | Defines LLM-based strategy generation parameters |\n\nSources: [types.d.ts:728-969](), [src/index.ts:10-18]()\n\n---\n\n## IStrategySchema\n\nDefines a trading strategy including signal generation logic, execution interval, and lifecycle callbacks. Registered via `addStrategy()` (see [Global Functions](#12.1)).\n\n**Interface Definition**\n\n```typescript\ninterface IStrategySchema {\n    strategyName: StrategyName;\n    note?: string;\n    interval: SignalInterval;\n    getSignal: (symbol: string, when: Date) => Promise<ISignalDto | null>;\n    callbacks?: Partial<IStrategyCallbacks>;\n    riskName?: RiskName;\n    riskList?: RiskName[];\n}\n\ntype SignalInterval = \"1m\" | \"3m\" | \"5m\" | \"15m\" | \"30m\" | \"1h\";\ntype StrategyName = string;\n```\n\nSources: [types.d.ts:728-747](), [types.d.ts:645](), [types.d.ts:896]()\n\n**Property Reference**\n\n| Property | Type | Required | Description |\n|----------|------|----------|-------------|\n| `strategyName` | `StrategyName` | ✓ | Unique identifier for strategy registration and retrieval |\n| `note` | `string` | ✗ | Optional documentation comment for developer reference |\n| `interval` | `SignalInterval` | ✓ | Minimum time between `getSignal()` calls (throttling) |\n| `getSignal` | `function` | ✓ | Signal generation function returning `ISignalDto` or `null` |\n| `callbacks` | `Partial<IStrategyCallbacks>` | ✗ | Lifecycle event hooks (onOpen, onClose, onActive, etc.) |\n| `riskName` | `RiskName` | ✗ | Single risk profile to apply before signal creation |\n| `riskList` | `RiskName[]` | ✗ | Multiple risk profiles to merge and apply (alternative to `riskName`) |\n\nSources: [types.d.ts:728-747]()\n\n**getSignal Function Contract**\n\nThe `getSignal` function is the core of strategy logic. It receives the current symbol and timestamp, and returns either a signal or `null`.\n\n```typescript\ngetSignal: (symbol: string, when: Date) => Promise<ISignalDto | null>\n```\n\n- **Parameters:**\n  - `symbol`: Trading pair (e.g., \"BTCUSDT\")\n  - `when`: Current execution timestamp (ExecutionContext.when)\n- **Returns:**\n  - `ISignalDto` with `priceOpen` set: Creates **scheduled signal** waiting for price to reach entry\n  - `ISignalDto` with `priceOpen` omitted: Creates **immediate signal** at current VWAP price\n  - `null`: No signal generated (idle state)\n\nInside `getSignal`, use `getCandles()` to fetch historical data for analysis (see [Exchange Functions](#12.1)).\n\nSources: [types.d.ts:740]()\n\n**Signal Generation Flow**\n\n```mermaid\ngraph TD\n    Tick[\"ClientStrategy.tick()\"]\n    Throttle{\"Throttled?<br/>interval check\"}\n    GetSignal[\"Call getSignal()<br/>user function\"]\n    Result{\"Result?\"}\n    Validate[\"Multi-stage validation<br/>prices, TP/SL logic, distance\"]\n    RiskCheck{\"Risk validation<br/>if riskName/riskList\"}\n    PriceOpen{\"priceOpen<br/>provided?\"}\n    Scheduled[\"Create IScheduledSignalRow<br/>action: scheduled\"]\n    Opened[\"Create ISignalRow<br/>action: opened<br/>Persist to storage\"]\n    Idle[\"Return IStrategyTickResultIdle<br/>action: idle\"]\n    \n    Tick --> Throttle\n    Throttle -->|\"Yes, skip\"| Idle\n    Throttle -->|\"No, proceed\"| GetSignal\n    GetSignal --> Result\n    Result -->|\"null\"| Idle\n    Result -->|\"ISignalDto\"| Validate\n    Validate --> RiskCheck\n    RiskCheck -->|\"Rejected\"| Idle\n    RiskCheck -->|\"Allowed\"| PriceOpen\n    PriceOpen -->|\"Yes\"| Scheduled\n    PriceOpen -->|\"No, use VWAP\"| Opened\n```\n\nSources: [types.d.ts:728-747]()\n\n**Strategy Callbacks**\n\nThe `IStrategyCallbacks` interface defines lifecycle hooks invoked during signal execution:\n\n```typescript\ninterface IStrategyCallbacks {\n    onTick: (symbol: string, result: IStrategyTickResult, backtest: boolean) => void;\n    onOpen: (symbol: string, data: ISignalRow, currentPrice: number, backtest: boolean) => void;\n    onActive: (symbol: string, data: ISignalRow, currentPrice: number, backtest: boolean) => void;\n    onIdle: (symbol: string, currentPrice: number, backtest: boolean) => void;\n    onClose: (symbol: string, data: ISignalRow, priceClose: number, backtest: boolean) => void;\n    onSchedule: (symbol: string, data: IScheduledSignalRow, currentPrice: number, backtest: boolean) => void;\n    onCancel: (symbol: string, data: IScheduledSignalRow, currentPrice: number, backtest: boolean) => void;\n    onWrite: (symbol: string, data: ISignalRow | null, backtest: boolean) => void;\n    onPartialProfit: (symbol: string, data: ISignalRow, currentPrice: number, revenuePercent: number, backtest: boolean) => void;\n    onPartialLoss: (symbol: string, data: ISignalRow, currentPrice: number, lossPercent: number, backtest: boolean) => void;\n}\n```\n\n| Callback | When Called | Use Case |\n|----------|-------------|----------|\n| `onTick` | Every tick regardless of state | General monitoring, logging all ticks |\n| `onOpen` | Signal activated at `priceOpen` | Track entry execution |\n| `onActive` | Signal being monitored (TP/SL/time) | Track active position progress |\n| `onIdle` | No active signal | Track idle periods |\n| `onClose` | Signal closed (TP/SL/time_expired) | Track exit execution and PNL |\n| `onSchedule` | Scheduled signal created | Track pending orders |\n| `onCancel` | Scheduled signal cancelled | Track cancelled limit orders |\n| `onWrite` | Signal persisted to storage | Testing persistence layer |\n| `onPartialProfit` | Profit milestone reached (10%, 20%, etc.) | Track unrealized gains |\n| `onPartialLoss` | Loss milestone reached (-10%, -20%, etc.) | Track unrealized losses |\n\nSources: [types.d.ts:702-723]()\n\n**Example: Simple Moving Average Crossover Strategy**\n\n```typescript\nimport { addStrategy, getCandles } from \"backtest-kit\";\n\naddStrategy({\n  strategyName: \"ma-crossover\",\n  interval: \"5m\",\n  \n  getSignal: async (symbol, when) => {\n    // Fetch last 50 candles at 1-hour interval\n    const candles = await getCandles(symbol, \"1h\", 50);\n    \n    // Calculate 20-period and 50-period moving averages\n    const ma20 = candles.slice(-20).reduce((sum, c) => sum + c.close, 0) / 20;\n    const ma50 = candles.slice(-50).reduce((sum, c) => sum + c.close, 0) / 50;\n    \n    const currentPrice = candles[candles.length - 1].close;\n    \n    // Bullish crossover: MA20 > MA50\n    if (ma20 > ma50) {\n      return {\n        position: \"long\",\n        priceTakeProfit: currentPrice * 1.03,  // 3% profit target\n        priceStopLoss: currentPrice * 0.98,     // 2% stop loss\n        minuteEstimatedTime: 240,               // 4 hours max duration\n        note: `MA20: ${ma20.toFixed(2)}, MA50: ${ma50.toFixed(2)}`\n      };\n    }\n    \n    return null;  // No signal\n  },\n  \n  callbacks: {\n    onOpen: (symbol, data, currentPrice) => {\n      console.log(`[OPEN] ${symbol} at ${currentPrice}`);\n    },\n    onClose: (symbol, data, priceClose) => {\n      console.log(`[CLOSE] ${symbol} at ${priceClose}`);\n    }\n  },\n  \n  riskName: \"conservative\"  // Apply risk validation\n});\n```\n\nSources: [types.d.ts:728-747]()\n\n---\n\n## IExchangeSchema\n\nDefines a data source for market data including candle fetching and price/quantity formatting. Registered via `addExchange()`.\n\n**Interface Definition**\n\n```typescript\ninterface IExchangeSchema {\n    exchangeName: ExchangeName;\n    note?: string;\n    getCandles: (symbol: string, interval: CandleInterval, since: Date, limit: number) => Promise<ICandleData[]>;\n    formatQuantity: (symbol: string, quantity: number) => Promise<string>;\n    formatPrice: (symbol: string, price: number) => Promise<string>;\n    callbacks?: Partial<IExchangeCallbacks>;\n}\n\ntype ExchangeName = string;\ntype CandleInterval = \"1m\" | \"3m\" | \"5m\" | \"15m\" | \"30m\" | \"1h\" | \"2h\" | \"4h\" | \"6h\" | \"8h\";\n\ninterface ICandleData {\n    timestamp: number;  // Unix timestamp in milliseconds\n    open: number;\n    high: number;\n    low: number;\n    close: number;\n    volume: number;\n}\n```\n\nSources: [types.d.ts:122-155](), [types.d.ts:82](), [types.d.ts:87-100]()\n\n**Property Reference**\n\n| Property | Type | Required | Description |\n|----------|------|----------|-------------|\n| `exchangeName` | `ExchangeName` | ✓ | Unique identifier for exchange registration |\n| `note` | `string` | ✗ | Optional documentation comment |\n| `getCandles` | `function` | ✓ | Fetch historical OHLCV candles from data source |\n| `formatQuantity` | `function` | ✓ | Format quantity according to exchange precision rules |\n| `formatPrice` | `function` | ✓ | Format price according to exchange precision rules |\n| `callbacks` | `Partial<IExchangeCallbacks>` | ✗ | Event hooks (onCandleData) |\n\nSources: [types.d.ts:122-155]()\n\n**getCandles Function Contract**\n\n```typescript\ngetCandles: (symbol: string, interval: CandleInterval, since: Date, limit: number) => Promise<ICandleData[]>\n```\n\n- **Parameters:**\n  - `symbol`: Trading pair (e.g., \"BTCUSDT\")\n  - `interval`: Candle timeframe (\"1m\", \"5m\", \"1h\", etc.)\n  - `since`: Start date for candle fetching (inclusive)\n  - `limit`: Maximum number of candles to return\n- **Returns:** Array of `ICandleData` sorted by timestamp ascending\n- **Requirements:**\n  - Must return complete candles only (no partial candles)\n  - Must detect and handle anomalous prices (validated by ClientExchange)\n  - Should implement retry logic for API failures\n\nSources: [types.d.ts:136]()\n\n**Data Flow: Exchange to VWAP Calculation**\n\n```mermaid\ngraph LR\n    User[\"getSignal() or tick()\"]\n    Global[\"getCandles() global function\"]\n    ExchConn[\"ExchangeConnectionService\"]\n    ClientExch[\"ClientExchange\"]\n    Schema[\"IExchangeSchema.getCandles()\"]\n    Buffer[\"Candle Buffer<br/>Last 5x 1m candles\"]\n    VWAP[\"VWAP Calculation<br/>Σ(typical price × volume) / Σ(volume)\"]\n    \n    User -->|\"calls\"| Global\n    Global --> ExchConn\n    ExchConn -->|\"routes by exchangeName\"| ClientExch\n    ClientExch -->|\"invokes\"| Schema\n    Schema -->|\"returns ICandleData[]\"| ClientExch\n    ClientExch --> Buffer\n    Buffer --> VWAP\n```\n\nSources: [types.d.ts:122-155]()\n\n**Example: CCXT Integration**\n\n```typescript\nimport { addExchange } from \"backtest-kit\";\nimport ccxt from \"ccxt\";\n\nconst exchange = new ccxt.binance();\n\naddExchange({\n  exchangeName: \"binance\",\n  \n  getCandles: async (symbol, interval, since, limit) => {\n    const ohlcv = await exchange.fetchOHLCV(symbol, interval, since.getTime(), limit);\n    return ohlcv.map(([timestamp, open, high, low, close, volume]) => ({\n      timestamp,\n      open,\n      high,\n      low,\n      close,\n      volume\n    }));\n  },\n  \n  formatQuantity: async (symbol, quantity) => {\n    await exchange.loadMarkets();\n    return exchange.amountToPrecision(symbol, quantity);\n  },\n  \n  formatPrice: async (symbol, price) => {\n    await exchange.loadMarkets();\n    return exchange.priceToPrecision(symbol, price);\n  },\n  \n  callbacks: {\n    onCandleData: (symbol, interval, since, limit, data) => {\n      console.log(`Fetched ${data.length} candles for ${symbol} ${interval}`);\n    }\n  }\n});\n```\n\nSources: [types.d.ts:122-155]()\n\n---\n\n## IFrameSchema\n\nDefines a backtest time period and iteration interval for generating timeframes. Registered via `addFrame()`.\n\n**Interface Definition**\n\n```typescript\ninterface IFrameSchema {\n    frameName: FrameName;\n    note?: string;\n    interval: FrameInterval;\n    startDate: Date;\n    endDate: Date;\n    callbacks?: Partial<IFrameCallbacks>;\n}\n\ntype FrameName = string;\ntype FrameInterval = \"1m\" | \"3m\" | \"5m\" | \"15m\" | \"30m\" | \"1h\" | \"2h\" | \"4h\" | \"6h\" | \"8h\" | \"12h\" | \"1d\" | \"3d\";\n```\n\nSources: [types.d.ts:262-275](), [types.d.ts:219]()\n\n**Property Reference**\n\n| Property | Type | Required | Description |\n|----------|------|----------|-------------|\n| `frameName` | `FrameName` | ✓ | Unique identifier for frame registration |\n| `note` | `string` | ✗ | Optional documentation comment |\n| `interval` | `FrameInterval` | ✓ | Spacing between generated timestamps |\n| `startDate` | `Date` | ✓ | Beginning of backtest period (inclusive) |\n| `endDate` | `Date` | ✓ | End of backtest period (inclusive) |\n| `callbacks` | `Partial<IFrameCallbacks>` | ✗ | Event hooks (onTimeframe) |\n\nSources: [types.d.ts:262-275]()\n\n**Timeframe Generation**\n\nClientFrame generates an array of `Date` objects from `startDate` to `endDate` spaced by `interval`. BacktestLogicPrivateService iterates through these timestamps, setting `ExecutionContext.when` for each tick.\n\n```mermaid\ngraph LR\n    Frame[\"IFrameSchema<br/>startDate: 2024-01-01<br/>endDate: 2024-01-02<br/>interval: 1m\"]\n    Generate[\"ClientFrame.getTimeframe()\"]\n    Timeframe[\"Date[]<br/>1440 timestamps<br/>spaced 1 minute apart\"]\n    Backtest[\"BacktestLogicPrivateService\"]\n    Loop[\"for each timestamp:<br/>ExecutionContext.when = timestamp<br/>StrategyCore.tick()\"]\n    \n    Frame --> Generate\n    Generate --> Timeframe\n    Timeframe --> Backtest\n    Backtest --> Loop\n```\n\nSources: [types.d.ts:262-275]()\n\n**Example: Multiple Time Ranges**\n\n```typescript\nimport { addFrame } from \"backtest-kit\";\n\n// Short-term test (1 day, 1-minute granularity)\naddFrame({\n  frameName: \"1d-test\",\n  interval: \"1m\",\n  startDate: new Date(\"2024-01-01T00:00:00Z\"),\n  endDate: new Date(\"2024-01-02T00:00:00Z\"),\n  note: \"Quick test with high resolution\"\n});\n\n// Medium-term backtest (1 month, 5-minute granularity)\naddFrame({\n  frameName: \"1m-backtest\",\n  interval: \"5m\",\n  startDate: new Date(\"2024-01-01T00:00:00Z\"),\n  endDate: new Date(\"2024-02-01T00:00:00Z\"),\n  note: \"Standard backtest period\"\n});\n\n// Long-term analysis (1 year, 1-hour granularity)\naddFrame({\n  frameName: \"1y-analysis\",\n  interval: \"1h\",\n  startDate: new Date(\"2023-01-01T00:00:00Z\"),\n  endDate: new Date(\"2024-01-01T00:00:00Z\"),\n  note: \"Long-term performance evaluation\"\n});\n```\n\nSources: [types.d.ts:262-275]()\n\n---\n\n## IRiskSchema\n\nDefines portfolio-level risk validation rules applied before signal creation. Registered via `addRisk()`.\n\n**Interface Definition**\n\n```typescript\ninterface IRiskSchema {\n    riskName: RiskName;\n    note?: string;\n    callbacks?: Partial<IRiskCallbacks>;\n    validations: (IRiskValidation | IRiskValidationFn)[];\n}\n\ntype RiskName = string;\n\ninterface IRiskValidation {\n    validate: IRiskValidationFn;\n    note?: string;\n}\n\ninterface IRiskValidationFn {\n    (payload: IRiskValidationPayload): void | Promise<void>;\n}\n\ninterface IRiskValidationPayload extends IRiskCheckArgs {\n    pendingSignal: ISignalDto;\n    activePositionCount: number;\n    activePositions: IRiskActivePosition[];\n}\n```\n\nSources: [types.d.ts:417-426](), [types.d.ts:395-411]()\n\n**Property Reference**\n\n| Property | Type | Required | Description |\n|----------|------|----------|-------------|\n| `riskName` | `RiskName` | ✓ | Unique identifier for risk profile registration |\n| `note` | `string` | ✗ | Optional documentation comment |\n| `callbacks` | `Partial<IRiskCallbacks>` | ✗ | Event hooks (onRejected, onAllowed) |\n| `validations` | Array | ✓ | Validation functions or objects with `validate` function and `note` |\n\nSources: [types.d.ts:417-426]()\n\n**Validation Function Contract**\n\n```typescript\ninterface IRiskValidationFn {\n    (payload: IRiskValidationPayload): void | Promise<void>;\n}\n```\n\nValidation functions receive a payload with:\n- `symbol`: Trading pair\n- `pendingSignal`: The signal to validate\n- `strategyName`: Strategy requesting the signal\n- `exchangeName`: Exchange name\n- `currentPrice`: Current VWAP price\n- `timestamp`: Current timestamp\n- `activePositionCount`: Number of currently open positions\n- `activePositions`: Array of active position details\n\n**Validation behavior:**\n- **Throw error**: Signal is rejected, `riskSubject` emits rejection event\n- **Return void**: Signal is allowed to proceed\n\nSources: [types.d.ts:395-411]()\n\n**Risk Validation Pipeline**\n\n```mermaid\ngraph TD\n    GetSignal[\"getSignal() returns ISignalDto\"]\n    Validate[\"Multi-stage validation<br/>GLOBAL_CONFIG checks\"]\n    HasRisk{\"riskName or<br/>riskList?\"}\n    RiskConn[\"RiskConnectionService\"]\n    ClientRisk[\"ClientRisk or MergeRisk\"]\n    Loop[\"For each validation function\"]\n    Execute[\"Execute validation(payload)\"]\n    Throws{\"Throws error?\"}\n    Reject[\"Emit riskSubject<br/>Return action: idle\"]\n    Allow[\"Proceed to signal creation\"]\n    \n    GetSignal --> Validate\n    Validate --> HasRisk\n    HasRisk -->|\"No\"| Allow\n    HasRisk -->|\"Yes\"| RiskConn\n    RiskConn --> ClientRisk\n    ClientRisk --> Loop\n    Loop --> Execute\n    Execute --> Throws\n    Throws -->|\"Yes\"| Reject\n    Throws -->|\"No, continue\"| Loop\n    Loop -->|\"All passed\"| Allow\n```\n\nSources: [types.d.ts:417-426]()\n\n**Example: Conservative Risk Profile**\n\n```typescript\nimport { addRisk } from \"backtest-kit\";\n\naddRisk({\n  riskName: \"conservative\",\n  note: \"Max 3 concurrent positions, no crypto pairs during weekends\",\n  \n  validations: [\n    // Validation 1: Maximum concurrent positions\n    {\n      validate: (payload) => {\n        if (payload.activePositionCount >= 3) {\n          throw new Error(`Max 3 concurrent positions (current: ${payload.activePositionCount})`);\n        }\n      },\n      note: \"Limit portfolio exposure\"\n    },\n    \n    // Validation 2: No crypto trading on weekends\n    {\n      validate: (payload) => {\n        const day = new Date(payload.timestamp).getDay();\n        const isWeekend = day === 0 || day === 6;\n        if (isWeekend && payload.symbol.includes(\"USD\")) {\n          throw new Error(\"No crypto trading on weekends\");\n        }\n      },\n      note: \"Reduce weekend volatility exposure\"\n    },\n    \n    // Validation 3: No overlapping symbols\n    {\n      validate: (payload) => {\n        const hasSymbol = payload.activePositions.some(pos => pos.signal.symbol === payload.symbol);\n        if (hasSymbol) {\n          throw new Error(`Already have active position for ${payload.symbol}`);\n        }\n      },\n      note: \"One position per symbol\"\n    }\n  ],\n  \n  callbacks: {\n    onRejected: (symbol, params) => {\n      console.log(`[RISK REJECTED] ${symbol}: ${params.strategyName}`);\n    }\n  }\n});\n```\n\nSources: [types.d.ts:417-426]()\n\n**MergeRisk Pattern**\n\nWhen a strategy specifies `riskList` instead of `riskName`, the system creates a `MergeRisk` instance that combines multiple risk profiles. All validations from all profiles must pass.\n\n```typescript\naddStrategy({\n  strategyName: \"aggressive-strategy\",\n  riskList: [\"conservative\", \"volatility-filter\", \"drawdown-limit\"],\n  // ... other properties\n});\n```\n\nSources: [types.d.ts:746]()\n\n---\n\n## IWalkerSchema\n\nDefines a strategy comparison configuration for A/B testing multiple strategies. Registered via `addWalker()`.\n\n**Interface Definition**\n\n```typescript\ninterface IWalkerSchema {\n    walkerName: WalkerName;\n    note?: string;\n    exchangeName: ExchangeName;\n    frameName: FrameName;\n    strategies: StrategyName[];\n    metric?: WalkerMetric;\n    callbacks?: Partial<IWalkerCallbacks>;\n}\n\ntype WalkerName = string;\ntype WalkerMetric = \"sharpeRatio\" | \"annualizedSharpeRatio\" | \"winRate\" | \"totalPnl\" | \"certaintyRatio\" | \"avgPnl\" | \"expectedYearlyReturns\";\n```\n\nSources: [types.d.ts:954-969](), [types.d.ts:949]()\n\n**Property Reference**\n\n| Property | Type | Required | Description |\n|----------|------|----------|-------------|\n| `walkerName` | `WalkerName` | ✓ | Unique identifier for walker registration |\n| `note` | `string` | ✗ | Optional documentation comment |\n| `exchangeName` | `ExchangeName` | ✓ | Exchange to use for all strategy backtests |\n| `frameName` | `FrameName` | ✓ | Timeframe to use for all strategy backtests |\n| `strategies` | `StrategyName[]` | ✓ | List of strategy names to compare |\n| `metric` | `WalkerMetric` | ✗ | Optimization metric (default: \"sharpeRatio\") |\n| `callbacks` | `Partial<IWalkerCallbacks>` | ✗ | Event hooks (onStrategyStart, onStrategyComplete) |\n\nSources: [types.d.ts:954-969]()\n\n**Walker Execution Flow**\n\n```mermaid\ngraph TD\n    WalkerRun[\"Walker.run(symbol, { walkerName })\"]\n    LoadSchema[\"Load IWalkerSchema\"]\n    Init[\"best = null<br/>results = []\"]\n    Loop[\"For each strategy in strategies\"]\n    RunBacktest[\"Backtest.run(symbol, {<br/>strategyName,<br/>exchangeName,<br/>frameName<br/>})\"]\n    GetStats[\"BacktestMarkdownService.getData()\"]\n    Extract[\"Extract metric value<br/>e.g., stats.sharpeRatio\"]\n    Compare{\"metric > best?\"}\n    UpdateBest[\"best = metric<br/>bestStrategy = strategyName\"]\n    Emit[\"Emit walkerEmitter<br/>with progress\"]\n    Done[\"Emit walkerCompleteSubject<br/>Return IWalkerResults\"]\n    \n    WalkerRun --> LoadSchema\n    LoadSchema --> Init\n    Init --> Loop\n    Loop --> RunBacktest\n    RunBacktest --> GetStats\n    GetStats --> Extract\n    Extract --> Compare\n    Compare -->|\"Yes\"| UpdateBest\n    Compare -->|\"No\"| Emit\n    UpdateBest --> Emit\n    Emit --> Loop\n    Loop -->|\"All complete\"| Done\n```\n\nSources: [types.d.ts:954-969]()\n\n**Optimization Metrics**\n\n| Metric | Formula / Description | Higher is Better |\n|--------|----------------------|------------------|\n| `sharpeRatio` | `avgPnl / stdDev` | ✓ |\n| `annualizedSharpeRatio` | `sharpeRatio × √365` | ✓ |\n| `winRate` | `(winCount / totalSignals) × 100` | ✓ |\n| `totalPnl` | `Σ(pnlPercentage)` | ✓ |\n| `certaintyRatio` | `avgWin / \\|avgLoss\\|` | ✓ |\n| `avgPnl` | `totalPnl / totalSignals` | ✓ |\n| `expectedYearlyReturns` | Based on avg trade duration and PNL | ✓ |\n\nSources: [types.d.ts:949]()\n\n**Example: Strategy Comparison**\n\n```typescript\nimport { addWalker } from \"backtest-kit\";\n\naddWalker({\n  walkerName: \"ma-comparison\",\n  exchangeName: \"binance\",\n  frameName: \"1m-backtest\",\n  \n  strategies: [\n    \"ma-crossover-fast\",   // 10/20 MA\n    \"ma-crossover-slow\",   // 20/50 MA\n    \"ma-crossover-ultra\",  // 50/200 MA\n  ],\n  \n  metric: \"sharpeRatio\",  // Optimize for risk-adjusted returns\n  \n  callbacks: {\n    onStrategyStart: (strategyName, symbol) => {\n      console.log(`Testing ${strategyName} on ${symbol}...`);\n    },\n    \n    onStrategyComplete: (strategyName, symbol, stats, metric) => {\n      console.log(`${strategyName}: Sharpe Ratio = ${metric}`);\n    }\n  }\n});\n\n// Run comparison\nconst results = await Walker.run(\"BTCUSDT\", { walkerName: \"ma-comparison\" });\nconsole.log(`Best strategy: ${results.bestStrategy} (${results.bestMetric})`);\n```\n\nSources: [types.d.ts:954-969]()\n\n---\n\n## ISizingSchema\n\nDefines position sizing calculation methods. Registered via `addSizing()`. Three sizing strategies are supported: fixed percentage, Kelly Criterion, and ATR-based.\n\n**Base Interface**\n\n```typescript\ninterface ISizingSchemaBase {\n    sizingName: SizingName;\n    note?: string;\n    callbacks?: Partial<ISizingCallbacks>;\n}\n\ntype SizingName = string;\n```\n\n**Fixed Percentage Sizing**\n\n```typescript\ninterface ISizingSchemaFixedPercentage extends ISizingSchemaBase {\n    strategy: \"fixed-percentage\";\n    params: IPositionSizeFixedPercentageParams;\n}\n\ninterface IPositionSizeFixedPercentageParams {\n    portfolioPercent: number;  // Percentage of portfolio to risk per trade (e.g., 2 = 2%)\n}\n```\n\n**Kelly Criterion Sizing**\n\n```typescript\ninterface ISizingSchemaKelly extends ISizingSchemaBase {\n    strategy: \"kelly\";\n    params: IPositionSizeKellyParams;\n}\n\ninterface IPositionSizeKellyParams {\n    winRate: number;           // Historical win rate (0-1, e.g., 0.55 = 55%)\n    avgWinPercent: number;     // Average win percentage\n    avgLossPercent: number;    // Average loss percentage\n    kellyFraction?: number;    // Fraction of Kelly to use (default: 0.5 for half-Kelly)\n}\n```\n\n**ATR-Based Sizing**\n\n```typescript\ninterface ISizingSchemaATR extends ISizingSchemaBase {\n    strategy: \"atr\";\n    params: IPositionSizeATRParams;\n}\n\ninterface IPositionSizeATRParams {\n    atrMultiplier: number;     // Stop loss distance in ATR units (e.g., 2 = 2×ATR)\n    riskPercent: number;       // Percentage of portfolio to risk (e.g., 1 = 1%)\n}\n```\n\n**Example: Multiple Sizing Profiles**\n\n```typescript\nimport { addSizing } from \"backtest-kit\";\n\n// Conservative fixed percentage\naddSizing({\n  sizingName: \"conservative\",\n  strategy: \"fixed-percentage\",\n  params: {\n    portfolioPercent: 1  // Risk 1% per trade\n  }\n});\n\n// Aggressive Kelly Criterion\naddSizing({\n  sizingName: \"kelly-aggressive\",\n  strategy: \"kelly\",\n  params: {\n    winRate: 0.58,\n    avgWinPercent: 3.2,\n    avgLossPercent: 1.8,\n    kellyFraction: 0.75  // Use 75% of full Kelly\n  }\n});\n\n// Volatility-based ATR sizing\naddSizing({\n  sizingName: \"atr-adaptive\",\n  strategy: \"atr\",\n  params: {\n    atrMultiplier: 2,   // Stop loss at 2×ATR\n    riskPercent: 2      // Risk 2% per trade\n  }\n});\n```\n\nSources: Referenced in [src/index.ts:93-103]()\n\n---\n\n## IOptimizerSchema\n\nDefines configuration for LLM-powered strategy generation. Registered via `addOptimizer()`.\n\n**Interface Definition**\n\n```typescript\ninterface IOptimizerSchema {\n    optimizerName: OptimizerName;\n    note?: string;\n    sources: IOptimizerSource[];\n    prompt: string;\n    template?: IOptimizerTemplate;\n    callbacks?: Partial<IOptimizerCallbacks>;\n}\n\ntype OptimizerName = string;\n\ninterface IOptimizerSource {\n    exchangeName: ExchangeName;\n    frameName: FrameName;\n    walkerName?: WalkerName;\n    strategies: IOptimizerStrategy[];\n}\n\ninterface IOptimizerStrategy {\n    strategyName: StrategyName;\n    range?: IOptimizerRange;\n    filter?: (args: IOptimizerFilterArgs) => boolean;\n}\n```\n\nSources: Referenced in [src/index.ts:124-134]()\n\n**Property Reference**\n\n| Property | Type | Required | Description |\n|----------|------|----------|-------------|\n| `optimizerName` | `OptimizerName` | ✓ | Unique identifier for optimizer registration |\n| `note` | `string` | ✗ | Optional documentation comment |\n| `sources` | `IOptimizerSource[]` | ✓ | Data sources (backtest results) to analyze |\n| `prompt` | `string` | ✓ | System prompt for LLM strategy generation |\n| `template` | `IOptimizerTemplate` | ✗ | Custom code generation template (default: OptimizerTemplateService) |\n| `callbacks` | `Partial<IOptimizerCallbacks>` | ✗ | Event hooks (onDataFetch, onGenerate, onSave) |\n\n**Optimizer Data Flow**\n\n```mermaid\ngraph TD\n    OptimizerRun[\"Optimizer.run(symbol, { optimizerName })\"]\n    LoadSchema[\"Load IOptimizerSchema\"]\n    FetchData[\"For each source:<br/>Backtest.run()<br/>Collect stats\"]\n    Aggregate[\"Aggregate data<br/>IOptimizerData[]\"]\n    LLM[\"Call Ollama LLM<br/>deepseek-v3.1:671b<br/>with prompt + data\"]\n    Response[\"LLM returns<br/>strategy code\"]\n    Template[\"OptimizerTemplateService<br/>Wrap in executable template\"]\n    SaveFile[\"Save to .mjs file<br/>./dump/optimizer/\"]\n    \n    OptimizerRun --> LoadSchema\n    LoadSchema --> FetchData\n    FetchData --> Aggregate\n    Aggregate --> LLM\n    LLM --> Response\n    Response --> Template\n    Template --> SaveFile\n```\n\nSources: Referenced in [src/index.ts:124-134]()\n\n**Example: Strategy Evolution**\n\n```typescript\nimport { addOptimizer } from \"backtest-kit\";\n\naddOptimizer({\n  optimizerName: \"evolve-ma-strategy\",\n  \n  sources: [\n    {\n      exchangeName: \"binance\",\n      frameName: \"1m-backtest\",\n      strategies: [\n        { strategyName: \"ma-crossover-fast\" },\n        { strategyName: \"ma-crossover-slow\" },\n        { strategyName: \"ma-crossover-ultra\" }\n      ]\n    }\n  ],\n  \n  prompt: `\n    Analyze the provided moving average crossover strategies.\n    Generate an improved version that combines the best characteristics.\n    \n    Requirements:\n    - Use multiple timeframe analysis\n    - Add volume confirmation\n    - Implement dynamic take profit based on volatility\n    - Return a complete strategy implementation\n  `,\n  \n  callbacks: {\n    onDataFetch: (data) => {\n      console.log(`Fetched ${data.length} strategy results`);\n    },\n    onGenerate: (code) => {\n      console.log(`Generated ${code.length} characters of code`);\n    },\n    onSave: (filepath) => {\n      console.log(`Saved to ${filepath}`);\n    }\n  }\n});\n```\n\nSources: Referenced in [src/index.ts:124-134]()\n\n---\n\n## Schema Interface Relationships\n\n**Type Hierarchy**\n\n```mermaid\ngraph TB\n    subgraph \"Schema Interfaces\"\n        Strategy[\"IStrategySchema<br/>Signal generation\"]\n        Exchange[\"IExchangeSchema<br/>Data source\"]\n        Frame[\"IFrameSchema<br/>Timeframe\"]\n        Risk[\"IRiskSchema<br/>Validation\"]\n        Walker[\"IWalkerSchema<br/>Comparison\"]\n        Sizing[\"ISizingSchema<br/>Position size\"]\n        Optimizer[\"IOptimizerSchema<br/>LLM generation\"]\n    end\n    \n    subgraph \"Core Types\"\n        SignalDto[\"ISignalDto\"]\n        SignalRow[\"ISignalRow\"]\n        TickResult[\"IStrategyTickResult\"]\n        Candle[\"ICandleData\"]\n        Stats[\"BacktestStatisticsModel\"]\n    end\n    \n    subgraph \"Context Services\"\n        ExecCtx[\"ExecutionContext<br/>symbol, when, backtest\"]\n        MethodCtx[\"MethodContext<br/>strategyName, exchangeName, frameName\"]\n    end\n    \n    Strategy -->|\"returns\"| SignalDto\n    Strategy -->|\"references\"| Risk\n    Strategy -->|\"uses\"| Exchange\n    \n    Exchange -->|\"returns\"| Candle\n    \n    Frame -->|\"sets\"| ExecCtx\n    \n    Walker -->|\"tests\"| Strategy\n    Walker -->|\"uses\"| Exchange\n    Walker -->|\"uses\"| Frame\n    Walker -->|\"produces\"| Stats\n    \n    Optimizer -->|\"analyzes\"| Stats\n    Optimizer -->|\"generates\"| Strategy\n    \n    MethodCtx -->|\"identifies\"| Strategy\n    MethodCtx -->|\"identifies\"| Exchange\n    MethodCtx -->|\"identifies\"| Frame\n    \n    SignalDto -->|\"validated to\"| SignalRow\n    SignalRow -->|\"wrapped in\"| TickResult\n```\n\nSources: [types.d.ts:11-969]()\n\n**Registration and Retrieval Pattern**\n\nAll schemas follow a consistent pattern:\n\n```mermaid\ngraph LR\n    Register[\"add*() function\"]\n    Validate[\"*ValidationService<br/>Check for duplicates\"]\n    Store[\"*SchemaService<br/>ToolRegistry storage\"]\n    Retrieve[\"*ConnectionService<br/>Memoized factory\"]\n    Client[\"Client*<br/>Implementation\"]\n    \n    Register --> Validate\n    Validate --> Store\n    Store --> Retrieve\n    Retrieve --> Client\n```\n\n| Step | Strategy | Exchange | Frame | Risk | Walker | Sizing | Optimizer |\n|------|----------|----------|-------|------|--------|--------|-----------|\n| **Register** | `addStrategy()` | `addExchange()` | `addFrame()` | `addRisk()` | `addWalker()` | `addSizing()` | `addOptimizer()` |\n| **Validate** | `StrategyValidationService` | `ExchangeValidationService` | `FrameValidationService` | `RiskValidationService` | `WalkerValidationService` | `SizingValidationService` | `OptimizerValidationService` |\n| **Store** | `StrategySchemaService` | `ExchangeSchemaService` | `FrameSchemaService` | `RiskSchemaService` | `WalkerSchemaService` | `SizingSchemaService` | `OptimizerSchemaService` |\n| **Connect** | `StrategyConnectionService` | `ExchangeConnectionService` | `FrameConnectionService` | `RiskConnectionService` | — | `SizingConnectionService` | `OptimizerConnectionService` |\n| **Client** | `ClientStrategy` | `ClientExchange` | `ClientFrame` | `ClientRisk` | — | `ClientSizing` | `ClientOptimizer` |\n\nSources: [src/index.ts:10-18](), [types.d.ts:728-969]()\n\n---\n\n## Related Pages\n\n- **[Global Functions](#12.1)**: `addStrategy()`, `addExchange()`, and other registration functions\n- **[Execution Classes API](#12.2)**: `Backtest`, `Live`, `Walker` classes that consume these schemas\n- **[Signal & Result Types](#12.5)**: `ISignalDto`, `ISignalRow`, `IStrategyTickResult` interfaces\n- **[Statistics & Contract Types](#12.6)**: Result models and event contracts\n- **[Service Layer Interfaces](#12.7)**: Internal service interfaces for advanced usage\n\nSources: [types.d.ts:1-969](), [src/index.ts:1-199]()"
                    },
                    {
                        "page_plan": {
                            "id": "12.5",
                            "title": "Signal & Result Types"
                        },
                        "content": "# Signal & Result Types\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [docs/classes/StrategyConnectionService.md](docs/classes/StrategyConnectionService.md)\n- [docs/index.md](docs/index.md)\n- [docs/interfaces/IStrategy.md](docs/interfaces/IStrategy.md)\n- [docs/interfaces/IStrategySchema.md](docs/interfaces/IStrategySchema.md)\n- [docs/types/IStrategyBacktestResult.md](docs/types/IStrategyBacktestResult.md)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose\n\nThis page documents the core type definitions for signals and strategy execution results in Backtest Kit. These types define the data structures passed between strategy functions (`getSignal`), returned from execution methods (`tick`, `backtest`), and emitted through the event system.\n\nFor strategy development and the `getSignal` function contract, see [Strategy Development](#6). For signal lifecycle state transitions, see [Signals & Signal Lifecycle](#3.1). For schema interface definitions, see [Core Interfaces](#12.4).\n\n**Sources:** [types.d.ts:641-892](), [src/index.ts:74-88]()\n\n---\n\n## Type Hierarchy Overview\n\nThe signal and result types form a hierarchy from user input to system output:\n\n```mermaid\ngraph TD\n    subgraph \"Input: Strategy Returns\"\n        DTO[\"ISignalDto<br/>(from getSignal)\"]\n    end\n    \n    subgraph \"Internal: System State\"\n        ROW[\"ISignalRow<br/>(with id, timestamps)\"]\n        SCHED[\"IScheduledSignalRow<br/>(extends ISignalRow)\"]\n    end\n    \n    subgraph \"Output: Result Discriminated Union\"\n        RESULT[\"IStrategyTickResult\"]\n        IDLE[\"IStrategyTickResultIdle\"]\n        SCHEDULED[\"IStrategyTickResultScheduled\"]\n        OPENED[\"IStrategyTickResultOpened\"]\n        ACTIVE[\"IStrategyTickResultActive\"]\n        CLOSED[\"IStrategyTickResultClosed\"]\n        CANCELLED[\"IStrategyTickResultCancelled\"]\n    end\n    \n    subgraph \"Backtest Subset\"\n        BT_RESULT[\"IStrategyBacktestResult\"]\n    end\n    \n    subgraph \"Supplemental Types\"\n        PNL[\"IStrategyPnL\"]\n        REASON[\"StrategyCloseReason\"]\n    end\n    \n    DTO -->|\"validation +<br/>auto-generation\"| ROW\n    DTO -->|\"if priceOpen specified\"| SCHED\n    \n    ROW --> OPENED\n    ROW --> ACTIVE\n    ROW --> CLOSED\n    \n    SCHED --> SCHEDULED\n    SCHED --> CANCELLED\n    \n    IDLE --> RESULT\n    SCHEDULED --> RESULT\n    OPENED --> RESULT\n    ACTIVE --> RESULT\n    CLOSED --> RESULT\n    CANCELLED --> RESULT\n    \n    CLOSED --> BT_RESULT\n    CANCELLED --> BT_RESULT\n    \n    CLOSED -.->|\"contains\"| PNL\n    CLOSED -.->|\"contains\"| REASON\n```\n\n**Sources:** [types.d.ts:641-892]()\n\n---\n\n## Signal Input Types\n\n### ISignalDto\n\nData transfer object returned by `getSignal()` in strategy implementations. Contains user-specified signal parameters that will be validated and augmented by the system.\n\n```typescript\ninterface ISignalDto {\n    id?: string;                      // Optional: auto-generated if omitted\n    position: \"long\" | \"short\";       // Trade direction\n    note?: string;                    // Human-readable reason\n    priceOpen?: number;               // Entry price (if omitted, opens at VWAP)\n    priceTakeProfit: number;          // TP target (required)\n    priceStopLoss: number;            // SL exit (required)\n    minuteEstimatedTime: number;      // Time limit in minutes\n}\n```\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `id` | `string` | No | Signal identifier (auto-generated UUID v4 if not provided) |\n| `position` | `\"long\" \\| \"short\"` | Yes | Trade direction: \"long\" for buy, \"short\" for sell |\n| `note` | `string` | No | Human-readable description of signal reason |\n| `priceOpen` | `number` | No | Entry price. If specified, creates scheduled signal. If omitted, opens immediately at VWAP |\n| `priceTakeProfit` | `number` | Yes | Take profit target. Must be > priceOpen for long, < priceOpen for short |\n| `priceStopLoss` | `number` | Yes | Stop loss exit. Must be < priceOpen for long, > priceOpen for short |\n| `minuteEstimatedTime` | `number` | Yes | Expected duration before `time_expired` closure |\n\n**Key Behavior:**\n- If `priceOpen` is **omitted**: Signal opens immediately at current VWAP price\n- If `priceOpen` is **specified**: Signal becomes \"scheduled\", waiting for price to reach entry point\n\n**Sources:** [types.d.ts:647-665]()\n\n---\n\n### ISignalRow\n\nComplete signal structure used throughout the system after validation and augmentation. All internal operations work with `ISignalRow` rather than `ISignalDto`.\n\n```typescript\ninterface ISignalRow extends ISignalDto {\n    id: string;                       // UUID v4 (always present after validation)\n    priceOpen: number;                // Entry price (always present, set to VWAP if was undefined)\n    exchangeName: ExchangeName;       // Exchange identifier\n    strategyName: StrategyName;       // Strategy identifier\n    scheduledAt: number;              // Creation timestamp (ms)\n    pendingAt: number;                // Activation timestamp (ms)\n    symbol: string;                   // Trading pair (e.g., \"BTCUSDT\")\n    _isScheduled: boolean;            // Internal flag for scheduled signals\n}\n```\n\n**Field Details:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `id` | `string` | Unique UUID v4 identifier, auto-generated during validation |\n| `priceOpen` | `number` | Entry price, always present (set to VWAP if undefined in DTO) |\n| `exchangeName` | `ExchangeName` | Exchange name from method context |\n| `strategyName` | `StrategyName` | Strategy name from method context |\n| `scheduledAt` | `number` | Unix timestamp (ms) when signal was first created |\n| `pendingAt` | `number` | Unix timestamp (ms) when signal became active/pending. For scheduled signals, equals `scheduledAt` until activation |\n| `symbol` | `string` | Trading pair symbol |\n| `_isScheduled` | `boolean` | Internal runtime marker indicating scheduled state |\n\n**Sources:** [types.d.ts:667-687]()\n\n---\n\n### IScheduledSignalRow\n\nSpecialized signal type for delayed entry at specific price. Inherits all fields from `ISignalRow`. Used when `getSignal()` returns a DTO with `priceOpen` specified.\n\n```typescript\ninterface IScheduledSignalRow extends ISignalRow {\n    priceOpen: number;                // Entry price (always present for scheduled signals)\n}\n```\n\n**Lifecycle:**\n1. Created when `getSignal()` returns DTO with `priceOpen` specified\n2. Monitors market price on each tick\n3. Checks for **SL breach before activation** (critical safety: prevents \"open-and-immediately-stop\" scenarios)\n4. If price reaches `priceOpen` without hitting SL → converts to regular `ISignalRow` (action: \"opened\")\n5. If SL hit before activation or time expires → action: \"cancelled\"\n\n**Sources:** [types.d.ts:689-697]()\n\n---\n\n## Result Types (Discriminated Union)\n\n### IStrategyTickResult\n\nDiscriminated union representing all possible outcomes of a strategy tick. Use the `action` field for type-safe pattern matching.\n\n```typescript\ntype IStrategyTickResult = \n    | IStrategyTickResultIdle\n    | IStrategyTickResultScheduled\n    | IStrategyTickResultOpened\n    | IStrategyTickResultActive\n    | IStrategyTickResultClosed\n    | IStrategyTickResultCancelled;\n```\n\n**Type Guard Pattern:**\n\n```typescript\nfunction handleTickResult(result: IStrategyTickResult) {\n    switch (result.action) {\n        case \"idle\":\n            // result is IStrategyTickResultIdle\n            console.log(`Idle at price ${result.currentPrice}`);\n            break;\n        case \"scheduled\":\n            // result is IStrategyTickResultScheduled\n            console.log(`Scheduled: waiting for ${result.signal.priceOpen}`);\n            break;\n        case \"opened\":\n            // result is IStrategyTickResultOpened\n            console.log(`Opened signal ${result.signal.id}`);\n            break;\n        case \"active\":\n            // result is IStrategyTickResultActive\n            console.log(`Active: ${result.percentTp}% to TP`);\n            break;\n        case \"closed\":\n            // result is IStrategyTickResultClosed\n            console.log(`Closed: ${result.closeReason}, PNL: ${result.pnl.pnlPercentage}%`);\n            break;\n        case \"cancelled\":\n            // result is IStrategyTickResultCancelled\n            console.log(`Cancelled scheduled signal ${result.signal.id}`);\n            break;\n    }\n}\n```\n\n**Sources:** [types.d.ts:888]()\n\n---\n\n### IStrategyTickResultIdle\n\nNo active signal exists. Strategy is idle and monitoring market conditions.\n\n```typescript\ninterface IStrategyTickResultIdle {\n    action: \"idle\";\n    signal: null;\n    strategyName: StrategyName;\n    exchangeName: ExchangeName;\n    symbol: string;\n    currentPrice: number;\n}\n```\n\n**When Emitted:**\n- No active or scheduled signal exists\n- `getSignal()` returned `null` or throttling prevents new signal generation\n\n**Sources:** [types.d.ts:767-781]()\n\n---\n\n### IStrategyTickResultScheduled\n\nScheduled signal created, waiting for price to reach entry point.\n\n```typescript\ninterface IStrategyTickResultScheduled {\n    action: \"scheduled\";\n    signal: IScheduledSignalRow;\n    strategyName: StrategyName;\n    exchangeName: ExchangeName;\n    symbol: string;\n    currentPrice: number;\n}\n```\n\n**When Emitted:**\n- `getSignal()` returned DTO with `priceOpen` specified\n- Signal passed validation\n- Price has not yet reached `priceOpen`\n\n**Sources:** [types.d.ts:783-799]()\n\n---\n\n### IStrategyTickResultOpened\n\nNew signal just created and activated (persisted to storage).\n\n```typescript\ninterface IStrategyTickResultOpened {\n    action: \"opened\";\n    signal: ISignalRow;\n    strategyName: StrategyName;\n    exchangeName: ExchangeName;\n    symbol: string;\n    currentPrice: number;\n}\n```\n\n**When Emitted:**\n- Immediate signal (no `priceOpen` specified) passed validation\n- OR scheduled signal activated (price reached `priceOpen`)\n- Signal persisted to crash-safe storage\n- TP/SL monitoring begins\n\n**Sources:** [types.d.ts:801-817]()\n\n---\n\n### IStrategyTickResultActive\n\nSignal is being monitored for TP/SL conditions. Emitted on every tick while signal is active.\n\n```typescript\ninterface IStrategyTickResultActive {\n    action: \"active\";\n    signal: ISignalRow;\n    currentPrice: number;\n    strategyName: StrategyName;\n    exchangeName: ExchangeName;\n    symbol: string;\n    percentTp: number;              // 0-100%, progress toward TP\n    percentSl: number;              // 0-100%, progress toward SL\n}\n```\n\n**Progress Calculation:**\n\n| Field | Formula | Description |\n|-------|---------|-------------|\n| `percentTp` | Progress from open to TP (0% at open, 100% at TP) | If price moves toward TP: increases. If price moves toward SL: 0% |\n| `percentSl` | Progress from open to SL (0% at open, 100% at SL) | If price moves toward SL: increases. If price moves toward TP: 0% |\n\n**When Emitted:**\n- Signal is open and being monitored\n- Neither TP nor SL has been reached\n- Time limit not yet expired\n\n**Sources:** [types.d.ts:819-839]()\n\n---\n\n### IStrategyTickResultClosed\n\nSignal closed with final PNL calculation. Terminal state.\n\n```typescript\ninterface IStrategyTickResultClosed {\n    action: \"closed\";\n    signal: ISignalRow;\n    currentPrice: number;\n    closeReason: StrategyCloseReason;\n    closeTimestamp: number;\n    pnl: IStrategyPnL;\n    strategyName: StrategyName;\n    exchangeName: ExchangeName;\n    symbol: string;\n}\n```\n\n**Field Details:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `closeReason` | `StrategyCloseReason` | Why signal closed: \"take_profit\", \"stop_loss\", or \"time_expired\" |\n| `closeTimestamp` | `number` | Unix timestamp (ms) when signal closed |\n| `pnl` | `IStrategyPnL` | Profit/loss calculation with fees and slippage |\n\n**When Emitted:**\n- TP reached: `closeReason === \"take_profit\"`\n- SL reached: `closeReason === \"stop_loss\"`\n- Time expired: `closeReason === \"time_expired\"`\n\n**Sources:** [types.d.ts:841-863]()\n\n---\n\n### IStrategyTickResultCancelled\n\nScheduled signal cancelled without opening position. Terminal state for scheduled signals that never activated.\n\n```typescript\ninterface IStrategyTickResultCancelled {\n    action: \"cancelled\";\n    signal: IScheduledSignalRow;\n    currentPrice: number;\n    closeTimestamp: number;\n    strategyName: StrategyName;\n    exchangeName: ExchangeName;\n    symbol: string;\n}\n```\n\n**When Emitted:**\n- Scheduled signal hit SL before reaching `priceOpen`\n- Time limit expired before activation\n- Manual cancellation (future feature)\n\n**Key Difference from Closed:**\n- No PNL calculation (position never opened)\n- Uses `IScheduledSignalRow` instead of `ISignalRow`\n\n**Sources:** [types.d.ts:865-883]()\n\n---\n\n## IStrategyBacktestResult\n\nSubset of `IStrategyTickResult` containing only terminal states returned by `backtest()` method.\n\n```typescript\ntype IStrategyBacktestResult = \n    | IStrategyTickResultClosed\n    | IStrategyTickResultCancelled;\n```\n\n**Usage Context:**\n\nThe `backtest()` method processes historical candles until signal reaches terminal state, then returns the final result. It never returns intermediate states like \"idle\", \"scheduled\", \"opened\", or \"active\".\n\n```typescript\n// backtest() signature\nbacktest(candles: ICandleData[]): Promise<IStrategyBacktestResult>\n\n// Type-safe handling\nconst result = await strategy.backtest(candles);\nif (result.action === \"closed\") {\n    // Has PNL\n    console.log(`PNL: ${result.pnl.pnlPercentage}%`);\n} else {\n    // result.action === \"cancelled\"\n    console.log(\"Signal cancelled before activation\");\n}\n```\n\n**Sources:** [types.d.ts:890-892](), [docs/types/IStrategyBacktestResult.md:9-12]()\n\n---\n\n## Profit/Loss Types\n\n### IStrategyPnL\n\nProfit and loss calculation with adjusted prices (includes 0.1% fees + 0.1% slippage).\n\n```typescript\ninterface IStrategyPnL {\n    pnlPercentage: number;            // Profit/loss as percentage (+1.5 = +1.5%, -2.3 = -2.3%)\n    priceOpen: number;                // Entry price adjusted with slippage and fees\n    priceClose: number;               // Exit price adjusted with slippage and fees\n}\n```\n\n**Calculation Logic:**\n\n1. **Entry Adjustment (0.1% fee + 0.1% slippage):**\n   - Long: `priceOpen × (1 + 0.001 + 0.001) = priceOpen × 1.002`\n   - Short: `priceOpen × (1 - 0.001 - 0.001) = priceOpen × 0.998`\n\n2. **Exit Adjustment:**\n   - Long: `priceClose × (1 - 0.001 - 0.001) = priceClose × 0.998`\n   - Short: `priceClose × (1 + 0.001 + 0.001) = priceClose × 1.002`\n\n3. **PNL Calculation:**\n   - Long: `((adjustedPriceClose - adjustedPriceOpen) / adjustedPriceOpen) × 100`\n   - Short: `((adjustedPriceOpen - adjustedPriceClose) / adjustedPriceOpen) × 100`\n\n**Configuration:**\n\nFee and slippage percentages are defined in `GLOBAL_CONFIG`:\n- `CC_PERCENT_FEE`: Default 0.1%\n- `CC_PERCENT_SLIPPAGE`: Default 0.1%\n\n**Sources:** [types.d.ts:754-763]()\n\n---\n\n### StrategyCloseReason\n\nEnumeration of possible signal closure reasons.\n\n```typescript\ntype StrategyCloseReason = \"time_expired\" | \"take_profit\" | \"stop_loss\";\n```\n\n| Value | Description |\n|-------|-------------|\n| `\"take_profit\"` | Signal closed because price reached `priceTakeProfit` |\n| `\"stop_loss\"` | Signal closed because price reached `priceStopLoss` |\n| `\"time_expired\"` | Signal closed because `minuteEstimatedTime` elapsed |\n\n**Usage in Closed Results:**\n\n```typescript\nif (result.action === \"closed\") {\n    switch (result.closeReason) {\n        case \"take_profit\":\n            console.log(\"Winner! TP hit\");\n            break;\n        case \"stop_loss\":\n            console.log(\"Loser! SL hit\");\n            break;\n        case \"time_expired\":\n            console.log(\"Time expired\");\n            break;\n    }\n}\n```\n\n**Sources:** [types.d.ts:752]()\n\n---\n\n## Working with Discriminated Unions\n\n### Type Guards and Pattern Matching\n\nTypeScript narrows types based on the `action` discriminator:\n\n```typescript\nimport { IStrategyTickResult } from \"backtest-kit\";\n\nfunction analyzeResult(result: IStrategyTickResult) {\n    // Type guard using action field\n    if (result.action === \"closed\") {\n        // TypeScript knows result is IStrategyTickResultClosed\n        console.log(`Close reason: ${result.closeReason}`);\n        console.log(`PNL: ${result.pnl.pnlPercentage}%`);\n        // result.pnl is accessible (type-safe)\n    }\n    \n    if (result.action === \"active\") {\n        // TypeScript knows result is IStrategyTickResultActive\n        console.log(`TP progress: ${result.percentTp}%`);\n        console.log(`SL progress: ${result.percentSl}%`);\n        // result.percentTp and result.percentSl are accessible\n    }\n}\n```\n\n**Sources:** [types.d.ts:888]()\n\n---\n\n### Filtering Event Streams\n\nUse discriminated union with event listeners for type-safe filtering:\n\n```typescript\nimport { listenSignal } from \"backtest-kit\";\n\n// Listen only for closed signals\nlistenSignal((result) => {\n    if (result.action === \"closed\") {\n        // result is IStrategyTickResultClosed\n        const { closeReason, pnl } = result;\n        \n        if (closeReason === \"take_profit\") {\n            console.log(`TP Hit! Profit: ${pnl.pnlPercentage}%`);\n        }\n    }\n});\n\n// Listen only for active signals on specific symbol\nlistenSignal((result) => {\n    if (result.action === \"active\" && result.symbol === \"BTCUSDT\") {\n        // result is IStrategyTickResultActive\n        console.log(`BTCUSDT: ${result.percentTp}% to TP`);\n    }\n});\n```\n\n**Sources:** [src/function/event.ts:70-73](), [types.d.ts:888]()\n\n---\n\n## Type Relationship Diagram\n\n```mermaid\ngraph TB\n    subgraph \"getSignal Returns\"\n        DTO[\"ISignalDto<br/>position, priceOpen?, TP, SL\"]\n    end\n    \n    subgraph \"Validation & Augmentation\"\n        VAL[\"ClientStrategy.tick()<br/>- Generate UUID<br/>- Set VWAP if no priceOpen<br/>- Add timestamps<br/>- Add context fields\"]\n    end\n    \n    subgraph \"Persisted State\"\n        ROW[\"ISignalRow<br/>id, scheduledAt, pendingAt\"]\n        SCHED_ROW[\"IScheduledSignalRow<br/>extends ISignalRow\"]\n    end\n    \n    subgraph \"Tick Results (All States)\"\n        IDLE_R[\"IStrategyTickResultIdle<br/>action: 'idle'<br/>signal: null\"]\n        SCHED_R[\"IStrategyTickResultScheduled<br/>action: 'scheduled'<br/>signal: IScheduledSignalRow\"]\n        OPEN_R[\"IStrategyTickResultOpened<br/>action: 'opened'<br/>signal: ISignalRow\"]\n        ACTIVE_R[\"IStrategyTickResultActive<br/>action: 'active'<br/>percentTp, percentSl\"]\n        CLOSED_R[\"IStrategyTickResultClosed<br/>action: 'closed'<br/>closeReason, pnl\"]\n        CANCEL_R[\"IStrategyTickResultCancelled<br/>action: 'cancelled'<br/>signal: IScheduledSignalRow\"]\n    end\n    \n    subgraph \"Backtest Results (Terminal Only)\"\n        BT_CLOSED[\"IStrategyTickResultClosed\"]\n        BT_CANCEL[\"IStrategyTickResultCancelled\"]\n    end\n    \n    DTO -->|\"no priceOpen\"| VAL\n    DTO -->|\"with priceOpen\"| VAL\n    \n    VAL -->|\"no priceOpen\"| ROW\n    VAL -->|\"with priceOpen\"| SCHED_ROW\n    \n    ROW --> OPEN_R\n    ROW --> ACTIVE_R\n    ROW --> CLOSED_R\n    \n    SCHED_ROW --> SCHED_R\n    SCHED_ROW --> CANCEL_R\n    \n    IDLE_R -.->|\"part of\"| TICK_UNION[\"IStrategyTickResult\"]\n    SCHED_R -.->|\"part of\"| TICK_UNION\n    OPEN_R -.->|\"part of\"| TICK_UNION\n    ACTIVE_R -.->|\"part of\"| TICK_UNION\n    CLOSED_R -.->|\"part of\"| TICK_UNION\n    CANCEL_R -.->|\"part of\"| TICK_UNION\n    \n    CLOSED_R --> BT_CLOSED\n    CANCEL_R --> BT_CANCEL\n    \n    BT_CLOSED -.->|\"part of\"| BT_UNION[\"IStrategyBacktestResult\"]\n    BT_CANCEL -.->|\"part of\"| BT_UNION\n```\n\n**Sources:** [types.d.ts:641-892]()\n\n---\n\n## Common Fields Across Result Types\n\nAll result types share these common fields:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `action` | `string` | Discriminator: \"idle\", \"scheduled\", \"opened\", \"active\", \"closed\", \"cancelled\" |\n| `strategyName` | `StrategyName` | Strategy identifier from method context |\n| `exchangeName` | `ExchangeName` | Exchange identifier from method context |\n| `symbol` | `string` | Trading pair symbol (e.g., \"BTCUSDT\") |\n| `currentPrice` | `number` | Current VWAP price at time of result |\n\n**Variation:**\n\n- `IStrategyTickResultIdle`: `signal` is `null`\n- `IStrategyTickResultScheduled`, `IStrategyTickResultCancelled`: `signal` is `IScheduledSignalRow`\n- `IStrategyTickResultOpened`, `IStrategyTickResultActive`, `IStrategyTickResultClosed`: `signal` is `ISignalRow`\n\n**Sources:** [types.d.ts:767-883]()\n\n---\n\n## Usage in Event System\n\nSignal and result types flow through the event system via Subject emitters:\n\n```mermaid\ngraph LR\n    subgraph \"Strategy Execution\"\n        TICK[\"ClientStrategy.tick()\"]\n        BT[\"ClientStrategy.backtest()\"]\n    end\n    \n    subgraph \"Emitters\"\n        SIGNAL_EMIT[\"signalEmitter<br/>Subject&lt;IStrategyTickResult&gt;\"]\n        BT_EMIT[\"signalBacktestEmitter<br/>Subject&lt;IStrategyTickResult&gt;\"]\n        LIVE_EMIT[\"signalLiveEmitter<br/>Subject&lt;IStrategyTickResult&gt;\"]\n    end\n    \n    subgraph \"Consumers\"\n        LISTEN[\"listenSignal()<br/>listenSignalBacktest()<br/>listenSignalLive()\"]\n        MD[\"BacktestMarkdownService<br/>LiveMarkdownService\"]\n    end\n    \n    TICK -->|\"IStrategyTickResult\"| SIGNAL_EMIT\n    TICK -->|\"if backtest\"| BT_EMIT\n    TICK -->|\"if live\"| LIVE_EMIT\n    \n    BT -->|\"IStrategyBacktestResult\"| BT_EMIT\n    \n    SIGNAL_EMIT --> LISTEN\n    BT_EMIT --> LISTEN\n    LIVE_EMIT --> LISTEN\n    \n    SIGNAL_EMIT --> MD\n    BT_EMIT --> MD\n    LIVE_EMIT --> MD\n```\n\n**Key Points:**\n\n1. **All tick results** emit to `signalEmitter` (global)\n2. **Backtest-specific** results also emit to `signalBacktestEmitter`\n3. **Live-specific** results also emit to `signalLiveEmitter`\n4. Markdown services subscribe and accumulate results for statistics\n5. User listeners receive results through `listenSignal*()` functions with queued processing\n\n**Sources:** [src/config/emitters.ts:15-31](), [src/function/event.ts:70-221]()"
                    },
                    {
                        "page_plan": {
                            "id": "12.6",
                            "title": "Statistics & Contract Types"
                        },
                        "content": "# Statistics & Contract Types\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\nThis page documents the statistics models and event contract types used throughout Backtest Kit. Statistics models aggregate and analyze signal data from backtests, live trading, and walker comparisons. Contract types define the payload structures emitted by event subjects during execution.\n\nFor information about the event system architecture and listeners, see [Event System Architecture](#4.4). For details on the reporting classes that generate these statistics, see [Reporting Classes API](#12.3).\n\n---\n\n## Statistics Models Overview\n\nStatistics models are immutable data structures returned by `getData()` methods on reporting classes. They contain aggregated metrics, raw event lists, and derived calculations for performance analysis.\n\n### Statistics Model Hierarchy\n\n```mermaid\ngraph TD\n    subgraph \"Backtest & Live Statistics\"\n        BSM[\"BacktestStatisticsModel\"]\n        LSM[\"LiveStatisticsModel\"]\n        BSM_Fields[\"signalList: IStrategyTickResultClosed[]<br/>totalSignals: number<br/>winCount: number<br/>lossCount: number<br/>winRate: number | null<br/>avgPnl: number | null<br/>totalPnl: number | null<br/>stdDev: number | null<br/>sharpeRatio: number | null<br/>annualizedSharpeRatio: number | null<br/>certaintyRatio: number | null<br/>expectedYearlyReturns: number | null\"]\n        LSM_Fields[\"Same as BacktestStatisticsModel<br/>but includes live-only events\"]\n    end\n    \n    subgraph \"Walker Statistics\"\n        WSM[\"WalkerStatisticsModel\"]\n        WSM_Fields[\"walkerName: WalkerName<br/>symbol: string<br/>exchangeName: ExchangeName<br/>frameName: FrameName<br/>metric: WalkerMetric<br/>totalStrategies: number<br/>bestStrategy: StrategyName | null<br/>bestMetric: number | null<br/>bestStats: BacktestStatisticsModel | null<br/>strategyResults: IStrategyResult[]\"]\n        STRAT_RES[\"IStrategyResult\"]\n        STRAT_RES_Fields[\"strategyName: StrategyName<br/>stats: BacktestStatisticsModel<br/>metricValue: number | null\"]\n    end\n    \n    subgraph \"Auxiliary Statistics\"\n        SCHED[\"ScheduleStatisticsModel\"]\n        SCHED_Fields[\"eventList: ScheduledEvent[]<br/>totalEvents: number<br/>totalScheduled: number<br/>totalOpened: number<br/>totalCancelled: number<br/>cancellationRate: number | null<br/>activationRate: number | null<br/>avgWaitTime: number | null<br/>avgActivationTime: number | null\"]\n        \n        RISK[\"RiskStatisticsModel\"]\n        RISK_Fields[\"eventList: RiskEvent[]<br/>totalRejections: number<br/>bySymbol: Record<string, number><br/>byStrategy: Record<string, number>\"]\n        \n        PARTIAL[\"PartialStatisticsModel\"]\n        PARTIAL_Fields[\"profitEvents: PartialProfitContract[]<br/>lossEvents: PartialLossContract[]<br/>totalProfitEvents: number<br/>totalLossEvents: number<br/>byLevel: Record<PartialLevel, number>\"]\n        \n        PERF[\"PerformanceStatisticsModel\"]\n        PERF_Fields[\"events: PerformanceContract[]<br/>totalEvents: number<br/>byMetricType: Record<PerformanceMetricType, {...}>\"]\n        \n        HEAT[\"HeatmapStatisticsModel\"]\n        HEAT_Fields[\"rows: IHeatmapRow[]<br/>totalRows: number<br/>aggregated statistics across symbols\"]\n    end\n    \n    BSM --> BSM_Fields\n    LSM --> LSM_Fields\n    WSM --> WSM_Fields\n    WSM --> STRAT_RES\n    STRAT_RES --> STRAT_RES_Fields\n    SCHED --> SCHED_Fields\n    RISK --> RISK_Fields\n    PARTIAL --> PARTIAL_Fields\n    PERF --> PERF_Fields\n    HEAT --> HEAT_Fields\n```\n\n**Sources:** [types.d.ts:918-943](), [types.d.ts:1095-1098](), [types.d.ts:1153-1172](), [types.d.ts:1209-1218](), [src/index.ts:139-146]()\n\n---\n\n## BacktestStatisticsModel\n\nContains comprehensive performance metrics calculated from closed backtest signals. All numeric values use null-safe math: calculations return `null` if result is NaN, Infinity, or division by zero occurs.\n\n### Structure\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `signalList` | `IStrategyTickResultClosed[]` | Array of all closed signals with full details (price, PNL, timestamps) |\n| `totalSignals` | `number` | Total number of closed signals |\n| `winCount` | `number` | Number of winning signals (PNL > 0) |\n| `lossCount` | `number` | Number of losing signals (PNL < 0) |\n| `winRate` | `number \\| null` | Win rate as percentage (0-100). Higher is better. |\n| `avgPnl` | `number \\| null` | Average PNL per signal as percentage. Higher is better. |\n| `totalPnl` | `number \\| null` | Cumulative PNL across all signals as percentage. Higher is better. |\n| `stdDev` | `number \\| null` | Standard deviation of returns (volatility metric). Lower is better. |\n| `sharpeRatio` | `number \\| null` | Risk-adjusted return (avgPnl / stdDev). Higher is better. |\n| `annualizedSharpeRatio` | `number \\| null` | Annualized Sharpe Ratio (sharpeRatio × √365). Higher is better. |\n| `certaintyRatio` | `number \\| null` | Ratio of average win to average loss magnitude (avgWin / \\|avgLoss\\|). Higher is better. |\n| `expectedYearlyReturns` | `number \\| null` | Projected yearly returns based on average trade duration and PNL. Higher is better. |\n\n### Key Metrics Explained\n\n**Sharpe Ratio**: Measures risk-adjusted returns. Calculated as `avgPnl / stdDev`. A higher Sharpe ratio indicates better risk-adjusted performance. Typical interpretations:\n- < 1.0: Poor risk-adjusted returns\n- 1.0 - 2.0: Good risk-adjusted returns\n- \\> 2.0: Excellent risk-adjusted returns\n\n**Certainty Ratio**: Compares the magnitude of average wins to average losses. Formula: `avgWin / |avgLoss|`. A ratio > 1.0 means wins are larger than losses on average. Combined with win rate, provides insight into strategy asymmetry.\n\n**Expected Yearly Returns**: Extrapolates returns to annual basis using average signal duration. Assumes consistent signal generation rate throughout the year.\n\n### Usage Example\n\n```typescript\nimport { Backtest } from \"backtest-kit\";\n\n// Run backtest\nawait Backtest.run(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\",\n  frameName: \"1d-backtest\"\n});\n\n// Get statistics\nconst stats = await Backtest.getData(\"my-strategy\");\n\nconsole.log(`Total signals: ${stats.totalSignals}`);\nconsole.log(`Win rate: ${stats.winRate?.toFixed(2)}%`);\nconsole.log(`Sharpe Ratio: ${stats.sharpeRatio?.toFixed(3)}`);\nconsole.log(`Total PNL: ${stats.totalPnl?.toFixed(2)}%`);\n\n// Null-safe access for derived metrics\nif (stats.sharpeRatio !== null && stats.sharpeRatio > 1.5) {\n  console.log(\"Good risk-adjusted performance!\");\n}\n\n// Access raw signal data\nstats.signalList.forEach(signal => {\n  console.log(`Signal ${signal.signal.id}: ${signal.pnl.pnlPercentage.toFixed(2)}%`);\n});\n```\n\n**Sources:** [types.d.ts:918-943](), [src/index.ts:139]()\n\n---\n\n## LiveStatisticsModel\n\nIdentical structure to `BacktestStatisticsModel` but aggregates signals from live trading execution. Generated by `LiveMarkdownService` which subscribes to `signalLiveEmitter`.\n\nThe key difference from backtest statistics is the data source: live statistics reflect real-time trading results with actual market execution, while backtest statistics are simulated.\n\n### Usage Example\n\n```typescript\nimport { Live } from \"backtest-kit\";\n\n// Start live trading\nLive.background(\"BTCUSDT\", {\n  strategyName: \"my-strategy\",\n  exchangeName: \"binance\"\n});\n\n// Later, get live statistics\nconst stats = await Live.getData(\"my-strategy\");\n\nconsole.log(`Live trading results:`);\nconsole.log(`Total signals: ${stats.totalSignals}`);\nconsole.log(`Win rate: ${stats.winRate?.toFixed(2)}%`);\nconsole.log(`Total PNL: ${stats.totalPnl?.toFixed(2)}%`);\n```\n\n**Sources:** [types.d.ts:918-943](), [src/index.ts:140]()\n\n---\n\n## WalkerStatisticsModel\n\nAggregates results from walker comparisons, ranking multiple strategies by a chosen optimization metric. Extends `WalkerCompleteContract` with additional strategy comparison data.\n\n### Structure\n\n```mermaid\ngraph LR\n    WSM[\"WalkerStatisticsModel\"]\n    WCC[\"extends WalkerCompleteContract\"]\n    STRAT_RES[\"strategyResults: IStrategyResult[]\"]\n    \n    FIELDS[\"walkerName: WalkerName<br/>symbol: string<br/>exchangeName: ExchangeName<br/>frameName: FrameName<br/>metric: WalkerMetric<br/>totalStrategies: number<br/>bestStrategy: StrategyName | null<br/>bestMetric: number | null<br/>bestStats: BacktestStatisticsModel | null\"]\n    \n    STRAT[\"IStrategyResult\"]\n    STRAT_FIELDS[\"strategyName: StrategyName<br/>stats: BacktestStatisticsModel<br/>metricValue: number | null\"]\n    \n    WSM --> WCC\n    WSM --> STRAT_RES\n    WSM --> FIELDS\n    STRAT_RES --> STRAT\n    STRAT --> STRAT_FIELDS\n```\n\n### IStrategyResult\n\nEach strategy in the walker comparison produces an `IStrategyResult`:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `strategyName` | `StrategyName` | Strategy identifier |\n| `stats` | `BacktestStatisticsModel` | Complete backtest statistics for this strategy |\n| `metricValue` | `number \\| null` | Value of the optimization metric used for ranking |\n\n### WalkerMetric Types\n\n```typescript\ntype WalkerMetric = \n  | \"sharpeRatio\"\n  | \"annualizedSharpeRatio\"\n  | \"winRate\"\n  | \"totalPnl\"\n  | \"certaintyRatio\"\n  | \"avgPnl\"\n  | \"expectedYearlyReturns\";\n```\n\nAll metrics are maximized - higher values rank better. The `metric` field in `WalkerStatisticsModel` indicates which metric was used for comparison.\n\n### Usage Example\n\n```typescript\nimport { Walker } from \"backtest-kit\";\n\n// Run walker comparison\nawait Walker.run(\"BTCUSDT\", {\n  walkerName: \"strategy-comparison\"\n});\n\n// Get walker results\nconst stats = await Walker.getData(\"strategy-comparison\");\n\nconsole.log(`Compared ${stats.totalStrategies} strategies`);\nconsole.log(`Best strategy: ${stats.bestStrategy}`);\nconsole.log(`Best ${stats.metric}: ${stats.bestMetric?.toFixed(3)}`);\n\n// Analyze all strategies\nstats.strategyResults.forEach(result => {\n  console.log(`${result.strategyName}: ${result.metricValue?.toFixed(3)}`);\n  console.log(`  Win rate: ${result.stats.winRate?.toFixed(2)}%`);\n  console.log(`  Sharpe: ${result.stats.sharpeRatio?.toFixed(3)}`);\n});\n\n// Access best strategy details\nif (stats.bestStats) {\n  console.log(`Best strategy total PNL: ${stats.bestStats.totalPnl?.toFixed(2)}%`);\n}\n```\n\n**Sources:** [types.d.ts:1095-1098](), [types.d.ts:1080-1088](), [types.d.ts:949](), [src/index.ts:144]()\n\n---\n\n## Auxiliary Statistics Models\n\n### ScheduleStatisticsModel\n\nTracks scheduled signal lifecycle: creation, activation, and cancellation events.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `eventList` | `ScheduledEvent[]` | All scheduled/opened/cancelled events with timestamps |\n| `totalEvents` | `number` | Total number of events (scheduled + opened + cancelled) |\n| `totalScheduled` | `number` | Number of signals created in scheduled state |\n| `totalOpened` | `number` | Number of scheduled signals that activated |\n| `totalCancelled` | `number` | Number of scheduled signals that cancelled before activation |\n| `cancellationRate` | `number \\| null` | Percentage of scheduled signals that cancelled (0-100). Lower is better. |\n| `activationRate` | `number \\| null` | Percentage of scheduled signals that opened (0-100). Higher is better. |\n| `avgWaitTime` | `number \\| null` | Average time in minutes that cancelled signals waited before cancellation |\n| `avgActivationTime` | `number \\| null` | Average time in minutes that opened signals waited before activation |\n\n**ScheduledEvent Structure:**\n\n```typescript\ninterface ScheduledEvent {\n  timestamp: number;           // Event timestamp in milliseconds\n  action: \"scheduled\" | \"opened\" | \"cancelled\";\n  symbol: string;\n  signalId: string;\n  position: string;\n  note?: string;\n  currentPrice: number;\n  priceOpen: number;           // Scheduled entry price\n  takeProfit: number;\n  stopLoss: number;\n  closeTimestamp?: number;     // Only for cancelled/opened\n  duration?: number;           // Only for cancelled/opened (minutes)\n}\n```\n\n**Sources:** [types.d.ts:1104-1130](), [types.d.ts:1153-1172](), [src/index.ts:142]()\n\n### RiskStatisticsModel\n\nTracks risk validation rejections with grouping by symbol and strategy.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `eventList` | `RiskEvent[]` | All risk rejection events with full context |\n| `totalRejections` | `number` | Total number of signals rejected due to risk limits |\n| `bySymbol` | `Record<string, number>` | Rejection count grouped by symbol |\n| `byStrategy` | `Record<string, number>` | Rejection count grouped by strategy |\n\n**RiskEvent Structure:**\n\n```typescript\ninterface RiskEvent {\n  timestamp: number;\n  symbol: string;\n  pendingSignal: ISignalDto;\n  strategyName: string;\n  exchangeName: string;\n  currentPrice: number;\n  activePositionCount: number;\n  comment: string;              // Rejection reason from validation note\n}\n```\n\n**Sources:** [types.d.ts:1178-1195](), [types.d.ts:1209-1218](), [src/index.ts:146]()\n\n### PartialStatisticsModel\n\nAggregates partial profit/loss milestone events for unrealized P&L tracking.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `profitEvents` | `PartialProfitContract[]` | All profit milestone events |\n| `lossEvents` | `PartialLossContract[]` | All loss milestone events |\n| `totalProfitEvents` | `number` | Total count of profit milestones reached |\n| `totalLossEvents` | `number` | Total count of loss milestones reached |\n| `byLevel` | `Record<PartialLevel, number>` | Event count grouped by percentage level (10, 20, 30, etc.) |\n\n**Sources:** [src/index.ts:145]()\n\n### PerformanceStatisticsModel\n\nAggregates execution timing metrics for profiling and bottleneck detection.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `events` | `PerformanceContract[]` | All performance measurement events |\n| `totalEvents` | `number` | Total count of performance events |\n| `byMetricType` | `Record<PerformanceMetricType, {...}>` | Statistics grouped by operation type |\n\nEach metric type aggregation includes:\n- `count`: Number of measurements\n- `totalDuration`: Sum of all durations (ms)\n- `avgDuration`: Average duration (ms)\n- `minDuration`: Minimum duration (ms)\n- `maxDuration`: Maximum duration (ms)\n\n**Sources:** [src/index.ts:143]()\n\n### HeatmapStatisticsModel\n\nProvides portfolio-wide aggregated statistics across multiple symbols and strategies.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `rows` | `IHeatmapRow[]` | Array of heatmap rows (one per symbol-strategy combination) |\n| `totalRows` | `number` | Total number of rows |\n| Additional aggregated statistics | Various | Cross-symbol aggregations |\n\n**Sources:** [src/index.ts:141]()\n\n---\n\n## Event Contract Types\n\nContract types define the payload structures emitted by event subjects. These types ensure type-safe event handling through discriminated unions and strict interfaces.\n\n### Contract Type to Emitter Mapping\n\n```mermaid\ngraph TD\n    subgraph \"Signal Events\"\n        SIG_EMT[\"signalEmitter<br/>signalBacktestEmitter<br/>signalLiveEmitter\"]\n        SIG_TYPE[\"IStrategyTickResult\"]\n    end\n    \n    subgraph \"Completion Events\"\n        DONE_EMT[\"doneLiveSubject<br/>doneBacktestSubject<br/>doneWalkerSubject\"]\n        DONE_TYPE[\"DoneContract\"]\n    end\n    \n    subgraph \"Progress Events\"\n        PROG_BT[\"progressBacktestEmitter\"]\n        PROG_BT_TYPE[\"ProgressBacktestContract\"]\n        PROG_WALK[\"progressWalkerEmitter\"]\n        PROG_WALK_TYPE[\"ProgressWalkerContract\"]\n        PROG_OPT[\"progressOptimizerEmitter\"]\n        PROG_OPT_TYPE[\"ProgressOptimizerContract\"]\n    end\n    \n    subgraph \"Performance Events\"\n        PERF_EMT[\"performanceEmitter\"]\n        PERF_TYPE[\"PerformanceContract\"]\n    end\n    \n    subgraph \"Walker Events\"\n        WALK_EMT[\"walkerEmitter\"]\n        WALK_TYPE[\"WalkerContract\"]\n        WALK_COMP[\"walkerCompleteSubject\"]\n        WALK_COMP_TYPE[\"WalkerCompleteContract\"]\n    end\n    \n    subgraph \"Partial Events\"\n        PP_EMT[\"partialProfitSubject\"]\n        PP_TYPE[\"PartialProfitContract\"]\n        PL_EMT[\"partialLossSubject\"]\n        PL_TYPE[\"PartialLossContract\"]\n    end\n    \n    subgraph \"Risk Events\"\n        RISK_EMT[\"riskSubject\"]\n        RISK_TYPE[\"RiskContract\"]\n    end\n    \n    subgraph \"Error Events\"\n        ERR_EMT[\"errorEmitter\"]\n        ERR_TYPE[\"Error\"]\n        EXIT_EMT[\"exitEmitter\"]\n        EXIT_TYPE[\"Error\"]\n    end\n    \n    SIG_EMT --> SIG_TYPE\n    DONE_EMT --> DONE_TYPE\n    PROG_BT --> PROG_BT_TYPE\n    PROG_WALK --> PROG_WALK_TYPE\n    PROG_OPT --> PROG_OPT_TYPE\n    PERF_EMT --> PERF_TYPE\n    WALK_EMT --> WALK_TYPE\n    WALK_COMP --> WALK_COMP_TYPE\n    PP_EMT --> PP_TYPE\n    PL_EMT --> PL_TYPE\n    RISK_EMT --> RISK_TYPE\n    ERR_EMT --> ERR_TYPE\n    EXIT_EMT --> EXIT_TYPE\n```\n\n**Sources:** [src/config/emitters.ts:1-133]()\n\n---\n\n## DoneContract\n\nEmitted when execution completes in any mode (backtest, live, walker). Provides final execution context.\n\n### Structure\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `symbol` | `string` | Trading pair symbol that completed |\n| `strategyName` | `StrategyName` | Strategy that completed execution |\n| `exchangeName` | `ExchangeName` | Exchange used for execution |\n| `frameName` | `FrameName` | Frame used (empty string for live mode) |\n\n### Emitters\n\n- `doneBacktestSubject`: Emitted by `Backtest.background()` on completion\n- `doneLiveSubject`: Emitted by `Live.background()` on graceful shutdown\n- `doneWalkerSubject`: Emitted by `Walker.background()` on completion\n\n### Usage Example\n\n```typescript\nimport { listenDoneBacktest } from \"backtest-kit\";\n\nlistenDoneBacktest((event) => {\n  console.log(`Backtest completed for ${event.symbol}`);\n  console.log(`Strategy: ${event.strategyName}`);\n  console.log(`Exchange: ${event.exchangeName}`);\n  console.log(`Frame: ${event.frameName}`);\n});\n```\n\n**Sources:** [src/config/emitters.ts:50-62](), [src/function/event.ts:308-344]()\n\n---\n\n## PerformanceContract\n\nEmitted during execution to track timing metrics for profiling and bottleneck detection.\n\n### Structure\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `timestamp` | `number` | When the metric was recorded (milliseconds since epoch) |\n| `previousTimestamp` | `number \\| null` | Timestamp of previous event (null for first event) |\n| `metricType` | `PerformanceMetricType` | Type of operation being measured |\n| `duration` | `number` | Duration of the operation in milliseconds |\n| `symbol` | `string` | Trading pair symbol |\n| `strategyName` | `StrategyName` | Strategy executing the operation |\n| `exchangeName` | `ExchangeName` | Exchange used |\n| `frameName` | `FrameName` | Frame used (empty string for live mode) |\n\n### PerformanceMetricType\n\n```typescript\ntype PerformanceMetricType = \n  | \"backtest_total\"      // Total backtest duration from start to finish\n  | \"backtest_timeframe\"  // Duration to process a single timeframe iteration\n  | \"backtest_signal\"     // Duration to process a signal (tick + getNextCandles + backtest)\n  | \"live_tick\";          // Duration of a single live tick iteration\n```\n\n### Usage Example\n\n```typescript\nimport { listenPerformance } from \"backtest-kit\";\n\nconst slowOperations = new Map<string, number>();\n\nlistenPerformance((event) => {\n  console.log(`[${event.metricType}] ${event.duration.toFixed(2)}ms`);\n  \n  // Track slow operations\n  if (event.duration > 100) {\n    const key = `${event.strategyName}:${event.metricType}`;\n    slowOperations.set(key, (slowOperations.get(key) || 0) + 1);\n  }\n  \n  // Calculate time between events\n  if (event.previousTimestamp !== null) {\n    const timeSinceLastEvent = event.timestamp - event.previousTimestamp;\n    console.log(`  Time since last event: ${timeSinceLastEvent}ms`);\n  }\n});\n```\n\n**Sources:** [types.d.ts:1231-1270](), [src/config/emitters.ts:86](), [src/function/event.ts:610-613](), [src/index.ts:158-160]()\n\n---\n\n## Progress Contract Types\n\n### ProgressBacktestContract\n\nEmitted during backtest execution to track frame processing progress.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `symbol` | `string` | Trading pair being backtested |\n| `strategyName` | `StrategyName` | Strategy executing |\n| `exchangeName` | `ExchangeName` | Exchange used |\n| `frameName` | `FrameName` | Frame being processed |\n| `processedFrames` | `number` | Number of timeframes processed so far |\n| `totalFrames` | `number` | Total number of timeframes to process |\n| `progress` | `number` | Progress ratio (0.0 to 1.0) |\n\n**Sources:** [src/config/emitters.ts:68](), [src/function/event.ts:509-512]()\n\n### ProgressWalkerContract\n\nEmitted during walker execution to track strategy comparison progress.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `symbol` | `string` | Trading pair being tested |\n| `walkerName` | `WalkerName` | Walker executing |\n| `processedStrategies` | `number` | Number of strategies tested so far |\n| `totalStrategies` | `number` | Total number of strategies to test |\n| `progress` | `number` | Progress ratio (0.0 to 1.0) |\n\n**Sources:** [src/config/emitters.ts:74](), [src/function/event.ts:544-547]()\n\n### ProgressOptimizerContract\n\nEmitted during optimizer execution to track data source processing.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `symbol` | `string` | Trading pair being analyzed |\n| `optimizerName` | `string` | Optimizer executing |\n| `processedSources` | `number` | Number of data sources processed |\n| `totalSources` | `number` | Total number of data sources |\n| `progress` | `number` | Progress ratio (0.0 to 1.0) |\n\n**Sources:** [src/config/emitters.ts:80](), [src/function/event.ts:573-576]()\n\n---\n\n## WalkerContract\n\nEmitted during walker execution after each strategy completes. Provides incremental comparison results.\n\n### Structure\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `symbol` | `string` | Trading pair being tested |\n| `walkerName` | `WalkerName` | Walker executing |\n| `exchangeName` | `ExchangeName` | Exchange used |\n| `frameName` | `FrameName` | Frame used |\n| `metric` | `WalkerMetric` | Optimization metric being used |\n| `totalStrategies` | `number` | Total strategies to test |\n| `strategiesTested` | `number` | Strategies tested so far |\n| `strategyName` | `StrategyName` | Current strategy that just completed |\n| `metricValue` | `number \\| null` | Metric value for current strategy |\n| `bestStrategy` | `StrategyName \\| null` | Best strategy so far |\n| `bestMetric` | `number \\| null` | Best metric value so far |\n\n### Usage Example\n\n```typescript\nimport { listenWalker } from \"backtest-kit\";\n\nlistenWalker((event) => {\n  console.log(`[${event.strategiesTested}/${event.totalStrategies}] ${event.strategyName}`);\n  console.log(`  ${event.metric}: ${event.metricValue?.toFixed(3) || \"N/A\"}`);\n  console.log(`  Best so far: ${event.bestStrategy} (${event.bestMetric?.toFixed(3) || \"N/A\"})`);\n});\n```\n\n**Sources:** [src/config/emitters.ts:92](), [src/function/event.ts:645-648]()\n\n---\n\n## WalkerCompleteContract\n\nEmitted when walker completes all strategy comparisons. Contains final results summary.\n\n### Structure\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `walkerName` | `WalkerName` | Walker that completed |\n| `symbol` | `string` | Trading pair tested |\n| `exchangeName` | `ExchangeName` | Exchange used |\n| `frameName` | `FrameName` | Frame used |\n| `metric` | `WalkerMetric` | Optimization metric used |\n| `totalStrategies` | `number` | Total strategies tested |\n| `bestStrategy` | `StrategyName \\| null` | Best performing strategy |\n| `bestMetric` | `number \\| null` | Best metric value achieved |\n| `bestStats` | `BacktestStatisticsModel \\| null` | Full statistics for best strategy |\n\n### Usage Example\n\n```typescript\nimport { listenWalkerComplete } from \"backtest-kit\";\n\nlistenWalkerComplete((results) => {\n  console.log(`\\n=== Walker ${results.walkerName} Completed ===`);\n  console.log(`Symbol: ${results.symbol}`);\n  console.log(`Tested ${results.totalStrategies} strategies`);\n  console.log(`\\nWinner: ${results.bestStrategy}`);\n  console.log(`Best ${results.metric}: ${results.bestMetric?.toFixed(3)}`);\n  \n  if (results.bestStats) {\n    console.log(`\\nBest Strategy Details:`);\n    console.log(`  Win Rate: ${results.bestStats.winRate?.toFixed(2)}%`);\n    console.log(`  Total PNL: ${results.bestStats.totalPnl?.toFixed(2)}%`);\n    console.log(`  Sharpe Ratio: ${results.bestStats.sharpeRatio?.toFixed(3)}`);\n  }\n});\n```\n\n**Sources:** [types.d.ts:1034-1053](), [src/config/emitters.ts:98](), [src/function/event.ts:728-731]()\n\n---\n\n## Partial Event Contracts\n\n### PartialProfitContract\n\nEmitted when a signal reaches a profit milestone (10%, 20%, 30%, etc.).\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `symbol` | `string` | Trading pair symbol |\n| `data` | `ISignalRow` | Signal that reached milestone |\n| `currentPrice` | `number` | Current market price |\n| `level` | `PartialLevel` | Profit level reached (10, 20, 30, ..., 100) |\n| `backtest` | `boolean` | True if backtest mode, false if live |\n| `timestamp` | `number` | Event timestamp in milliseconds |\n\n**PartialLevel Type:**\n```typescript\ntype PartialLevel = 10 | 20 | 30 | 40 | 50 | 60 | 70 | 80 | 90 | 100;\n```\n\n**Sources:** [types.d.ts:486-497](), [src/config/emitters.ts:118](), [src/function/event.ts:786-789]()\n\n### PartialLossContract\n\nEmitted when a signal reaches a loss milestone (10%, 20%, 30%, etc.).\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `symbol` | `string` | Trading pair symbol |\n| `data` | `ISignalRow` | Signal that reached milestone |\n| `currentPrice` | `number` | Current market price |\n| `level` | `PartialLevel` | Loss level reached (10, 20, 30, ..., 100) |\n| `backtest` | `boolean` | True if backtest mode, false if live |\n| `timestamp` | `number` | Event timestamp in milliseconds |\n\n### Usage Example\n\n```typescript\nimport { listenPartialProfit, listenPartialLoss } from \"backtest-kit\";\n\n// Track profit milestones\nlistenPartialProfit((event) => {\n  console.log(`[PROFIT] ${event.symbol}: ${event.level}% profit reached`);\n  console.log(`  Signal: ${event.data.id}`);\n  console.log(`  Price: ${event.currentPrice}`);\n});\n\n// Track loss milestones\nlistenPartialLoss((event) => {\n  console.log(`[LOSS] ${event.symbol}: ${event.level}% loss reached`);\n  console.log(`  Signal: ${event.data.id}`);\n  console.log(`  Price: ${event.currentPrice}`);\n  \n  // Consider risk management action at high loss levels\n  if (event.level >= 30) {\n    console.warn(`  High loss level! Consider intervention.`);\n  }\n});\n```\n\n**Sources:** [src/config/emitters.ts:118-124](), [src/function/event.ts:786-789](), [src/function/event.ts:853-856]()\n\n---\n\n## RiskContract\n\nEmitted when a signal is rejected due to risk validation failure. Only rejection events are emitted (allowed signals do not emit).\n\n### Structure\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `symbol` | `string` | Trading pair symbol |\n| `pendingSignal` | `ISignalDto` | Signal that was rejected |\n| `strategyName` | `StrategyName` | Strategy requesting the signal |\n| `exchangeName` | `ExchangeName` | Exchange name |\n| `currentPrice` | `number` | Current market price at rejection |\n| `activePositionCount` | `number` | Number of active positions at rejection time |\n| `comment` | `string` | Rejection reason from validation note or \"N/A\" |\n| `timestamp` | `number` | Event timestamp in milliseconds |\n\n### Usage Example\n\n```typescript\nimport { listenRisk } from \"backtest-kit\";\n\nconst rejectionStats = new Map<string, number>();\n\nlistenRisk((event) => {\n  console.log(`[RISK REJECTED] ${event.symbol}`);\n  console.log(`  Strategy: ${event.strategyName}`);\n  console.log(`  Position: ${event.pendingSignal.position}`);\n  console.log(`  Active positions: ${event.activePositionCount}`);\n  console.log(`  Reason: ${event.comment}`);\n  console.log(`  Price: ${event.currentPrice}`);\n  \n  // Track rejection patterns\n  const key = `${event.strategyName}:${event.comment}`;\n  rejectionStats.set(key, (rejectionStats.get(key) || 0) + 1);\n  \n  // Alert on high rejection counts\n  if (rejectionStats.get(key)! > 10) {\n    console.warn(`  High rejection count for: ${key}`);\n  }\n});\n```\n\n**Sources:** [src/config/emitters.ts:131](), [src/function/event.ts:924-927](), [types.d.ts:1178-1195]()\n\n---\n\n## Type Safety and Null Handling\n\nAll statistics models follow consistent null-safety patterns:\n\n1. **Raw Data Lists**: Always present, never null (e.g., `signalList`, `eventList`)\n2. **Count Fields**: Always present, never null (e.g., `totalSignals`, `winCount`)\n3. **Derived Metrics**: Nullable (e.g., `winRate`, `sharpeRatio`, `avgPnl`)\n\n### Null-Safe Math Implementation\n\nDerived metrics return `null` when:\n- Division by zero would occur\n- Result is NaN or Infinity\n- Insufficient data for calculation (e.g., standard deviation with < 2 samples)\n\nThis approach prevents misleading statistics and forces explicit null checks in consuming code:\n\n```typescript\nconst stats = await Backtest.getData(\"my-strategy\");\n\n// Safe: Always available\nconsole.log(`Processed ${stats.totalSignals} signals`);\n\n// Requires null check: Derived metric\nif (stats.sharpeRatio !== null) {\n  console.log(`Sharpe Ratio: ${stats.sharpeRatio.toFixed(3)}`);\n} else {\n  console.log(\"Sharpe Ratio: Insufficient data\");\n}\n\n// Safe pattern with nullish coalescing\nconst displaySharpe = stats.sharpeRatio?.toFixed(3) ?? \"N/A\";\nconsole.log(`Sharpe Ratio: ${displaySharpe}`);\n```\n\n**Sources:** [types.d.ts:918-943](), [types.d.ts:1153-1172]()\n\n---\n\n## Statistics Generation Flow\n\n```mermaid\ngraph TD\n    subgraph \"Execution\"\n        EXEC[\"Strategy Execution<br/>(tick/backtest methods)\"]\n        EMIT[\"Event Emission<br/>(signalEmitter, etc.)\"]\n    end\n    \n    subgraph \"Markdown Services\"\n        BT_MD[\"BacktestMarkdownService\"]\n        LIVE_MD[\"LiveMarkdownService\"]\n        WALK_MD[\"WalkerMarkdownService\"]\n        SCHED_MD[\"ScheduleMarkdownService\"]\n        RISK_MD[\"RiskMarkdownService\"]\n        PART_MD[\"PartialMarkdownService\"]\n        PERF_MD[\"PerformanceMarkdownService\"]\n    end\n    \n    subgraph \"Storage\"\n        STORAGE[\"ReportStorage<br/>In-memory event accumulation<br/>Max 250 events per key\"]\n    end\n    \n    subgraph \"API Access\"\n        GET_DATA[\"Backtest.getData()<br/>Live.getData()<br/>Walker.getData()<br/>etc.\"]\n        MODELS[\"BacktestStatisticsModel<br/>LiveStatisticsModel<br/>WalkerStatisticsModel<br/>etc.\"]\n    end\n    \n    EXEC --> EMIT\n    EMIT -->|\"signalBacktestEmitter\"| BT_MD\n    EMIT -->|\"signalLiveEmitter\"| LIVE_MD\n    EMIT -->|\"walkerEmitter\"| WALK_MD\n    EMIT -->|\"signalEmitter (scheduled/cancelled)\"| SCHED_MD\n    EMIT -->|\"riskSubject\"| RISK_MD\n    EMIT -->|\"partialProfitSubject/partialLossSubject\"| PART_MD\n    EMIT -->|\"performanceEmitter\"| PERF_MD\n    \n    BT_MD --> STORAGE\n    LIVE_MD --> STORAGE\n    WALK_MD --> STORAGE\n    SCHED_MD --> STORAGE\n    RISK_MD --> STORAGE\n    PART_MD --> STORAGE\n    PERF_MD --> STORAGE\n    \n    STORAGE --> GET_DATA\n    GET_DATA --> MODELS\n```\n\n**Flow Description:**\n\n1. **Execution**: Strategy methods (`tick`, `backtest`) generate signal events\n2. **Emission**: Events emitted to appropriate subjects (mode-specific or global)\n3. **Markdown Services**: Subscribe to relevant emitters, accumulate events in memory\n4. **Storage**: Events stored in `ReportStorage` with 250-event limit per key\n5. **API Access**: `getData()` methods trigger statistics calculation from accumulated events\n6. **Models**: Markdown services compute derived metrics and return statistics models\n\n**Sources:** [src/config/emitters.ts:1-133](), [types.d.ts:918-943]()\n\n---\n\n## Summary Table: Contract Types\n\n| Contract Type | Emitter | Purpose | Key Fields |\n|---------------|---------|---------|------------|\n| `IStrategyTickResult` | `signalEmitter`, `signalBacktestEmitter`, `signalLiveEmitter` | Signal lifecycle events | `action`, `signal`, `currentPrice` |\n| `DoneContract` | `doneLiveSubject`, `doneBacktestSubject`, `doneWalkerSubject` | Execution completion | `symbol`, `strategyName`, `exchangeName` |\n| `ProgressBacktestContract` | `progressBacktestEmitter` | Backtest frame progress | `processedFrames`, `totalFrames`, `progress` |\n| `ProgressWalkerContract` | `progressWalkerEmitter` | Walker strategy progress | `processedStrategies`, `totalStrategies`, `progress` |\n| `ProgressOptimizerContract` | `progressOptimizerEmitter` | Optimizer source progress | `processedSources`, `totalSources`, `progress` |\n| `PerformanceContract` | `performanceEmitter` | Execution timing metrics | `metricType`, `duration`, `timestamp` |\n| `WalkerContract` | `walkerEmitter` | Walker incremental results | `strategyName`, `metricValue`, `bestStrategy` |\n| `WalkerCompleteContract` | `walkerCompleteSubject` | Walker final results | `bestStrategy`, `bestMetric`, `bestStats` |\n| `PartialProfitContract` | `partialProfitSubject` | Profit milestones | `level`, `data`, `currentPrice` |\n| `PartialLossContract` | `partialLossSubject` | Loss milestones | `level`, `data`, `currentPrice` |\n| `RiskContract` | `riskSubject` | Risk rejections | `pendingSignal`, `comment`, `activePositionCount` |\n\n**Sources:** [src/config/emitters.ts:1-133](), [src/function/event.ts:1-969](), [src/index.ts:148-160]()"
                    },
                    {
                        "page_plan": {
                            "id": "12.7",
                            "title": "Service Layer Interfaces"
                        },
                        "content": "# Service Layer Interfaces\n\n<details>\n<summary>Relevant source files</summary>\n\nThe following files were used as context for generating this wiki page:\n\n- [assets/uml.svg](assets/uml.svg)\n- [docs/classes/StrategyConnectionService.md](docs/classes/StrategyConnectionService.md)\n- [docs/classes/WalkerCommandService.md](docs/classes/WalkerCommandService.md)\n- [docs/index.md](docs/index.md)\n- [docs/interfaces/BacktestStatistics.md](docs/interfaces/BacktestStatistics.md)\n- [docs/interfaces/IStrategy.md](docs/interfaces/IStrategy.md)\n- [docs/interfaces/IStrategyCallbacks.md](docs/interfaces/IStrategyCallbacks.md)\n- [docs/interfaces/IStrategySchema.md](docs/interfaces/IStrategySchema.md)\n- [docs/interfaces/LiveStatistics.md](docs/interfaces/LiveStatistics.md)\n- [docs/internals.md](docs/internals.md)\n- [docs/types/IStrategyBacktestResult.md](docs/types/IStrategyBacktestResult.md)\n- [docs/types/IStrategyTickResult.md](docs/types/IStrategyTickResult.md)\n- [docs/uml.puml](docs/uml.puml)\n- [scripts/uml.mjs](scripts/uml.mjs)\n- [src/config/emitters.ts](src/config/emitters.ts)\n- [src/function/event.ts](src/function/event.ts)\n- [src/index.ts](src/index.ts)\n- [types.d.ts](types.d.ts)\n\n</details>\n\n\n\n## Purpose and Scope\n\nThis page documents the internal service interfaces used by the backtest-kit service layer. These interfaces define the contract between service layer components (Connection Services, Core Services, Global Services) and the client layer implementations (ClientStrategy, ClientExchange, ClientFrame, ClientRisk, ClientPartial).\n\n**Target Audience:** Advanced users who need to understand the internal architecture for debugging, extending the framework, or implementing custom components.\n\n**Related Pages:**\n- For user-facing schema interfaces (`IStrategySchema`, `IExchangeSchema`, etc.), see [Core Interfaces](#12.4)\n- For public API methods and classes, see [Execution Classes API](#12.2)\n- For service layer architecture overview, see [Service Layer & Dependency Injection](#4.1)\n\n---\n\n## Architecture Overview\n\nThe service layer acts as a bridge between user-defined schemas and runtime client implementations. Service interfaces define the operational contract that client classes must fulfill.\n\n```mermaid\ngraph TB\n    subgraph \"User Configuration Layer\"\n        SCHEMA_STRAT[\"IStrategySchema<br/>(User-defined)\"]\n        SCHEMA_EXCH[\"IExchangeSchema<br/>(User-defined)\"]\n        SCHEMA_FRAME[\"IFrameSchema<br/>(User-defined)\"]\n        SCHEMA_RISK[\"IRiskSchema<br/>(User-defined)\"]\n    end\n    \n    subgraph \"Service Interface Layer\"\n        IFACE_STRAT[\"IStrategy<br/>(Internal interface)\"]\n        IFACE_EXCH[\"IExchange<br/>(Internal interface)\"]\n        IFACE_FRAME[\"IFrame<br/>(Internal interface)\"]\n        IFACE_RISK[\"IRisk<br/>(Internal interface)\"]\n        IFACE_PARTIAL[\"IPartial<br/>(Internal interface)\"]\n    end\n    \n    subgraph \"Client Implementation Layer\"\n        CLIENT_STRAT[\"ClientStrategy<br/>(Prototype class)\"]\n        CLIENT_EXCH[\"ClientExchange<br/>(Prototype class)\"]\n        CLIENT_FRAME[\"ClientFrame<br/>(Prototype class)\"]\n        CLIENT_RISK[\"ClientRisk<br/>(Prototype class)\"]\n        CLIENT_PARTIAL[\"ClientPartial<br/>(Prototype class)\"]\n    end\n    \n    subgraph \"Service Layer Routing\"\n        CONN_STRAT[\"StrategyConnectionService<br/>(Memoized factory)\"]\n        CONN_EXCH[\"ExchangeConnectionService<br/>(Memoized factory)\"]\n        CONN_FRAME[\"FrameConnectionService<br/>(Memoized factory)\"]\n        CONN_RISK[\"RiskConnectionService<br/>(Memoized factory)\"]\n        CONN_PARTIAL[\"PartialConnectionService<br/>(Memoized factory)\"]\n    end\n    \n    SCHEMA_STRAT --> CONN_STRAT\n    SCHEMA_EXCH --> CONN_EXCH\n    SCHEMA_FRAME --> CONN_FRAME\n    SCHEMA_RISK --> CONN_RISK\n    \n    CONN_STRAT --> CLIENT_STRAT\n    CONN_EXCH --> CLIENT_EXCH\n    CONN_FRAME --> CLIENT_FRAME\n    CONN_RISK --> CLIENT_RISK\n    CONN_PARTIAL --> CLIENT_PARTIAL\n    \n    CLIENT_STRAT -.implements.-> IFACE_STRAT\n    CLIENT_EXCH -.implements.-> IFACE_EXCH\n    CLIENT_FRAME -.implements.-> IFACE_FRAME\n    CLIENT_RISK -.implements.-> IFACE_RISK\n    CLIENT_PARTIAL -.implements.-> IFACE_PARTIAL\n    \n    CONN_STRAT -.returns.-> IFACE_STRAT\n    CONN_EXCH -.returns.-> IFACE_EXCH\n    CONN_FRAME -.returns.-> IFACE_FRAME\n    CONN_RISK -.returns.-> IFACE_RISK\n    CONN_PARTIAL -.returns.-> IFACE_PARTIAL\n```\n\n**Sources:** [types.d.ts:1-900](), [docs/internals.md:28-53]()\n\n---\n\n## Core Domain Interfaces\n\n### IStrategy Interface\n\nThe `IStrategy` interface defines the execution contract for trading strategies. `ClientStrategy` implements this interface to provide signal generation and monitoring capabilities.\n\n**Location:** Not explicitly exported, but documented in [docs/interfaces/IStrategy.md]()\n\n**Methods:**\n\n| Method | Signature | Purpose |\n|--------|-----------|---------|\n| `tick` | `(symbol: string) => Promise<IStrategyTickResult>` | Single tick of strategy execution with VWAP monitoring, throttled signal generation, and TP/SL checks |\n| `getPendingSignal` | `(symbol: string) => Promise<ISignalRow>` | Retrieves currently active signal or null |\n| `backtest` | `(candles: ICandleData[]) => Promise<IStrategyBacktestResult>` | Fast backtest using historical candles with VWAP calculation |\n| `stop` | `(symbol: string) => Promise<void>` | Prevents new signal generation while allowing active signals to complete |\n\n**Key Characteristics:**\n- Discriminated union return types for type-safe state handling\n- Async operations for data fetching and validation\n- Stateful instance (maintains `_pendingSignal` and `_stopped` flags)\n- Context-aware through `ExecutionContextService` and `MethodContextService`\n\n**Usage Example:**\nConnection services route calls to `IStrategy` methods:\n\n```typescript\n// StrategyConnectionService routes to ClientStrategy instance\nconst strategy: IStrategy = strategyConnectionService.getStrategy(symbol, strategyName);\nconst result = await strategy.tick(symbol);\n```\n\n**Sources:** [docs/interfaces/IStrategy.md:1-55](), [types.d.ts:6-20]()\n\n---\n\n### IExchange Interface\n\nThe `IExchange` interface defines data access and formatting operations for exchange data sources. `ClientExchange` implements this interface to provide candle data and VWAP calculations.\n\n**Location:** [types.d.ts:160-205]()\n\n**Methods:**\n\n| Method | Signature | Purpose |\n|--------|-----------|---------|\n| `getCandles` | `(symbol: string, interval: CandleInterval, limit: number) => Promise<ICandleData[]>` | Fetches historical candles backwards from execution context time |\n| `getNextCandles` | `(symbol: string, interval: CandleInterval, limit: number) => Promise<ICandleData[]>` | Fetches future candles forward from execution context time (backtest only) |\n| `formatQuantity` | `(symbol: string, quantity: number) => Promise<string>` | Formats quantity according to exchange precision rules |\n| `formatPrice` | `(symbol: string, price: number) => Promise<string>` | Formats price according to exchange precision rules |\n| `getAveragePrice` | `(symbol: string) => Promise<number>` | Calculates VWAP from last 5 1-minute candles using formula: VWAP = Σ(Typical Price × Volume) / Σ(Volume) |\n\n**Key Characteristics:**\n- Read-only operations (no state modification)\n- Context-aware through `ExecutionContextService` (uses `when` timestamp)\n- All methods accept `symbol` parameter for multi-symbol support\n- VWAP calculation uses candle data: `(High + Low + Close) / 3 × Volume`\n\n**Implementation Details:**\n`ClientExchange` wraps user-defined `IExchangeSchema.getCandles` function and adds:\n- Candle buffer management (caches up to 500 candles)\n- Anomaly detection (filters candles with zero/NaN/Infinity prices)\n- Retry logic with exponential backoff\n- VWAP calculation using last 5 1-minute candles\n\n**Sources:** [types.d.ts:160-205](), [types.d.ts:87-155]()\n\n---\n\n### IFrame Interface\n\nThe `IFrame` interface defines timeframe generation for backtesting. `ClientFrame` implements this interface to provide timestamp arrays for iteration.\n\n**Location:** [types.d.ts:280-289]()\n\n**Methods:**\n\n| Method | Signature | Purpose |\n|--------|-----------|---------|\n| `getTimeframe` | `(symbol: string, frameName: FrameName) => Promise<Date[]>` | Generates array of timestamps for backtest iteration, spaced according to configured interval |\n\n**Key Characteristics:**\n- Single method interface (simplest domain interface)\n- Symbol parameter unused but included for API consistency\n- Stateless operation (generates dates from schema configuration)\n- Interval options: `1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d`\n\n**Implementation Details:**\n`ClientFrame` uses [types.d.ts:262-275]() schema properties:\n- `startDate`: Beginning of backtest period (inclusive)\n- `endDate`: End of backtest period (inclusive)\n- `interval`: Time spacing between timestamps\n- `callbacks.onTimeframe`: Optional callback after generation\n\n**Usage Pattern:**\n```typescript\n// FrameConnectionService routes to ClientFrame instance\nconst frame: IFrame = frameConnectionService.getFrame(frameName);\nconst timeframes = await frame.getTimeframe(symbol, frameName);\n// Returns: [Date(2024-01-01 00:00), Date(2024-01-01 00:01), ...]\n```\n\n**Sources:** [types.d.ts:280-289](), [types.d.ts:262-275]()\n\n---\n\n### IRisk Interface\n\nThe `IRisk` interface defines risk management operations for signal validation. `ClientRisk` and `MergeRisk` implement this interface to provide portfolio-level controls.\n\n**Location:** [types.d.ts:448-479]()\n\n**Methods:**\n\n| Method | Signature | Purpose |\n|--------|-----------|---------|\n| `checkSignal` | `(params: IRiskCheckArgs) => Promise<boolean>` | Validates signal against risk limits, returns true if allowed |\n| `addSignal` | `(symbol: string, context: {strategyName, riskName}) => Promise<void>` | Registers new opened signal/position |\n| `removeSignal` | `(symbol: string, context: {strategyName, riskName}) => Promise<void>` | Removes closed signal/position |\n\n**Key Data Structures:**\n\n```mermaid\nclassDiagram\n    class IRiskCheckArgs {\n        +string symbol\n        +ISignalDto pendingSignal\n        +string strategyName\n        +string exchangeName\n        +number currentPrice\n        +number timestamp\n    }\n    \n    class IRiskValidationPayload {\n        +string symbol\n        +ISignalDto pendingSignal\n        +string strategyName\n        +string exchangeName\n        +number currentPrice\n        +number timestamp\n        +number activePositionCount\n        +IRiskActivePosition[] activePositions\n    }\n    \n    class IRiskActivePosition {\n        +ISignalRow signal\n        +string strategyName\n        +string exchangeName\n        +number openTimestamp\n    }\n    \n    IRiskValidationPayload --|> IRiskCheckArgs\n    IRiskValidationPayload --> IRiskActivePosition\n```\n\n**Key Characteristics:**\n- Stateful tracking of active positions across strategies\n- Validation functions throw errors to reject signals\n- `addSignal`/`removeSignal` lifecycle matches signal open/close\n- Multi-strategy awareness through `activePositions` array\n\n**Implementation Variants:**\n\n1. **ClientRisk** ([types.d.ts:417-426]()): Single risk profile with custom validations\n2. **MergeRisk**: Combines multiple `ClientRisk` instances (used when `riskList` provided in strategy schema)\n\n**Validation Flow:**\n```mermaid\nsequenceDiagram\n    participant Strat as \"ClientStrategy\"\n    participant Risk as \"ClientRisk/MergeRisk\"\n    participant Validation as \"IRiskValidationFn[]\"\n    \n    Strat->>Risk: checkSignal(params)\n    Risk->>Risk: Build IRiskValidationPayload\n    Note over Risk: Add activePositionCount<br/>and activePositions array\n    \n    loop For each validation\n        Risk->>Validation: validate(payload)\n        alt Validation passes\n            Validation-->>Risk: void (no error)\n        else Validation fails\n            Validation-->>Risk: throw Error(note)\n            Risk-->>Strat: return false\n        end\n    end\n    \n    Risk-->>Strat: return true\n```\n\n**Sources:** [types.d.ts:448-479](), [types.d.ts:339-426]()\n\n---\n\n### IPartial Interface\n\nThe `IPartial` interface defines profit/loss milestone tracking for active signals. `ClientPartial` implements this interface to emit events when signals reach 10%, 20%, 30% profit or loss thresholds.\n\n**Location:** [types.d.ts:548-639]()\n\n**Methods:**\n\n| Method | Signature | Purpose |\n|--------|-----------|---------|\n| `profit` | `(symbol, data, currentPrice, revenuePercent, backtest, when) => Promise<void>` | Processes profit state and emits events for new profit levels reached |\n| `loss` | `(symbol, data, currentPrice, lossPercent, backtest, when) => Promise<void>` | Processes loss state and emits events for new loss levels reached |\n| `clear` | `(symbol, data, priceClose, backtest) => Promise<void>` | Clears partial profit/loss state when signal closes |\n\n**Type Definition: PartialLevel**\n\n```typescript\ntype PartialLevel = 10 | 20 | 30 | 40 | 50 | 60 | 70 | 80 | 90 | 100;\n```\n\n**State Management:**\n\n```mermaid\nstateDiagram-v2\n    [*] --> Initialized: new signal opens\n    Initialized --> Tracking: profit()/loss() called\n    Tracking --> Tracking: Additional levels reached\n    Tracking --> [*]: clear() called on signal close\n    \n    state Tracking {\n        [*] --> CheckLevel\n        CheckLevel --> EmitEvent: Level not yet reached\n        CheckLevel --> Skip: Level already emitted\n        EmitEvent --> UpdateState: Add level to Set\n        UpdateState --> CheckLevel: Check next level\n        Skip --> CheckLevel: Check next level\n    }\n```\n\n**Key Characteristics:**\n- Stateful tracking using `Map<signalId, IPartialState>` where state contains:\n  - `profitLevels: Set<PartialLevel>` - Deduplication via Set\n  - `lossLevels: Set<PartialLevel>` - Prevents duplicate events\n- Persistent state via `PersistPartialAdapter` for crash recovery\n- Only tracks levels >= 10% (no sub-10% granularity)\n- Separate profit and loss tracking (signal can have both if price oscillates)\n\n**Event Emission Logic:**\n\n```mermaid\ngraph TD\n    A[\"profit(revenuePercent)\"] --> B{revenuePercent >= 10?}\n    B -->|No| C[Return without event]\n    B -->|Yes| D[Calculate levels reached]\n    D --> E[levels = 10, 20, 30... up to floor(revenuePercent/10) * 10]\n    E --> F{For each level}\n    F --> G{Already in profitLevels Set?}\n    G -->|Yes| H[Skip level]\n    G -->|No| I[Add to profitLevels Set]\n    I --> J[Emit partialProfitSubject]\n    J --> K[Persist state to disk]\n    H --> F\n    K --> F\n```\n\n**Persistence Schema:**\n\n```typescript\ninterface IPartialData {\n    profitLevels: PartialLevel[];  // Array (serialized from Set)\n    lossLevels: PartialLevel[];    // Array (serialized from Set)\n}\n```\n\nStored as: `Map<signalId, IPartialData>` in `PersistPartialAdapter`\n\n**Sources:** [types.d.ts:548-639](), [types.d.ts:486-516]()\n\n---\n\n## Service Categories\n\n### Connection Services (Memoized Factories)\n\nConnection services act as memoized factories that create and cache client instances. They route operations based on context and implement the factory pattern with caching.\n\n```mermaid\ngraph LR\n    subgraph \"Connection Services\"\n        SC[\"StrategyConnectionService\"]\n        EC[\"ExchangeConnectionService\"]\n        FC[\"FrameConnectionService\"]\n        RC[\"RiskConnectionService\"]\n        PC[\"PartialConnectionService\"]\n    end\n    \n    subgraph \"Client Instances (Cached)\"\n        CS[\"ClientStrategy<br/>(key: symbol:strategyName)\"]\n        CE[\"ClientExchange<br/>(key: exchangeName)\"]\n        CF[\"ClientFrame<br/>(key: frameName)\"]\n        CR[\"ClientRisk/MergeRisk<br/>(key: riskName)\"]\n        CP[\"ClientPartial<br/>(key: symbol:signalId)\"]\n    end\n    \n    SC -->|getStrategy| CS\n    EC -->|getExchange| CE\n    FC -->|getFrame| CF\n    RC -->|getRisk| CR\n    PC -->|getPartial| CP\n    \n    SC -->|tick/backtest/stop| CS\n    EC -->|getCandles/getAveragePrice| CE\n    FC -->|getTimeframe| CF\n    RC -->|checkSignal/addSignal| CR\n    PC -->|profit/loss/clear| CP\n```\n\n**Common Pattern:**\n\nAll connection services follow this pattern:\n1. Inject schema service + context services\n2. Implement memoized getter (e.g., `getStrategy`, `getExchange`)\n3. Delegate method calls to cached client instances\n4. Use context services for routing decisions\n\n**Example: StrategyConnectionService**\n\nKey properties from [docs/classes/StrategyConnectionService.md:21-68]():\n\n| Property | Type | Purpose |\n|----------|------|---------|\n| `loggerService` | LoggerService | Centralized logging |\n| `executionContextService` | TExecutionContextService | Symbol, when, backtest flag |\n| `methodContextService` | MethodContextService | Strategy/exchange/frame names |\n| `strategySchemaService` | StrategySchemaService | Schema registry |\n| `riskConnectionService` | RiskConnectionService | Risk validation routing |\n| `exchangeConnectionService` | ExchangeConnectionService | Exchange data routing |\n| `partialConnectionService` | PartialConnectionService | Partial tracking routing |\n| `getStrategy` | Memoized function | Returns cached `ClientStrategy` |\n\n**Memoization Key Pattern:**\n\n```typescript\n// StrategyConnectionService\nkey = `${symbol}:${strategyName}`;  // \"BTCUSDT:my-strategy\"\n\n// ExchangeConnectionService\nkey = exchangeName;  // \"binance\"\n\n// FrameConnectionService\nkey = frameName;  // \"1d-backtest\"\n\n// RiskConnectionService\nkey = riskName;  // \"portfolio-limit\"\n\n// PartialConnectionService\nkey = `${symbol}:${signalId}`;  // \"BTCUSDT:uuid-v4-here\"\n```\n\n**Sources:** [docs/classes/StrategyConnectionService.md:1-145](), [types.d.ts:1-900]()\n\n---\n\n### Core Services (Orchestration)\n\nCore services orchestrate business logic by coordinating connection services and validation services. They implement the service facade pattern.\n\n```mermaid\ngraph TB\n    subgraph \"Core Services\"\n        StratCore[\"StrategyCoreService<br/>tick() orchestration\"]\n        ExchCore[\"ExchangeCoreService<br/>Data fetching\"]\n        FrameCore[\"FrameCoreService<br/>Timeframe generation\"]\n    end\n    \n    subgraph \"Connection Services\"\n        StratConn[\"StrategyConnectionService\"]\n        ExchConn[\"ExchangeConnectionService\"]\n        FrameConn[\"FrameConnectionService\"]\n    end\n    \n    subgraph \"Validation Services\"\n        StratVal[\"StrategyValidationService\"]\n        ExchVal[\"ExchangeValidationService\"]\n        FrameVal[\"FrameValidationService\"]\n        RiskVal[\"RiskValidationService\"]\n    end\n    \n    StratCore --> StratConn\n    StratCore --> StratVal\n    StratCore --> RiskVal\n    \n    ExchCore --> ExchConn\n    ExchCore --> ExchVal\n    \n    FrameCore --> FrameConn\n    FrameCore --> FrameVal\n```\n\n**StrategyCoreService Responsibilities:**\n\n1. Pre-execution validation (strategy exists, risk exists)\n2. Context propagation via `MethodContextService`\n3. Routing tick/backtest calls to `StrategyConnectionService`\n4. No business logic (pure orchestration)\n\n**Delegation Pattern:**\n\n```mermaid\nsequenceDiagram\n    participant Logic as \"BacktestLogicPrivateService\"\n    participant Core as \"StrategyCoreService\"\n    participant Val as \"StrategyValidationService\"\n    participant Conn as \"StrategyConnectionService\"\n    participant Client as \"ClientStrategy\"\n    \n    Logic->>Core: tick(symbol)\n    Core->>Val: strategyValidation()\n    Val-->>Core: validation result\n    Core->>Val: riskValidation()\n    Val-->>Core: validation result\n    Core->>Conn: tick(symbol, strategyName)\n    Conn->>Client: tick(symbol)\n    Client-->>Conn: IStrategyTickResult\n    Conn-->>Core: IStrategyTickResult\n    Core-->>Logic: IStrategyTickResult\n```\n\n**Sources:** [docs/internals.md:28-53](), [types.d.ts:1-900]()\n\n---\n\n### Global Services (Shared State)\n\nGlobal services manage cross-strategy state and provide singleton access to shared resources.\n\n```mermaid\ngraph TB\n    subgraph \"Global Services\"\n        RiskGlobal[\"RiskGlobalService<br/>Portfolio-wide position tracking\"]\n        PartialGlobal[\"PartialGlobalService<br/>Cross-symbol partial state\"]\n        OptimizerGlobal[\"OptimizerGlobalService<br/>LLM session management\"]\n    end\n    \n    subgraph \"Persistence Layer\"\n        RiskPersist[\"PersistRiskAdapter<br/>Active positions by symbol\"]\n        PartialPersist[\"PersistPartialAdapter<br/>Profit/loss levels by signal\"]\n    end\n    \n    subgraph \"External Services\"\n        Ollama[\"Ollama LLM<br/>Strategy code generation\"]\n    end\n    \n    RiskGlobal --> RiskPersist\n    PartialGlobal --> PartialPersist\n    OptimizerGlobal --> Ollama\n```\n\n**RiskGlobalService:**\n\nTracks active positions across all strategies for portfolio-level risk management. Maintains in-memory map of active signals and persists to disk for crash recovery.\n\n**Key Data:**\n- `Map<symbol, Set<{strategyName, riskName}>>` - Active position tracking\n- Updated via `IRisk.addSignal()` and `IRisk.removeSignal()`\n- Queried by `IRiskValidationPayload.activePositionCount` and `activePositions`\n\n**PartialGlobalService:**\n\nAggregates partial profit/loss events across symbols for portfolio-wide reporting. Provides global access to partial state without requiring symbol-specific routing.\n\n**OptimizerGlobalService:**\n\nManages LLM connection pool and prompt history for strategy optimization. Implements conversation state management for iterative code generation.\n\n**Sources:** [types.d.ts:339-479](), [types.d.ts:486-639]()\n\n---\n\n## Dependency Injection Flow\n\nThe service layer uses a custom dependency injection container built with Symbol-based tokens. The `backtest` object aggregates all services.\n\n```mermaid\ngraph TB\n    subgraph \"DI Container (lib/index.ts)\"\n        TYPES[\"TYPES Symbol Registry<br/>Unique identifiers\"]\n        PROVIDE[\"provide() function<br/>Register factories\"]\n        INJECT[\"inject() function<br/>Lazy resolution\"]\n        BACKTEST[\"backtest object<br/>Service aggregator\"]\n    end\n    \n    subgraph \"Service Tokens\"\n        T_LOG[\"TYPES.LoggerService\"]\n        T_EXEC[\"TYPES.ExecutionContextService\"]\n        T_METHOD[\"TYPES.MethodContextService\"]\n        T_STRAT_SCHEMA[\"TYPES.StrategySchemaService\"]\n        T_STRAT_CONN[\"TYPES.StrategyConnectionService\"]\n        T_STRAT_CORE[\"TYPES.StrategyCoreService\"]\n    end\n    \n    subgraph \"Service Instances\"\n        LOG[\"LoggerService instance\"]\n        EXEC[\"ExecutionContextService instance\"]\n        METHOD[\"MethodContextService instance\"]\n        STRAT_SCHEMA[\"StrategySchemaService instance\"]\n        STRAT_CONN[\"StrategyConnectionService instance\"]\n        STRAT_CORE[\"StrategyCoreService instance\"]\n    end\n    \n    TYPES --> PROVIDE\n    PROVIDE --> INJECT\n    INJECT --> BACKTEST\n    \n    T_LOG --> LOG\n    T_EXEC --> EXEC\n    T_METHOD --> METHOD\n    T_STRAT_SCHEMA --> STRAT_SCHEMA\n    T_STRAT_CONN --> STRAT_CONN\n    T_STRAT_CORE --> STRAT_CORE\n    \n    BACKTEST --> LOG\n    BACKTEST --> EXEC\n    BACKTEST --> METHOD\n    BACKTEST --> STRAT_SCHEMA\n    BACKTEST --> STRAT_CONN\n    BACKTEST --> STRAT_CORE\n```\n\n**Resolution Order:**\n\nServices are resolved lazily when first accessed. Dependencies are injected via constructor parameters using `inject()` function.\n\n**Example Service Registration:**\n\n```typescript\n// Conceptual representation of service registration\nprovide(TYPES.StrategyConnectionService, () => {\n    return new StrategyConnectionService(\n        inject(TYPES.LoggerService),\n        inject(TYPES.ExecutionContextService),\n        inject(TYPES.StrategySchemaService),\n        inject(TYPES.RiskConnectionService),\n        inject(TYPES.ExchangeConnectionService),\n        inject(TYPES.MethodContextService),\n        inject(TYPES.PartialConnectionService)\n    );\n});\n```\n\n**Access Pattern:**\n\nAll services are accessed through the `backtest` object:\n\n```typescript\nimport { lib } from 'backtest-kit';\n\n// Access services\nconst logger = lib.loggerService;\nconst strategyCore = lib.strategyCoreService;\nconst strategyConnection = lib.strategyConnectionService;\n```\n\n**Sources:** [docs/internals.md:41-53](), [src/index.ts:198]()\n\n---\n\n## Context Propagation\n\nService interfaces receive ambient context through two scoped services: `ExecutionContextService` and `MethodContextService`. This enables implicit parameter passing without polluting method signatures.\n\n```mermaid\ngraph TB\n    subgraph \"Context Services\"\n        EXEC[\"ExecutionContextService<br/>{symbol, when, backtest}\"]\n        METHOD[\"MethodContextService<br/>{strategyName, exchangeName, frameName}\"]\n    end\n    \n    subgraph \"Execution Layer\"\n        BT_LOGIC[\"BacktestLogicPrivateService\"]\n        LIVE_LOGIC[\"LiveLogicPrivateService\"]\n    end\n    \n    subgraph \"Core Services\"\n        STRAT_CORE[\"StrategyCoreService\"]\n    end\n    \n    subgraph \"Connection Services\"\n        STRAT_CONN[\"StrategyConnectionService\"]\n    end\n    \n    subgraph \"Client Implementations\"\n        CLIENT[\"ClientStrategy\"]\n    end\n    \n    BT_LOGIC -->|\"MethodContextService.runInContext()\"| STRAT_CORE\n    LIVE_LOGIC -->|\"MethodContextService.runInContext()\"| STRAT_CORE\n    \n    STRAT_CORE -->|\"ExecutionContextService.runInContext()\"| STRAT_CONN\n    \n    STRAT_CONN -->|Reads context| EXEC\n    STRAT_CONN -->|Reads context| METHOD\n    \n    STRAT_CONN --> CLIENT\n    \n    CLIENT -->|Reads context| EXEC\n    CLIENT -->|Reads context| METHOD\n```\n\n**ExecutionContextService:**\n\nProvides runtime execution parameters. Accessible via `executionContextService.context`:\n\n```typescript\ninterface IExecutionContext {\n    symbol: string;        // \"BTCUSDT\"\n    when: Date;            // Current timestamp\n    backtest: boolean;     // true for backtest, false for live\n}\n```\n\n**MethodContextService:**\n\nProvides schema routing parameters. Accessible via `methodContextService.context`:\n\n```typescript\ninterface IMethodContext {\n    exchangeName: string;   // \"binance\"\n    strategyName: string;   // \"my-strategy\"\n    frameName: string;      // \"1d-backtest\" or \"\" for live\n}\n```\n\n**Usage Pattern:**\n\n```typescript\n// In ClientExchange.getCandles()\nconst { when, backtest } = this.executionContextService.context;\n\nif (backtest) {\n    // Fetch backward from 'when'\n    const since = new Date(when.getTime() - interval * limit);\n    return this.getCandlesImpl(symbol, interval, since, limit);\n} else {\n    // Fetch most recent\n    const since = new Date(Date.now() - interval * limit);\n    return this.getCandlesImpl(symbol, interval, since, limit);\n}\n```\n\n**Sources:** [types.d.ts:6-49](), [types.d.ts:297-336]()\n\n---\n\n## Method Signature Reference\n\n### IStrategy Methods\n\n#### tick(symbol: string): Promise<IStrategyTickResult>\n\nExecutes single strategy tick with throttled signal generation and TP/SL monitoring.\n\n**Return Types (Discriminated Union):**\n\n```typescript\ntype IStrategyTickResult = \n    | { action: \"idle\", signal: null, currentPrice, ... }\n    | { action: \"scheduled\", signal: IScheduledSignalRow, ... }\n    | { action: \"opened\", signal: ISignalRow, ... }\n    | { action: \"active\", signal: ISignalRow, percentTp, percentSl, ... }\n    | { action: \"closed\", signal: ISignalRow, closeReason, pnl, ... }\n    | { action: \"cancelled\", signal: IScheduledSignalRow, ... }\n```\n\n**Flow:**\n1. Check if strategy stopped → return idle\n2. Check interval throttling → skip if too soon\n3. Check pending signal exists → monitor TP/SL/time\n4. Check scheduled signal exists → monitor activation/cancellation\n5. Call `getSignal()` → validate → persist → return opened\n\n**Sources:** [docs/interfaces/IStrategy.md:14-21](), [types.d.ts:767-888]()\n\n#### backtest(candles: ICandleData[]): Promise<IStrategyBacktestResult>\n\nFast backtest using bulk candle processing with VWAP calculation per candle.\n\n**Return Types:**\n\n```typescript\ntype IStrategyBacktestResult = \n    | IStrategyTickResultClosed    // TP/SL/time_expired\n    | IStrategyTickResultCancelled  // Scheduled never activated\n```\n\n**Flow:**\n1. Check pending/scheduled signal exists → monitor per candle\n2. For each candle: calculate VWAP, check TP/SL, emit partial events\n3. Return closed/cancelled result when signal completes\n\n**Sources:** [docs/interfaces/IStrategy.md:33-43](), [types.d.ts:892]()\n\n---\n\n### IExchange Methods\n\n#### getCandles(symbol, interval, limit): Promise<ICandleData[]>\n\nFetches historical candles backward from execution context time.\n\n**Parameters:**\n- `symbol`: Trading pair (e.g., \"BTCUSDT\")\n- `interval`: Candle time interval (`1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h`)\n- `limit`: Maximum candles to fetch\n\n**Context-Aware Behavior:**\n- Uses `executionContextService.context.when` as reference point\n- Calculates `since = when - (interval * limit)`\n- Caches candles in buffer (up to 500)\n\n**Sources:** [types.d.ts:160-169]()\n\n#### getAveragePrice(symbol): Promise<number>\n\nCalculates VWAP from last 5 1-minute candles.\n\n**Formula:**\n```\nTypical Price = (High + Low + Close) / 3\nVWAP = Σ(Typical Price × Volume) / Σ(Volume)\n```\n\n**Sources:** [types.d.ts:196-204]()\n\n---\n\n### IRisk Methods\n\n#### checkSignal(params: IRiskCheckArgs): Promise<boolean>\n\nValidates signal against risk limits. Returns `true` if allowed, `false` if rejected.\n\n**Validation Process:**\n1. Build `IRiskValidationPayload` with active position data\n2. Execute each validation function in `validations[]` array\n3. If any validation throws error → return `false` (rejected)\n4. If all validations pass → return `true` (allowed)\n\n**Error Handling:**\nValidation functions throw errors with `note` property for rejection reasons:\n\n```typescript\nconst validation: IRiskValidationFn = (payload) => {\n    if (payload.activePositionCount >= 3) {\n        throw new Error(\"Max 3 concurrent positions\");\n    }\n};\n```\n\n**Sources:** [types.d.ts:452-458]()\n\n---\n\n### IPartial Methods\n\n#### profit(symbol, data, currentPrice, revenuePercent, backtest, when): Promise<void>\n\nProcesses profit state and emits events for newly reached profit levels.\n\n**Parameters:**\n- `revenuePercent`: Current profit as positive percentage (e.g., `15.5` for 15.5% profit)\n\n**Deduplication:**\nUses `Set<PartialLevel>` to track emitted levels. Only emits event once per level per signal.\n\n**Example:**\n```typescript\n// First call: revenuePercent = 12.3\nawait partial.profit(..., 12.3, ...);\n// Emits: 10% profit event\n\n// Second call: revenuePercent = 23.7\nawait partial.profit(..., 23.7, ...);\n// Emits: 20% profit event (10% already emitted)\n```\n\n**Sources:** [types.d.ts:549-581]()\n\n---\n\n## Summary Table: Service Interfaces\n\n| Interface | Implementing Class | Purpose | Key Methods |\n|-----------|-------------------|---------|-------------|\n| `IStrategy` | `ClientStrategy` | Strategy execution and monitoring | `tick`, `backtest`, `getPendingSignal`, `stop` |\n| `IExchange` | `ClientExchange` | Exchange data access | `getCandles`, `getNextCandles`, `getAveragePrice`, `formatPrice`, `formatQuantity` |\n| `IFrame` | `ClientFrame` | Timeframe generation | `getTimeframe` |\n| `IRisk` | `ClientRisk`, `MergeRisk` | Risk validation and tracking | `checkSignal`, `addSignal`, `removeSignal` |\n| `IPartial` | `ClientPartial` | Profit/loss milestone tracking | `profit`, `loss`, `clear` |\n\n**Sources:** [types.d.ts:160-639](), [docs/interfaces/IStrategy.md:1-55]()"
                    }
                ]
            }
        },
        "default_language": "en"
    },
    "git_connection_type": "bitbucket_oauth",
    "git_host": "bitbucket.org"
}