import { test } from "worker-testbed";

import {
  addExchange,
  addFrame,
  addStrategy,
  Backtest,
  listenDoneBacktest,
} from "../../build/index.mjs";

import { Subject, sleep } from "functools-kit";

/**
 * PERSIST TEST #7: SEQUENCE - Track writeValue content through signal lifecycle
 *
 * Scenario:
 * - Signal #1: LONG scheduled → opened → closed by TP
 * - Signal #2: LONG scheduled → opened → closed by SL
 * - Check writeValue content at each step:
 *   - scheduled: writeValue NOT called
 *   - opened: writeValue called with full signal data
 *   - closed: writeValue called with null (signal deleted)
 */
test("PERSIST SEQUENCE: Track writeValue content - 2 LONG signals (TP, SL)", async ({ pass, fail }) => {
  const writeHistory = [];
  let onScheduleCount = 0;
  let onOpenCount = 0;
  let onCloseCount = 0;

  const startTime = new Date("2024-01-01T00:00:00Z").getTime();
  const intervalMs = 60000;
  const basePrice = 95000;

  let allCandles = [];

  // Предзаполняем начальные свечи для getAveragePrice
  for (let i = 0; i < 5; i++) {
    allCandles.push({
      timestamp: startTime + i * intervalMs,
      open: basePrice,
      high: basePrice + 100,
      low: basePrice - 100,
      close: basePrice,
      volume: 100,
    });
  }

  addExchange({
    exchangeName: "binance-persist-seq-1",
    getCandles: async (_symbol, _interval, since, limit) => {
      const sinceIndex = Math.floor((since.getTime() - startTime) / intervalMs);
      const result = allCandles.slice(sinceIndex, sinceIndex + limit);
      return result.length > 0 ? result : allCandles.slice(0, Math.min(limit, allCandles.length));
    },
    formatPrice: async (_symbol, p) => p.toFixed(8),
    formatQuantity: async (_symbol, quantity) => quantity.toFixed(8),
  });

  let signalCount = 0;

  addStrategy({
    strategyName: "persist-seq-strategy-1",
    interval: "1m",
    getSignal: async () => {
      signalCount++;
      if (signalCount > 2) return null;

      // Генерируем все свечи только в первый раз
      if (signalCount === 1) {
        allCandles = [];

        for (let i = 0; i < 60; i++) {
          const timestamp = startTime + i * intervalMs;

          // Сигнал #1: TP (0-4: ожидание, 5-9: активация, 10-14: TP)
          if (i < 5) {
            allCandles.push({ timestamp, open: basePrice + 500, high: basePrice + 600, low: basePrice + 400, close: basePrice + 500, volume: 100 });
          } else if (i >= 5 && i < 10) {
            allCandles.push({ timestamp, open: basePrice, high: basePrice + 100, low: basePrice - 100, close: basePrice, volume: 100 });
          } else if (i >= 10 && i < 15) {
            allCandles.push({ timestamp, open: basePrice + 1000, high: basePrice + 1100, low: basePrice + 900, close: basePrice + 1000, volume: 100 });
          }

          // Сигнал #2: SL (20-24: ожидание, 25-29: активация, 30-34: SL)
          else if (i >= 20 && i < 25) {
            allCandles.push({ timestamp, open: basePrice + 500, high: basePrice + 600, low: basePrice + 400, close: basePrice + 500, volume: 100 });
          } else if (i >= 25 && i < 30) {
            allCandles.push({ timestamp, open: basePrice, high: basePrice + 100, low: basePrice - 100, close: basePrice, volume: 100 });
          } else if (i >= 30 && i < 35) {
            allCandles.push({ timestamp, open: basePrice - 1000, high: basePrice - 900, low: basePrice - 1100, close: basePrice - 1000, volume: 100 });
          }

          // Остальное время: нейтральные свечи
          else {
            allCandles.push({ timestamp, open: basePrice, high: basePrice + 100, low: basePrice - 100, close: basePrice, volume: 100 });
          }
        }
      }

      return {
        position: "long",
        note: `Persist seq signal #${signalCount}`,
        priceOpen: basePrice,
        priceTakeProfit: basePrice + 1000,
        priceStopLoss: basePrice - 1000,
        minuteEstimatedTime: 60,
      };
    },
    callbacks: {
      onSchedule: () => {
        onScheduleCount++;
      },
      onOpen: () => {
        onOpenCount++;
      },
      onClose: () => {
        onCloseCount++;
      },
      onWrite: (_symbol, signal) => {
        // Записываем полную историю вызовов onWrite
        writeHistory.push({
          timestamp: Date.now(),
          signal: signal ? JSON.parse(JSON.stringify(signal)) : null,
          scheduledCount: onScheduleCount,
          openedCount: onOpenCount,
          closedCount: onCloseCount,
        });
      },
    },
  });

  addFrame({
    frameName: "60m-test",
    interval: "1m",
    startDate: new Date("2024-01-01T00:00:00Z"),
    endDate: new Date("2024-01-01T01:00:00Z"), // 60 minutes
  });

  const awaitSubject = new Subject();
  listenDoneBacktest(() => awaitSubject.next());

  Backtest.background("BTCUSDT", {
    strategyName: "persist-seq-strategy-1",
    exchangeName: "binance-persist-seq-1",
    frameName: "60m-test",
  });

  await awaitSubject.toPromise();
  await sleep(1000);

  // ПРОВЕРКА #1: writeValue должен вызываться минимум 2 раза (для 2 сигналов)
  if (writeHistory.length < 2) {
    fail(`Expected at least 2 writeValue calls, got ${writeHistory.length}`);
    return;
  }

  // ПРОВЕРКА #2: Первый writeValue должен содержать signal data (opened)
  const firstWrite = writeHistory[0];
  if (!firstWrite.signal) {
    fail(`First writeValue should contain signal data (opened), got null`);
    return;
  }

  if (firstWrite.signal.position !== "long") {
    fail(`First writeValue signal.position should be "long", got ${firstWrite.signal.position}`);
    return;
  }

  if (firstWrite.signal.priceOpen !== basePrice) {
    fail(`First writeValue signal.priceOpen should be ${basePrice}, got ${firstWrite.signal.priceOpen}`);
    return;
  }

  // ПРОВЕРКА #3: После закрытия первого сигнала должен быть writeValue(null)
  const nullWrites = writeHistory.filter(h => h.signal === null);
  if (nullWrites.length < 1) {
    fail(`Expected at least 1 writeValue(null) after signal close, got ${nullWrites.length}`);
    return;
  }

  // ПРОВЕРКА #4: Второй сигнал также должен быть записан
  const nonNullWrites = writeHistory.filter(h => h.signal !== null);
  if (nonNullWrites.length < 2) {
    fail(`Expected at least 2 non-null writeValue calls (for 2 signals), got ${nonNullWrites.length}`);
    return;
  }

  const summary = `${writeHistory.length} writeValue calls: ${nonNullWrites.length} opened, ${nullWrites.length} closed`;
  pass(`PERSIST SEQUENCE: ${summary}. First signal: position=${firstWrite.signal.position}, priceOpen=${firstWrite.signal.priceOpen}`);
});

/**
 * PERSIST TEST #8: SEQUENCE - Verify signal fields in writeValue
 *
 * Scenario:
 * - Signal: LONG scheduled → opened
 * - Check writeValue contains all critical fields:
 *   - position, priceOpen, priceTakeProfit, priceStopLoss
 *   - minuteEstimatedTime, symbol, strategyName, exchangeName
 *   - scheduledAt, pendingAt, timestamp
 */
test("PERSIST SEQUENCE: Verify all signal fields in writeValue", async ({ pass, fail }) => {
  let capturedSignal = null;
  let onOpenCalled = false;

  const startTime = new Date("2024-01-01T00:00:00Z").getTime();
  const intervalMs = 60000;
  const basePrice = 95000;

  let allCandles = [];

  for (let i = 0; i < 5; i++) {
    allCandles.push({
      timestamp: startTime + i * intervalMs,
      open: basePrice,
      high: basePrice + 100,
      low: basePrice - 100,
      close: basePrice,
      volume: 100,
    });
  }

  addExchange({
    exchangeName: "binance-persist-seq-2",
    getCandles: async (_symbol, _interval, since, limit) => {
      const sinceIndex = Math.floor((since.getTime() - startTime) / intervalMs);
      const result = allCandles.slice(sinceIndex, sinceIndex + limit);
      return result.length > 0 ? result : allCandles.slice(0, Math.min(limit, allCandles.length));
    },
    formatPrice: async (_symbol, p) => p.toFixed(8),
    formatQuantity: async (_symbol, quantity) => quantity.toFixed(8),
  });

  let signalGenerated = false;

  addStrategy({
    strategyName: "persist-seq-strategy-2",
    interval: "1m",
    getSignal: async () => {
      if (signalGenerated) return null;
      signalGenerated = true;

      // Генерируем свечи для активации
      allCandles = [];
      for (let i = 0; i < 20; i++) {
        const timestamp = startTime + i * intervalMs;

        if (i < 5) {
          allCandles.push({ timestamp, open: basePrice + 500, high: basePrice + 600, low: basePrice + 400, close: basePrice + 500, volume: 100 });
        } else {
          allCandles.push({ timestamp, open: basePrice, high: basePrice + 100, low: basePrice - 100, close: basePrice, volume: 100 });
        }
      }

      return {
        position: "long",
        note: "Field verification test",
        priceOpen: basePrice,
        priceTakeProfit: basePrice + 1000,
        priceStopLoss: basePrice - 1000,
        minuteEstimatedTime: 60,
      };
    },
    callbacks: {
      onOpen: () => {
        onOpenCalled = true;
      },
      onWrite: (_symbol, signal) => {
        if (signal && !capturedSignal) {
          capturedSignal = JSON.parse(JSON.stringify(signal));
        }
      },
    },
  });

  addFrame({
    frameName: "20m-test",
    interval: "1m",
    startDate: new Date("2024-01-01T00:00:00Z"),
    endDate: new Date("2024-01-01T00:20:00Z"), // 20 minutes
  });

  const awaitSubject = new Subject();
  listenDoneBacktest(() => awaitSubject.next());

  Backtest.background("BTCUSDT", {
    strategyName: "persist-seq-strategy-2",
    exchangeName: "binance-persist-seq-2",
    frameName: "20m-test",
  });

  await awaitSubject.toPromise();
  await sleep(1000);

  if (!onOpenCalled) {
    fail("Signal was not opened");
    return;
  }

  if (!capturedSignal) {
    fail("writeValue was NOT called with signal data");
    return;
  }

  // Проверяем все критические поля
  const requiredFields = [
    'position', 'priceOpen', 'priceTakeProfit', 'priceStopLoss',
    'minuteEstimatedTime', 'symbol', 'strategyName', 'exchangeName',
    'scheduledAt', 'pendingAt'
  ];

  const missingFields = requiredFields.filter(field => !(field in capturedSignal));

  if (missingFields.length > 0) {
    fail(`Missing fields in writeValue signal: ${missingFields.join(', ')}`);
    return;
  }

  // Проверяем корректность значений
  if (capturedSignal.position !== "long") {
    fail(`position should be "long", got ${capturedSignal.position}`);
    return;
  }

  if (capturedSignal.priceOpen !== basePrice) {
    fail(`priceOpen should be ${basePrice}, got ${capturedSignal.priceOpen}`);
    return;
  }

  if (capturedSignal.symbol !== "BTCUSDT") {
    fail(`symbol should be "BTCUSDT", got ${capturedSignal.symbol}`);
    return;
  }

  if (capturedSignal.strategyName !== "persist-seq-strategy-2") {
    fail(`strategyName should be "persist-seq-strategy-2", got ${capturedSignal.strategyName}`);
    return;
  }

  pass(`PERSIST SEQUENCE: All ${requiredFields.length} fields verified in writeValue. position=${capturedSignal.position}, priceOpen=${capturedSignal.priceOpen}, symbol=${capturedSignal.symbol}`);
});

/**
 * PERSIST TEST #9: SEQUENCE - SHORT signal lifecycle in writeValue
 *
 * Scenario:
 * - SHORT signal: scheduled → opened → closed by TP
 * - Track writeValue calls:
 *   - 1st call: signal opened (should have SHORT position data)
 *   - 2nd call: signal closed (should be null)
 */
test("PERSIST SEQUENCE: SHORT signal lifecycle tracking", async ({ pass, fail }) => {
  const writeHistory = [];
  let onOpenCalled = false;
  let onCloseCalled = false;

  const startTime = new Date("2024-01-01T00:00:00Z").getTime();
  const intervalMs = 60000;
  const basePrice = 95000;

  let allCandles = [];

  for (let i = 0; i < 5; i++) {
    allCandles.push({
      timestamp: startTime + i * intervalMs,
      open: basePrice,
      high: basePrice + 100,
      low: basePrice - 100,
      close: basePrice,
      volume: 100,
    });
  }

  addExchange({
    exchangeName: "binance-persist-seq-3",
    getCandles: async (_symbol, _interval, since, limit) => {
      const sinceIndex = Math.floor((since.getTime() - startTime) / intervalMs);
      const result = allCandles.slice(sinceIndex, sinceIndex + limit);
      return result.length > 0 ? result : allCandles.slice(0, Math.min(limit, allCandles.length));
    },
    formatPrice: async (_symbol, p) => p.toFixed(8),
    formatQuantity: async (_symbol, quantity) => quantity.toFixed(8),
  });

  let signalGenerated = false;

  addStrategy({
    strategyName: "persist-seq-strategy-3",
    interval: "1m",
    getSignal: async () => {
      if (signalGenerated) return null;
      signalGenerated = true;

      // Генерируем свечи: ожидание снизу → активация → TP снизу
      allCandles = [];
      for (let i = 0; i < 20; i++) {
        const timestamp = startTime + i * intervalMs;

        if (i < 5) {
          // Ожидание снизу (SHORT ждет роста цены до priceOpen)
          allCandles.push({ timestamp, open: basePrice - 500, high: basePrice - 400, low: basePrice - 600, close: basePrice - 500, volume: 100 });
        } else if (i >= 5 && i < 10) {
          // Активация (цена растет до priceOpen)
          allCandles.push({ timestamp, open: basePrice, high: basePrice + 100, low: basePrice - 100, close: basePrice, volume: 100 });
        } else {
          // TP снизу (цена падает до TP)
          allCandles.push({ timestamp, open: basePrice - 1000, high: basePrice - 900, low: basePrice - 1100, close: basePrice - 1000, volume: 100 });
        }
      }

      return {
        position: "short",
        note: "SHORT lifecycle test",
        priceOpen: basePrice,
        priceTakeProfit: basePrice - 1000, // SHORT: TP below priceOpen
        priceStopLoss: basePrice + 1000,   // SHORT: SL above priceOpen
        minuteEstimatedTime: 60,
      };
    },
    callbacks: {
      onOpen: () => {
        onOpenCalled = true;
      },
      onClose: () => {
        onCloseCalled = true;
      },
      onWrite: (_symbol, signal) => {
        writeHistory.push({
          timestamp: Date.now(),
          signal: signal ? JSON.parse(JSON.stringify(signal)) : null,
        });
      },
    },
  });

  addFrame({
    frameName: "20m-test-short",
    interval: "1m",
    startDate: new Date("2024-01-01T00:00:00Z"),
    endDate: new Date("2024-01-01T00:20:00Z"), // 20 minutes
  });

  const awaitSubject = new Subject();
  listenDoneBacktest(() => awaitSubject.next());

  Backtest.background("BTCUSDT", {
    strategyName: "persist-seq-strategy-3",
    exchangeName: "binance-persist-seq-3",
    frameName: "20m-test-short",
  });

  await awaitSubject.toPromise();
  await sleep(1000);

  if (!onOpenCalled) {
    fail("SHORT signal was NOT opened");
    return;
  }

  if (!onCloseCalled) {
    fail("SHORT signal was NOT closed");
    return;
  }

  if (writeHistory.length < 2) {
    fail(`Expected at least 2 writeValue calls, got ${writeHistory.length}`);
    return;
  }

  // Проверяем первый вызов (открытие)
  const openWrite = writeHistory[0];
  if (!openWrite.signal) {
    fail("First writeValue should contain signal (opened), got null");
    return;
  }

  if (openWrite.signal.position !== "short") {
    fail(`Opened signal should be SHORT, got ${openWrite.signal.position}`);
    return;
  }

  // Проверяем что есть хотя бы один writeValue(null) - закрытие
  const nullWrites = writeHistory.filter(h => h.signal === null);
  if (nullWrites.length < 1) {
    fail(`Expected at least 1 writeValue(null) after close, got ${nullWrites.length}`);
    return;
  }

  pass(`PERSIST SEQUENCE SHORT: Tracked ${writeHistory.length} calls. Opened: position=${openWrite.signal.position}, Closed: ${nullWrites.length} null writes`);
});
