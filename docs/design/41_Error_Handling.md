# Error Handling

## Purpose and Scope

This document describes the error handling mechanisms in the backtest-kit framework, including validation errors, exchange data errors, persistence errors, and recommended error handling patterns for users. The framework uses a combination of explicit error throwing for unrecoverable errors, warning logs for degraded conditions, and graceful fallbacks for recoverable failures.

For information about the logging system that captures error messages, see [Logging System](40_Logging_System.md). For signal lifecycle management, see [Signal Lifecycle](23_Signal_Lifecycle.md).

---

## Error Categories

The framework distinguishes between several categories of errors based on their origin and recovery strategy:

| Error Category | Recovery Strategy | Examples |
|---------------|-------------------|----------|
| **Validation Errors** | Fail-fast, throw immediately | Invalid TP/SL prices, negative timestamps |
| **Exchange Data Errors** | Warn and continue or throw | Missing candles, empty datasets |
| **Persistence Errors** | Implicit (atomic file writes) | Disk write failures, corrupted state files |
| **Configuration Errors** | Throw on initialization | Unknown intervals, invalid date ranges |
| **State Errors** | Throw with context | Calling backtest in live mode, no pending signal |


---

## Validation Error System

### Signal Validation Pipeline

All signals generated by `getSignal()` are validated before persistence. The `VALIDATE_SIGNAL_FN` performs comprehensive checks and throws an error with aggregated error messages if validation fails.

![Mermaid Diagram](./diagrams/41_Error_Handling_0.svg)

**Diagram: Signal Validation Error Flow**

The validation logic is implemented as a pure function that aggregates all validation errors before throwing:


### Validation Rules

The following validation rules are enforced:

#### Price Validation
- `priceOpen > 0` - Entry price must be positive
- `priceTakeProfit > 0` - Take profit target must be positive  
- `priceStopLoss > 0` - Stop loss target must be positive


#### Long Position Validation
- `priceTakeProfit > priceOpen` - Profit target must be above entry
- `priceStopLoss < priceOpen` - Stop loss must be below entry


#### Short Position Validation
- `priceTakeProfit < priceOpen` - Profit target must be below entry
- `priceStopLoss > priceOpen` - Stop loss must be above entry


#### Time Validation
- `minuteEstimatedTime > 0` - Signal duration must be positive
- `timestamp > 0` - Signal creation time must be valid


### Error Message Format

Validation errors are thrown with detailed multi-line messages that list all validation failures:

```
Invalid signal for long position:
priceTakeProfit must be positive, got -100
Long: priceTakeProfit (49000) must be > priceOpen (50000)
minuteEstimatedTime must be positive, got -5
```

This format allows users to fix all validation issues in a single iteration rather than discovering them one at a time.


---

## Graceful Error Recovery

### Trycatch Wrapper Pattern

The `GET_SIGNAL_FN` uses the `trycatch` wrapper from `functools-kit` to handle errors gracefully during signal generation:

![Mermaid Diagram](./diagrams/41_Error_Handling_1.svg)

**Diagram: Graceful Error Recovery with Trycatch Wrapper**

This pattern ensures that:
1. User-provided `getSignal()` errors are caught
2. Validation errors are caught
3. Signal generation failures return `null` instead of crashing
4. The tick continues with "idle" state when `null` is returned


---

## Exchange Data Errors

### Missing Candle Data

The `ClientExchange` class handles missing or incomplete candle data with warning logs rather than throwing errors:

![Mermaid Diagram](./diagrams/41_Error_Handling_2.svg)

**Diagram: Exchange Data Error Handling**


### Empty Dataset Errors

When VWAP calculation encounters empty candle arrays, an error is thrown immediately since VWAP cannot be calculated without data:

```typescript
// In ClientExchange.getAveragePrice()
if (candles.length === 0) {
  throw new Error(
    `ClientExchange getAveragePrice: no candles data for symbol=${symbol}`
  );
}
```

This is a fail-fast approach because VWAP is critical for signal monitoring and cannot be approximated.


### Future Candle Validation

The `getNextCandles()` method validates that requested candles don't exceed `Date.now()` in live mode:

```typescript
// Prevent future candle requests in live mode
if (endTime > now) {
  return [];  // Graceful empty array return
}
```

This prevents errors when backtesting approaches real-time but returns empty arrays rather than throwing.


---

## State Transition Errors

### Invalid Backtest State

The `backtest()` method validates preconditions and throws descriptive errors:

| Error Condition | Error Message | File Reference |
|----------------|---------------|----------------|
| No pending signal | `"ClientStrategy backtest: no pending signal"` | [ClientStrategy.ts:495-497]() |
| Live mode context | `"ClientStrategy backtest: running in live context"` | [ClientStrategy.ts:499-501]() |

These errors catch programmer mistakes (calling `backtest()` at the wrong time) rather than user input errors.


### Insufficient Candle Data

When backtesting with fewer than 5 candles (minimum for VWAP calculation), a warning is logged but execution continues:

```typescript
if (candles.length < 5) {
  this.params.logger.warn(
    `ClientStrategy backtest: Expected at least 5 candles for VWAP, got ${candles.length}`
  );
}
```

The system proceeds with whatever data is available rather than failing completely.


---

## Warning System for Degraded Performance

### Stop Loss Warnings

When signals close at a loss via stop loss, warnings are logged to alert users:

![Mermaid Diagram](./diagrams/41_Error_Handling_3.svg)

**Diagram: Loss Warning System**


These warnings serve as operational alerts during live trading without interrupting execution.

---

## Configuration Errors

### Unknown Interval Errors

Configuration errors are detected early and throw immediately:

```typescript
// In ClientExchange
if (!adjust) {
  throw new Error(
    `ClientExchange unknown time adjust for interval=${interval}`
  );
}

// In ClientFrame
if (!intervalMinutes) {
  throw new Error(`ClientFrame unknown interval: ${interval}`);
}
```

These errors indicate configuration mistakes that must be fixed before execution can proceed.


---

## Error Handling Patterns for Users

### Recommended Pattern: Callback Error Handling

Users should handle errors in strategy callbacks rather than in the main execution loop:

```typescript
addStrategy({
  strategyName: "my-strategy",
  interval: "5m",
  getSignal: async (symbol) => {
    try {
      // User signal generation logic
      return {
        position: "long",
        priceOpen: currentPrice,
        priceTakeProfit: currentPrice * 1.02,
        priceStopLoss: currentPrice * 0.98,
        minuteEstimatedTime: 60,
      };
    } catch (error) {
      console.error("Signal generation failed:", error);
      return null; // Graceful fallback
    }
  },
  callbacks: {
    onTick: (symbol, result, backtest) => {
      if (result.action === "closed" && result.closeReason === "stop_loss") {
        console.warn(`Stop loss hit for ${symbol}`);
      }
    },
  },
});
```

This pattern allows errors to be handled at the appropriate level without interrupting the framework's execution.


### Type-Safe Error Prevention

The framework uses discriminated unions to prevent type errors at compile time:

```typescript
// Type-safe result handling
const result = await strategy.tick();

if (result.action === "closed") {
  // TypeScript knows result.pnl exists here
  console.log(`PNL: ${result.pnl.pnlPercentage}%`);
} else if (result.action === "opened") {
  // TypeScript knows result.signal exists here
  console.log(`Signal opened: ${result.signal.id}`);
}
```

This eliminates entire classes of runtime errors by making invalid states unrepresentable.


---

## Error Context and Debugging

### Logger Context Enrichment

All error and warning messages are enriched with context from `ExecutionContextService` and `MethodContextService`:

![Mermaid Diagram](./diagrams/41_Error_Handling_4.svg)

**Diagram: Error Context Enrichment**

This ensures that error messages contain sufficient context for debugging without manual parameter threading.


### Debug Logging for Error Paths

Debug-level logs trace execution through error-prone code paths:

```typescript
this.params.logger.debug("ClientStrategy tick check", {
  symbol: this.params.execution.context.symbol,
  averagePrice,
  signalId: signal.id,
  position: signal.position,
});
```

Enable debug logging via the `LoggerService` configuration to trace error conditions.


---

## Persistence Error Handling

The `PersistSignalAdapter` uses atomic file writes to prevent corruption, but file system errors are not explicitly caught. The framework relies on the operating system's crash recovery:

1. **Atomic Writes**: Signal state is written atomically to prevent partial writes
2. **Crash Recovery**: On restart, the last valid state is loaded
3. **State Validation**: Loaded state is validated against current strategy/exchange

For details on persistence mechanisms, see [Signal Persistence](26_Signal_Persistence.md).


---

## Summary of Error Handling Strategy

| Layer | Strategy | Example |
|-------|----------|---------|
| **Validation** | Fail-fast with detailed messages | Signal price/time validation |
| **Data Fetching** | Warn and continue with partial data | Missing candles |
| **State Transitions** | Throw on invalid state | Calling backtest() in live mode |
| **User Code** | Graceful fallback with trycatch | Signal generation errors return null |
| **Critical Operations** | Fail-fast | Empty VWAP dataset |
| **Performance Issues** | Warn but continue | Stop loss hits, time expiration |

The framework prioritizes **fail-fast for configuration errors** (caught at startup) and **graceful degradation for runtime errors** (logged and recovered), ensuring production stability while maintaining debuggability.

